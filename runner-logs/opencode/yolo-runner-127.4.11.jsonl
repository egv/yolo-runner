{"type":"step_start","timestamp":1768851036440,"sessionID":"ses_428432b5cffeiuHqPgEDLEHUBi","part":{"id":"prt_bd7bcd9170015bcvnpbDS700Jg","sessionID":"ses_428432b5cffeiuHqPgEDLEHUBi","messageID":"msg_bd7bcd5ab001EzeVvFJVb7R6YL","type":"step-start","snapshot":"55ed06089af3044d0aafb084ba799f0d06411269"}}
{"type":"tool_use","timestamp":1768851038850,"sessionID":"ses_428432b5cffeiuHqPgEDLEHUBi","part":{"id":"prt_bd7bce1480015rrrcS4hKpWY8S","sessionID":"ses_428432b5cffeiuHqPgEDLEHUBi","messageID":"msg_bd7bcd5ab001EzeVvFJVb7R6YL","type":"tool","callID":"call_WxjSTVMNN47MGehU2iEYhOMX","tool":"glob","state":{"status":"completed","input":{"path":".","pattern":"cmd/yolo-runner/*"},"output":"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main.go\n/Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go\n/Users/egv/dev/yolo-runner/cmd/yolo-runner/exec.go\n/Users/egv/dev/yolo-runner/cmd/yolo-runner/exec_test.go","title":"","metadata":{"count":4,"truncated":false},"time":{"start":1768851038843,"end":1768851038850}},"metadata":{"openai":{"itemId":"fc_0cbd49a0d83e2b1b01696e865e6fd48191a9ecf355167695a9"}}}}
{"type":"step_finish","timestamp":1768851038866,"sessionID":"ses_428432b5cffeiuHqPgEDLEHUBi","part":{"id":"prt_bd7bce284001ydUdKQr4JEyrkk","sessionID":"ses_428432b5cffeiuHqPgEDLEHUBi","messageID":"msg_bd7bcd5ab001EzeVvFJVb7R6YL","type":"step-finish","reason":"tool-calls","snapshot":"e7e6a7e0e1f1310e26f92d3b74ac1753c483313f","cost":0,"tokens":{"input":9575,"output":28,"reasoning":0,"cache":{"read":0,"write":0}}}}
{"type":"step_start","timestamp":1768851039581,"sessionID":"ses_428432b5cffeiuHqPgEDLEHUBi","part":{"id":"prt_bd7bce55d001e3T3C0FriQFdF6","sessionID":"ses_428432b5cffeiuHqPgEDLEHUBi","messageID":"msg_bd7bce2a0001kChUp7A5tWy0Jl","type":"step-start","snapshot":"6717ae69685e0d3d5934c1388628867ef102d535"}}
{"type":"tool_use","timestamp":1768851040624,"sessionID":"ses_428432b5cffeiuHqPgEDLEHUBi","part":{"id":"prt_bd7bce80c001jv173sS6OtVCrb","sessionID":"ses_428432b5cffeiuHqPgEDLEHUBi","messageID":"msg_bd7bce2a0001kChUp7A5tWy0Jl","type":"tool","callID":"call_h0ltYIH77C7NVutkfU2Rtqfy","tool":"glob","state":{"status":"completed","input":{"path":".","pattern":"internal/opencode/*"},"output":"/Users/egv/dev/yolo-runner/internal/opencode/agent_test.go\n/Users/egv/dev/yolo-runner/internal/opencode/agent.go\n/Users/egv/dev/yolo-runner/internal/opencode/client.go\n/Users/egv/dev/yolo-runner/internal/opencode/watchdog.go\n/Users/egv/dev/yolo-runner/internal/opencode/client_test.go\n/Users/egv/dev/yolo-runner/internal/opencode/watchdog_test.go","title":"","metadata":{"count":6,"truncated":false},"time":{"start":1768851040616,"end":1768851040623}},"metadata":{"openai":{"itemId":"fc_096f57aef30b93f701696e865ffb70819187847a595a703d30"}}}}
{"type":"step_finish","timestamp":1768851041065,"sessionID":"ses_428432b5cffeiuHqPgEDLEHUBi","part":{"id":"prt_bd7bceb1b001njbCNMfD0hIJQW","sessionID":"ses_428432b5cffeiuHqPgEDLEHUBi","messageID":"msg_bd7bce2a0001kChUp7A5tWy0Jl","type":"step-finish","reason":"tool-calls","snapshot":"5ee33b8fcd7e00a544a98618f3a6b3c66badf544","cost":0,"tokens":{"input":215,"output":24,"reasoning":0,"cache":{"read":9472,"write":0}}}}
{"type":"step_start","timestamp":1768851041838,"sessionID":"ses_428432b5cffeiuHqPgEDLEHUBi","part":{"id":"prt_bd7bcee2e001P3gl9kap5YAXla","sessionID":"ses_428432b5cffeiuHqPgEDLEHUBi","messageID":"msg_bd7bceb36001ASIQ5XOjz3JWyp","type":"step-start","snapshot":"4f79a83fdb6ecedba45916e7bb42d6a9f8b82259"}}
{"type":"tool_use","timestamp":1768851044287,"sessionID":"ses_428432b5cffeiuHqPgEDLEHUBi","part":{"id":"prt_bd7bcefae001TkDa4uDNSrOiTF","sessionID":"ses_428432b5cffeiuHqPgEDLEHUBi","messageID":"msg_bd7bceb36001ASIQ5XOjz3JWyp","type":"tool","callID":"call_645d0LFSX4jG7S4iKjxwfkRc","tool":"read","state":{"status":"completed","input":{"filePath":"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main.go"},"output":"<file>\n00001| package main\n00002| \n00003| import (\n00004| \t\"bufio\"\n00005| \t\"encoding/json\"\n00006| \t\"errors\"\n00007| \t\"flag\"\n00008| \t\"fmt\"\n00009| \t\"io\"\n00010| \t\"os\"\n00011| \t\"path/filepath\"\n00012| \t\"strings\"\n00013| \n00014| \t\"yolo-runner/internal/beads\"\n00015| \t\"yolo-runner/internal/logging\"\n00016| \t\"yolo-runner/internal/opencode\"\n00017| \t\"yolo-runner/internal/prompt\"\n00018| \t\"yolo-runner/internal/runner\"\n00019| \t\"yolo-runner/internal/ui/tui\"\n00020| \tgitadapter \"yolo-runner/internal/vcs/git\"\n00021| \n00022| \ttea \"github.com/charmbracelet/bubbletea\"\n00023| \t\"golang.org/x/term\"\n00024| )\n00025| \n00026| type runOnceFunc func(opts runner.RunOnceOptions, deps runner.RunOnceDeps) (string, error)\n00027| \n00028| type exitFunc func(code int)\n00029| \n00030| type beadsRunner interface {\n00031| \tRun(args ...string) (string, error)\n00032| }\n00033| \n00034| type gitRunner interface {\n00035| \tRun(name string, args ...string) (string, error)\n00036| }\n00037| \n00038| type openCodeRunner interface {\n00039| \tStart(args []string, env map[string]string, stdoutPath string) (opencode.Process, error)\n00040| }\n00041| \n00042| type tuiProgram interface {\n00043| \tStart() error\n00044| \tSend(event runner.Event)\n00045| \tQuit()\n00046| }\n00047| \n00048| type tuiEmitter struct {\n00049| \tprogram tuiProgram\n00050| }\n00051| \n00052| func (t tuiEmitter) Emit(event runner.Event) {\n00053| \tif t.program == nil {\n00054| \t\treturn\n00055| \t}\n00056| \tgo t.program.Send(event)\n00057| }\n00058| \n00059| type bubbleTUIProgram struct {\n00060| \tprogram *tea.Program\n00061| }\n00062| \n00063| func (b bubbleTUIProgram) Start() error {\n00064| \tif b.program == nil {\n00065| \t\treturn nil\n00066| \t}\n00067| \treturn b.program.Start()\n00068| }\n00069| \n00070| func (b bubbleTUIProgram) Send(event runner.Event) {\n00071| \tif b.program == nil {\n00072| \t\treturn\n00073| \t}\n00074| \tb.program.Send(event)\n00075| }\n00076| \n00077| func (b bubbleTUIProgram) Quit() {\n00078| \tif b.program == nil {\n00079| \t\treturn\n00080| \t}\n00081| \tb.program.Quit()\n00082| }\n00083| \n00084| var isTerminal = func(writer io.Writer) bool {\n00085| \tif file, ok := writer.(*os.File); ok {\n00086| \t\treturn term.IsTerminal(int(file.Fd()))\n00087| \t}\n00088| \treturn false\n00089| }\n00090| \n00091| var newTUIProgram = func(stdout io.Writer) tuiProgram {\n00092| \tprogram := tea.NewProgram(tui.NewModel(nil), tea.WithInput(nil), tea.WithOutput(stdout))\n00093| \treturn bubbleTUIProgram{program: program}\n00094| }\n00095| \n00096| type adapterRunner struct{}\n00097| \n00098| func (adapterRunner) Run(args ...string) (string, error) {\n00099| \treturn runCommand(args...)\n00100| }\n00101| \n00102| type adapterGitRunner struct{}\n00103| \n00104| func (adapterGitRunner) Run(name string, args ...string) (string, error) {\n00105| \treturn runCommand(append([]string{name}, args...)...)\n00106| }\n00107| \n00108| type openCodeAdapter struct {\n00109| \trunner openCodeRunner\n00110| }\n00111| \n00112| func (o openCodeAdapter) Run(issueID string, repoRoot string, promptText string, model string, configRoot string, configDir string, logPath string) error {\n00113| \treturn opencode.Run(issueID, repoRoot, promptText, model, configRoot, configDir, logPath, o.runner)\n00114| }\n00115| \n00116| func RunOnceMain(args []string, runOnce runOnceFunc, exit exitFunc, stdout io.Writer, stderr io.Writer, beadsRunner beadsRunner, gitRunner gitRunner) int {\n00117| \tfs := flag.NewFlagSet(\"yolo-runner\", flag.ContinueOnError)\n00118| \tfs.SetOutput(stderr)\n00119| \n00120| \trepoRoot := fs.String(\"repo\", \".\", \"Repository root path\")\n00121| \trootID := fs.String(\"root\", \"\", \"Root bead/epic ID\")\n00122| \tmodel := fs.String(\"model\", \"\", \"OpenCode model\")\n00123| \tdryRun := fs.Bool(\"dry-run\", false, \"Print task and prompt without executing\")\n00124| \theadless := fs.Bool(\"headless\", false, \"Force plain output without TUI\")\n00125| \tconfigRoot := fs.String(\"config-root\", \"\", \"OpenCode config root\")\n00126| \tconfigDir := fs.String(\"config-dir\", \"\", \"OpenCode config dir\")\n00127| \n00128| \tif err := fs.Parse(args); err != nil {\n00129| \t\tfmt.Fprintln(stderr, err)\n00130| \t\tif exit != nil {\n00131| \t\t\texit(1)\n00132| \t\t}\n00133| \t\treturn 1\n00134| \t}\n00135| \n00136| \tif runOnce == nil {\n00137| \t\trunOnce = runner.RunOnce\n00138| \t}\n00139| \n00140| \tif err := opencode.ValidateAgent(*repoRoot); err != nil {\n00141| \t\tfmt.Fprintln(stderr, err)\n00142| \t\tif exit != nil {\n00143| \t\t\texit(1)\n00144| \t\t}\n00145| \t\treturn 1\n00146| \t}\n00147| \n00148| \tif beadsRunner == nil {\n00149| \t\tbeadsRunner = adapterRunner{}\n00150| \t}\n00151| \tif gitRunner == nil {\n00152| \t\tgitRunner = adapterGitRunner{}\n00153| \t}\n00154| \n00155| \tbeadsAdapter := beads.New(beadsRunner)\n00156| \tgitAdapter := gitadapter.New(gitRunner)\n00157| \topenCodeAdapter := openCodeAdapter{runner: defaultOpenCodeRunner{}}\n00158| \n00159| \tresolvedRootID := *rootID\n00160| \tif resolvedRootID == \"\" {\n00161| \t\tinferredRootID, err := inferDefaultRootID(*repoRoot)\n00162| \t\tif err != nil {\n00163| \t\t\tfmt.Fprintln(stderr, err)\n00164| \t\t\tif exit != nil {\n00165| \t\t\t\texit(1)\n00166| \t\t\t}\n00167| \t\t\treturn 1\n00168| \t\t}\n00169| \t\tresolvedRootID = inferredRootID\n00170| \t}\n00171| \n00172| \tdeps := runner.RunOnceDeps{\n00173| \t\tBeads:    beadsAdapter,\n00174| \t\tPrompt:   promptBuilder{},\n00175| \t\tOpenCode: openCodeAdapter,\n00176| \t\tGit:      gitAdapter,\n00177| \t\tLogger:   runnerLogger{},\n00178| \t}\n00179| \n00180| \tresolvedConfigRoot := *configRoot\n00181| \tresolvedConfigDir := *configDir\n00182| \tif resolvedConfigRoot == \"\" {\n00183| \t\thomeDir := os.Getenv(\"HOME\")\n00184| \t\tif homeDir != \"\" {\n00185| \t\t\tresolvedConfigRoot = filepath.Join(homeDir, \".config\", \"opencode-runner\")\n00186| \t\t}\n00187| \t}\n00188| \tif resolvedConfigDir == \"\" && resolvedConfigRoot != \"\" {\n00189| \t\tresolvedConfigDir = filepath.Join(resolvedConfigRoot, \"opencode\")\n00190| \t}\n00191| \n00192| \toptions := runner.RunOnceOptions{\n00193| \t\tRepoRoot:   *repoRoot,\n00194| \t\tRootID:     resolvedRootID,\n00195| \t\tModel:      *model,\n00196| \t\tConfigRoot: resolvedConfigRoot,\n00197| \t\tConfigDir:  resolvedConfigDir,\n00198| \t\tDryRun:     *dryRun,\n00199| \t\tOut:        stdout,\n00200| \t}\n00201| \n00202| \tif stdout == nil {\n00203| \t\toptions.Out = io.Discard\n00204| \t}\n00205| \tif stderr == nil {\n00206| \t\tstderr = io.Discard\n00207| \t}\n00208| \n00209| \tvar program tuiProgram\n00210| \tif !*headless && isTerminal(stdout) {\n00211| \t\tprogram = newTUIProgram(stdout)\n00212| \t\tdeps.Events = tuiEmitter{program: program}\n00213| \t\tgo func() {\n00214| \t\t\tif err := program.Start(); err != nil {\n00215| \t\t\t\tfmt.Fprintln(stderr, err)\n00216| \t\t\t\tif exit != nil {\n00217| \t\t\t\t\texit(1)\n00218| \t\t\t\t}\n00219| \t\t\t}\n00220| \t\t}()\n00221| \t}\n00222| \n00223| \t_, err := runOnce(options, deps)\n00224| \tif program != nil {\n00225| \t\tprogram.Quit()\n00226| \t}\n00227| \tif err != nil {\n00228| \t\tfmt.Fprintln(stderr, err)\n00229| \t\tif exit != nil {\n00230| \t\t\texit(1)\n00231| \t\t}\n00232| \t\treturn 1\n00233| \t}\n00234| \n00235| \tif exit != nil {\n00236| \t\texit(0)\n00237| \t}\n00238| \treturn 0\n00239| }\n00240| \n00241| func main() {\n00242| \tRunOnceMain(os.Args[1:], runner.RunOnce, os.Exit, os.Stdout, os.Stderr, nil, nil)\n00243| }\n00244| \n00245| type promptBuilder struct{}\n00246| \n00247| func (promptBuilder) Build(issueID string, title string, description string, acceptance string) string {\n00248| \treturn prompt.Build(issueID, title, description, acceptance)\n00249| }\n00250| \n00251| type runnerLogger struct{}\n00252| \n00253| func (runnerLogger) AppendRunnerSummary(repoRoot string, issueID string, title string, status string, commitSHA string) error {\n00254| \treturn logging.AppendRunnerSummary(repoRoot, issueID, title, status, commitSHA)\n00255| }\n00256| \n00257| type defaultOpenCodeRunner struct{}\n00258| \n00259| func (defaultOpenCodeRunner) Start(args []string, env map[string]string, stdoutPath string) (opencode.Process, error) {\n00260| \treturn startCommandWithEnv(args, env, stdoutPath)\n00261| }\n00262| \n00263| type roadmapCandidate struct {\n00264| \tID     string `json:\"id\"`\n00265| \tTitle  string `json:\"title\"`\n00266| \tType   string `json:\"issue_type\"`\n00267| \tStatus string `json:\"status\"`\n00268| }\n00269| \n00270| func inferDefaultRootID(repoRoot string) (string, error) {\n00271| \tissuesPath := filepath.Join(repoRoot, \".beads\", \"issues.jsonl\")\n00272| \tfile, err := os.Open(issuesPath)\n00273| \tif err != nil {\n00274| \t\treturn \"\", errors.New(\"missing --root and no readable .beads/issues.jsonl; pass --root explicitly\")\n00275| \t}\n00276| \tdefer file.Close()\n00277| \n00278| \tscanner := bufio.NewScanner(file)\n00279| \tcount := 0\n00280| \tvar match roadmapCandidate\n00281| \tfor scanner.Scan() {\n00282| \t\tline := strings.TrimSpace(scanner.Text())\n00283| \t\tif line == \"\" {\n00284| \t\t\tcontinue\n00285| \t\t}\n00286| \t\tvar item roadmapCandidate\n00287| \t\tif err := json.Unmarshal([]byte(line), &item); err != nil {\n00288| \t\t\tcontinue\n00289| \t\t}\n00290| \t\tif item.Title == \"Roadmap\" && item.Type == \"epic\" && (item.Status == \"open\" || item.Status == \"in_progress\") {\n00291| \t\t\tcount++\n00292| \t\t\tmatch = item\n00293| \t\t}\n00294| \t}\n00295| \tif err := scanner.Err(); err != nil {\n00296| \t\treturn \"\", errors.New(\"missing --root and unable to read .beads/issues.jsonl; pass --root explicitly\")\n00297| \t}\n00298| \tif count == 1 && match.ID != \"\" {\n00299| \t\treturn match.ID, nil\n00300| \t}\n00301| \treturn \"\", errors.New(\"missing --root and no unique Roadmap epic found; pass --root explicitly\")\n00302| }\n00303| \n\n(End of file - total 303 lines)\n</file>","title":"cmd/yolo-runner/main.go","metadata":{"preview":"package main\n\nimport (\n\t\"bufio\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"flag\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\n\t\"yolo-runner/internal/beads\"\n\t\"yolo-runner/internal/logging\"\n\t\"yolo-runner/internal/opencode\"\n\t\"yolo-runner/internal/prompt\"\n\t\"yolo-runner/internal/runner\"\n\t\"yolo-runner/internal/ui/tui\"\n\tgitadapter \"yolo-runner/internal/vcs/git\"","truncated":false},"time":{"start":1768851044286,"end":1768851044287}},"metadata":{"openai":{"itemId":"fc_049edd37a57fd74101696e8661ecb08191b926cf9b34c75c2f"}}}}
{"type":"step_finish","timestamp":1768851044571,"sessionID":"ses_428432b5cffeiuHqPgEDLEHUBi","part":{"id":"prt_bd7bcf8cc001ZXAVPnRCOBjA1m","sessionID":"ses_428432b5cffeiuHqPgEDLEHUBi","messageID":"msg_bd7bceb36001ASIQ5XOjz3JWyp","type":"step-finish","reason":"tool-calls","snapshot":"6320b4c956a393e49622c574057597d91d36df4a","cost":0,"tokens":{"input":220,"output":35,"reasoning":0,"cache":{"read":9600,"write":0}}}}
{"type":"step_start","timestamp":1768851045113,"sessionID":"ses_428432b5cffeiuHqPgEDLEHUBi","part":{"id":"prt_bd7bcfaf9001WDIYaRQKtLvCuF","sessionID":"ses_428432b5cffeiuHqPgEDLEHUBi","messageID":"msg_bd7bcf8ea001IJwdz133lCPqPM","type":"step-start","snapshot":"37447c9ad68337d4e38999833aa2d3f2a1746a82"}}
{"type":"tool_use","timestamp":1768851045930,"sessionID":"ses_428432b5cffeiuHqPgEDLEHUBi","part":{"id":"prt_bd7bcfc1b0010ifa3gVSGwoqUA","sessionID":"ses_428432b5cffeiuHqPgEDLEHUBi","messageID":"msg_bd7bcf8ea001IJwdz133lCPqPM","type":"tool","callID":"call_AmzbO7yPslg2iqQS6TRcXLAz","tool":"read","state":{"status":"completed","input":{"filePath":"/Users/egv/dev/yolo-runner/internal/opencode/agent.go"},"output":"<file>\n00001| package opencode\n00002| \n00003| import (\n00004| \t\"errors\"\n00005| \t\"fmt\"\n00006| \t\"os\"\n00007| \t\"path/filepath\"\n00008| \t\"strings\"\n00009| )\n00010| \n00011| const (\n00012| \tagentRelativePath = \".opencode/agent/yolo.md\"\n00013| )\n00014| \n00015| var (\n00016| \tErrAgentMissing         = errors.New(\"yolo agent missing\")\n00017| \tErrAgentPermissionUnset = errors.New(\"yolo agent missing permission allow\")\n00018| )\n00019| \n00020| func ValidateAgent(repoRoot string) error {\n00021| \tagentPath := filepath.Join(repoRoot, agentRelativePath)\n00022| \tcontent, err := os.ReadFile(agentPath)\n00023| \tif err != nil {\n00024| \t\tif os.IsNotExist(err) {\n00025| \t\t\treturn fmt.Errorf(\"missing yolo agent file at %s\", agentRelativePath)\n00026| \t\t}\n00027| \t\treturn err\n00028| \t}\n00029| \tif !hasPermissionAllow(content) {\n00030| \t\treturn fmt.Errorf(\"yolo agent missing permission: allow; run opencode init\")\n00031| \t}\n00032| \treturn nil\n00033| }\n00034| \n00035| func hasPermissionAllow(content []byte) bool {\n00036| \tlines := strings.Split(string(content), \"\\n\")\n00037| \tfor _, line := range lines {\n00038| \t\tif strings.TrimSpace(line) == \"permission: allow\" {\n00039| \t\t\treturn true\n00040| \t\t}\n00041| \t}\n00042| \treturn false\n00043| }\n00044| \n\n(End of file - total 44 lines)\n</file>","title":"internal/opencode/agent.go","metadata":{"preview":"package opencode\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n)\n\nconst (\n\tagentRelativePath = \".opencode/agent/yolo.md\"\n)\n\nvar (\n\tErrAgentMissing         = errors.New(\"yolo agent missing\")\n\tErrAgentPermissionUnset = errors.New(\"yolo agent missing permission allow\")\n)\n\nfunc ValidateAgent(repoRoot string) error {","truncated":false},"time":{"start":1768851045930,"end":1768851045930}},"metadata":{"openai":{"itemId":"fc_097b7342987430c401696e866563e08191bc7f22ed4976110e"}}}}
{"type":"step_finish","timestamp":1768851046100,"sessionID":"ses_428432b5cffeiuHqPgEDLEHUBi","part":{"id":"prt_bd7bcfec6001e5WXGBvWhvL8ck","sessionID":"ses_428432b5cffeiuHqPgEDLEHUBi","messageID":"msg_bd7bcf8ea001IJwdz133lCPqPM","type":"step-finish","reason":"tool-calls","snapshot":"e438f6defb72b343dd6bfda4f7f6de7d51bd0674","cost":0,"tokens":{"input":3171,"output":33,"reasoning":0,"cache":{"read":9728,"write":0}}}}
{"type":"step_start","timestamp":1768851046550,"sessionID":"ses_428432b5cffeiuHqPgEDLEHUBi","part":{"id":"prt_bd7bd0095001FRu1uHu980K8NV","sessionID":"ses_428432b5cffeiuHqPgEDLEHUBi","messageID":"msg_bd7bcfee0001Q8kvqufxb5VmZM","type":"step-start","snapshot":"4612a41039d1fb70dd1ee578906669980f95f1a6"}}
{"type":"tool_use","timestamp":1768851047568,"sessionID":"ses_428432b5cffeiuHqPgEDLEHUBi","part":{"id":"prt_bd7bd01f8001mC5gtYmx70rQbe","sessionID":"ses_428432b5cffeiuHqPgEDLEHUBi","messageID":"msg_bd7bcfee0001Q8kvqufxb5VmZM","type":"tool","callID":"call_D0AhpsIAv42fWdJsIk6hCIQ1","tool":"read","state":{"status":"completed","input":{"filePath":"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go"},"output":"<file>\n00001| package main\n00002| \n00003| import (\n00004| \t\"bytes\"\n00005| \t\"errors\"\n00006| \t\"io\"\n00007| \t\"os\"\n00008| \t\"path/filepath\"\n00009| \t\"strings\"\n00010| \t\"testing\"\n00011| \t\"time\"\n00012| \n00013| \t\"yolo-runner/internal/opencode\"\n00014| \t\"yolo-runner/internal/runner\"\n00015| )\n00016| \n00017| type fakeRunner struct {\n00018| \tcalls []string\n00019| }\n00020| \n00021| func (f *fakeRunner) Run(args ...string) (string, error) {\n00022| \tf.calls = append(f.calls, strings.Join(args, \" \"))\n00023| \treturn \"\", nil\n00024| }\n00025| \n00026| type fakeOpenCodeRunLogger struct {\n00027| \tcalled     bool\n00028| \tissueID    string\n00029| \trepoRoot   string\n00030| \tprompt     string\n00031| \tmodel      string\n00032| \tconfigRoot string\n00033| \tconfigDir  string\n00034| \tlogPath    string\n00035| }\n00036| \n00037| func (f *fakeOpenCodeRunLogger) Run(issueID string, repoRoot string, prompt string, model string, configRoot string, configDir string, logPath string) error {\n00038| \tf.called = true\n00039| \tf.issueID = issueID\n00040| \tf.repoRoot = repoRoot\n00041| \tf.prompt = prompt\n00042| \tf.model = model\n00043| \tf.configRoot = configRoot\n00044| \tf.configDir = configDir\n00045| \tf.logPath = logPath\n00046| \treturn nil\n00047| }\n00048| \n00049| type fakeOpenCodeRunner struct {\n00050| \tenv map[string]string\n00051| }\n00052| \n00053| type fakeOpenCodeProcess struct{}\n00054| \n00055| func (fakeOpenCodeProcess) Wait() error { return nil }\n00056| \n00057| func (fakeOpenCodeProcess) Kill() error { return nil }\n00058| \n00059| func (f *fakeOpenCodeRunner) Start(args []string, env map[string]string, stdoutPath string) (opencode.Process, error) {\n00060| \tf.env = env\n00061| \treturn fakeOpenCodeProcess{}, nil\n00062| }\n00063| \n00064| type fakeGitRunner struct {\n00065| \tcalls  []string\n00066| \toutput string\n00067| \terr    error\n00068| }\n00069| \n00070| func (f *fakeGitRunner) Run(name string, args ...string) (string, error) {\n00071| \tf.calls = append(f.calls, name+\" \"+strings.Join(args, \" \"))\n00072| \treturn f.output, f.err\n00073| }\n00074| \n00075| type fakeExit struct {\n00076| \tcode int\n00077| }\n00078| \n00079| func (f *fakeExit) Exit(code int) {\n00080| \tf.code = code\n00081| }\n00082| \n00083| type fakeRunOnce struct {\n00084| \tcalled bool\n00085| \topts   runner.RunOnceOptions\n00086| \tdeps   runner.RunOnceDeps\n00087| \tresult string\n00088| \terr    error\n00089| }\n00090| \n00091| func (f *fakeRunOnce) Run(opts runner.RunOnceOptions, deps runner.RunOnceDeps) (string, error) {\n00092| \n00093| \tf.called = true\n00094| \tf.opts = opts\n00095| \tf.deps = deps\n00096| \treturn f.result, f.err\n00097| }\n00098| \n00099| func TestRunOnceMainReturnsErrorCodeOnFailure(t *testing.T) {\n00100| \ttempDir := t.TempDir()\n00101| \twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n00102| \trunner := &fakeRunOnce{err: errors.New(\"boom\")}\n00103| \texit := &fakeExit{}\n00104| \tout := &bytes.Buffer{}\n00105| \n00106| \tcode := RunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\"}, runner.Run, exit.Exit, out, out, nil, nil)\n00107| \n00108| \tif code != 1 {\n00109| \t\tt.Fatalf(\"expected exit code 1, got %d\", code)\n00110| \t}\n00111| \tif exit.code != 1 {\n00112| \t\tt.Fatalf(\"expected exit to be called with 1, got %d\", exit.code)\n00113| \t}\n00114| \tif !strings.Contains(out.String(), \"boom\") {\n00115| \t\tt.Fatalf(\"expected error output, got %q\", out.String())\n00116| \t}\n00117| }\n00118| \n00119| func TestRunOnceMainWiresDependencies(t *testing.T) {\n00120| \ttempDir := t.TempDir()\n00121| \twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n00122| \trunner := &fakeRunOnce{result: \"no_tasks\"}\n00123| \texit := &fakeExit{}\n00124| \tout := &bytes.Buffer{}\n00125| \tbeadsRunner := &fakeRunner{}\n00126| \tgitRunner := &fakeGitRunner{}\n00127| \n00128| \tRunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\", \"--model\", \"model\", \"--dry-run\"}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n00129| \n00130| \tif !runner.called {\n00131| \t\tt.Fatalf(\"expected run once to be called\")\n00132| \t}\n00133| \tif runner.opts.RepoRoot != tempDir || runner.opts.RootID != \"root\" || runner.opts.Model != \"model\" || !runner.opts.DryRun {\n00134| \t\tt.Fatalf(\"unexpected options: %#v\", runner.opts)\n00135| \t}\n00136| \tif runner.opts.Out == nil {\n00137| \t\tt.Fatalf(\"expected output writer\")\n00138| \t}\n00139| \tif runner.deps.Beads == nil || runner.deps.Git == nil || runner.deps.Prompt == nil || runner.deps.OpenCode == nil || runner.deps.Logger == nil {\n00140| \t\tt.Fatalf(\"expected deps to be wired\")\n00141| \t}\n00142| \tif exit.code != 0 {\n00143| \t\tt.Fatalf(\"expected exit code 0, got %d\", exit.code)\n00144| \t}\n00145| }\n00146| \n00147| func TestRunOnceMainDefaultsConfigPaths(t *testing.T) {\n00148| \ttempDir := t.TempDir()\n00149| \twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n00150| \trunner := &fakeRunOnce{result: \"no_tasks\"}\n00151| \texit := &fakeExit{}\n00152| \tout := &bytes.Buffer{}\n00153| \tbeadsRunner := &fakeRunner{}\n00154| \tgitRunner := &fakeGitRunner{}\n00155| \n00156| \tt.Setenv(\"HOME\", \"/home/user\")\n00157| \tt.Setenv(\"XDG_CONFIG_HOME\", \"\")\n00158| \n00159| \tRunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\"}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n00160| \n00161| \tif !runner.called {\n00162| \t\tt.Fatalf(\"expected run once to be called\")\n00163| \t}\n00164| \tif runner.opts.ConfigRoot == \"\" {\n00165| \t\tt.Fatalf(\"expected config root to be set\")\n00166| \t}\n00167| \tif runner.opts.ConfigDir == \"\" {\n00168| \t\tt.Fatalf(\"expected config dir to be set\")\n00169| \t}\n00170| \texpectedConfigRoot := filepath.Join(\"/home/user\", \".config\", \"opencode-runner\")\n00171| \tif runner.opts.ConfigRoot != expectedConfigRoot {\n00172| \t\tt.Fatalf(\"expected config root %q, got %q\", expectedConfigRoot, runner.opts.ConfigRoot)\n00173| \t}\n00174| \texpectedConfigDir := filepath.Join(expectedConfigRoot, \"opencode\")\n00175| \tif runner.opts.ConfigDir != expectedConfigDir {\n00176| \t\tt.Fatalf(\"expected config dir %q, got %q\", expectedConfigDir, runner.opts.ConfigDir)\n00177| \t}\n00178| \tif exit.code != 0 {\n00179| \t\tt.Fatalf(\"expected exit code 0, got %d\", exit.code)\n00180| \t}\n00181| }\n00182| \n00183| func TestRunOnceMainFailsWhenYoloAgentMissing(t *testing.T) {\n00184| \ttempDir := t.TempDir()\n00185| \trunner := &fakeRunOnce{result: \"no_tasks\"}\n00186| \texit := &fakeExit{}\n00187| \tstdout := &bytes.Buffer{}\n00188| \tstderr := &bytes.Buffer{}\n00189| \tbeadsRunner := &fakeRunner{}\n00190| \tgitRunner := &fakeGitRunner{}\n00191| \n00192| \tcode := RunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\"}, runner.Run, exit.Exit, stdout, stderr, beadsRunner, gitRunner)\n00193| \n00194| \tif code != 1 {\n00195| \t\tt.Fatalf(\"expected exit code 1, got %d\", code)\n00196| \t}\n00197| \tif exit.code != 1 {\n00198| \t\tt.Fatalf(\"expected exit to be called with 1, got %d\", exit.code)\n00199| \t}\n00200| \tif runner.called {\n00201| \t\tt.Fatalf(\"expected run once not to be called\")\n00202| \t}\n00203| \tif !strings.Contains(stderr.String(), \"yolo.md\") {\n00204| \t\tt.Fatalf(\"expected error to mention yolo.md, got %q\", stderr.String())\n00205| \t}\n00206| }\n00207| \n00208| func TestRunOnceMainFailsWhenYoloAgentMissingPermission(t *testing.T) {\n00209| \ttempDir := t.TempDir()\n00210| \twriteAgentFile(t, tempDir, \"---\\nname: yolo\\n---\\n\")\n00211| \trunner := &fakeRunOnce{result: \"no_tasks\"}\n00212| \texit := &fakeExit{}\n00213| \tstdout := &bytes.Buffer{}\n00214| \tstderr := &bytes.Buffer{}\n00215| \tbeadsRunner := &fakeRunner{}\n00216| \tgitRunner := &fakeGitRunner{}\n00217| \n00218| \tcode := RunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\"}, runner.Run, exit.Exit, stdout, stderr, beadsRunner, gitRunner)\n00219| \n00220| \tif code != 1 {\n00221| \t\tt.Fatalf(\"expected exit code 1, got %d\", code)\n00222| \t}\n00223| \tif exit.code != 1 {\n00224| \t\tt.Fatalf(\"expected exit to be called with 1, got %d\", exit.code)\n00225| \t}\n00226| \tif runner.called {\n00227| \t\tt.Fatalf(\"expected run once not to be called\")\n00228| \t}\n00229| \tif !strings.Contains(stderr.String(), \"permission: allow\") {\n00230| \t\tt.Fatalf(\"expected error to mention permission allow, got %q\", stderr.String())\n00231| \t}\n00232| \tif !strings.Contains(strings.ToLower(stderr.String()), \"init\") {\n00233| \t\tt.Fatalf(\"expected guidance to run init, got %q\", stderr.String())\n00234| \t}\n00235| }\n00236| \n00237| func TestRunOnceMainInfersRoadmapRootWhenMissing(t *testing.T) {\n00238| \ttempDir := t.TempDir()\n00239| \twriteIssuesFile(t, tempDir, `{\"id\":\"roadmap-1\",\"title\":\"Roadmap\",\"issue_type\":\"epic\",\"status\":\"open\"}`)\n00240| \twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n00241| \trunner := &fakeRunOnce{result: \"no_tasks\"}\n00242| \texit := &fakeExit{}\n00243| \tout := &bytes.Buffer{}\n00244| \tbeadsRunner := &fakeRunner{}\n00245| \tgitRunner := &fakeGitRunner{}\n00246| \n00247| \tcode := RunOnceMain([]string{\"--repo\", tempDir}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n00248| \n00249| \tif code != 0 {\n00250| \t\tt.Fatalf(\"expected exit code 0, got %d\", code)\n00251| \t}\n00252| \tif !runner.called {\n00253| \t\tt.Fatalf(\"expected run once to be called\")\n00254| \t}\n00255| \tif runner.opts.RootID != \"roadmap-1\" {\n00256| \t\tt.Fatalf(\"expected root id to be inferred, got %q\", runner.opts.RootID)\n00257| \t}\n00258| }\n00259| \n00260| func TestRunOnceMainInfersRoadmapRootWhenInProgress(t *testing.T) {\n00261| \ttempDir := t.TempDir()\n00262| \twriteIssuesFile(t, tempDir, `{\"id\":\"roadmap-2\",\"title\":\"Roadmap\",\"issue_type\":\"epic\",\"status\":\"in_progress\"}`)\n00263| \twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n00264| \trunner := &fakeRunOnce{result: \"no_tasks\"}\n00265| \texit := &fakeExit{}\n00266| \tout := &bytes.Buffer{}\n00267| \tbeadsRunner := &fakeRunner{}\n00268| \tgitRunner := &fakeGitRunner{}\n00269| \n00270| \tcode := RunOnceMain([]string{\"--repo\", tempDir}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n00271| \n00272| \tif code != 0 {\n00273| \t\tt.Fatalf(\"expected exit code 0, got %d\", code)\n00274| \t}\n00275| \tif !runner.called {\n00276| \t\tt.Fatalf(\"expected run once to be called\")\n00277| \t}\n00278| \tif runner.opts.RootID != \"roadmap-2\" {\n00279| \t\tt.Fatalf(\"expected root id to be inferred, got %q\", runner.opts.RootID)\n00280| \t}\n00281| }\n00282| \n00283| func TestRunOnceMainMissingRootRequiresExplicitFlag(t *testing.T) {\n00284| \ttempDir := t.TempDir()\n00285| \twriteIssuesFile(t, tempDir, `{\"id\":\"epic-1\",\"title\":\"Other\",\"issue_type\":\"epic\",\"status\":\"open\"}`)\n00286| \twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n00287| \trunner := &fakeRunOnce{result: \"no_tasks\"}\n00288| \texit := &fakeExit{}\n00289| \tstdout := &bytes.Buffer{}\n00290| \tstderr := &bytes.Buffer{}\n00291| \tbeadsRunner := &fakeRunner{}\n00292| \tgitRunner := &fakeGitRunner{}\n00293| \n00294| \tcode := RunOnceMain([]string{\"--repo\", tempDir}, runner.Run, exit.Exit, stdout, stderr, beadsRunner, gitRunner)\n00295| \n00296| \tif code != 1 {\n00297| \t\tt.Fatalf(\"expected exit code 1, got %d\", code)\n00298| \t}\n00299| \tif exit.code != 1 {\n00300| \t\tt.Fatalf(\"expected exit to be called with 1, got %d\", exit.code)\n00301| \t}\n00302| \tif runner.called {\n00303| \t\tt.Fatalf(\"expected run once not to be called\")\n00304| \t}\n00305| \tif !strings.Contains(stderr.String(), \"--root\") {\n00306| \t\tt.Fatalf(\"expected error to mention --root, got %q\", stderr.String())\n00307| \t}\n00308| \tif !strings.Contains(strings.ToLower(stderr.String()), \"roadmap\") {\n00309| \t\tt.Fatalf(\"expected error to mention roadmap, got %q\", stderr.String())\n00310| \t}\n00311| }\n00312| \n00313| type fakeTUIProgram struct {\n00314| \tstarted chan struct{}\n00315| \tquit    chan struct{}\n00316| \tevents  chan runner.Event\n00317| }\n00318| \n00319| func newFakeTUIProgram() *fakeTUIProgram {\n00320| \treturn &fakeTUIProgram{\n00321| \t\tstarted: make(chan struct{}),\n00322| \t\tquit:    make(chan struct{}),\n00323| \t\tevents:  make(chan runner.Event, 1),\n00324| \t}\n00325| }\n00326| \n00327| func (f *fakeTUIProgram) Start() error {\n00328| \tclose(f.started)\n00329| \treturn nil\n00330| }\n00331| \n00332| func (f *fakeTUIProgram) Send(event runner.Event) {\n00333| \tf.events <- event\n00334| }\n00335| \n00336| func (f *fakeTUIProgram) Quit() {\n00337| \tclose(f.quit)\n00338| }\n00339| \n00340| func waitForSignal(t *testing.T, signal chan struct{}, label string) {\n00341| \tt.Helper()\n00342| \tselect {\n00343| \tcase <-signal:\n00344| \t\treturn\n00345| \tcase <-time.After(200 * time.Millisecond):\n00346| \t\tt.Fatalf(\"expected %s\", label)\n00347| \t}\n00348| }\n00349| \n00350| func writeIssuesFile(t *testing.T, repoRoot string, payload string) {\n00351| \tt.Helper()\n00352| \tbeadsDir := filepath.Join(repoRoot, \".beads\")\n00353| \tif err := os.MkdirAll(beadsDir, 0o755); err != nil {\n00354| \t\tt.Fatalf(\"mkdir .beads: %v\", err)\n00355| \t}\n00356| \tissuesPath := filepath.Join(beadsDir, \"issues.jsonl\")\n00357| \tif err := os.WriteFile(issuesPath, []byte(payload+\"\\n\"), 0o644); err != nil {\n00358| \t\tt.Fatalf(\"write issues: %v\", err)\n00359| \t}\n00360| }\n00361| \n00362| func writeAgentFile(t *testing.T, repoRoot string, payload string) {\n00363| \tt.Helper()\n00364| \tagentDir := filepath.Join(repoRoot, \".opencode\", \"agent\")\n00365| \tif err := os.MkdirAll(agentDir, 0o755); err != nil {\n00366| \t\tt.Fatalf(\"mkdir agent dir: %v\", err)\n00367| \t}\n00368| \tagentPath := filepath.Join(agentDir, \"yolo.md\")\n00369| \tif err := os.WriteFile(agentPath, []byte(payload), 0o644); err != nil {\n00370| \t\tt.Fatalf(\"write agent file: %v\", err)\n00371| \t}\n00372| }\n00373| \n00374| func TestRunOnceMainUsesTUIOnTTYByDefault(t *testing.T) {\n00375| \tfakeProgram := newFakeTUIProgram()\n00376| \tprevIsTerminal := isTerminal\n00377| \tprevNewTUIProgram := newTUIProgram\n00378| \tisTerminal = func(io.Writer) bool { return true }\n00379| \tnewTUIProgram = func(stdout io.Writer) tuiProgram { return fakeProgram }\n00380| \tt.Cleanup(func() {\n00381| \t\tisTerminal = prevIsTerminal\n00382| \t\tnewTUIProgram = prevNewTUIProgram\n00383| \t})\n00384| \n00385| \ttempDir := t.TempDir()\n00386| \twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n00387| \trunOnce := &fakeRunOnce{result: \"no_tasks\"}\n00388| \texit := &fakeExit{}\n00389| \tout := &bytes.Buffer{}\n00390| \tbeadsRunner := &fakeRunner{}\n00391| \tgitRunner := &fakeGitRunner{}\n00392| \n00393| \tcode := RunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\"}, runOnce.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n00394| \n00395| \tif code != 0 {\n00396| \t\tt.Fatalf(\"expected exit code 0, got %d\", code)\n00397| \t}\n00398| \tif runOnce.deps.Events == nil {\n00399| \t\tt.Fatalf(\"expected events emitter to be set\")\n00400| \t}\n00401| \trunOnce.deps.Events.Emit(runner.Event{Type: runner.EventSelectTask})\n00402| \twaitForSignal(t, fakeProgram.started, \"tui start\")\n00403| \twaitForSignal(t, fakeProgram.quit, \"tui quit\")\n00404| \tselect {\n00405| \tcase <-fakeProgram.events:\n00406| \t\t// ok\n00407| \tcase <-time.After(200 * time.Millisecond):\n00408| \t\tt.Fatalf(\"expected event to be forwarded to TUI\")\n00409| \t}\n00410| }\n00411| \n00412| func TestRunOnceMainHeadlessDisablesTUI(t *testing.T) {\n00413| \tcalled := false\n00414| \tprevIsTerminal := isTerminal\n00415| \tprevNewTUIProgram := newTUIProgram\n00416| \tisTerminal = func(io.Writer) bool { return true }\n00417| \tnewTUIProgram = func(stdout io.Writer) tuiProgram {\n00418| \t\tcalled = true\n00419| \t\treturn newFakeTUIProgram()\n00420| \t}\n00421| \tt.Cleanup(func() {\n00422| \t\tisTerminal = prevIsTerminal\n00423| \t\tnewTUIProgram = prevNewTUIProgram\n00424| \t})\n00425| \n00426| \ttempDir := t.TempDir()\n00427| \twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n00428| \trunOnce := &fakeRunOnce{result: \"no_tasks\"}\n00429| \texit := &fakeExit{}\n00430| \tout := &bytes.Buffer{}\n00431| \tbeadsRunner := &fakeRunner{}\n00432| \tgitRunner := &fakeGitRunner{}\n00433| \tstderr := &bytes.Buffer{}\n00434| \n00435| \tRunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\", \"--headless\"}, runOnce.Run, exit.Exit, out, stderr, beadsRunner, gitRunner)\n00436| \n00437| \tif called {\n00438| \t\tt.Fatalf(\"expected TUI program not to start\")\n00439| \t}\n00440| \tif runOnce.deps.Events != nil {\n00441| \t\tt.Fatalf(\"expected no events emitter in headless mode\")\n00442| \t}\n00443| }\n00444| \n00445| func TestOpenCodeRunDefaultsCreateConfigAndEnv(t *testing.T) {\n00446| \ttempDir := t.TempDir()\n00447| \trepoRoot := filepath.Join(tempDir, \"repo\")\n00448| \tif err := os.MkdirAll(repoRoot, 0o755); err != nil {\n00449| \t\tt.Fatalf(\"mkdir repo: %v\", err)\n00450| \t}\n00451| \tt.Setenv(\"HOME\", tempDir)\n00452| \n00453| \topenCodeRunner := &fakeOpenCodeRunner{}\n00454| \topenCodeAdapter := openCodeAdapter{runner: openCodeRunner}\n00455| \n00456| \tconfigRoot := filepath.Join(tempDir, \".config\", \"opencode-runner\")\n00457| \tconfigDir := filepath.Join(configRoot, \"opencode\")\n00458| \tlogPath := filepath.Join(tempDir, \"runner-logs\", \"opencode\", \"issue-1.jsonl\")\n00459| \n00460| \tif err := openCodeAdapter.Run(\"issue-1\", repoRoot, \"prompt\", \"\", configRoot, configDir, logPath); err != nil {\n00461| \t\tt.Fatalf(\"open code run error: %v\", err)\n00462| \t}\n00463| \n00464| \tconfigFile := filepath.Join(configDir, \"opencode.json\")\n00465| \tif _, err := os.Stat(configFile); err != nil {\n00466| \t\tt.Fatalf(\"expected opencode.json to exist: %v\", err)\n00467| \t}\n00468| \texpectedConfigFile := filepath.Join(configDir, \"opencode.json\")\n00469| \tif openCodeRunner.env[\"XDG_CONFIG_HOME\"] != configRoot {\n00470| \t\tt.Fatalf(\"expected XDG_CONFIG_HOME set\")\n00471| \t}\n00472| \tif openCodeRunner.env[\"OPENCODE_CONFIG_DIR\"] != configDir {\n00473| \t\tt.Fatalf(\"expected OPENCODE_CONFIG_DIR set\")\n00474| \t}\n00475| \tif openCodeRunner.env[\"OPENCODE_CONFIG\"] != expectedConfigFile {\n00476| \t\tt.Fatalf(\"expected OPENCODE_CONFIG set\")\n00477| \t}\n00478| \tif openCodeRunner.env[\"OPENCODE_CONFIG_CONTENT\"] != \"{}\" {\n00479| \t\tt.Fatalf(\"expected OPENCODE_CONFIG_CONTENT set\")\n00480| \t}\n00481| }\n00482| \n\n(End of file - total 482 lines)\n</file>","title":"cmd/yolo-runner/main_test.go","metadata":{"preview":"package main\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"yolo-runner/internal/opencode\"\n\t\"yolo-runner/internal/runner\"\n)\n\ntype fakeRunner struct {\n\tcalls []string\n}\n","truncated":false},"time":{"start":1768851047567,"end":1768851047568}},"metadata":{"openai":{"itemId":"fc_05d0d0624d72f8c401696e8666dfb48191bc7d20d962fad7ab"}}}}
{"type":"step_finish","timestamp":1768851047712,"sessionID":"ses_428432b5cffeiuHqPgEDLEHUBi","part":{"id":"prt_bd7bd050f001RvOOgnJzWcIQT5","sessionID":"ses_428432b5cffeiuHqPgEDLEHUBi","messageID":"msg_bd7bcfee0001Q8kvqufxb5VmZM","type":"step-finish","reason":"tool-calls","snapshot":"19cdc8ca83b8b42840c0869a0701f1dac6d3662e","cost":0,"tokens":{"input":543,"output":36,"reasoning":0,"cache":{"read":12800,"write":0}}}}
{"type":"step_start","timestamp":1768851048293,"sessionID":"ses_428432b5cffeiuHqPgEDLEHUBi","part":{"id":"prt_bd7bd0764001330obDcHdT0b6Q","sessionID":"ses_428432b5cffeiuHqPgEDLEHUBi","messageID":"msg_bd7bd052f001sIXQ9hIXXJQHLH","type":"step-start","snapshot":"ef7f611c7550ebeb3ed35d4e56a5d581884d0cc1"}}
{"type":"tool_use","timestamp":1768851049872,"sessionID":"ses_428432b5cffeiuHqPgEDLEHUBi","part":{"id":"prt_bd7bd0b1e001a9V2KwPxLBUivP","sessionID":"ses_428432b5cffeiuHqPgEDLEHUBi","messageID":"msg_bd7bd052f001sIXQ9hIXXJQHLH","type":"tool","callID":"call_H9zUe19Wdv9Bc802IbV8jqe0","tool":"read","state":{"status":"completed","input":{"filePath":"/Users/egv/dev/yolo-runner/internal/opencode/agent_test.go"},"output":"<file>\n00001| package opencode\n00002| \n00003| import (\n00004| \t\"os\"\n00005| \t\"path/filepath\"\n00006| \t\"strings\"\n00007| \t\"testing\"\n00008| )\n00009| \n00010| func TestValidateAgentMissingFile(t *testing.T) {\n00011| \trepoRoot := t.TempDir()\n00012| \n00013| \terr := ValidateAgent(repoRoot)\n00014| \n00015| \tif err == nil {\n00016| \t\tt.Fatalf(\"expected error\")\n00017| \t}\n00018| \tif !strings.Contains(err.Error(), \"yolo.md\") {\n00019| \t\tt.Fatalf(\"expected error to mention yolo.md, got %q\", err.Error())\n00020| \t}\n00021| }\n00022| \n00023| func TestValidateAgentMissingPermission(t *testing.T) {\n00024| \trepoRoot := t.TempDir()\n00025| \tagentDir := filepath.Join(repoRoot, \".opencode\", \"agent\")\n00026| \tif err := os.MkdirAll(agentDir, 0o755); err != nil {\n00027| \t\tt.Fatalf(\"mkdir agent dir: %v\", err)\n00028| \t}\n00029| \tagentPath := filepath.Join(agentDir, \"yolo.md\")\n00030| \tif err := os.WriteFile(agentPath, []byte(\"---\\nname: yolo\\n---\\n\"), 0o644); err != nil {\n00031| \t\tt.Fatalf(\"write agent file: %v\", err)\n00032| \t}\n00033| \n00034| \terr := ValidateAgent(repoRoot)\n00035| \n00036| \tif err == nil {\n00037| \t\tt.Fatalf(\"expected error\")\n00038| \t}\n00039| \tif !strings.Contains(err.Error(), \"permission: allow\") {\n00040| \t\tt.Fatalf(\"expected error to mention permission allow, got %q\", err.Error())\n00041| \t}\n00042| \tif !strings.Contains(strings.ToLower(err.Error()), \"init\") {\n00043| \t\tt.Fatalf(\"expected guidance to run init, got %q\", err.Error())\n00044| \t}\n00045| }\n00046| \n00047| func TestValidateAgentAllowsPermissionAllow(t *testing.T) {\n00048| \trepoRoot := t.TempDir()\n00049| \tagentDir := filepath.Join(repoRoot, \".opencode\", \"agent\")\n00050| \tif err := os.MkdirAll(agentDir, 0o755); err != nil {\n00051| \t\tt.Fatalf(\"mkdir agent dir: %v\", err)\n00052| \t}\n00053| \tagentPath := filepath.Join(agentDir, \"yolo.md\")\n00054| \tcontent := \"---\\nname: yolo\\npermission: allow\\n---\\n\"\n00055| \tif err := os.WriteFile(agentPath, []byte(content), 0o644); err != nil {\n00056| \t\tt.Fatalf(\"write agent file: %v\", err)\n00057| \t}\n00058| \n00059| \terr := ValidateAgent(repoRoot)\n00060| \n00061| \tif err != nil {\n00062| \t\tt.Fatalf(\"expected no error, got %v\", err)\n00063| \t}\n00064| }\n00065| \n\n(End of file - total 65 lines)\n</file>","title":"internal/opencode/agent_test.go","metadata":{"preview":"package opencode\n\nimport (\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"testing\"\n)\n\nfunc TestValidateAgentMissingFile(t *testing.T) {\n\trepoRoot := t.TempDir()\n\n\terr := ValidateAgent(repoRoot)\n\n\tif err == nil {\n\t\tt.Fatalf(\"expected error\")\n\t}\n\tif !strings.Contains(err.Error(), \"yolo.md\") {\n\t\tt.Fatalf(\"expected error to mention yolo.md, got %q\", err.Error())\n\t}","truncated":false},"time":{"start":1768851049871,"end":1768851049872}},"metadata":{"openai":{"itemId":"fc_0197ccf97209369701696e86692be481918ccfda1760403ce9"}}}}
{"type":"step_finish","timestamp":1768851050066,"sessionID":"ses_428432b5cffeiuHqPgEDLEHUBi","part":{"id":"prt_bd7bd0e440014DzGPrqO0tWQzG","sessionID":"ses_428432b5cffeiuHqPgEDLEHUBi","messageID":"msg_bd7bd052f001sIXQ9hIXXJQHLH","type":"step-finish","reason":"tool-calls","snapshot":"da3d2e9200ab61f9b741eb498229eed6195997f5","cost":0,"tokens":{"input":6244,"output":34,"reasoning":0,"cache":{"read":12928,"write":0}}}}
{"type":"step_start","timestamp":1768851050591,"sessionID":"ses_428432b5cffeiuHqPgEDLEHUBi","part":{"id":"prt_bd7bd105f001YnQ1d797fg6bDa","sessionID":"ses_428432b5cffeiuHqPgEDLEHUBi","messageID":"msg_bd7bd0e60001ATuZ28THXKlr5d","type":"step-start","snapshot":"508a1c79d9b4f9dad9270b74ae6c8b83910feae6"}}
{"type":"tool_use","timestamp":1768851052411,"sessionID":"ses_428432b5cffeiuHqPgEDLEHUBi","part":{"id":"prt_bd7bd16760019JtYJoH8NVKqpQ","sessionID":"ses_428432b5cffeiuHqPgEDLEHUBi","messageID":"msg_bd7bd0e60001ATuZ28THXKlr5d","type":"tool","callID":"call_rQmnHZAJTm7qg8tKL6vCNpp4","tool":"glob","state":{"status":"completed","input":{"path":".","pattern":"**/yolo.md"},"output":"/Users/egv/dev/yolo-runner/.opencode/agent/yolo.md\n/Users/egv/dev/yolo-runner/yolo.md","title":"","metadata":{"count":2,"truncated":false},"time":{"start":1768851052404,"end":1768851052411}},"metadata":{"openai":{"itemId":"fc_075ce49da98d37ac01696e866c00908191bc91b93ab5a56a27"}}}}
{"type":"step_finish","timestamp":1768851052545,"sessionID":"ses_428432b5cffeiuHqPgEDLEHUBi","part":{"id":"prt_bd7bd17f2001Y0cg2LBDQaHYsI","sessionID":"ses_428432b5cffeiuHqPgEDLEHUBi","messageID":"msg_bd7bd0e60001ATuZ28THXKlr5d","type":"step-finish","reason":"tool-calls","snapshot":"9f17acb92c147f603458feb28e68213f50d9f375","cost":0,"tokens":{"input":883,"output":27,"reasoning":0,"cache":{"read":19072,"write":0}}}}
{"type":"step_start","timestamp":1768851053005,"sessionID":"ses_428432b5cffeiuHqPgEDLEHUBi","part":{"id":"prt_bd7bd19cc001zUfhw0DhwTodIa","sessionID":"ses_428432b5cffeiuHqPgEDLEHUBi","messageID":"msg_bd7bd1810001H5dSJxFvJHh36h","type":"step-start","snapshot":"00a6a0a902700dc8ba7110bca6dcf415cb4f29ab"}}
{"type":"tool_use","timestamp":1768851053811,"sessionID":"ses_428432b5cffeiuHqPgEDLEHUBi","part":{"id":"prt_bd7bd1b85001n2gU5U9TsY1UWO","sessionID":"ses_428432b5cffeiuHqPgEDLEHUBi","messageID":"msg_bd7bd1810001H5dSJxFvJHh36h","type":"tool","callID":"call_l08BO1SebR58v07lxC5emWsG","tool":"read","state":{"status":"completed","input":{"filePath":"/Users/egv/dev/yolo-runner/yolo.md"},"output":"<file>\n00001| ---\n00002| description: YOLO automation agent for beads task implementation\n00003| mode: primary\n00004| model: openai/gpt-5.2-codex\n00005| temperature: 0.1\n00006| tools:\n00007|   bash: true\n00008|   read: true\n00009|   grep: true\n00010|   glob: true\n00011|   list: true\n00012|   write: true\n00013|   edit: true\n00014|   patch: true\n00015|   todowrite: true\n00016|   todoread: true\n00017|   webfetch: true\n00018| permission: allow\n00019| ---\n00020| You are in YOLO mode - all permissions granted.\n00021| \n00022| Your purpose is to implement the single task described in the prompt using strict TDD protocol.\n00023| \n00024| **Scope:**\n00025| - Work only on the task provided in the prompt.\n00026| - Do NOT request or select additional tasks.\n00027| - Do NOT use beads commands (`bd`); the runner manages task selection and closing.\n00028| - Do NOT ask the user for clarification; proceed with best-effort assumptions.\n00029| \n00030| **TDD requirements:**\n00031| - NEVER write implementation code before a failing test exists.\n00032| - Watch the test fail before writing code.\n00033| - Write minimal code to pass each test.\n00034| - Do not modify unrelated files.\n00035| - Use real code, not mocks unless unavoidable.\n00036| - All tests must pass before marking the task complete.\n00037| \n00038| **Acceptance criteria focus:**\n00039| - Each task has strict Given/When/Then acceptance criteria.\n00040| - Tests must verify every bullet point in acceptance criteria.\n00041| - No test should pass by accident without implementing the required behavior.\n00042| \n00043| **Git workflow:**\n00044| - Commit the completed task immediately.\n00045| - Use conventional commit messages: \"feat: task name\" or \"fix: issue description\".\n00046| - Do not batch multiple tasks into one commit.\n00047| \n00048| **When stuck:**\n00049| - Read the existing codebase for patterns.\n00050| - Search for similar implementations.\n00051| - Proceed with best-effort assumptions and log any uncertainty in code comments.\n00052| \n00053| **Strict rules:**\n00054| - If acceptance criteria says \"Given X, when Y, then Z\", you MUST verify that Z happens.\n00055| - If a test passes unexpectedly, investigate why before proceeding.\n00056| - Never skip writing tests for \"simple\" changes.\n00057| - If a test fails for the wrong reason, fix the test, not the code (unless the test was wrong).\n00058| \n00059| Start now by analyzing the codebase and writing your first failing test.\n00060| \n\n(End of file - total 60 lines)\n</file>","title":"yolo.md","metadata":{"preview":"---\ndescription: YOLO automation agent for beads task implementation\nmode: primary\nmodel: openai/gpt-5.2-codex\ntemperature: 0.1\ntools:\n  bash: true\n  read: true\n  grep: true\n  glob: true\n  list: true\n  write: true\n  edit: true\n  patch: true\n  todowrite: true\n  todoread: true\n  webfetch: true\npermission: allow\n---\nYou are in YOLO mode - all permissions granted.","truncated":false},"time":{"start":1768851053810,"end":1768851053811}},"metadata":{"openai":{"itemId":"fc_0c851b7ff245651601696e866d5d848191a4851d89c1d3c5c7"}}}}
{"type":"step_finish","timestamp":1768851053919,"sessionID":"ses_428432b5cffeiuHqPgEDLEHUBi","part":{"id":"prt_bd7bd1d52001ve503XPHe4dycj","sessionID":"ses_428432b5cffeiuHqPgEDLEHUBi","messageID":"msg_bd7bd1810001H5dSJxFvJHh36h","type":"step-finish","reason":"tool-calls","snapshot":"896db3a06cd74a6568012f5e338945d91ba8bf07","cost":0,"tokens":{"input":179,"output":30,"reasoning":0,"cache":{"read":19840,"write":0}}}}
{"type":"step_start","timestamp":1768851054353,"sessionID":"ses_428432b5cffeiuHqPgEDLEHUBi","part":{"id":"prt_bd7bd1f11001YcLLQ1yrht2j0A","sessionID":"ses_428432b5cffeiuHqPgEDLEHUBi","messageID":"msg_bd7bd1d710014ngh2mHAcxDnrL","type":"step-start","snapshot":"00777b8e76310adeabd1ffe3506f80200d3312a9"}}
{"type":"tool_use","timestamp":1768851056775,"sessionID":"ses_428432b5cffeiuHqPgEDLEHUBi","part":{"id":"prt_bd7bd26d7001FAmTGBzO2LITXf","sessionID":"ses_428432b5cffeiuHqPgEDLEHUBi","messageID":"msg_bd7bd1d710014ngh2mHAcxDnrL","type":"tool","callID":"call_6rfi3yCJq2F6gLXsVSV5HVpc","tool":"read","state":{"status":"completed","input":{"filePath":"/Users/egv/dev/yolo-runner/cmd/yolo-runner/exec.go"},"output":"<file>\n00001| package main\n00002| \n00003| import (\n00004| \t\"os\"\n00005| \t\"os/exec\"\n00006| \t\"strings\"\n00007| \n00008| \t\"yolo-runner/internal/opencode\"\n00009| )\n00010| \n00011| func runCommand(args ...string) (string, error) {\n00012| \tcmd := exec.Command(args[0], args[1:]...)\n00013| \toutput, err := cmd.CombinedOutput()\n00014| \treturn string(output), err\n00015| }\n00016| \n00017| type cmdProcess struct {\n00018| \tcmd        *exec.Cmd\n00019| \tstdoutFile *os.File\n00020| \tstderrFile *os.File\n00021| }\n00022| \n00023| func (process cmdProcess) Wait() error {\n00024| \terr := process.cmd.Wait()\n00025| \tif process.stdoutFile != nil {\n00026| \t\t_ = process.stdoutFile.Close()\n00027| \t}\n00028| \tif process.stderrFile != nil {\n00029| \t\t_ = process.stderrFile.Close()\n00030| \t}\n00031| \treturn err\n00032| }\n00033| \n00034| func (process cmdProcess) Kill() error {\n00035| \tif process.cmd.Process == nil {\n00036| \t\tif process.stdoutFile != nil {\n00037| \t\t\t_ = process.stdoutFile.Close()\n00038| \t\t}\n00039| \t\tif process.stderrFile != nil {\n00040| \t\t\t_ = process.stderrFile.Close()\n00041| \t\t}\n00042| \t\treturn nil\n00043| \t}\n00044| \terr := process.cmd.Process.Kill()\n00045| \tif process.stdoutFile != nil {\n00046| \t\t_ = process.stdoutFile.Close()\n00047| \t}\n00048| \tif process.stderrFile != nil {\n00049| \t\t_ = process.stderrFile.Close()\n00050| \t}\n00051| \treturn err\n00052| }\n00053| \n00054| func startCommandWithEnv(args []string, env map[string]string, stdoutPath string) (opencode.Process, error) {\n00055| \tcmd := exec.Command(args[0], args[1:]...)\n00056| \tcmd.Env = os.Environ()\n00057| \tfor key, value := range env {\n00058| \t\tcmd.Env = append(cmd.Env, key+\"=\"+value)\n00059| \t}\n00060| \tstdoutFile, err := os.Create(stdoutPath)\n00061| \tif err != nil {\n00062| \t\treturn nil, err\n00063| \t}\n00064| \tstderrPath := strings.TrimSuffix(stdoutPath, \".jsonl\") + \".stderr.log\"\n00065| \tstderrFile, err := os.Create(stderrPath)\n00066| \tif err != nil {\n00067| \t\t_ = stdoutFile.Close()\n00068| \t\treturn nil, err\n00069| \t}\n00070| \tcmd.Stdout = stdoutFile\n00071| \tcmd.Stderr = stderrFile\n00072| \tif err := cmd.Start(); err != nil {\n00073| \t\t_ = stdoutFile.Close()\n00074| \t\t_ = stderrFile.Close()\n00075| \t\treturn nil, err\n00076| \t}\n00077| \treturn cmdProcess{cmd: cmd, stdoutFile: stdoutFile, stderrFile: stderrFile}, nil\n00078| }\n00079| \n\n(End of file - total 79 lines)\n</file>","title":"cmd/yolo-runner/exec.go","metadata":{"preview":"package main\n\nimport (\n\t\"os\"\n\t\"os/exec\"\n\t\"strings\"\n\n\t\"yolo-runner/internal/opencode\"\n)\n\nfunc runCommand(args ...string) (string, error) {\n\tcmd := exec.Command(args[0], args[1:]...)\n\toutput, err := cmd.CombinedOutput()\n\treturn string(output), err\n}\n\ntype cmdProcess struct {\n\tcmd        *exec.Cmd\n\tstdoutFile *os.File\n\tstderrFile *os.File","truncated":false},"time":{"start":1768851056774,"end":1768851056775}},"metadata":{"openai":{"itemId":"fc_0a6a7c7bf0b68d2401696e86704d9c8191bd0974c9ff7b324f"}}}}
{"type":"step_finish","timestamp":1768851056882,"sessionID":"ses_428432b5cffeiuHqPgEDLEHUBi","part":{"id":"prt_bd7bd28e4001XymjQQ3RM2JZJj","sessionID":"ses_428432b5cffeiuHqPgEDLEHUBi","messageID":"msg_bd7bd1d710014ngh2mHAcxDnrL","type":"step-finish","reason":"tool-calls","snapshot":"8643970f6c765fc312fa47bea204ee12d43cee16","cost":0,"tokens":{"input":1650,"output":38,"reasoning":0,"cache":{"read":19072,"write":0}}}}
{"type":"step_start","timestamp":1768851057234,"sessionID":"ses_428432b5cffeiuHqPgEDLEHUBi","part":{"id":"prt_bd7bd2a500011OSfCyfTfdQ6As","sessionID":"ses_428432b5cffeiuHqPgEDLEHUBi","messageID":"msg_bd7bd2900001NUH6iz0Fg6GnvR","type":"step-start","snapshot":"aef38ef4aba648e7904342bee0474fd2c3ef6045"}}
{"type":"tool_use","timestamp":1768851110147,"sessionID":"ses_428432b5cffeiuHqPgEDLEHUBi","part":{"id":"prt_bd7bde75a001aReOw7OFPvhOu4","sessionID":"ses_428432b5cffeiuHqPgEDLEHUBi","messageID":"msg_bd7bd2900001NUH6iz0Fg6GnvR","type":"tool","callID":"call_u5YCBUpnwT5FA9Tu8QnrzKQh","tool":"edit","state":{"status":"completed","input":{"filePath":"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go","oldString":"func writeAgentFile(t *testing.T, repoRoot string, payload string) {\n\tt.Helper()\n\tagentDir := filepath.Join(repoRoot, \".opencode\", \"agent\")\n\tif err := os.MkdirAll(agentDir, 0o755); err != nil {\n\t\tt.Fatalf(\"mkdir agent dir: %v\", err)\n\t}\n\tagentPath := filepath.Join(agentDir, \"yolo.md\")\n\tif err := os.WriteFile(agentPath, []byte(payload), 0o644); err != nil {\n\t\tt.Fatalf(\"write agent file: %v\", err)\n\t}\n}\n","newString":"func writeAgentFile(t *testing.T, repoRoot string, payload string) {\n\tt.Helper()\n\tagentDir := filepath.Join(repoRoot, \".opencode\", \"agent\")\n\tif err := os.MkdirAll(agentDir, 0o755); err != nil {\n\t\tt.Fatalf(\"mkdir agent dir: %v\", err)\n\t}\n\tagentPath := filepath.Join(agentDir, \"yolo.md\")\n\tif err := os.WriteFile(agentPath, []byte(payload), 0o644); err != nil {\n\t\tt.Fatalf(\"write agent file: %v\", err)\n\t}\n}\n\nfunc writeRootYoloFile(t *testing.T, repoRoot string, payload string) {\n\tt.Helper()\n\tagentPath := filepath.Join(repoRoot, \"yolo.md\")\n\tif err := os.WriteFile(agentPath, []byte(payload), 0o644); err != nil {\n\t\tt.Fatalf(\"write yolo.md: %v\", err)\n\t}\n}\n"},"output":"Edit applied successfully.","title":"cmd/yolo-runner/main_test.go","metadata":{"diagnostics":{"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main.go":[],"/Users/egv/dev/yolo-runner/go.mod":[{"range":{"start":{"line":6,"character":44},"end":{"line":6,"character":55}},"severity":2,"source":"go mod tidy","message":"github.com/charmbracelet/bubbletea should be direct"},{"range":{"start":{"line":19,"character":26},"end":{"line":19,"character":37}},"severity":2,"source":"go mod tidy","message":"golang.org/x/term should be direct"}],"/Users/egv/dev/yolo-runner/internal/opencode/agent.go":[],"/Users/egv/dev/yolo-runner/internal/opencode/client.go":[{"range":{"start":{"line":28,"character":1},"end":{"line":28,"character":18}},"severity":2,"code":"default","codeDescription":{"href":"https://staticcheck.dev/docs/checks/#S1031"},"source":"S1031","message":"unnecessary nil check around range"}],"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go":[],"/Users/egv/dev/yolo-runner/internal/opencode/agent_test.go":[],"/Users/egv/dev/yolo-runner/cmd/yolo-runner/exec.go":[]},"diff":"Index: /Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go\n===================================================================\n--- /Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go\n+++ /Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go\n@@ -370,8 +370,16 @@\n \t\tt.Fatalf(\"write agent file: %v\", err)\n \t}\n }\n \n+func writeRootYoloFile(t *testing.T, repoRoot string, payload string) {\n+\tt.Helper()\n+\tagentPath := filepath.Join(repoRoot, \"yolo.md\")\n+\tif err := os.WriteFile(agentPath, []byte(payload), 0o644); err != nil {\n+\t\tt.Fatalf(\"write yolo.md: %v\", err)\n+\t}\n+}\n+\n func TestRunOnceMainUsesTUIOnTTYByDefault(t *testing.T) {\n \tfakeProgram := newFakeTUIProgram()\n \tprevIsTerminal := isTerminal\n \tprevNewTUIProgram := newTUIProgram\n","filediff":{"file":"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go","before":"package main\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"yolo-runner/internal/opencode\"\n\t\"yolo-runner/internal/runner\"\n)\n\ntype fakeRunner struct {\n\tcalls []string\n}\n\nfunc (f *fakeRunner) Run(args ...string) (string, error) {\n\tf.calls = append(f.calls, strings.Join(args, \" \"))\n\treturn \"\", nil\n}\n\ntype fakeOpenCodeRunLogger struct {\n\tcalled     bool\n\tissueID    string\n\trepoRoot   string\n\tprompt     string\n\tmodel      string\n\tconfigRoot string\n\tconfigDir  string\n\tlogPath    string\n}\n\nfunc (f *fakeOpenCodeRunLogger) Run(issueID string, repoRoot string, prompt string, model string, configRoot string, configDir string, logPath string) error {\n\tf.called = true\n\tf.issueID = issueID\n\tf.repoRoot = repoRoot\n\tf.prompt = prompt\n\tf.model = model\n\tf.configRoot = configRoot\n\tf.configDir = configDir\n\tf.logPath = logPath\n\treturn nil\n}\n\ntype fakeOpenCodeRunner struct {\n\tenv map[string]string\n}\n\ntype fakeOpenCodeProcess struct{}\n\nfunc (fakeOpenCodeProcess) Wait() error { return nil }\n\nfunc (fakeOpenCodeProcess) Kill() error { return nil }\n\nfunc (f *fakeOpenCodeRunner) Start(args []string, env map[string]string, stdoutPath string) (opencode.Process, error) {\n\tf.env = env\n\treturn fakeOpenCodeProcess{}, nil\n}\n\ntype fakeGitRunner struct {\n\tcalls  []string\n\toutput string\n\terr    error\n}\n\nfunc (f *fakeGitRunner) Run(name string, args ...string) (string, error) {\n\tf.calls = append(f.calls, name+\" \"+strings.Join(args, \" \"))\n\treturn f.output, f.err\n}\n\ntype fakeExit struct {\n\tcode int\n}\n\nfunc (f *fakeExit) Exit(code int) {\n\tf.code = code\n}\n\ntype fakeRunOnce struct {\n\tcalled bool\n\topts   runner.RunOnceOptions\n\tdeps   runner.RunOnceDeps\n\tresult string\n\terr    error\n}\n\nfunc (f *fakeRunOnce) Run(opts runner.RunOnceOptions, deps runner.RunOnceDeps) (string, error) {\n\n\tf.called = true\n\tf.opts = opts\n\tf.deps = deps\n\treturn f.result, f.err\n}\n\nfunc TestRunOnceMainReturnsErrorCodeOnFailure(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n\trunner := &fakeRunOnce{err: errors.New(\"boom\")}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\"}, runner.Run, exit.Exit, out, out, nil, nil)\n\n\tif code != 1 {\n\t\tt.Fatalf(\"expected exit code 1, got %d\", code)\n\t}\n\tif exit.code != 1 {\n\t\tt.Fatalf(\"expected exit to be called with 1, got %d\", exit.code)\n\t}\n\tif !strings.Contains(out.String(), \"boom\") {\n\t\tt.Fatalf(\"expected error output, got %q\", out.String())\n\t}\n}\n\nfunc TestRunOnceMainWiresDependencies(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tRunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\", \"--model\", \"model\", \"--dry-run\"}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif !runner.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n\tif runner.opts.RepoRoot != tempDir || runner.opts.RootID != \"root\" || runner.opts.Model != \"model\" || !runner.opts.DryRun {\n\t\tt.Fatalf(\"unexpected options: %#v\", runner.opts)\n\t}\n\tif runner.opts.Out == nil {\n\t\tt.Fatalf(\"expected output writer\")\n\t}\n\tif runner.deps.Beads == nil || runner.deps.Git == nil || runner.deps.Prompt == nil || runner.deps.OpenCode == nil || runner.deps.Logger == nil {\n\t\tt.Fatalf(\"expected deps to be wired\")\n\t}\n\tif exit.code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", exit.code)\n\t}\n}\n\nfunc TestRunOnceMainDefaultsConfigPaths(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tt.Setenv(\"HOME\", \"/home/user\")\n\tt.Setenv(\"XDG_CONFIG_HOME\", \"\")\n\n\tRunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\"}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif !runner.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n\tif runner.opts.ConfigRoot == \"\" {\n\t\tt.Fatalf(\"expected config root to be set\")\n\t}\n\tif runner.opts.ConfigDir == \"\" {\n\t\tt.Fatalf(\"expected config dir to be set\")\n\t}\n\texpectedConfigRoot := filepath.Join(\"/home/user\", \".config\", \"opencode-runner\")\n\tif runner.opts.ConfigRoot != expectedConfigRoot {\n\t\tt.Fatalf(\"expected config root %q, got %q\", expectedConfigRoot, runner.opts.ConfigRoot)\n\t}\n\texpectedConfigDir := filepath.Join(expectedConfigRoot, \"opencode\")\n\tif runner.opts.ConfigDir != expectedConfigDir {\n\t\tt.Fatalf(\"expected config dir %q, got %q\", expectedConfigDir, runner.opts.ConfigDir)\n\t}\n\tif exit.code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", exit.code)\n\t}\n}\n\nfunc TestRunOnceMainFailsWhenYoloAgentMissing(t *testing.T) {\n\ttempDir := t.TempDir()\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tstdout := &bytes.Buffer{}\n\tstderr := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\"}, runner.Run, exit.Exit, stdout, stderr, beadsRunner, gitRunner)\n\n\tif code != 1 {\n\t\tt.Fatalf(\"expected exit code 1, got %d\", code)\n\t}\n\tif exit.code != 1 {\n\t\tt.Fatalf(\"expected exit to be called with 1, got %d\", exit.code)\n\t}\n\tif runner.called {\n\t\tt.Fatalf(\"expected run once not to be called\")\n\t}\n\tif !strings.Contains(stderr.String(), \"yolo.md\") {\n\t\tt.Fatalf(\"expected error to mention yolo.md, got %q\", stderr.String())\n\t}\n}\n\nfunc TestRunOnceMainFailsWhenYoloAgentMissingPermission(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteAgentFile(t, tempDir, \"---\\nname: yolo\\n---\\n\")\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tstdout := &bytes.Buffer{}\n\tstderr := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\"}, runner.Run, exit.Exit, stdout, stderr, beadsRunner, gitRunner)\n\n\tif code != 1 {\n\t\tt.Fatalf(\"expected exit code 1, got %d\", code)\n\t}\n\tif exit.code != 1 {\n\t\tt.Fatalf(\"expected exit to be called with 1, got %d\", exit.code)\n\t}\n\tif runner.called {\n\t\tt.Fatalf(\"expected run once not to be called\")\n\t}\n\tif !strings.Contains(stderr.String(), \"permission: allow\") {\n\t\tt.Fatalf(\"expected error to mention permission allow, got %q\", stderr.String())\n\t}\n\tif !strings.Contains(strings.ToLower(stderr.String()), \"init\") {\n\t\tt.Fatalf(\"expected guidance to run init, got %q\", stderr.String())\n\t}\n}\n\nfunc TestRunOnceMainInfersRoadmapRootWhenMissing(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteIssuesFile(t, tempDir, `{\"id\":\"roadmap-1\",\"title\":\"Roadmap\",\"issue_type\":\"epic\",\"status\":\"open\"}`)\n\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", code)\n\t}\n\tif !runner.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n\tif runner.opts.RootID != \"roadmap-1\" {\n\t\tt.Fatalf(\"expected root id to be inferred, got %q\", runner.opts.RootID)\n\t}\n}\n\nfunc TestRunOnceMainInfersRoadmapRootWhenInProgress(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteIssuesFile(t, tempDir, `{\"id\":\"roadmap-2\",\"title\":\"Roadmap\",\"issue_type\":\"epic\",\"status\":\"in_progress\"}`)\n\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", code)\n\t}\n\tif !runner.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n\tif runner.opts.RootID != \"roadmap-2\" {\n\t\tt.Fatalf(\"expected root id to be inferred, got %q\", runner.opts.RootID)\n\t}\n}\n\nfunc TestRunOnceMainMissingRootRequiresExplicitFlag(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteIssuesFile(t, tempDir, `{\"id\":\"epic-1\",\"title\":\"Other\",\"issue_type\":\"epic\",\"status\":\"open\"}`)\n\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tstdout := &bytes.Buffer{}\n\tstderr := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir}, runner.Run, exit.Exit, stdout, stderr, beadsRunner, gitRunner)\n\n\tif code != 1 {\n\t\tt.Fatalf(\"expected exit code 1, got %d\", code)\n\t}\n\tif exit.code != 1 {\n\t\tt.Fatalf(\"expected exit to be called with 1, got %d\", exit.code)\n\t}\n\tif runner.called {\n\t\tt.Fatalf(\"expected run once not to be called\")\n\t}\n\tif !strings.Contains(stderr.String(), \"--root\") {\n\t\tt.Fatalf(\"expected error to mention --root, got %q\", stderr.String())\n\t}\n\tif !strings.Contains(strings.ToLower(stderr.String()), \"roadmap\") {\n\t\tt.Fatalf(\"expected error to mention roadmap, got %q\", stderr.String())\n\t}\n}\n\ntype fakeTUIProgram struct {\n\tstarted chan struct{}\n\tquit    chan struct{}\n\tevents  chan runner.Event\n}\n\nfunc newFakeTUIProgram() *fakeTUIProgram {\n\treturn &fakeTUIProgram{\n\t\tstarted: make(chan struct{}),\n\t\tquit:    make(chan struct{}),\n\t\tevents:  make(chan runner.Event, 1),\n\t}\n}\n\nfunc (f *fakeTUIProgram) Start() error {\n\tclose(f.started)\n\treturn nil\n}\n\nfunc (f *fakeTUIProgram) Send(event runner.Event) {\n\tf.events <- event\n}\n\nfunc (f *fakeTUIProgram) Quit() {\n\tclose(f.quit)\n}\n\nfunc waitForSignal(t *testing.T, signal chan struct{}, label string) {\n\tt.Helper()\n\tselect {\n\tcase <-signal:\n\t\treturn\n\tcase <-time.After(200 * time.Millisecond):\n\t\tt.Fatalf(\"expected %s\", label)\n\t}\n}\n\nfunc writeIssuesFile(t *testing.T, repoRoot string, payload string) {\n\tt.Helper()\n\tbeadsDir := filepath.Join(repoRoot, \".beads\")\n\tif err := os.MkdirAll(beadsDir, 0o755); err != nil {\n\t\tt.Fatalf(\"mkdir .beads: %v\", err)\n\t}\n\tissuesPath := filepath.Join(beadsDir, \"issues.jsonl\")\n\tif err := os.WriteFile(issuesPath, []byte(payload+\"\\n\"), 0o644); err != nil {\n\t\tt.Fatalf(\"write issues: %v\", err)\n\t}\n}\n\nfunc writeAgentFile(t *testing.T, repoRoot string, payload string) {\n\tt.Helper()\n\tagentDir := filepath.Join(repoRoot, \".opencode\", \"agent\")\n\tif err := os.MkdirAll(agentDir, 0o755); err != nil {\n\t\tt.Fatalf(\"mkdir agent dir: %v\", err)\n\t}\n\tagentPath := filepath.Join(agentDir, \"yolo.md\")\n\tif err := os.WriteFile(agentPath, []byte(payload), 0o644); err != nil {\n\t\tt.Fatalf(\"write agent file: %v\", err)\n\t}\n}\n\nfunc TestRunOnceMainUsesTUIOnTTYByDefault(t *testing.T) {\n\tfakeProgram := newFakeTUIProgram()\n\tprevIsTerminal := isTerminal\n\tprevNewTUIProgram := newTUIProgram\n\tisTerminal = func(io.Writer) bool { return true }\n\tnewTUIProgram = func(stdout io.Writer) tuiProgram { return fakeProgram }\n\tt.Cleanup(func() {\n\t\tisTerminal = prevIsTerminal\n\t\tnewTUIProgram = prevNewTUIProgram\n\t})\n\n\ttempDir := t.TempDir()\n\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n\trunOnce := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\"}, runOnce.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", code)\n\t}\n\tif runOnce.deps.Events == nil {\n\t\tt.Fatalf(\"expected events emitter to be set\")\n\t}\n\trunOnce.deps.Events.Emit(runner.Event{Type: runner.EventSelectTask})\n\twaitForSignal(t, fakeProgram.started, \"tui start\")\n\twaitForSignal(t, fakeProgram.quit, \"tui quit\")\n\tselect {\n\tcase <-fakeProgram.events:\n\t\t// ok\n\tcase <-time.After(200 * time.Millisecond):\n\t\tt.Fatalf(\"expected event to be forwarded to TUI\")\n\t}\n}\n\nfunc TestRunOnceMainHeadlessDisablesTUI(t *testing.T) {\n\tcalled := false\n\tprevIsTerminal := isTerminal\n\tprevNewTUIProgram := newTUIProgram\n\tisTerminal = func(io.Writer) bool { return true }\n\tnewTUIProgram = func(stdout io.Writer) tuiProgram {\n\t\tcalled = true\n\t\treturn newFakeTUIProgram()\n\t}\n\tt.Cleanup(func() {\n\t\tisTerminal = prevIsTerminal\n\t\tnewTUIProgram = prevNewTUIProgram\n\t})\n\n\ttempDir := t.TempDir()\n\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n\trunOnce := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\tstderr := &bytes.Buffer{}\n\n\tRunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\", \"--headless\"}, runOnce.Run, exit.Exit, out, stderr, beadsRunner, gitRunner)\n\n\tif called {\n\t\tt.Fatalf(\"expected TUI program not to start\")\n\t}\n\tif runOnce.deps.Events != nil {\n\t\tt.Fatalf(\"expected no events emitter in headless mode\")\n\t}\n}\n\nfunc TestOpenCodeRunDefaultsCreateConfigAndEnv(t *testing.T) {\n\ttempDir := t.TempDir()\n\trepoRoot := filepath.Join(tempDir, \"repo\")\n\tif err := os.MkdirAll(repoRoot, 0o755); err != nil {\n\t\tt.Fatalf(\"mkdir repo: %v\", err)\n\t}\n\tt.Setenv(\"HOME\", tempDir)\n\n\topenCodeRunner := &fakeOpenCodeRunner{}\n\topenCodeAdapter := openCodeAdapter{runner: openCodeRunner}\n\n\tconfigRoot := filepath.Join(tempDir, \".config\", \"opencode-runner\")\n\tconfigDir := filepath.Join(configRoot, \"opencode\")\n\tlogPath := filepath.Join(tempDir, \"runner-logs\", \"opencode\", \"issue-1.jsonl\")\n\n\tif err := openCodeAdapter.Run(\"issue-1\", repoRoot, \"prompt\", \"\", configRoot, configDir, logPath); err != nil {\n\t\tt.Fatalf(\"open code run error: %v\", err)\n\t}\n\n\tconfigFile := filepath.Join(configDir, \"opencode.json\")\n\tif _, err := os.Stat(configFile); err != nil {\n\t\tt.Fatalf(\"expected opencode.json to exist: %v\", err)\n\t}\n\texpectedConfigFile := filepath.Join(configDir, \"opencode.json\")\n\tif openCodeRunner.env[\"XDG_CONFIG_HOME\"] != configRoot {\n\t\tt.Fatalf(\"expected XDG_CONFIG_HOME set\")\n\t}\n\tif openCodeRunner.env[\"OPENCODE_CONFIG_DIR\"] != configDir {\n\t\tt.Fatalf(\"expected OPENCODE_CONFIG_DIR set\")\n\t}\n\tif openCodeRunner.env[\"OPENCODE_CONFIG\"] != expectedConfigFile {\n\t\tt.Fatalf(\"expected OPENCODE_CONFIG set\")\n\t}\n\tif openCodeRunner.env[\"OPENCODE_CONFIG_CONTENT\"] != \"{}\" {\n\t\tt.Fatalf(\"expected OPENCODE_CONFIG_CONTENT set\")\n\t}\n}\n","after":"package main\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"yolo-runner/internal/opencode\"\n\t\"yolo-runner/internal/runner\"\n)\n\ntype fakeRunner struct {\n\tcalls []string\n}\n\nfunc (f *fakeRunner) Run(args ...string) (string, error) {\n\tf.calls = append(f.calls, strings.Join(args, \" \"))\n\treturn \"\", nil\n}\n\ntype fakeOpenCodeRunLogger struct {\n\tcalled     bool\n\tissueID    string\n\trepoRoot   string\n\tprompt     string\n\tmodel      string\n\tconfigRoot string\n\tconfigDir  string\n\tlogPath    string\n}\n\nfunc (f *fakeOpenCodeRunLogger) Run(issueID string, repoRoot string, prompt string, model string, configRoot string, configDir string, logPath string) error {\n\tf.called = true\n\tf.issueID = issueID\n\tf.repoRoot = repoRoot\n\tf.prompt = prompt\n\tf.model = model\n\tf.configRoot = configRoot\n\tf.configDir = configDir\n\tf.logPath = logPath\n\treturn nil\n}\n\ntype fakeOpenCodeRunner struct {\n\tenv map[string]string\n}\n\ntype fakeOpenCodeProcess struct{}\n\nfunc (fakeOpenCodeProcess) Wait() error { return nil }\n\nfunc (fakeOpenCodeProcess) Kill() error { return nil }\n\nfunc (f *fakeOpenCodeRunner) Start(args []string, env map[string]string, stdoutPath string) (opencode.Process, error) {\n\tf.env = env\n\treturn fakeOpenCodeProcess{}, nil\n}\n\ntype fakeGitRunner struct {\n\tcalls  []string\n\toutput string\n\terr    error\n}\n\nfunc (f *fakeGitRunner) Run(name string, args ...string) (string, error) {\n\tf.calls = append(f.calls, name+\" \"+strings.Join(args, \" \"))\n\treturn f.output, f.err\n}\n\ntype fakeExit struct {\n\tcode int\n}\n\nfunc (f *fakeExit) Exit(code int) {\n\tf.code = code\n}\n\ntype fakeRunOnce struct {\n\tcalled bool\n\topts   runner.RunOnceOptions\n\tdeps   runner.RunOnceDeps\n\tresult string\n\terr    error\n}\n\nfunc (f *fakeRunOnce) Run(opts runner.RunOnceOptions, deps runner.RunOnceDeps) (string, error) {\n\n\tf.called = true\n\tf.opts = opts\n\tf.deps = deps\n\treturn f.result, f.err\n}\n\nfunc TestRunOnceMainReturnsErrorCodeOnFailure(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n\trunner := &fakeRunOnce{err: errors.New(\"boom\")}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\"}, runner.Run, exit.Exit, out, out, nil, nil)\n\n\tif code != 1 {\n\t\tt.Fatalf(\"expected exit code 1, got %d\", code)\n\t}\n\tif exit.code != 1 {\n\t\tt.Fatalf(\"expected exit to be called with 1, got %d\", exit.code)\n\t}\n\tif !strings.Contains(out.String(), \"boom\") {\n\t\tt.Fatalf(\"expected error output, got %q\", out.String())\n\t}\n}\n\nfunc TestRunOnceMainWiresDependencies(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tRunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\", \"--model\", \"model\", \"--dry-run\"}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif !runner.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n\tif runner.opts.RepoRoot != tempDir || runner.opts.RootID != \"root\" || runner.opts.Model != \"model\" || !runner.opts.DryRun {\n\t\tt.Fatalf(\"unexpected options: %#v\", runner.opts)\n\t}\n\tif runner.opts.Out == nil {\n\t\tt.Fatalf(\"expected output writer\")\n\t}\n\tif runner.deps.Beads == nil || runner.deps.Git == nil || runner.deps.Prompt == nil || runner.deps.OpenCode == nil || runner.deps.Logger == nil {\n\t\tt.Fatalf(\"expected deps to be wired\")\n\t}\n\tif exit.code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", exit.code)\n\t}\n}\n\nfunc TestRunOnceMainDefaultsConfigPaths(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tt.Setenv(\"HOME\", \"/home/user\")\n\tt.Setenv(\"XDG_CONFIG_HOME\", \"\")\n\n\tRunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\"}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif !runner.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n\tif runner.opts.ConfigRoot == \"\" {\n\t\tt.Fatalf(\"expected config root to be set\")\n\t}\n\tif runner.opts.ConfigDir == \"\" {\n\t\tt.Fatalf(\"expected config dir to be set\")\n\t}\n\texpectedConfigRoot := filepath.Join(\"/home/user\", \".config\", \"opencode-runner\")\n\tif runner.opts.ConfigRoot != expectedConfigRoot {\n\t\tt.Fatalf(\"expected config root %q, got %q\", expectedConfigRoot, runner.opts.ConfigRoot)\n\t}\n\texpectedConfigDir := filepath.Join(expectedConfigRoot, \"opencode\")\n\tif runner.opts.ConfigDir != expectedConfigDir {\n\t\tt.Fatalf(\"expected config dir %q, got %q\", expectedConfigDir, runner.opts.ConfigDir)\n\t}\n\tif exit.code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", exit.code)\n\t}\n}\n\nfunc TestRunOnceMainFailsWhenYoloAgentMissing(t *testing.T) {\n\ttempDir := t.TempDir()\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tstdout := &bytes.Buffer{}\n\tstderr := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\"}, runner.Run, exit.Exit, stdout, stderr, beadsRunner, gitRunner)\n\n\tif code != 1 {\n\t\tt.Fatalf(\"expected exit code 1, got %d\", code)\n\t}\n\tif exit.code != 1 {\n\t\tt.Fatalf(\"expected exit to be called with 1, got %d\", exit.code)\n\t}\n\tif runner.called {\n\t\tt.Fatalf(\"expected run once not to be called\")\n\t}\n\tif !strings.Contains(stderr.String(), \"yolo.md\") {\n\t\tt.Fatalf(\"expected error to mention yolo.md, got %q\", stderr.String())\n\t}\n}\n\nfunc TestRunOnceMainFailsWhenYoloAgentMissingPermission(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteAgentFile(t, tempDir, \"---\\nname: yolo\\n---\\n\")\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tstdout := &bytes.Buffer{}\n\tstderr := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\"}, runner.Run, exit.Exit, stdout, stderr, beadsRunner, gitRunner)\n\n\tif code != 1 {\n\t\tt.Fatalf(\"expected exit code 1, got %d\", code)\n\t}\n\tif exit.code != 1 {\n\t\tt.Fatalf(\"expected exit to be called with 1, got %d\", exit.code)\n\t}\n\tif runner.called {\n\t\tt.Fatalf(\"expected run once not to be called\")\n\t}\n\tif !strings.Contains(stderr.String(), \"permission: allow\") {\n\t\tt.Fatalf(\"expected error to mention permission allow, got %q\", stderr.String())\n\t}\n\tif !strings.Contains(strings.ToLower(stderr.String()), \"init\") {\n\t\tt.Fatalf(\"expected guidance to run init, got %q\", stderr.String())\n\t}\n}\n\nfunc TestRunOnceMainInfersRoadmapRootWhenMissing(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteIssuesFile(t, tempDir, `{\"id\":\"roadmap-1\",\"title\":\"Roadmap\",\"issue_type\":\"epic\",\"status\":\"open\"}`)\n\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", code)\n\t}\n\tif !runner.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n\tif runner.opts.RootID != \"roadmap-1\" {\n\t\tt.Fatalf(\"expected root id to be inferred, got %q\", runner.opts.RootID)\n\t}\n}\n\nfunc TestRunOnceMainInfersRoadmapRootWhenInProgress(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteIssuesFile(t, tempDir, `{\"id\":\"roadmap-2\",\"title\":\"Roadmap\",\"issue_type\":\"epic\",\"status\":\"in_progress\"}`)\n\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", code)\n\t}\n\tif !runner.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n\tif runner.opts.RootID != \"roadmap-2\" {\n\t\tt.Fatalf(\"expected root id to be inferred, got %q\", runner.opts.RootID)\n\t}\n}\n\nfunc TestRunOnceMainMissingRootRequiresExplicitFlag(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteIssuesFile(t, tempDir, `{\"id\":\"epic-1\",\"title\":\"Other\",\"issue_type\":\"epic\",\"status\":\"open\"}`)\n\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tstdout := &bytes.Buffer{}\n\tstderr := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir}, runner.Run, exit.Exit, stdout, stderr, beadsRunner, gitRunner)\n\n\tif code != 1 {\n\t\tt.Fatalf(\"expected exit code 1, got %d\", code)\n\t}\n\tif exit.code != 1 {\n\t\tt.Fatalf(\"expected exit to be called with 1, got %d\", exit.code)\n\t}\n\tif runner.called {\n\t\tt.Fatalf(\"expected run once not to be called\")\n\t}\n\tif !strings.Contains(stderr.String(), \"--root\") {\n\t\tt.Fatalf(\"expected error to mention --root, got %q\", stderr.String())\n\t}\n\tif !strings.Contains(strings.ToLower(stderr.String()), \"roadmap\") {\n\t\tt.Fatalf(\"expected error to mention roadmap, got %q\", stderr.String())\n\t}\n}\n\ntype fakeTUIProgram struct {\n\tstarted chan struct{}\n\tquit    chan struct{}\n\tevents  chan runner.Event\n}\n\nfunc newFakeTUIProgram() *fakeTUIProgram {\n\treturn &fakeTUIProgram{\n\t\tstarted: make(chan struct{}),\n\t\tquit:    make(chan struct{}),\n\t\tevents:  make(chan runner.Event, 1),\n\t}\n}\n\nfunc (f *fakeTUIProgram) Start() error {\n\tclose(f.started)\n\treturn nil\n}\n\nfunc (f *fakeTUIProgram) Send(event runner.Event) {\n\tf.events <- event\n}\n\nfunc (f *fakeTUIProgram) Quit() {\n\tclose(f.quit)\n}\n\nfunc waitForSignal(t *testing.T, signal chan struct{}, label string) {\n\tt.Helper()\n\tselect {\n\tcase <-signal:\n\t\treturn\n\tcase <-time.After(200 * time.Millisecond):\n\t\tt.Fatalf(\"expected %s\", label)\n\t}\n}\n\nfunc writeIssuesFile(t *testing.T, repoRoot string, payload string) {\n\tt.Helper()\n\tbeadsDir := filepath.Join(repoRoot, \".beads\")\n\tif err := os.MkdirAll(beadsDir, 0o755); err != nil {\n\t\tt.Fatalf(\"mkdir .beads: %v\", err)\n\t}\n\tissuesPath := filepath.Join(beadsDir, \"issues.jsonl\")\n\tif err := os.WriteFile(issuesPath, []byte(payload+\"\\n\"), 0o644); err != nil {\n\t\tt.Fatalf(\"write issues: %v\", err)\n\t}\n}\n\nfunc writeAgentFile(t *testing.T, repoRoot string, payload string) {\n\tt.Helper()\n\tagentDir := filepath.Join(repoRoot, \".opencode\", \"agent\")\n\tif err := os.MkdirAll(agentDir, 0o755); err != nil {\n\t\tt.Fatalf(\"mkdir agent dir: %v\", err)\n\t}\n\tagentPath := filepath.Join(agentDir, \"yolo.md\")\n\tif err := os.WriteFile(agentPath, []byte(payload), 0o644); err != nil {\n\t\tt.Fatalf(\"write agent file: %v\", err)\n\t}\n}\n\nfunc writeRootYoloFile(t *testing.T, repoRoot string, payload string) {\n\tt.Helper()\n\tagentPath := filepath.Join(repoRoot, \"yolo.md\")\n\tif err := os.WriteFile(agentPath, []byte(payload), 0o644); err != nil {\n\t\tt.Fatalf(\"write yolo.md: %v\", err)\n\t}\n}\n\nfunc TestRunOnceMainUsesTUIOnTTYByDefault(t *testing.T) {\n\tfakeProgram := newFakeTUIProgram()\n\tprevIsTerminal := isTerminal\n\tprevNewTUIProgram := newTUIProgram\n\tisTerminal = func(io.Writer) bool { return true }\n\tnewTUIProgram = func(stdout io.Writer) tuiProgram { return fakeProgram }\n\tt.Cleanup(func() {\n\t\tisTerminal = prevIsTerminal\n\t\tnewTUIProgram = prevNewTUIProgram\n\t})\n\n\ttempDir := t.TempDir()\n\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n\trunOnce := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\"}, runOnce.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", code)\n\t}\n\tif runOnce.deps.Events == nil {\n\t\tt.Fatalf(\"expected events emitter to be set\")\n\t}\n\trunOnce.deps.Events.Emit(runner.Event{Type: runner.EventSelectTask})\n\twaitForSignal(t, fakeProgram.started, \"tui start\")\n\twaitForSignal(t, fakeProgram.quit, \"tui quit\")\n\tselect {\n\tcase <-fakeProgram.events:\n\t\t// ok\n\tcase <-time.After(200 * time.Millisecond):\n\t\tt.Fatalf(\"expected event to be forwarded to TUI\")\n\t}\n}\n\nfunc TestRunOnceMainHeadlessDisablesTUI(t *testing.T) {\n\tcalled := false\n\tprevIsTerminal := isTerminal\n\tprevNewTUIProgram := newTUIProgram\n\tisTerminal = func(io.Writer) bool { return true }\n\tnewTUIProgram = func(stdout io.Writer) tuiProgram {\n\t\tcalled = true\n\t\treturn newFakeTUIProgram()\n\t}\n\tt.Cleanup(func() {\n\t\tisTerminal = prevIsTerminal\n\t\tnewTUIProgram = prevNewTUIProgram\n\t})\n\n\ttempDir := t.TempDir()\n\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n\trunOnce := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\tstderr := &bytes.Buffer{}\n\n\tRunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\", \"--headless\"}, runOnce.Run, exit.Exit, out, stderr, beadsRunner, gitRunner)\n\n\tif called {\n\t\tt.Fatalf(\"expected TUI program not to start\")\n\t}\n\tif runOnce.deps.Events != nil {\n\t\tt.Fatalf(\"expected no events emitter in headless mode\")\n\t}\n}\n\nfunc TestOpenCodeRunDefaultsCreateConfigAndEnv(t *testing.T) {\n\ttempDir := t.TempDir()\n\trepoRoot := filepath.Join(tempDir, \"repo\")\n\tif err := os.MkdirAll(repoRoot, 0o755); err != nil {\n\t\tt.Fatalf(\"mkdir repo: %v\", err)\n\t}\n\tt.Setenv(\"HOME\", tempDir)\n\n\topenCodeRunner := &fakeOpenCodeRunner{}\n\topenCodeAdapter := openCodeAdapter{runner: openCodeRunner}\n\n\tconfigRoot := filepath.Join(tempDir, \".config\", \"opencode-runner\")\n\tconfigDir := filepath.Join(configRoot, \"opencode\")\n\tlogPath := filepath.Join(tempDir, \"runner-logs\", \"opencode\", \"issue-1.jsonl\")\n\n\tif err := openCodeAdapter.Run(\"issue-1\", repoRoot, \"prompt\", \"\", configRoot, configDir, logPath); err != nil {\n\t\tt.Fatalf(\"open code run error: %v\", err)\n\t}\n\n\tconfigFile := filepath.Join(configDir, \"opencode.json\")\n\tif _, err := os.Stat(configFile); err != nil {\n\t\tt.Fatalf(\"expected opencode.json to exist: %v\", err)\n\t}\n\texpectedConfigFile := filepath.Join(configDir, \"opencode.json\")\n\tif openCodeRunner.env[\"XDG_CONFIG_HOME\"] != configRoot {\n\t\tt.Fatalf(\"expected XDG_CONFIG_HOME set\")\n\t}\n\tif openCodeRunner.env[\"OPENCODE_CONFIG_DIR\"] != configDir {\n\t\tt.Fatalf(\"expected OPENCODE_CONFIG_DIR set\")\n\t}\n\tif openCodeRunner.env[\"OPENCODE_CONFIG\"] != expectedConfigFile {\n\t\tt.Fatalf(\"expected OPENCODE_CONFIG set\")\n\t}\n\tif openCodeRunner.env[\"OPENCODE_CONFIG_CONTENT\"] != \"{}\" {\n\t\tt.Fatalf(\"expected OPENCODE_CONFIG_CONTENT set\")\n\t}\n}\n","additions":8,"deletions":0},"truncated":false},"time":{"start":1768851109974,"end":1768851110146}},"metadata":{"openai":{"itemId":"fc_0cba46f74dfb2a7901696e86a173548191a72fbe3487096ee7"}}}}
{"type":"step_finish","timestamp":1768851110164,"sessionID":"ses_428432b5cffeiuHqPgEDLEHUBi","part":{"id":"prt_bd7bdf9030014vR29xcS6kt1eS","sessionID":"ses_428432b5cffeiuHqPgEDLEHUBi","messageID":"msg_bd7bd2900001NUH6iz0Fg6GnvR","type":"step-finish","reason":"tool-calls","snapshot":"c6216ef00ca9c4ed0bb39d44f6629e695856995e","cost":0,"tokens":{"input":935,"output":2851,"reasoning":2432,"cache":{"read":20608,"write":0}}}}
{"type":"step_start","timestamp":1768851110520,"sessionID":"ses_428432b5cffeiuHqPgEDLEHUBi","part":{"id":"prt_bd7bdfa78001TatdjGG0qkVBwq","sessionID":"ses_428432b5cffeiuHqPgEDLEHUBi","messageID":"msg_bd7bdf926001VzUOshNfmHzz8W","type":"step-start","snapshot":"16a9e3f6d7391d88665ffbcf92092676179f3436"}}
{"type":"tool_use","timestamp":1768851134524,"sessionID":"ses_428432b5cffeiuHqPgEDLEHUBi","part":{"id":"prt_bd7bdfc660015JameGvjEgtkLV","sessionID":"ses_428432b5cffeiuHqPgEDLEHUBi","messageID":"msg_bd7bdf926001VzUOshNfmHzz8W","type":"tool","callID":"call_dIGq0CmtozDu6DlzK6RTpNzT","tool":"edit","state":{"status":"completed","input":{"filePath":"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go","oldString":"func TestRunOnceMainHeadlessDisablesTUI(t *testing.T) {\n\tcalled := false\n\tprevIsTerminal := isTerminal\n\tprevNewTUIProgram := newTUIProgram\n\tisTerminal = func(io.Writer) bool { return true }\n\tnewTUIProgram = func(stdout io.Writer) tuiProgram {\n\t\tcalled = true\n\t\treturn newFakeTUIProgram()\n\t}\n\tt.Cleanup(func() {\n\t\tisTerminal = prevIsTerminal\n\t\tnewTUIProgram = prevNewTUIProgram\n\t})\n\n\ttempDir := t.TempDir()\n\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n\trunOnce := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\tstderr := &bytes.Buffer{}\n\n\tRunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\", \"--headless\"}, runOnce.Run, exit.Exit, out, stderr, beadsRunner, gitRunner)\n\n\tif called {\n\t\tt.Fatalf(\"expected TUI program not to start\")\n\t}\n\tif runOnce.deps.Events != nil {\n\t\tt.Fatalf(\"expected no events emitter in headless mode\")\n\t}\n}\n","newString":"func TestRunOnceMainHeadlessDisablesTUI(t *testing.T) {\n\tcalled := false\n\tprevIsTerminal := isTerminal\n\tprevNewTUIProgram := newTUIProgram\n\tisTerminal = func(io.Writer) bool { return true }\n\tnewTUIProgram = func(stdout io.Writer) tuiProgram {\n\t\tcalled = true\n\t\treturn newFakeTUIProgram()\n\t}\n\tt.Cleanup(func() {\n\t\tisTerminal = prevIsTerminal\n\t\tnewTUIProgram = prevNewTUIProgram\n\t})\n\n\ttempDir := t.TempDir()\n\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n\trunOnce := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\tstderr := &bytes.Buffer{}\n\n\tRunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\", \"--headless\"}, runOnce.Run, exit.Exit, out, stderr, beadsRunner, gitRunner)\n\n\tif called {\n\t\tt.Fatalf(\"expected TUI program not to start\")\n\t}\n\tif runOnce.deps.Events != nil {\n\t\tt.Fatalf(\"expected no events emitter in headless mode\")\n\t}\n}\n\nfunc TestRunOnceMainInitOverwritesAgentFile(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteRootYoloFile(t, tempDir, \"root-agent\")\n\twriteAgentFile(t, tempDir, \"stale\")\n\n\tstdout := &bytes.Buffer{}\n\tstderr := &bytes.Buffer{}\n\texit := &fakeExit{}\n\n\tcode := RunOnceMain([]string{\"init\", \"--repo\", tempDir}, nil, exit.Exit, stdout, stderr, nil, nil)\n\n\tif code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", code)\n\t}\n\tif exit.code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", exit.code)\n\t}\n\tagentPath := filepath.Join(tempDir, \".opencode\", \"agent\", \"yolo.md\")\n\tcontent, err := os.ReadFile(agentPath)\n\tif err != nil {\n\t\tt.Fatalf(\"read agent file: %v\", err)\n\t}\n\tif string(content) != \"root-agent\" {\n\t\tt.Fatalf(\"expected agent file to be overwritten\")\n\t}\n}\n\nfunc TestRunOnceMainInitCreatesAgentDir(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteRootYoloFile(t, tempDir, \"root-agent\")\n\n\tstdout := &bytes.Buffer{}\n\tstderr := &bytes.Buffer{}\n\texit := &fakeExit{}\n\n\tcode := RunOnceMain([]string{\"init\", \"--repo\", tempDir}, nil, exit.Exit, stdout, stderr, nil, nil)\n\n\tif code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", code)\n\t}\n\tagentPath := filepath.Join(tempDir, \".opencode\", \"agent\", \"yolo.md\")\n\tcontent, err := os.ReadFile(agentPath)\n\tif err != nil {\n\t\tt.Fatalf(\"read agent file: %v\", err)\n\t}\n\tif string(content) != \"root-agent\" {\n\t\tt.Fatalf(\"expected agent file to be created\")\n\t}\n}\n\nfunc TestRunOnceMainRunModePassesAfterInit(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteRootYoloFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n\n\tstdout := &bytes.Buffer{}\n\tstderr := &bytes.Buffer{}\n\texit := &fakeExit{}\n\n\tcode := RunOnceMain([]string{\"init\", \"--repo\", tempDir}, nil, exit.Exit, stdout, stderr, nil, nil)\n\tif code != 0 {\n\t\tt.Fatalf(\"expected init exit code 0, got %d\", code)\n\t}\n\n\trunOnce := &fakeRunOnce{result: \"no_tasks\"}\n\tcode = RunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\"}, runOnce.Run, exit.Exit, stdout, stderr, nil, nil)\n\n\tif code != 0 {\n\t\tt.Fatalf(\"expected run mode exit code 0, got %d\", code)\n\t}\n\tif !runOnce.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n}\n"},"output":"Edit applied successfully.","title":"cmd/yolo-runner/main_test.go","metadata":{"diagnostics":{"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main.go":[],"/Users/egv/dev/yolo-runner/go.mod":[{"range":{"start":{"line":6,"character":44},"end":{"line":6,"character":55}},"severity":2,"source":"go mod tidy","message":"github.com/charmbracelet/bubbletea should be direct"},{"range":{"start":{"line":19,"character":26},"end":{"line":19,"character":37}},"severity":2,"source":"go mod tidy","message":"golang.org/x/term should be direct"}],"/Users/egv/dev/yolo-runner/internal/opencode/agent.go":[],"/Users/egv/dev/yolo-runner/internal/opencode/client.go":[{"range":{"start":{"line":28,"character":1},"end":{"line":28,"character":18}},"severity":2,"code":"default","codeDescription":{"href":"https://staticcheck.dev/docs/checks/#S1031"},"source":"S1031","message":"unnecessary nil check around range"}],"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go":[],"/Users/egv/dev/yolo-runner/internal/opencode/agent_test.go":[],"/Users/egv/dev/yolo-runner/cmd/yolo-runner/exec.go":[]},"diff":"Index: /Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go\n===================================================================\n--- /Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go\n+++ /Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go\n@@ -449,8 +449,82 @@\n \t\tt.Fatalf(\"expected no events emitter in headless mode\")\n \t}\n }\n \n+func TestRunOnceMainInitOverwritesAgentFile(t *testing.T) {\n+\ttempDir := t.TempDir()\n+\twriteRootYoloFile(t, tempDir, \"root-agent\")\n+\twriteAgentFile(t, tempDir, \"stale\")\n+\n+\tstdout := &bytes.Buffer{}\n+\tstderr := &bytes.Buffer{}\n+\texit := &fakeExit{}\n+\n+\tcode := RunOnceMain([]string{\"init\", \"--repo\", tempDir}, nil, exit.Exit, stdout, stderr, nil, nil)\n+\n+\tif code != 0 {\n+\t\tt.Fatalf(\"expected exit code 0, got %d\", code)\n+\t}\n+\tif exit.code != 0 {\n+\t\tt.Fatalf(\"expected exit code 0, got %d\", exit.code)\n+\t}\n+\tagentPath := filepath.Join(tempDir, \".opencode\", \"agent\", \"yolo.md\")\n+\tcontent, err := os.ReadFile(agentPath)\n+\tif err != nil {\n+\t\tt.Fatalf(\"read agent file: %v\", err)\n+\t}\n+\tif string(content) != \"root-agent\" {\n+\t\tt.Fatalf(\"expected agent file to be overwritten\")\n+\t}\n+}\n+\n+func TestRunOnceMainInitCreatesAgentDir(t *testing.T) {\n+\ttempDir := t.TempDir()\n+\twriteRootYoloFile(t, tempDir, \"root-agent\")\n+\n+\tstdout := &bytes.Buffer{}\n+\tstderr := &bytes.Buffer{}\n+\texit := &fakeExit{}\n+\n+\tcode := RunOnceMain([]string{\"init\", \"--repo\", tempDir}, nil, exit.Exit, stdout, stderr, nil, nil)\n+\n+\tif code != 0 {\n+\t\tt.Fatalf(\"expected exit code 0, got %d\", code)\n+\t}\n+\tagentPath := filepath.Join(tempDir, \".opencode\", \"agent\", \"yolo.md\")\n+\tcontent, err := os.ReadFile(agentPath)\n+\tif err != nil {\n+\t\tt.Fatalf(\"read agent file: %v\", err)\n+\t}\n+\tif string(content) != \"root-agent\" {\n+\t\tt.Fatalf(\"expected agent file to be created\")\n+\t}\n+}\n+\n+func TestRunOnceMainRunModePassesAfterInit(t *testing.T) {\n+\ttempDir := t.TempDir()\n+\twriteRootYoloFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n+\n+\tstdout := &bytes.Buffer{}\n+\tstderr := &bytes.Buffer{}\n+\texit := &fakeExit{}\n+\n+\tcode := RunOnceMain([]string{\"init\", \"--repo\", tempDir}, nil, exit.Exit, stdout, stderr, nil, nil)\n+\tif code != 0 {\n+\t\tt.Fatalf(\"expected init exit code 0, got %d\", code)\n+\t}\n+\n+\trunOnce := &fakeRunOnce{result: \"no_tasks\"}\n+\tcode = RunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\"}, runOnce.Run, exit.Exit, stdout, stderr, nil, nil)\n+\n+\tif code != 0 {\n+\t\tt.Fatalf(\"expected run mode exit code 0, got %d\", code)\n+\t}\n+\tif !runOnce.called {\n+\t\tt.Fatalf(\"expected run once to be called\")\n+\t}\n+}\n+\n func TestOpenCodeRunDefaultsCreateConfigAndEnv(t *testing.T) {\n \ttempDir := t.TempDir()\n \trepoRoot := filepath.Join(tempDir, \"repo\")\n \tif err := os.MkdirAll(repoRoot, 0o755); err != nil {\n","filediff":{"file":"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go","before":"package main\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"yolo-runner/internal/opencode\"\n\t\"yolo-runner/internal/runner\"\n)\n\ntype fakeRunner struct {\n\tcalls []string\n}\n\nfunc (f *fakeRunner) Run(args ...string) (string, error) {\n\tf.calls = append(f.calls, strings.Join(args, \" \"))\n\treturn \"\", nil\n}\n\ntype fakeOpenCodeRunLogger struct {\n\tcalled     bool\n\tissueID    string\n\trepoRoot   string\n\tprompt     string\n\tmodel      string\n\tconfigRoot string\n\tconfigDir  string\n\tlogPath    string\n}\n\nfunc (f *fakeOpenCodeRunLogger) Run(issueID string, repoRoot string, prompt string, model string, configRoot string, configDir string, logPath string) error {\n\tf.called = true\n\tf.issueID = issueID\n\tf.repoRoot = repoRoot\n\tf.prompt = prompt\n\tf.model = model\n\tf.configRoot = configRoot\n\tf.configDir = configDir\n\tf.logPath = logPath\n\treturn nil\n}\n\ntype fakeOpenCodeRunner struct {\n\tenv map[string]string\n}\n\ntype fakeOpenCodeProcess struct{}\n\nfunc (fakeOpenCodeProcess) Wait() error { return nil }\n\nfunc (fakeOpenCodeProcess) Kill() error { return nil }\n\nfunc (f *fakeOpenCodeRunner) Start(args []string, env map[string]string, stdoutPath string) (opencode.Process, error) {\n\tf.env = env\n\treturn fakeOpenCodeProcess{}, nil\n}\n\ntype fakeGitRunner struct {\n\tcalls  []string\n\toutput string\n\terr    error\n}\n\nfunc (f *fakeGitRunner) Run(name string, args ...string) (string, error) {\n\tf.calls = append(f.calls, name+\" \"+strings.Join(args, \" \"))\n\treturn f.output, f.err\n}\n\ntype fakeExit struct {\n\tcode int\n}\n\nfunc (f *fakeExit) Exit(code int) {\n\tf.code = code\n}\n\ntype fakeRunOnce struct {\n\tcalled bool\n\topts   runner.RunOnceOptions\n\tdeps   runner.RunOnceDeps\n\tresult string\n\terr    error\n}\n\nfunc (f *fakeRunOnce) Run(opts runner.RunOnceOptions, deps runner.RunOnceDeps) (string, error) {\n\n\tf.called = true\n\tf.opts = opts\n\tf.deps = deps\n\treturn f.result, f.err\n}\n\nfunc TestRunOnceMainReturnsErrorCodeOnFailure(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n\trunner := &fakeRunOnce{err: errors.New(\"boom\")}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\"}, runner.Run, exit.Exit, out, out, nil, nil)\n\n\tif code != 1 {\n\t\tt.Fatalf(\"expected exit code 1, got %d\", code)\n\t}\n\tif exit.code != 1 {\n\t\tt.Fatalf(\"expected exit to be called with 1, got %d\", exit.code)\n\t}\n\tif !strings.Contains(out.String(), \"boom\") {\n\t\tt.Fatalf(\"expected error output, got %q\", out.String())\n\t}\n}\n\nfunc TestRunOnceMainWiresDependencies(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tRunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\", \"--model\", \"model\", \"--dry-run\"}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif !runner.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n\tif runner.opts.RepoRoot != tempDir || runner.opts.RootID != \"root\" || runner.opts.Model != \"model\" || !runner.opts.DryRun {\n\t\tt.Fatalf(\"unexpected options: %#v\", runner.opts)\n\t}\n\tif runner.opts.Out == nil {\n\t\tt.Fatalf(\"expected output writer\")\n\t}\n\tif runner.deps.Beads == nil || runner.deps.Git == nil || runner.deps.Prompt == nil || runner.deps.OpenCode == nil || runner.deps.Logger == nil {\n\t\tt.Fatalf(\"expected deps to be wired\")\n\t}\n\tif exit.code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", exit.code)\n\t}\n}\n\nfunc TestRunOnceMainDefaultsConfigPaths(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tt.Setenv(\"HOME\", \"/home/user\")\n\tt.Setenv(\"XDG_CONFIG_HOME\", \"\")\n\n\tRunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\"}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif !runner.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n\tif runner.opts.ConfigRoot == \"\" {\n\t\tt.Fatalf(\"expected config root to be set\")\n\t}\n\tif runner.opts.ConfigDir == \"\" {\n\t\tt.Fatalf(\"expected config dir to be set\")\n\t}\n\texpectedConfigRoot := filepath.Join(\"/home/user\", \".config\", \"opencode-runner\")\n\tif runner.opts.ConfigRoot != expectedConfigRoot {\n\t\tt.Fatalf(\"expected config root %q, got %q\", expectedConfigRoot, runner.opts.ConfigRoot)\n\t}\n\texpectedConfigDir := filepath.Join(expectedConfigRoot, \"opencode\")\n\tif runner.opts.ConfigDir != expectedConfigDir {\n\t\tt.Fatalf(\"expected config dir %q, got %q\", expectedConfigDir, runner.opts.ConfigDir)\n\t}\n\tif exit.code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", exit.code)\n\t}\n}\n\nfunc TestRunOnceMainFailsWhenYoloAgentMissing(t *testing.T) {\n\ttempDir := t.TempDir()\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tstdout := &bytes.Buffer{}\n\tstderr := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\"}, runner.Run, exit.Exit, stdout, stderr, beadsRunner, gitRunner)\n\n\tif code != 1 {\n\t\tt.Fatalf(\"expected exit code 1, got %d\", code)\n\t}\n\tif exit.code != 1 {\n\t\tt.Fatalf(\"expected exit to be called with 1, got %d\", exit.code)\n\t}\n\tif runner.called {\n\t\tt.Fatalf(\"expected run once not to be called\")\n\t}\n\tif !strings.Contains(stderr.String(), \"yolo.md\") {\n\t\tt.Fatalf(\"expected error to mention yolo.md, got %q\", stderr.String())\n\t}\n}\n\nfunc TestRunOnceMainFailsWhenYoloAgentMissingPermission(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteAgentFile(t, tempDir, \"---\\nname: yolo\\n---\\n\")\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tstdout := &bytes.Buffer{}\n\tstderr := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\"}, runner.Run, exit.Exit, stdout, stderr, beadsRunner, gitRunner)\n\n\tif code != 1 {\n\t\tt.Fatalf(\"expected exit code 1, got %d\", code)\n\t}\n\tif exit.code != 1 {\n\t\tt.Fatalf(\"expected exit to be called with 1, got %d\", exit.code)\n\t}\n\tif runner.called {\n\t\tt.Fatalf(\"expected run once not to be called\")\n\t}\n\tif !strings.Contains(stderr.String(), \"permission: allow\") {\n\t\tt.Fatalf(\"expected error to mention permission allow, got %q\", stderr.String())\n\t}\n\tif !strings.Contains(strings.ToLower(stderr.String()), \"init\") {\n\t\tt.Fatalf(\"expected guidance to run init, got %q\", stderr.String())\n\t}\n}\n\nfunc TestRunOnceMainInfersRoadmapRootWhenMissing(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteIssuesFile(t, tempDir, `{\"id\":\"roadmap-1\",\"title\":\"Roadmap\",\"issue_type\":\"epic\",\"status\":\"open\"}`)\n\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", code)\n\t}\n\tif !runner.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n\tif runner.opts.RootID != \"roadmap-1\" {\n\t\tt.Fatalf(\"expected root id to be inferred, got %q\", runner.opts.RootID)\n\t}\n}\n\nfunc TestRunOnceMainInfersRoadmapRootWhenInProgress(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteIssuesFile(t, tempDir, `{\"id\":\"roadmap-2\",\"title\":\"Roadmap\",\"issue_type\":\"epic\",\"status\":\"in_progress\"}`)\n\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", code)\n\t}\n\tif !runner.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n\tif runner.opts.RootID != \"roadmap-2\" {\n\t\tt.Fatalf(\"expected root id to be inferred, got %q\", runner.opts.RootID)\n\t}\n}\n\nfunc TestRunOnceMainMissingRootRequiresExplicitFlag(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteIssuesFile(t, tempDir, `{\"id\":\"epic-1\",\"title\":\"Other\",\"issue_type\":\"epic\",\"status\":\"open\"}`)\n\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tstdout := &bytes.Buffer{}\n\tstderr := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir}, runner.Run, exit.Exit, stdout, stderr, beadsRunner, gitRunner)\n\n\tif code != 1 {\n\t\tt.Fatalf(\"expected exit code 1, got %d\", code)\n\t}\n\tif exit.code != 1 {\n\t\tt.Fatalf(\"expected exit to be called with 1, got %d\", exit.code)\n\t}\n\tif runner.called {\n\t\tt.Fatalf(\"expected run once not to be called\")\n\t}\n\tif !strings.Contains(stderr.String(), \"--root\") {\n\t\tt.Fatalf(\"expected error to mention --root, got %q\", stderr.String())\n\t}\n\tif !strings.Contains(strings.ToLower(stderr.String()), \"roadmap\") {\n\t\tt.Fatalf(\"expected error to mention roadmap, got %q\", stderr.String())\n\t}\n}\n\ntype fakeTUIProgram struct {\n\tstarted chan struct{}\n\tquit    chan struct{}\n\tevents  chan runner.Event\n}\n\nfunc newFakeTUIProgram() *fakeTUIProgram {\n\treturn &fakeTUIProgram{\n\t\tstarted: make(chan struct{}),\n\t\tquit:    make(chan struct{}),\n\t\tevents:  make(chan runner.Event, 1),\n\t}\n}\n\nfunc (f *fakeTUIProgram) Start() error {\n\tclose(f.started)\n\treturn nil\n}\n\nfunc (f *fakeTUIProgram) Send(event runner.Event) {\n\tf.events <- event\n}\n\nfunc (f *fakeTUIProgram) Quit() {\n\tclose(f.quit)\n}\n\nfunc waitForSignal(t *testing.T, signal chan struct{}, label string) {\n\tt.Helper()\n\tselect {\n\tcase <-signal:\n\t\treturn\n\tcase <-time.After(200 * time.Millisecond):\n\t\tt.Fatalf(\"expected %s\", label)\n\t}\n}\n\nfunc writeIssuesFile(t *testing.T, repoRoot string, payload string) {\n\tt.Helper()\n\tbeadsDir := filepath.Join(repoRoot, \".beads\")\n\tif err := os.MkdirAll(beadsDir, 0o755); err != nil {\n\t\tt.Fatalf(\"mkdir .beads: %v\", err)\n\t}\n\tissuesPath := filepath.Join(beadsDir, \"issues.jsonl\")\n\tif err := os.WriteFile(issuesPath, []byte(payload+\"\\n\"), 0o644); err != nil {\n\t\tt.Fatalf(\"write issues: %v\", err)\n\t}\n}\n\nfunc writeAgentFile(t *testing.T, repoRoot string, payload string) {\n\tt.Helper()\n\tagentDir := filepath.Join(repoRoot, \".opencode\", \"agent\")\n\tif err := os.MkdirAll(agentDir, 0o755); err != nil {\n\t\tt.Fatalf(\"mkdir agent dir: %v\", err)\n\t}\n\tagentPath := filepath.Join(agentDir, \"yolo.md\")\n\tif err := os.WriteFile(agentPath, []byte(payload), 0o644); err != nil {\n\t\tt.Fatalf(\"write agent file: %v\", err)\n\t}\n}\n\nfunc writeRootYoloFile(t *testing.T, repoRoot string, payload string) {\n\tt.Helper()\n\tagentPath := filepath.Join(repoRoot, \"yolo.md\")\n\tif err := os.WriteFile(agentPath, []byte(payload), 0o644); err != nil {\n\t\tt.Fatalf(\"write yolo.md: %v\", err)\n\t}\n}\n\nfunc TestRunOnceMainUsesTUIOnTTYByDefault(t *testing.T) {\n\tfakeProgram := newFakeTUIProgram()\n\tprevIsTerminal := isTerminal\n\tprevNewTUIProgram := newTUIProgram\n\tisTerminal = func(io.Writer) bool { return true }\n\tnewTUIProgram = func(stdout io.Writer) tuiProgram { return fakeProgram }\n\tt.Cleanup(func() {\n\t\tisTerminal = prevIsTerminal\n\t\tnewTUIProgram = prevNewTUIProgram\n\t})\n\n\ttempDir := t.TempDir()\n\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n\trunOnce := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\"}, runOnce.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", code)\n\t}\n\tif runOnce.deps.Events == nil {\n\t\tt.Fatalf(\"expected events emitter to be set\")\n\t}\n\trunOnce.deps.Events.Emit(runner.Event{Type: runner.EventSelectTask})\n\twaitForSignal(t, fakeProgram.started, \"tui start\")\n\twaitForSignal(t, fakeProgram.quit, \"tui quit\")\n\tselect {\n\tcase <-fakeProgram.events:\n\t\t// ok\n\tcase <-time.After(200 * time.Millisecond):\n\t\tt.Fatalf(\"expected event to be forwarded to TUI\")\n\t}\n}\n\nfunc TestRunOnceMainHeadlessDisablesTUI(t *testing.T) {\n\tcalled := false\n\tprevIsTerminal := isTerminal\n\tprevNewTUIProgram := newTUIProgram\n\tisTerminal = func(io.Writer) bool { return true }\n\tnewTUIProgram = func(stdout io.Writer) tuiProgram {\n\t\tcalled = true\n\t\treturn newFakeTUIProgram()\n\t}\n\tt.Cleanup(func() {\n\t\tisTerminal = prevIsTerminal\n\t\tnewTUIProgram = prevNewTUIProgram\n\t})\n\n\ttempDir := t.TempDir()\n\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n\trunOnce := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\tstderr := &bytes.Buffer{}\n\n\tRunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\", \"--headless\"}, runOnce.Run, exit.Exit, out, stderr, beadsRunner, gitRunner)\n\n\tif called {\n\t\tt.Fatalf(\"expected TUI program not to start\")\n\t}\n\tif runOnce.deps.Events != nil {\n\t\tt.Fatalf(\"expected no events emitter in headless mode\")\n\t}\n}\n\nfunc TestOpenCodeRunDefaultsCreateConfigAndEnv(t *testing.T) {\n\ttempDir := t.TempDir()\n\trepoRoot := filepath.Join(tempDir, \"repo\")\n\tif err := os.MkdirAll(repoRoot, 0o755); err != nil {\n\t\tt.Fatalf(\"mkdir repo: %v\", err)\n\t}\n\tt.Setenv(\"HOME\", tempDir)\n\n\topenCodeRunner := &fakeOpenCodeRunner{}\n\topenCodeAdapter := openCodeAdapter{runner: openCodeRunner}\n\n\tconfigRoot := filepath.Join(tempDir, \".config\", \"opencode-runner\")\n\tconfigDir := filepath.Join(configRoot, \"opencode\")\n\tlogPath := filepath.Join(tempDir, \"runner-logs\", \"opencode\", \"issue-1.jsonl\")\n\n\tif err := openCodeAdapter.Run(\"issue-1\", repoRoot, \"prompt\", \"\", configRoot, configDir, logPath); err != nil {\n\t\tt.Fatalf(\"open code run error: %v\", err)\n\t}\n\n\tconfigFile := filepath.Join(configDir, \"opencode.json\")\n\tif _, err := os.Stat(configFile); err != nil {\n\t\tt.Fatalf(\"expected opencode.json to exist: %v\", err)\n\t}\n\texpectedConfigFile := filepath.Join(configDir, \"opencode.json\")\n\tif openCodeRunner.env[\"XDG_CONFIG_HOME\"] != configRoot {\n\t\tt.Fatalf(\"expected XDG_CONFIG_HOME set\")\n\t}\n\tif openCodeRunner.env[\"OPENCODE_CONFIG_DIR\"] != configDir {\n\t\tt.Fatalf(\"expected OPENCODE_CONFIG_DIR set\")\n\t}\n\tif openCodeRunner.env[\"OPENCODE_CONFIG\"] != expectedConfigFile {\n\t\tt.Fatalf(\"expected OPENCODE_CONFIG set\")\n\t}\n\tif openCodeRunner.env[\"OPENCODE_CONFIG_CONTENT\"] != \"{}\" {\n\t\tt.Fatalf(\"expected OPENCODE_CONFIG_CONTENT set\")\n\t}\n}\n","after":"package main\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"yolo-runner/internal/opencode\"\n\t\"yolo-runner/internal/runner\"\n)\n\ntype fakeRunner struct {\n\tcalls []string\n}\n\nfunc (f *fakeRunner) Run(args ...string) (string, error) {\n\tf.calls = append(f.calls, strings.Join(args, \" \"))\n\treturn \"\", nil\n}\n\ntype fakeOpenCodeRunLogger struct {\n\tcalled     bool\n\tissueID    string\n\trepoRoot   string\n\tprompt     string\n\tmodel      string\n\tconfigRoot string\n\tconfigDir  string\n\tlogPath    string\n}\n\nfunc (f *fakeOpenCodeRunLogger) Run(issueID string, repoRoot string, prompt string, model string, configRoot string, configDir string, logPath string) error {\n\tf.called = true\n\tf.issueID = issueID\n\tf.repoRoot = repoRoot\n\tf.prompt = prompt\n\tf.model = model\n\tf.configRoot = configRoot\n\tf.configDir = configDir\n\tf.logPath = logPath\n\treturn nil\n}\n\ntype fakeOpenCodeRunner struct {\n\tenv map[string]string\n}\n\ntype fakeOpenCodeProcess struct{}\n\nfunc (fakeOpenCodeProcess) Wait() error { return nil }\n\nfunc (fakeOpenCodeProcess) Kill() error { return nil }\n\nfunc (f *fakeOpenCodeRunner) Start(args []string, env map[string]string, stdoutPath string) (opencode.Process, error) {\n\tf.env = env\n\treturn fakeOpenCodeProcess{}, nil\n}\n\ntype fakeGitRunner struct {\n\tcalls  []string\n\toutput string\n\terr    error\n}\n\nfunc (f *fakeGitRunner) Run(name string, args ...string) (string, error) {\n\tf.calls = append(f.calls, name+\" \"+strings.Join(args, \" \"))\n\treturn f.output, f.err\n}\n\ntype fakeExit struct {\n\tcode int\n}\n\nfunc (f *fakeExit) Exit(code int) {\n\tf.code = code\n}\n\ntype fakeRunOnce struct {\n\tcalled bool\n\topts   runner.RunOnceOptions\n\tdeps   runner.RunOnceDeps\n\tresult string\n\terr    error\n}\n\nfunc (f *fakeRunOnce) Run(opts runner.RunOnceOptions, deps runner.RunOnceDeps) (string, error) {\n\n\tf.called = true\n\tf.opts = opts\n\tf.deps = deps\n\treturn f.result, f.err\n}\n\nfunc TestRunOnceMainReturnsErrorCodeOnFailure(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n\trunner := &fakeRunOnce{err: errors.New(\"boom\")}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\"}, runner.Run, exit.Exit, out, out, nil, nil)\n\n\tif code != 1 {\n\t\tt.Fatalf(\"expected exit code 1, got %d\", code)\n\t}\n\tif exit.code != 1 {\n\t\tt.Fatalf(\"expected exit to be called with 1, got %d\", exit.code)\n\t}\n\tif !strings.Contains(out.String(), \"boom\") {\n\t\tt.Fatalf(\"expected error output, got %q\", out.String())\n\t}\n}\n\nfunc TestRunOnceMainWiresDependencies(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tRunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\", \"--model\", \"model\", \"--dry-run\"}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif !runner.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n\tif runner.opts.RepoRoot != tempDir || runner.opts.RootID != \"root\" || runner.opts.Model != \"model\" || !runner.opts.DryRun {\n\t\tt.Fatalf(\"unexpected options: %#v\", runner.opts)\n\t}\n\tif runner.opts.Out == nil {\n\t\tt.Fatalf(\"expected output writer\")\n\t}\n\tif runner.deps.Beads == nil || runner.deps.Git == nil || runner.deps.Prompt == nil || runner.deps.OpenCode == nil || runner.deps.Logger == nil {\n\t\tt.Fatalf(\"expected deps to be wired\")\n\t}\n\tif exit.code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", exit.code)\n\t}\n}\n\nfunc TestRunOnceMainDefaultsConfigPaths(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tt.Setenv(\"HOME\", \"/home/user\")\n\tt.Setenv(\"XDG_CONFIG_HOME\", \"\")\n\n\tRunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\"}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif !runner.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n\tif runner.opts.ConfigRoot == \"\" {\n\t\tt.Fatalf(\"expected config root to be set\")\n\t}\n\tif runner.opts.ConfigDir == \"\" {\n\t\tt.Fatalf(\"expected config dir to be set\")\n\t}\n\texpectedConfigRoot := filepath.Join(\"/home/user\", \".config\", \"opencode-runner\")\n\tif runner.opts.ConfigRoot != expectedConfigRoot {\n\t\tt.Fatalf(\"expected config root %q, got %q\", expectedConfigRoot, runner.opts.ConfigRoot)\n\t}\n\texpectedConfigDir := filepath.Join(expectedConfigRoot, \"opencode\")\n\tif runner.opts.ConfigDir != expectedConfigDir {\n\t\tt.Fatalf(\"expected config dir %q, got %q\", expectedConfigDir, runner.opts.ConfigDir)\n\t}\n\tif exit.code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", exit.code)\n\t}\n}\n\nfunc TestRunOnceMainFailsWhenYoloAgentMissing(t *testing.T) {\n\ttempDir := t.TempDir()\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tstdout := &bytes.Buffer{}\n\tstderr := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\"}, runner.Run, exit.Exit, stdout, stderr, beadsRunner, gitRunner)\n\n\tif code != 1 {\n\t\tt.Fatalf(\"expected exit code 1, got %d\", code)\n\t}\n\tif exit.code != 1 {\n\t\tt.Fatalf(\"expected exit to be called with 1, got %d\", exit.code)\n\t}\n\tif runner.called {\n\t\tt.Fatalf(\"expected run once not to be called\")\n\t}\n\tif !strings.Contains(stderr.String(), \"yolo.md\") {\n\t\tt.Fatalf(\"expected error to mention yolo.md, got %q\", stderr.String())\n\t}\n}\n\nfunc TestRunOnceMainFailsWhenYoloAgentMissingPermission(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteAgentFile(t, tempDir, \"---\\nname: yolo\\n---\\n\")\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tstdout := &bytes.Buffer{}\n\tstderr := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\"}, runner.Run, exit.Exit, stdout, stderr, beadsRunner, gitRunner)\n\n\tif code != 1 {\n\t\tt.Fatalf(\"expected exit code 1, got %d\", code)\n\t}\n\tif exit.code != 1 {\n\t\tt.Fatalf(\"expected exit to be called with 1, got %d\", exit.code)\n\t}\n\tif runner.called {\n\t\tt.Fatalf(\"expected run once not to be called\")\n\t}\n\tif !strings.Contains(stderr.String(), \"permission: allow\") {\n\t\tt.Fatalf(\"expected error to mention permission allow, got %q\", stderr.String())\n\t}\n\tif !strings.Contains(strings.ToLower(stderr.String()), \"init\") {\n\t\tt.Fatalf(\"expected guidance to run init, got %q\", stderr.String())\n\t}\n}\n\nfunc TestRunOnceMainInfersRoadmapRootWhenMissing(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteIssuesFile(t, tempDir, `{\"id\":\"roadmap-1\",\"title\":\"Roadmap\",\"issue_type\":\"epic\",\"status\":\"open\"}`)\n\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", code)\n\t}\n\tif !runner.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n\tif runner.opts.RootID != \"roadmap-1\" {\n\t\tt.Fatalf(\"expected root id to be inferred, got %q\", runner.opts.RootID)\n\t}\n}\n\nfunc TestRunOnceMainInfersRoadmapRootWhenInProgress(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteIssuesFile(t, tempDir, `{\"id\":\"roadmap-2\",\"title\":\"Roadmap\",\"issue_type\":\"epic\",\"status\":\"in_progress\"}`)\n\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", code)\n\t}\n\tif !runner.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n\tif runner.opts.RootID != \"roadmap-2\" {\n\t\tt.Fatalf(\"expected root id to be inferred, got %q\", runner.opts.RootID)\n\t}\n}\n\nfunc TestRunOnceMainMissingRootRequiresExplicitFlag(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteIssuesFile(t, tempDir, `{\"id\":\"epic-1\",\"title\":\"Other\",\"issue_type\":\"epic\",\"status\":\"open\"}`)\n\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tstdout := &bytes.Buffer{}\n\tstderr := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir}, runner.Run, exit.Exit, stdout, stderr, beadsRunner, gitRunner)\n\n\tif code != 1 {\n\t\tt.Fatalf(\"expected exit code 1, got %d\", code)\n\t}\n\tif exit.code != 1 {\n\t\tt.Fatalf(\"expected exit to be called with 1, got %d\", exit.code)\n\t}\n\tif runner.called {\n\t\tt.Fatalf(\"expected run once not to be called\")\n\t}\n\tif !strings.Contains(stderr.String(), \"--root\") {\n\t\tt.Fatalf(\"expected error to mention --root, got %q\", stderr.String())\n\t}\n\tif !strings.Contains(strings.ToLower(stderr.String()), \"roadmap\") {\n\t\tt.Fatalf(\"expected error to mention roadmap, got %q\", stderr.String())\n\t}\n}\n\ntype fakeTUIProgram struct {\n\tstarted chan struct{}\n\tquit    chan struct{}\n\tevents  chan runner.Event\n}\n\nfunc newFakeTUIProgram() *fakeTUIProgram {\n\treturn &fakeTUIProgram{\n\t\tstarted: make(chan struct{}),\n\t\tquit:    make(chan struct{}),\n\t\tevents:  make(chan runner.Event, 1),\n\t}\n}\n\nfunc (f *fakeTUIProgram) Start() error {\n\tclose(f.started)\n\treturn nil\n}\n\nfunc (f *fakeTUIProgram) Send(event runner.Event) {\n\tf.events <- event\n}\n\nfunc (f *fakeTUIProgram) Quit() {\n\tclose(f.quit)\n}\n\nfunc waitForSignal(t *testing.T, signal chan struct{}, label string) {\n\tt.Helper()\n\tselect {\n\tcase <-signal:\n\t\treturn\n\tcase <-time.After(200 * time.Millisecond):\n\t\tt.Fatalf(\"expected %s\", label)\n\t}\n}\n\nfunc writeIssuesFile(t *testing.T, repoRoot string, payload string) {\n\tt.Helper()\n\tbeadsDir := filepath.Join(repoRoot, \".beads\")\n\tif err := os.MkdirAll(beadsDir, 0o755); err != nil {\n\t\tt.Fatalf(\"mkdir .beads: %v\", err)\n\t}\n\tissuesPath := filepath.Join(beadsDir, \"issues.jsonl\")\n\tif err := os.WriteFile(issuesPath, []byte(payload+\"\\n\"), 0o644); err != nil {\n\t\tt.Fatalf(\"write issues: %v\", err)\n\t}\n}\n\nfunc writeAgentFile(t *testing.T, repoRoot string, payload string) {\n\tt.Helper()\n\tagentDir := filepath.Join(repoRoot, \".opencode\", \"agent\")\n\tif err := os.MkdirAll(agentDir, 0o755); err != nil {\n\t\tt.Fatalf(\"mkdir agent dir: %v\", err)\n\t}\n\tagentPath := filepath.Join(agentDir, \"yolo.md\")\n\tif err := os.WriteFile(agentPath, []byte(payload), 0o644); err != nil {\n\t\tt.Fatalf(\"write agent file: %v\", err)\n\t}\n}\n\nfunc writeRootYoloFile(t *testing.T, repoRoot string, payload string) {\n\tt.Helper()\n\tagentPath := filepath.Join(repoRoot, \"yolo.md\")\n\tif err := os.WriteFile(agentPath, []byte(payload), 0o644); err != nil {\n\t\tt.Fatalf(\"write yolo.md: %v\", err)\n\t}\n}\n\nfunc TestRunOnceMainUsesTUIOnTTYByDefault(t *testing.T) {\n\tfakeProgram := newFakeTUIProgram()\n\tprevIsTerminal := isTerminal\n\tprevNewTUIProgram := newTUIProgram\n\tisTerminal = func(io.Writer) bool { return true }\n\tnewTUIProgram = func(stdout io.Writer) tuiProgram { return fakeProgram }\n\tt.Cleanup(func() {\n\t\tisTerminal = prevIsTerminal\n\t\tnewTUIProgram = prevNewTUIProgram\n\t})\n\n\ttempDir := t.TempDir()\n\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n\trunOnce := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\"}, runOnce.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", code)\n\t}\n\tif runOnce.deps.Events == nil {\n\t\tt.Fatalf(\"expected events emitter to be set\")\n\t}\n\trunOnce.deps.Events.Emit(runner.Event{Type: runner.EventSelectTask})\n\twaitForSignal(t, fakeProgram.started, \"tui start\")\n\twaitForSignal(t, fakeProgram.quit, \"tui quit\")\n\tselect {\n\tcase <-fakeProgram.events:\n\t\t// ok\n\tcase <-time.After(200 * time.Millisecond):\n\t\tt.Fatalf(\"expected event to be forwarded to TUI\")\n\t}\n}\n\nfunc TestRunOnceMainHeadlessDisablesTUI(t *testing.T) {\n\tcalled := false\n\tprevIsTerminal := isTerminal\n\tprevNewTUIProgram := newTUIProgram\n\tisTerminal = func(io.Writer) bool { return true }\n\tnewTUIProgram = func(stdout io.Writer) tuiProgram {\n\t\tcalled = true\n\t\treturn newFakeTUIProgram()\n\t}\n\tt.Cleanup(func() {\n\t\tisTerminal = prevIsTerminal\n\t\tnewTUIProgram = prevNewTUIProgram\n\t})\n\n\ttempDir := t.TempDir()\n\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n\trunOnce := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\tstderr := &bytes.Buffer{}\n\n\tRunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\", \"--headless\"}, runOnce.Run, exit.Exit, out, stderr, beadsRunner, gitRunner)\n\n\tif called {\n\t\tt.Fatalf(\"expected TUI program not to start\")\n\t}\n\tif runOnce.deps.Events != nil {\n\t\tt.Fatalf(\"expected no events emitter in headless mode\")\n\t}\n}\n\nfunc TestRunOnceMainInitOverwritesAgentFile(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteRootYoloFile(t, tempDir, \"root-agent\")\n\twriteAgentFile(t, tempDir, \"stale\")\n\n\tstdout := &bytes.Buffer{}\n\tstderr := &bytes.Buffer{}\n\texit := &fakeExit{}\n\n\tcode := RunOnceMain([]string{\"init\", \"--repo\", tempDir}, nil, exit.Exit, stdout, stderr, nil, nil)\n\n\tif code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", code)\n\t}\n\tif exit.code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", exit.code)\n\t}\n\tagentPath := filepath.Join(tempDir, \".opencode\", \"agent\", \"yolo.md\")\n\tcontent, err := os.ReadFile(agentPath)\n\tif err != nil {\n\t\tt.Fatalf(\"read agent file: %v\", err)\n\t}\n\tif string(content) != \"root-agent\" {\n\t\tt.Fatalf(\"expected agent file to be overwritten\")\n\t}\n}\n\nfunc TestRunOnceMainInitCreatesAgentDir(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteRootYoloFile(t, tempDir, \"root-agent\")\n\n\tstdout := &bytes.Buffer{}\n\tstderr := &bytes.Buffer{}\n\texit := &fakeExit{}\n\n\tcode := RunOnceMain([]string{\"init\", \"--repo\", tempDir}, nil, exit.Exit, stdout, stderr, nil, nil)\n\n\tif code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", code)\n\t}\n\tagentPath := filepath.Join(tempDir, \".opencode\", \"agent\", \"yolo.md\")\n\tcontent, err := os.ReadFile(agentPath)\n\tif err != nil {\n\t\tt.Fatalf(\"read agent file: %v\", err)\n\t}\n\tif string(content) != \"root-agent\" {\n\t\tt.Fatalf(\"expected agent file to be created\")\n\t}\n}\n\nfunc TestRunOnceMainRunModePassesAfterInit(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteRootYoloFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n\n\tstdout := &bytes.Buffer{}\n\tstderr := &bytes.Buffer{}\n\texit := &fakeExit{}\n\n\tcode := RunOnceMain([]string{\"init\", \"--repo\", tempDir}, nil, exit.Exit, stdout, stderr, nil, nil)\n\tif code != 0 {\n\t\tt.Fatalf(\"expected init exit code 0, got %d\", code)\n\t}\n\n\trunOnce := &fakeRunOnce{result: \"no_tasks\"}\n\tcode = RunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\"}, runOnce.Run, exit.Exit, stdout, stderr, nil, nil)\n\n\tif code != 0 {\n\t\tt.Fatalf(\"expected run mode exit code 0, got %d\", code)\n\t}\n\tif !runOnce.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n}\n\nfunc TestOpenCodeRunDefaultsCreateConfigAndEnv(t *testing.T) {\n\ttempDir := t.TempDir()\n\trepoRoot := filepath.Join(tempDir, \"repo\")\n\tif err := os.MkdirAll(repoRoot, 0o755); err != nil {\n\t\tt.Fatalf(\"mkdir repo: %v\", err)\n\t}\n\tt.Setenv(\"HOME\", tempDir)\n\n\topenCodeRunner := &fakeOpenCodeRunner{}\n\topenCodeAdapter := openCodeAdapter{runner: openCodeRunner}\n\n\tconfigRoot := filepath.Join(tempDir, \".config\", \"opencode-runner\")\n\tconfigDir := filepath.Join(configRoot, \"opencode\")\n\tlogPath := filepath.Join(tempDir, \"runner-logs\", \"opencode\", \"issue-1.jsonl\")\n\n\tif err := openCodeAdapter.Run(\"issue-1\", repoRoot, \"prompt\", \"\", configRoot, configDir, logPath); err != nil {\n\t\tt.Fatalf(\"open code run error: %v\", err)\n\t}\n\n\tconfigFile := filepath.Join(configDir, \"opencode.json\")\n\tif _, err := os.Stat(configFile); err != nil {\n\t\tt.Fatalf(\"expected opencode.json to exist: %v\", err)\n\t}\n\texpectedConfigFile := filepath.Join(configDir, \"opencode.json\")\n\tif openCodeRunner.env[\"XDG_CONFIG_HOME\"] != configRoot {\n\t\tt.Fatalf(\"expected XDG_CONFIG_HOME set\")\n\t}\n\tif openCodeRunner.env[\"OPENCODE_CONFIG_DIR\"] != configDir {\n\t\tt.Fatalf(\"expected OPENCODE_CONFIG_DIR set\")\n\t}\n\tif openCodeRunner.env[\"OPENCODE_CONFIG\"] != expectedConfigFile {\n\t\tt.Fatalf(\"expected OPENCODE_CONFIG set\")\n\t}\n\tif openCodeRunner.env[\"OPENCODE_CONFIG_CONTENT\"] != \"{}\" {\n\t\tt.Fatalf(\"expected OPENCODE_CONFIG_CONTENT set\")\n\t}\n}\n","additions":74,"deletions":0},"truncated":false},"time":{"start":1768851134358,"end":1768851134523}},"metadata":{"openai":{"itemId":"fc_0537560a65e1f5e201696e86a6ffdc8191a7146e2b33f76f66"}}}}
{"type":"step_finish","timestamp":1768851134543,"sessionID":"ses_428432b5cffeiuHqPgEDLEHUBi","part":{"id":"prt_bd7be583c0012CxnqmDypDp296","sessionID":"ses_428432b5cffeiuHqPgEDLEHUBi","messageID":"msg_bd7bdf926001VzUOshNfmHzz8W","type":"step-finish","reason":"tool-calls","snapshot":"67ab4518c12764fd2fe576239e419d49048fbde1","cost":0,"tokens":{"input":852,"output":1452,"reasoning":0,"cache":{"read":21120,"write":0}}}}
{"type":"step_start","timestamp":1768851135004,"sessionID":"ses_428432b5cffeiuHqPgEDLEHUBi","part":{"id":"prt_bd7be5a1c001iww7lANoT3DqHG","sessionID":"ses_428432b5cffeiuHqPgEDLEHUBi","messageID":"msg_bd7be5863001Lw5brHNly0Bwmm","type":"step-start","snapshot":"ee5170164c2baaa69e10a465657a52d9a1b1e6e2"}}
{"type":"tool_use","timestamp":1768851137789,"sessionID":"ses_428432b5cffeiuHqPgEDLEHUBi","part":{"id":"prt_bd7be5e24001yxS4flI351lCJ3","sessionID":"ses_428432b5cffeiuHqPgEDLEHUBi","messageID":"msg_bd7be5863001Lw5brHNly0Bwmm","type":"tool","callID":"call_TmQ1jOBor6zinWvv7e3xMwCI","tool":"bash","state":{"status":"completed","input":{"command":"go test ./...","description":"Run full Go test suite"},"output":"ok  \tyolo-runner\t(cached)\n--- FAIL: TestRunOnceMainInitOverwritesAgentFile (0.00s)\n    main_test.go:465: expected exit code 0, got 1\n--- FAIL: TestRunOnceMainInitCreatesAgentDir (0.00s)\n    main_test.go:491: expected exit code 0, got 1\n--- FAIL: TestRunOnceMainRunModePassesAfterInit (0.00s)\n    main_test.go:513: expected init exit code 0, got 1\nFAIL\nFAIL\tyolo-runner/cmd/yolo-runner\t0.818s\nok  \tyolo-runner/internal/beads\t(cached)\nok  \tyolo-runner/internal/logging\t(cached)\nok  \tyolo-runner/internal/opencode\t(cached)\nok  \tyolo-runner/internal/prompt\t(cached)\nok  \tyolo-runner/internal/runner\t(cached)\nok  \tyolo-runner/internal/ui/tui\t(cached)\nok  \tyolo-runner/internal/vcs/git\t(cached)\nFAIL\n","title":"Run full Go test suite","metadata":{"output":"ok  \tyolo-runner\t(cached)\n--- FAIL: TestRunOnceMainInitOverwritesAgentFile (0.00s)\n    main_test.go:465: expected exit code 0, got 1\n--- FAIL: TestRunOnceMainInitCreatesAgentDir (0.00s)\n    main_test.go:491: expected exit code 0, got 1\n--- FAIL: TestRunOnceMainRunModePassesAfterInit (0.00s)\n    main_test.go:513: expected init exit code 0, got 1\nFAIL\nFAIL\tyolo-runner/cmd/yolo-runner\t0.818s\nok  \tyolo-runner/internal/beads\t(cached)\nok  \tyolo-runner/internal/logging\t(cached)\nok  \tyolo-runner/internal/opencode\t(cached)\nok  \tyolo-runner/internal/prompt\t(cached)\nok  \tyolo-runner/internal/runner\t(cached)\nok  \tyolo-runner/internal/ui/tui\t(cached)\nok  \tyolo-runner/internal/vcs/git\t(cached)\nFAIL\n","exit":1,"description":"Run full Go test suite","truncated":false},"time":{"start":1768851136564,"end":1768851137789}},"metadata":{"openai":{"itemId":"fc_0c98b92b1bbc1df401696e86c001748191ad4a6bb2c0a8ffde"}}}}
{"type":"step_finish","timestamp":1768851137804,"sessionID":"ses_428432b5cffeiuHqPgEDLEHUBi","part":{"id":"prt_bd7be64fd001Rz7uN7JpEYYYaU","sessionID":"ses_428432b5cffeiuHqPgEDLEHUBi","messageID":"msg_bd7be5863001Lw5brHNly0Bwmm","type":"step-finish","reason":"tool-calls","snapshot":"d97562afcf76e49735a0320e25139d549def45b4","cost":0,"tokens":{"input":2315,"output":29,"reasoning":0,"cache":{"read":21120,"write":0}}}}
{"type":"step_start","timestamp":1768851138214,"sessionID":"ses_428432b5cffeiuHqPgEDLEHUBi","part":{"id":"prt_bd7be66a5001aY7QbZAP3gdL00","sessionID":"ses_428432b5cffeiuHqPgEDLEHUBi","messageID":"msg_bd7be651d0010lLx2n4RvDl7VM","type":"step-start","snapshot":"521a16a519f2529299781e80c67f3ec2dd6cb17a"}}
{"type":"tool_use","timestamp":1768851153926,"sessionID":"ses_428432b5cffeiuHqPgEDLEHUBi","part":{"id":"prt_bd7be9f0c001Had2LqX7d0HRiI","sessionID":"ses_428432b5cffeiuHqPgEDLEHUBi","messageID":"msg_bd7be651d0010lLx2n4RvDl7VM","type":"tool","callID":"call_iBlGMEIhQ6b9MTgPZ6oSTozB","tool":"edit","state":{"status":"completed","input":{"filePath":"/Users/egv/dev/yolo-runner/internal/opencode/agent.go","oldString":"const (\n\tagentRelativePath = \".opencode/agent/yolo.md\"\n)\n","newString":"const (\n\tagentRelativePath      = \".opencode/agent/yolo.md\"\n\tagentSourceRelativePath = \"yolo.md\"\n)\n"},"output":"Edit applied successfully.","title":"internal/opencode/agent.go","metadata":{"diagnostics":{"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main.go":[{"range":{"start":{"line":66,"character":8},"end":{"line":66,"character":23}},"severity":4,"code":"default","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/gopls/internal/analysis/deprecated"},"source":"deprecated","message":"b.program.Start is deprecated: please use [Program.Run] instead.","tags":[2]}],"/Users/egv/dev/yolo-runner/go.mod":[{"range":{"start":{"line":6,"character":44},"end":{"line":6,"character":55}},"severity":2,"source":"go mod tidy","message":"github.com/charmbracelet/bubbletea should be direct"},{"range":{"start":{"line":19,"character":26},"end":{"line":19,"character":37}},"severity":2,"source":"go mod tidy","message":"golang.org/x/term should be direct"}],"/Users/egv/dev/yolo-runner/internal/opencode/agent.go":[],"/Users/egv/dev/yolo-runner/internal/opencode/client.go":[],"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go":[],"/Users/egv/dev/yolo-runner/internal/opencode/agent_test.go":[],"/Users/egv/dev/yolo-runner/cmd/yolo-runner/exec.go":[]},"diff":"Index: /Users/egv/dev/yolo-runner/internal/opencode/agent.go\n===================================================================\n--- /Users/egv/dev/yolo-runner/internal/opencode/agent.go\n+++ /Users/egv/dev/yolo-runner/internal/opencode/agent.go\n@@ -8,9 +8,10 @@\n \t\"strings\"\n )\n \n const (\n-\tagentRelativePath = \".opencode/agent/yolo.md\"\n+\tagentRelativePath       = \".opencode/agent/yolo.md\"\n+\tagentSourceRelativePath = \"yolo.md\"\n )\n \n var (\n \tErrAgentMissing         = errors.New(\"yolo agent missing\")\n","filediff":{"file":"/Users/egv/dev/yolo-runner/internal/opencode/agent.go","before":"package opencode\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n)\n\nconst (\n\tagentRelativePath = \".opencode/agent/yolo.md\"\n)\n\nvar (\n\tErrAgentMissing         = errors.New(\"yolo agent missing\")\n\tErrAgentPermissionUnset = errors.New(\"yolo agent missing permission allow\")\n)\n\nfunc ValidateAgent(repoRoot string) error {\n\tagentPath := filepath.Join(repoRoot, agentRelativePath)\n\tcontent, err := os.ReadFile(agentPath)\n\tif err != nil {\n\t\tif os.IsNotExist(err) {\n\t\t\treturn fmt.Errorf(\"missing yolo agent file at %s\", agentRelativePath)\n\t\t}\n\t\treturn err\n\t}\n\tif !hasPermissionAllow(content) {\n\t\treturn fmt.Errorf(\"yolo agent missing permission: allow; run opencode init\")\n\t}\n\treturn nil\n}\n\nfunc hasPermissionAllow(content []byte) bool {\n\tlines := strings.Split(string(content), \"\\n\")\n\tfor _, line := range lines {\n\t\tif strings.TrimSpace(line) == \"permission: allow\" {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n","after":"package opencode\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n)\n\nconst (\n\tagentRelativePath       = \".opencode/agent/yolo.md\"\n\tagentSourceRelativePath = \"yolo.md\"\n)\n\nvar (\n\tErrAgentMissing         = errors.New(\"yolo agent missing\")\n\tErrAgentPermissionUnset = errors.New(\"yolo agent missing permission allow\")\n)\n\nfunc ValidateAgent(repoRoot string) error {\n\tagentPath := filepath.Join(repoRoot, agentRelativePath)\n\tcontent, err := os.ReadFile(agentPath)\n\tif err != nil {\n\t\tif os.IsNotExist(err) {\n\t\t\treturn fmt.Errorf(\"missing yolo agent file at %s\", agentRelativePath)\n\t\t}\n\t\treturn err\n\t}\n\tif !hasPermissionAllow(content) {\n\t\treturn fmt.Errorf(\"yolo agent missing permission: allow; run opencode init\")\n\t}\n\treturn nil\n}\n\nfunc hasPermissionAllow(content []byte) bool {\n\tlines := strings.Split(string(content), \"\\n\")\n\tfor _, line := range lines {\n\t\tif strings.TrimSpace(line) == \"permission: allow\" {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n","additions":2,"deletions":1},"truncated":false},"time":{"start":1768851153765,"end":1768851153925}},"metadata":{"openai":{"itemId":"fc_064aa03f362f033301696e86d09e4481918034e94fc9b833b5"}}}}
{"type":"step_finish","timestamp":1768851153943,"sessionID":"ses_428432b5cffeiuHqPgEDLEHUBi","part":{"id":"prt_bd7bea4060018UsCmsnz5sDSVk","sessionID":"ses_428432b5cffeiuHqPgEDLEHUBi","messageID":"msg_bd7be651d0010lLx2n4RvDl7VM","type":"step-finish","reason":"tool-calls","snapshot":"58e3ad4cc3a33a53f35099365ddcc72c225ee35e","cost":0,"tokens":{"input":406,"output":805,"reasoning":704,"cache":{"read":23296,"write":0}}}}
{"type":"step_start","timestamp":1768851154398,"sessionID":"ses_428432b5cffeiuHqPgEDLEHUBi","part":{"id":"prt_bd7bea5dd0019MTcEYhvJh07nh","sessionID":"ses_428432b5cffeiuHqPgEDLEHUBi","messageID":"msg_bd7bea42600102EWnPJpC6qFhi","type":"step-start","snapshot":"a14a6c2708bfa30d92c44b56a5ebfbab3b1e2832"}}
{"type":"tool_use","timestamp":1768851162667,"sessionID":"ses_428432b5cffeiuHqPgEDLEHUBi","part":{"id":"prt_bd7bea7dc001uqgL4McbbVMQ7h","sessionID":"ses_428432b5cffeiuHqPgEDLEHUBi","messageID":"msg_bd7bea42600102EWnPJpC6qFhi","type":"tool","callID":"call_jIOdONpdbxoSNlwNLlR3qnO0","tool":"edit","state":{"status":"completed","input":{"filePath":"/Users/egv/dev/yolo-runner/internal/opencode/agent.go","oldString":"func ValidateAgent(repoRoot string) error {\n\tagentPath := filepath.Join(repoRoot, agentRelativePath)\n\tcontent, err := os.ReadFile(agentPath)\n\tif err != nil {\n\t\tif os.IsNotExist(err) {\n\t\t\treturn fmt.Errorf(\"missing yolo agent file at %s\", agentRelativePath)\n\t\t}\n\t\treturn err\n\t}\n\tif !hasPermissionAllow(content) {\n\t\treturn fmt.Errorf(\"yolo agent missing permission: allow; run opencode init\")\n\t}\n\treturn nil\n}\n","newString":"func ValidateAgent(repoRoot string) error {\n\tagentPath := filepath.Join(repoRoot, agentRelativePath)\n\tcontent, err := os.ReadFile(agentPath)\n\tif err != nil {\n\t\tif os.IsNotExist(err) {\n\t\t\treturn fmt.Errorf(\"missing yolo agent file at %s\", agentRelativePath)\n\t\t}\n\t\treturn err\n\t}\n\tif !hasPermissionAllow(content) {\n\t\treturn fmt.Errorf(\"yolo agent missing permission: allow; run opencode init\")\n\t}\n\treturn nil\n}\n\nfunc InitAgent(repoRoot string) error {\n\tsourcePath := filepath.Join(repoRoot, agentSourceRelativePath)\n\tsourceContent, err := os.ReadFile(sourcePath)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"read yolo agent template: %w\", err)\n\t}\n\tdestinationPath := filepath.Join(repoRoot, agentRelativePath)\n\tif err := os.MkdirAll(filepath.Dir(destinationPath), 0o755); err != nil {\n\t\treturn fmt.Errorf(\"create agent dir: %w\", err)\n\t}\n\tif err := os.WriteFile(destinationPath, sourceContent, 0o644); err != nil {\n\t\treturn fmt.Errorf(\"write agent file: %w\", err)\n\t}\n\treturn nil\n}\n"},"output":"Edit applied successfully.","title":"internal/opencode/agent.go","metadata":{"diagnostics":{"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main.go":[{"range":{"start":{"line":66,"character":8},"end":{"line":66,"character":23}},"severity":4,"code":"default","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/gopls/internal/analysis/deprecated"},"source":"deprecated","message":"b.program.Start is deprecated: please use [Program.Run] instead.","tags":[2]}],"/Users/egv/dev/yolo-runner/go.mod":[{"range":{"start":{"line":6,"character":44},"end":{"line":6,"character":55}},"severity":2,"source":"go mod tidy","message":"github.com/charmbracelet/bubbletea should be direct"},{"range":{"start":{"line":19,"character":26},"end":{"line":19,"character":37}},"severity":2,"source":"go mod tidy","message":"golang.org/x/term should be direct"}],"/Users/egv/dev/yolo-runner/internal/opencode/agent.go":[],"/Users/egv/dev/yolo-runner/internal/opencode/client.go":[],"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go":[],"/Users/egv/dev/yolo-runner/internal/opencode/agent_test.go":[],"/Users/egv/dev/yolo-runner/cmd/yolo-runner/exec.go":[]},"diff":"Index: /Users/egv/dev/yolo-runner/internal/opencode/agent.go\n===================================================================\n--- /Users/egv/dev/yolo-runner/internal/opencode/agent.go\n+++ /Users/egv/dev/yolo-runner/internal/opencode/agent.go\n@@ -32,8 +32,24 @@\n \t}\n \treturn nil\n }\n \n+func InitAgent(repoRoot string) error {\n+\tsourcePath := filepath.Join(repoRoot, agentSourceRelativePath)\n+\tsourceContent, err := os.ReadFile(sourcePath)\n+\tif err != nil {\n+\t\treturn fmt.Errorf(\"read yolo agent template: %w\", err)\n+\t}\n+\tdestinationPath := filepath.Join(repoRoot, agentRelativePath)\n+\tif err := os.MkdirAll(filepath.Dir(destinationPath), 0o755); err != nil {\n+\t\treturn fmt.Errorf(\"create agent dir: %w\", err)\n+\t}\n+\tif err := os.WriteFile(destinationPath, sourceContent, 0o644); err != nil {\n+\t\treturn fmt.Errorf(\"write agent file: %w\", err)\n+\t}\n+\treturn nil\n+}\n+\n func hasPermissionAllow(content []byte) bool {\n \tlines := strings.Split(string(content), \"\\n\")\n \tfor _, line := range lines {\n \t\tif strings.TrimSpace(line) == \"permission: allow\" {\n","filediff":{"file":"/Users/egv/dev/yolo-runner/internal/opencode/agent.go","before":"package opencode\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n)\n\nconst (\n\tagentRelativePath       = \".opencode/agent/yolo.md\"\n\tagentSourceRelativePath = \"yolo.md\"\n)\n\nvar (\n\tErrAgentMissing         = errors.New(\"yolo agent missing\")\n\tErrAgentPermissionUnset = errors.New(\"yolo agent missing permission allow\")\n)\n\nfunc ValidateAgent(repoRoot string) error {\n\tagentPath := filepath.Join(repoRoot, agentRelativePath)\n\tcontent, err := os.ReadFile(agentPath)\n\tif err != nil {\n\t\tif os.IsNotExist(err) {\n\t\t\treturn fmt.Errorf(\"missing yolo agent file at %s\", agentRelativePath)\n\t\t}\n\t\treturn err\n\t}\n\tif !hasPermissionAllow(content) {\n\t\treturn fmt.Errorf(\"yolo agent missing permission: allow; run opencode init\")\n\t}\n\treturn nil\n}\n\nfunc hasPermissionAllow(content []byte) bool {\n\tlines := strings.Split(string(content), \"\\n\")\n\tfor _, line := range lines {\n\t\tif strings.TrimSpace(line) == \"permission: allow\" {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n","after":"package opencode\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n)\n\nconst (\n\tagentRelativePath       = \".opencode/agent/yolo.md\"\n\tagentSourceRelativePath = \"yolo.md\"\n)\n\nvar (\n\tErrAgentMissing         = errors.New(\"yolo agent missing\")\n\tErrAgentPermissionUnset = errors.New(\"yolo agent missing permission allow\")\n)\n\nfunc ValidateAgent(repoRoot string) error {\n\tagentPath := filepath.Join(repoRoot, agentRelativePath)\n\tcontent, err := os.ReadFile(agentPath)\n\tif err != nil {\n\t\tif os.IsNotExist(err) {\n\t\t\treturn fmt.Errorf(\"missing yolo agent file at %s\", agentRelativePath)\n\t\t}\n\t\treturn err\n\t}\n\tif !hasPermissionAllow(content) {\n\t\treturn fmt.Errorf(\"yolo agent missing permission: allow; run opencode init\")\n\t}\n\treturn nil\n}\n\nfunc InitAgent(repoRoot string) error {\n\tsourcePath := filepath.Join(repoRoot, agentSourceRelativePath)\n\tsourceContent, err := os.ReadFile(sourcePath)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"read yolo agent template: %w\", err)\n\t}\n\tdestinationPath := filepath.Join(repoRoot, agentRelativePath)\n\tif err := os.MkdirAll(filepath.Dir(destinationPath), 0o755); err != nil {\n\t\treturn fmt.Errorf(\"create agent dir: %w\", err)\n\t}\n\tif err := os.WriteFile(destinationPath, sourceContent, 0o644); err != nil {\n\t\treturn fmt.Errorf(\"write agent file: %w\", err)\n\t}\n\treturn nil\n}\n\nfunc hasPermissionAllow(content []byte) bool {\n\tlines := strings.Split(string(content), \"\\n\")\n\tfor _, line := range lines {\n\t\tif strings.TrimSpace(line) == \"permission: allow\" {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n","additions":16,"deletions":0},"truncated":false},"time":{"start":1768851162508,"end":1768851162667}},"metadata":{"openai":{"itemId":"fc_0c4182990bdea02001696e86d2d9048191a239709cfd8ba6ab"}}}}
{"type":"step_finish","timestamp":1768851162683,"sessionID":"ses_428432b5cffeiuHqPgEDLEHUBi","part":{"id":"prt_bd7bec62b001VGIqXt9Px2Y7Da","sessionID":"ses_428432b5cffeiuHqPgEDLEHUBi","messageID":"msg_bd7bea42600102EWnPJpC6qFhi","type":"step-finish","reason":"tool-calls","snapshot":"676edaad1891ae4e6dc1023684e7784ab768938e","cost":0,"tokens":{"input":644,"output":471,"reasoning":0,"cache":{"read":23168,"write":0}}}}
{"type":"step_start","timestamp":1768851163137,"sessionID":"ses_428432b5cffeiuHqPgEDLEHUBi","part":{"id":"prt_bd7bec800001HuH5atScITlRj1","sessionID":"ses_428432b5cffeiuHqPgEDLEHUBi","messageID":"msg_bd7bec64c0011ap3GKl63fNN29","type":"step-start","snapshot":"bb5f983965c6a66b4116d11f695479fb05b0dc67"}}
{"type":"tool_use","timestamp":1768851182840,"sessionID":"ses_428432b5cffeiuHqPgEDLEHUBi","part":{"id":"prt_bd7bef30e001pDzeZkhGZ583AM","sessionID":"ses_428432b5cffeiuHqPgEDLEHUBi","messageID":"msg_bd7bec64c0011ap3GKl63fNN29","type":"tool","callID":"call_xOAVtlHWOFgH02IWqdq7mU4t","tool":"edit","state":{"status":"completed","input":{"filePath":"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main.go","oldString":"func RunOnceMain(args []string, runOnce runOnceFunc, exit exitFunc, stdout io.Writer, stderr io.Writer, beadsRunner beadsRunner, gitRunner gitRunner) int {\n\tfs := flag.NewFlagSet(\"yolo-runner\", flag.ContinueOnError)\n\tfs.SetOutput(stderr)\n\n\trepoRoot := fs.String(\"repo\", \".\", \"Repository root path\")\n\trootID := fs.String(\"root\", \"\", \"Root bead/epic ID\")\n\tmodel := fs.String(\"model\", \"\", \"OpenCode model\")\n\tdryRun := fs.Bool(\"dry-run\", false, \"Print task and prompt without executing\")\n\theadless := fs.Bool(\"headless\", false, \"Force plain output without TUI\")\n\tconfigRoot := fs.String(\"config-root\", \"\", \"OpenCode config root\")\n\tconfigDir := fs.String(\"config-dir\", \"\", \"OpenCode config dir\")\n\n\tif err := fs.Parse(args); err != nil {\n\t\tfmt.Fprintln(stderr, err)\n\t\tif exit != nil {\n\t\t\texit(1)\n\t\t}\n\t\treturn 1\n\t}\n","newString":"func RunOnceMain(args []string, runOnce runOnceFunc, exit exitFunc, stdout io.Writer, stderr io.Writer, beadsRunner beadsRunner, gitRunner gitRunner) int {\n\tif len(args) > 0 && args[0] == \"init\" {\n\t\treturn InitMain(args[1:], exit, stderr)\n\t}\n\n\tfs := flag.NewFlagSet(\"yolo-runner\", flag.ContinueOnError)\n\tfs.SetOutput(stderr)\n\n\trepoRoot := fs.String(\"repo\", \".\", \"Repository root path\")\n\trootID := fs.String(\"root\", \"\", \"Root bead/epic ID\")\n\tmodel := fs.String(\"model\", \"\", \"OpenCode model\")\n\tdryRun := fs.Bool(\"dry-run\", false, \"Print task and prompt without executing\")\n\theadless := fs.Bool(\"headless\", false, \"Force plain output without TUI\")\n\tconfigRoot := fs.String(\"config-root\", \"\", \"OpenCode config root\")\n\tconfigDir := fs.String(\"config-dir\", \"\", \"OpenCode config dir\")\n\n\tif err := fs.Parse(args); err != nil {\n\t\tfmt.Fprintln(stderr, err)\n\t\tif exit != nil {\n\t\t\texit(1)\n\t\t}\n\t\treturn 1\n\t}\n"},"output":"Edit applied successfully.\n\nLSP errors detected in this file, please fix:\n<diagnostics file=\"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main.go\">\nERROR [118:10] undefined: InitMain\n</diagnostics>","title":"cmd/yolo-runner/main.go","metadata":{"diagnostics":{"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main.go":[{"range":{"start":{"line":117,"character":9},"end":{"line":117,"character":17}},"severity":1,"code":"UndeclaredName","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UndeclaredName"},"source":"compiler","message":"undefined: InitMain"}],"/Users/egv/dev/yolo-runner/go.mod":[{"range":{"start":{"line":6,"character":44},"end":{"line":6,"character":55}},"severity":2,"source":"go mod tidy","message":"github.com/charmbracelet/bubbletea should be direct"},{"range":{"start":{"line":19,"character":26},"end":{"line":19,"character":37}},"severity":2,"source":"go mod tidy","message":"golang.org/x/term should be direct"}],"/Users/egv/dev/yolo-runner/internal/opencode/agent.go":[],"/Users/egv/dev/yolo-runner/internal/opencode/client.go":[{"range":{"start":{"line":28,"character":1},"end":{"line":28,"character":18}},"severity":2,"code":"default","codeDescription":{"href":"https://staticcheck.dev/docs/checks/#S1031"},"source":"S1031","message":"unnecessary nil check around range"}],"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go":[],"/Users/egv/dev/yolo-runner/internal/opencode/agent_test.go":[],"/Users/egv/dev/yolo-runner/cmd/yolo-runner/exec.go":[]},"diff":"Index: /Users/egv/dev/yolo-runner/cmd/yolo-runner/main.go\n===================================================================\n--- /Users/egv/dev/yolo-runner/cmd/yolo-runner/main.go\n+++ /Users/egv/dev/yolo-runner/cmd/yolo-runner/main.go\n@@ -113,8 +113,12 @@\n \treturn opencode.Run(issueID, repoRoot, promptText, model, configRoot, configDir, logPath, o.runner)\n }\n \n func RunOnceMain(args []string, runOnce runOnceFunc, exit exitFunc, stdout io.Writer, stderr io.Writer, beadsRunner beadsRunner, gitRunner gitRunner) int {\n+\tif len(args) > 0 && args[0] == \"init\" {\n+\t\treturn InitMain(args[1:], exit, stderr)\n+\t}\n+\n \tfs := flag.NewFlagSet(\"yolo-runner\", flag.ContinueOnError)\n \tfs.SetOutput(stderr)\n \n \trepoRoot := fs.String(\"repo\", \".\", \"Repository root path\")\n","filediff":{"file":"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main.go","before":"package main\n\nimport (\n\t\"bufio\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"flag\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\n\t\"yolo-runner/internal/beads\"\n\t\"yolo-runner/internal/logging\"\n\t\"yolo-runner/internal/opencode\"\n\t\"yolo-runner/internal/prompt\"\n\t\"yolo-runner/internal/runner\"\n\t\"yolo-runner/internal/ui/tui\"\n\tgitadapter \"yolo-runner/internal/vcs/git\"\n\n\ttea \"github.com/charmbracelet/bubbletea\"\n\t\"golang.org/x/term\"\n)\n\ntype runOnceFunc func(opts runner.RunOnceOptions, deps runner.RunOnceDeps) (string, error)\n\ntype exitFunc func(code int)\n\ntype beadsRunner interface {\n\tRun(args ...string) (string, error)\n}\n\ntype gitRunner interface {\n\tRun(name string, args ...string) (string, error)\n}\n\ntype openCodeRunner interface {\n\tStart(args []string, env map[string]string, stdoutPath string) (opencode.Process, error)\n}\n\ntype tuiProgram interface {\n\tStart() error\n\tSend(event runner.Event)\n\tQuit()\n}\n\ntype tuiEmitter struct {\n\tprogram tuiProgram\n}\n\nfunc (t tuiEmitter) Emit(event runner.Event) {\n\tif t.program == nil {\n\t\treturn\n\t}\n\tgo t.program.Send(event)\n}\n\ntype bubbleTUIProgram struct {\n\tprogram *tea.Program\n}\n\nfunc (b bubbleTUIProgram) Start() error {\n\tif b.program == nil {\n\t\treturn nil\n\t}\n\treturn b.program.Start()\n}\n\nfunc (b bubbleTUIProgram) Send(event runner.Event) {\n\tif b.program == nil {\n\t\treturn\n\t}\n\tb.program.Send(event)\n}\n\nfunc (b bubbleTUIProgram) Quit() {\n\tif b.program == nil {\n\t\treturn\n\t}\n\tb.program.Quit()\n}\n\nvar isTerminal = func(writer io.Writer) bool {\n\tif file, ok := writer.(*os.File); ok {\n\t\treturn term.IsTerminal(int(file.Fd()))\n\t}\n\treturn false\n}\n\nvar newTUIProgram = func(stdout io.Writer) tuiProgram {\n\tprogram := tea.NewProgram(tui.NewModel(nil), tea.WithInput(nil), tea.WithOutput(stdout))\n\treturn bubbleTUIProgram{program: program}\n}\n\ntype adapterRunner struct{}\n\nfunc (adapterRunner) Run(args ...string) (string, error) {\n\treturn runCommand(args...)\n}\n\ntype adapterGitRunner struct{}\n\nfunc (adapterGitRunner) Run(name string, args ...string) (string, error) {\n\treturn runCommand(append([]string{name}, args...)...)\n}\n\ntype openCodeAdapter struct {\n\trunner openCodeRunner\n}\n\nfunc (o openCodeAdapter) Run(issueID string, repoRoot string, promptText string, model string, configRoot string, configDir string, logPath string) error {\n\treturn opencode.Run(issueID, repoRoot, promptText, model, configRoot, configDir, logPath, o.runner)\n}\n\nfunc RunOnceMain(args []string, runOnce runOnceFunc, exit exitFunc, stdout io.Writer, stderr io.Writer, beadsRunner beadsRunner, gitRunner gitRunner) int {\n\tfs := flag.NewFlagSet(\"yolo-runner\", flag.ContinueOnError)\n\tfs.SetOutput(stderr)\n\n\trepoRoot := fs.String(\"repo\", \".\", \"Repository root path\")\n\trootID := fs.String(\"root\", \"\", \"Root bead/epic ID\")\n\tmodel := fs.String(\"model\", \"\", \"OpenCode model\")\n\tdryRun := fs.Bool(\"dry-run\", false, \"Print task and prompt without executing\")\n\theadless := fs.Bool(\"headless\", false, \"Force plain output without TUI\")\n\tconfigRoot := fs.String(\"config-root\", \"\", \"OpenCode config root\")\n\tconfigDir := fs.String(\"config-dir\", \"\", \"OpenCode config dir\")\n\n\tif err := fs.Parse(args); err != nil {\n\t\tfmt.Fprintln(stderr, err)\n\t\tif exit != nil {\n\t\t\texit(1)\n\t\t}\n\t\treturn 1\n\t}\n\n\tif runOnce == nil {\n\t\trunOnce = runner.RunOnce\n\t}\n\n\tif err := opencode.ValidateAgent(*repoRoot); err != nil {\n\t\tfmt.Fprintln(stderr, err)\n\t\tif exit != nil {\n\t\t\texit(1)\n\t\t}\n\t\treturn 1\n\t}\n\n\tif beadsRunner == nil {\n\t\tbeadsRunner = adapterRunner{}\n\t}\n\tif gitRunner == nil {\n\t\tgitRunner = adapterGitRunner{}\n\t}\n\n\tbeadsAdapter := beads.New(beadsRunner)\n\tgitAdapter := gitadapter.New(gitRunner)\n\topenCodeAdapter := openCodeAdapter{runner: defaultOpenCodeRunner{}}\n\n\tresolvedRootID := *rootID\n\tif resolvedRootID == \"\" {\n\t\tinferredRootID, err := inferDefaultRootID(*repoRoot)\n\t\tif err != nil {\n\t\t\tfmt.Fprintln(stderr, err)\n\t\t\tif exit != nil {\n\t\t\t\texit(1)\n\t\t\t}\n\t\t\treturn 1\n\t\t}\n\t\tresolvedRootID = inferredRootID\n\t}\n\n\tdeps := runner.RunOnceDeps{\n\t\tBeads:    beadsAdapter,\n\t\tPrompt:   promptBuilder{},\n\t\tOpenCode: openCodeAdapter,\n\t\tGit:      gitAdapter,\n\t\tLogger:   runnerLogger{},\n\t}\n\n\tresolvedConfigRoot := *configRoot\n\tresolvedConfigDir := *configDir\n\tif resolvedConfigRoot == \"\" {\n\t\thomeDir := os.Getenv(\"HOME\")\n\t\tif homeDir != \"\" {\n\t\t\tresolvedConfigRoot = filepath.Join(homeDir, \".config\", \"opencode-runner\")\n\t\t}\n\t}\n\tif resolvedConfigDir == \"\" && resolvedConfigRoot != \"\" {\n\t\tresolvedConfigDir = filepath.Join(resolvedConfigRoot, \"opencode\")\n\t}\n\n\toptions := runner.RunOnceOptions{\n\t\tRepoRoot:   *repoRoot,\n\t\tRootID:     resolvedRootID,\n\t\tModel:      *model,\n\t\tConfigRoot: resolvedConfigRoot,\n\t\tConfigDir:  resolvedConfigDir,\n\t\tDryRun:     *dryRun,\n\t\tOut:        stdout,\n\t}\n\n\tif stdout == nil {\n\t\toptions.Out = io.Discard\n\t}\n\tif stderr == nil {\n\t\tstderr = io.Discard\n\t}\n\n\tvar program tuiProgram\n\tif !*headless && isTerminal(stdout) {\n\t\tprogram = newTUIProgram(stdout)\n\t\tdeps.Events = tuiEmitter{program: program}\n\t\tgo func() {\n\t\t\tif err := program.Start(); err != nil {\n\t\t\t\tfmt.Fprintln(stderr, err)\n\t\t\t\tif exit != nil {\n\t\t\t\t\texit(1)\n\t\t\t\t}\n\t\t\t}\n\t\t}()\n\t}\n\n\t_, err := runOnce(options, deps)\n\tif program != nil {\n\t\tprogram.Quit()\n\t}\n\tif err != nil {\n\t\tfmt.Fprintln(stderr, err)\n\t\tif exit != nil {\n\t\t\texit(1)\n\t\t}\n\t\treturn 1\n\t}\n\n\tif exit != nil {\n\t\texit(0)\n\t}\n\treturn 0\n}\n\nfunc main() {\n\tRunOnceMain(os.Args[1:], runner.RunOnce, os.Exit, os.Stdout, os.Stderr, nil, nil)\n}\n\ntype promptBuilder struct{}\n\nfunc (promptBuilder) Build(issueID string, title string, description string, acceptance string) string {\n\treturn prompt.Build(issueID, title, description, acceptance)\n}\n\ntype runnerLogger struct{}\n\nfunc (runnerLogger) AppendRunnerSummary(repoRoot string, issueID string, title string, status string, commitSHA string) error {\n\treturn logging.AppendRunnerSummary(repoRoot, issueID, title, status, commitSHA)\n}\n\ntype defaultOpenCodeRunner struct{}\n\nfunc (defaultOpenCodeRunner) Start(args []string, env map[string]string, stdoutPath string) (opencode.Process, error) {\n\treturn startCommandWithEnv(args, env, stdoutPath)\n}\n\ntype roadmapCandidate struct {\n\tID     string `json:\"id\"`\n\tTitle  string `json:\"title\"`\n\tType   string `json:\"issue_type\"`\n\tStatus string `json:\"status\"`\n}\n\nfunc inferDefaultRootID(repoRoot string) (string, error) {\n\tissuesPath := filepath.Join(repoRoot, \".beads\", \"issues.jsonl\")\n\tfile, err := os.Open(issuesPath)\n\tif err != nil {\n\t\treturn \"\", errors.New(\"missing --root and no readable .beads/issues.jsonl; pass --root explicitly\")\n\t}\n\tdefer file.Close()\n\n\tscanner := bufio.NewScanner(file)\n\tcount := 0\n\tvar match roadmapCandidate\n\tfor scanner.Scan() {\n\t\tline := strings.TrimSpace(scanner.Text())\n\t\tif line == \"\" {\n\t\t\tcontinue\n\t\t}\n\t\tvar item roadmapCandidate\n\t\tif err := json.Unmarshal([]byte(line), &item); err != nil {\n\t\t\tcontinue\n\t\t}\n\t\tif item.Title == \"Roadmap\" && item.Type == \"epic\" && (item.Status == \"open\" || item.Status == \"in_progress\") {\n\t\t\tcount++\n\t\t\tmatch = item\n\t\t}\n\t}\n\tif err := scanner.Err(); err != nil {\n\t\treturn \"\", errors.New(\"missing --root and unable to read .beads/issues.jsonl; pass --root explicitly\")\n\t}\n\tif count == 1 && match.ID != \"\" {\n\t\treturn match.ID, nil\n\t}\n\treturn \"\", errors.New(\"missing --root and no unique Roadmap epic found; pass --root explicitly\")\n}\n","after":"package main\n\nimport (\n\t\"bufio\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"flag\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\n\t\"yolo-runner/internal/beads\"\n\t\"yolo-runner/internal/logging\"\n\t\"yolo-runner/internal/opencode\"\n\t\"yolo-runner/internal/prompt\"\n\t\"yolo-runner/internal/runner\"\n\t\"yolo-runner/internal/ui/tui\"\n\tgitadapter \"yolo-runner/internal/vcs/git\"\n\n\ttea \"github.com/charmbracelet/bubbletea\"\n\t\"golang.org/x/term\"\n)\n\ntype runOnceFunc func(opts runner.RunOnceOptions, deps runner.RunOnceDeps) (string, error)\n\ntype exitFunc func(code int)\n\ntype beadsRunner interface {\n\tRun(args ...string) (string, error)\n}\n\ntype gitRunner interface {\n\tRun(name string, args ...string) (string, error)\n}\n\ntype openCodeRunner interface {\n\tStart(args []string, env map[string]string, stdoutPath string) (opencode.Process, error)\n}\n\ntype tuiProgram interface {\n\tStart() error\n\tSend(event runner.Event)\n\tQuit()\n}\n\ntype tuiEmitter struct {\n\tprogram tuiProgram\n}\n\nfunc (t tuiEmitter) Emit(event runner.Event) {\n\tif t.program == nil {\n\t\treturn\n\t}\n\tgo t.program.Send(event)\n}\n\ntype bubbleTUIProgram struct {\n\tprogram *tea.Program\n}\n\nfunc (b bubbleTUIProgram) Start() error {\n\tif b.program == nil {\n\t\treturn nil\n\t}\n\treturn b.program.Start()\n}\n\nfunc (b bubbleTUIProgram) Send(event runner.Event) {\n\tif b.program == nil {\n\t\treturn\n\t}\n\tb.program.Send(event)\n}\n\nfunc (b bubbleTUIProgram) Quit() {\n\tif b.program == nil {\n\t\treturn\n\t}\n\tb.program.Quit()\n}\n\nvar isTerminal = func(writer io.Writer) bool {\n\tif file, ok := writer.(*os.File); ok {\n\t\treturn term.IsTerminal(int(file.Fd()))\n\t}\n\treturn false\n}\n\nvar newTUIProgram = func(stdout io.Writer) tuiProgram {\n\tprogram := tea.NewProgram(tui.NewModel(nil), tea.WithInput(nil), tea.WithOutput(stdout))\n\treturn bubbleTUIProgram{program: program}\n}\n\ntype adapterRunner struct{}\n\nfunc (adapterRunner) Run(args ...string) (string, error) {\n\treturn runCommand(args...)\n}\n\ntype adapterGitRunner struct{}\n\nfunc (adapterGitRunner) Run(name string, args ...string) (string, error) {\n\treturn runCommand(append([]string{name}, args...)...)\n}\n\ntype openCodeAdapter struct {\n\trunner openCodeRunner\n}\n\nfunc (o openCodeAdapter) Run(issueID string, repoRoot string, promptText string, model string, configRoot string, configDir string, logPath string) error {\n\treturn opencode.Run(issueID, repoRoot, promptText, model, configRoot, configDir, logPath, o.runner)\n}\n\nfunc RunOnceMain(args []string, runOnce runOnceFunc, exit exitFunc, stdout io.Writer, stderr io.Writer, beadsRunner beadsRunner, gitRunner gitRunner) int {\n\tif len(args) > 0 && args[0] == \"init\" {\n\t\treturn InitMain(args[1:], exit, stderr)\n\t}\n\n\tfs := flag.NewFlagSet(\"yolo-runner\", flag.ContinueOnError)\n\tfs.SetOutput(stderr)\n\n\trepoRoot := fs.String(\"repo\", \".\", \"Repository root path\")\n\trootID := fs.String(\"root\", \"\", \"Root bead/epic ID\")\n\tmodel := fs.String(\"model\", \"\", \"OpenCode model\")\n\tdryRun := fs.Bool(\"dry-run\", false, \"Print task and prompt without executing\")\n\theadless := fs.Bool(\"headless\", false, \"Force plain output without TUI\")\n\tconfigRoot := fs.String(\"config-root\", \"\", \"OpenCode config root\")\n\tconfigDir := fs.String(\"config-dir\", \"\", \"OpenCode config dir\")\n\n\tif err := fs.Parse(args); err != nil {\n\t\tfmt.Fprintln(stderr, err)\n\t\tif exit != nil {\n\t\t\texit(1)\n\t\t}\n\t\treturn 1\n\t}\n\n\tif runOnce == nil {\n\t\trunOnce = runner.RunOnce\n\t}\n\n\tif err := opencode.ValidateAgent(*repoRoot); err != nil {\n\t\tfmt.Fprintln(stderr, err)\n\t\tif exit != nil {\n\t\t\texit(1)\n\t\t}\n\t\treturn 1\n\t}\n\n\tif beadsRunner == nil {\n\t\tbeadsRunner = adapterRunner{}\n\t}\n\tif gitRunner == nil {\n\t\tgitRunner = adapterGitRunner{}\n\t}\n\n\tbeadsAdapter := beads.New(beadsRunner)\n\tgitAdapter := gitadapter.New(gitRunner)\n\topenCodeAdapter := openCodeAdapter{runner: defaultOpenCodeRunner{}}\n\n\tresolvedRootID := *rootID\n\tif resolvedRootID == \"\" {\n\t\tinferredRootID, err := inferDefaultRootID(*repoRoot)\n\t\tif err != nil {\n\t\t\tfmt.Fprintln(stderr, err)\n\t\t\tif exit != nil {\n\t\t\t\texit(1)\n\t\t\t}\n\t\t\treturn 1\n\t\t}\n\t\tresolvedRootID = inferredRootID\n\t}\n\n\tdeps := runner.RunOnceDeps{\n\t\tBeads:    beadsAdapter,\n\t\tPrompt:   promptBuilder{},\n\t\tOpenCode: openCodeAdapter,\n\t\tGit:      gitAdapter,\n\t\tLogger:   runnerLogger{},\n\t}\n\n\tresolvedConfigRoot := *configRoot\n\tresolvedConfigDir := *configDir\n\tif resolvedConfigRoot == \"\" {\n\t\thomeDir := os.Getenv(\"HOME\")\n\t\tif homeDir != \"\" {\n\t\t\tresolvedConfigRoot = filepath.Join(homeDir, \".config\", \"opencode-runner\")\n\t\t}\n\t}\n\tif resolvedConfigDir == \"\" && resolvedConfigRoot != \"\" {\n\t\tresolvedConfigDir = filepath.Join(resolvedConfigRoot, \"opencode\")\n\t}\n\n\toptions := runner.RunOnceOptions{\n\t\tRepoRoot:   *repoRoot,\n\t\tRootID:     resolvedRootID,\n\t\tModel:      *model,\n\t\tConfigRoot: resolvedConfigRoot,\n\t\tConfigDir:  resolvedConfigDir,\n\t\tDryRun:     *dryRun,\n\t\tOut:        stdout,\n\t}\n\n\tif stdout == nil {\n\t\toptions.Out = io.Discard\n\t}\n\tif stderr == nil {\n\t\tstderr = io.Discard\n\t}\n\n\tvar program tuiProgram\n\tif !*headless && isTerminal(stdout) {\n\t\tprogram = newTUIProgram(stdout)\n\t\tdeps.Events = tuiEmitter{program: program}\n\t\tgo func() {\n\t\t\tif err := program.Start(); err != nil {\n\t\t\t\tfmt.Fprintln(stderr, err)\n\t\t\t\tif exit != nil {\n\t\t\t\t\texit(1)\n\t\t\t\t}\n\t\t\t}\n\t\t}()\n\t}\n\n\t_, err := runOnce(options, deps)\n\tif program != nil {\n\t\tprogram.Quit()\n\t}\n\tif err != nil {\n\t\tfmt.Fprintln(stderr, err)\n\t\tif exit != nil {\n\t\t\texit(1)\n\t\t}\n\t\treturn 1\n\t}\n\n\tif exit != nil {\n\t\texit(0)\n\t}\n\treturn 0\n}\n\nfunc main() {\n\tRunOnceMain(os.Args[1:], runner.RunOnce, os.Exit, os.Stdout, os.Stderr, nil, nil)\n}\n\ntype promptBuilder struct{}\n\nfunc (promptBuilder) Build(issueID string, title string, description string, acceptance string) string {\n\treturn prompt.Build(issueID, title, description, acceptance)\n}\n\ntype runnerLogger struct{}\n\nfunc (runnerLogger) AppendRunnerSummary(repoRoot string, issueID string, title string, status string, commitSHA string) error {\n\treturn logging.AppendRunnerSummary(repoRoot, issueID, title, status, commitSHA)\n}\n\ntype defaultOpenCodeRunner struct{}\n\nfunc (defaultOpenCodeRunner) Start(args []string, env map[string]string, stdoutPath string) (opencode.Process, error) {\n\treturn startCommandWithEnv(args, env, stdoutPath)\n}\n\ntype roadmapCandidate struct {\n\tID     string `json:\"id\"`\n\tTitle  string `json:\"title\"`\n\tType   string `json:\"issue_type\"`\n\tStatus string `json:\"status\"`\n}\n\nfunc inferDefaultRootID(repoRoot string) (string, error) {\n\tissuesPath := filepath.Join(repoRoot, \".beads\", \"issues.jsonl\")\n\tfile, err := os.Open(issuesPath)\n\tif err != nil {\n\t\treturn \"\", errors.New(\"missing --root and no readable .beads/issues.jsonl; pass --root explicitly\")\n\t}\n\tdefer file.Close()\n\n\tscanner := bufio.NewScanner(file)\n\tcount := 0\n\tvar match roadmapCandidate\n\tfor scanner.Scan() {\n\t\tline := strings.TrimSpace(scanner.Text())\n\t\tif line == \"\" {\n\t\t\tcontinue\n\t\t}\n\t\tvar item roadmapCandidate\n\t\tif err := json.Unmarshal([]byte(line), &item); err != nil {\n\t\t\tcontinue\n\t\t}\n\t\tif item.Title == \"Roadmap\" && item.Type == \"epic\" && (item.Status == \"open\" || item.Status == \"in_progress\") {\n\t\t\tcount++\n\t\t\tmatch = item\n\t\t}\n\t}\n\tif err := scanner.Err(); err != nil {\n\t\treturn \"\", errors.New(\"missing --root and unable to read .beads/issues.jsonl; pass --root explicitly\")\n\t}\n\tif count == 1 && match.ID != \"\" {\n\t\treturn match.ID, nil\n\t}\n\treturn \"\", errors.New(\"missing --root and no unique Roadmap epic found; pass --root explicitly\")\n}\n","additions":4,"deletions":0},"truncated":false},"time":{"start":1768851182678,"end":1768851182839}},"metadata":{"openai":{"itemId":"fc_0fa98eef573c4df001696e86e62444819197bc97a0efa46ec0"}}}}
{"type":"step_finish","timestamp":1768851182859,"sessionID":"ses_428432b5cffeiuHqPgEDLEHUBi","part":{"id":"prt_bd7bf14f70013KGaaPDgxfJJ1A","sessionID":"ses_428432b5cffeiuHqPgEDLEHUBi","messageID":"msg_bd7bec64c0011ap3GKl63fNN29","type":"step-finish","reason":"tool-calls","snapshot":"b13945a262076dbfa70a9996be57a6ba81a3e29c","cost":0,"tokens":{"input":1126,"output":1186,"reasoning":576,"cache":{"read":23168,"write":0}}}}
{"type":"step_start","timestamp":1768851183256,"sessionID":"ses_428432b5cffeiuHqPgEDLEHUBi","part":{"id":"prt_bd7bf1697001rbjG0L6QKjnImA","sessionID":"ses_428432b5cffeiuHqPgEDLEHUBi","messageID":"msg_bd7bf151e001Gj4BKk14FB9Wzi","type":"step-start","snapshot":"7cd410db265cd3bb832f467430793b2abcbf6163"}}
{"type":"step_finish","timestamp":1768851188643,"sessionID":"ses_428432b5cffeiuHqPgEDLEHUBi","part":{"id":"prt_bd7bf2b96001GVR1yrgr76MpG4","sessionID":"ses_428432b5cffeiuHqPgEDLEHUBi","messageID":"msg_bd7bf151e001Gj4BKk14FB9Wzi","type":"step-finish","reason":"tool-calls","snapshot":"15b63580d0db6632b235e2080f318c6ffbac9837","cost":0,"tokens":{"input":770,"output":235,"reasoning":0,"cache":{"read":24192,"write":0}}}}
{"type":"step_start","timestamp":1768851189008,"sessionID":"ses_428432b5cffeiuHqPgEDLEHUBi","part":{"id":"prt_bd7bf2d100017zhtZAHlH1f0LO","sessionID":"ses_428432b5cffeiuHqPgEDLEHUBi","messageID":"msg_bd7bf2bb400145B1WC3ktL6QeZ","type":"step-start","snapshot":"8853392745f0ff8ccbcb75b5f0d6bd42b1f2d190"}}
{"type":"tool_use","timestamp":1768851195736,"sessionID":"ses_428432b5cffeiuHqPgEDLEHUBi","part":{"id":"prt_bd7bf3354001yMBjG84gJZkTOb","sessionID":"ses_428432b5cffeiuHqPgEDLEHUBi","messageID":"msg_bd7bf2bb400145B1WC3ktL6QeZ","type":"tool","callID":"call_lbBubzFDivpf4f8wbDjFTosR","tool":"edit","state":{"status":"completed","input":{"filePath":"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main.go","oldString":"func main() {\n\tRunOnceMain(os.Args[1:], runner.RunOnce, os.Exit, os.Stdout, os.Stderr, nil, nil)\n}\n","newString":"func main() {\n\tRunOnceMain(os.Args[1:], runner.RunOnce, os.Exit, os.Stdout, os.Stderr, nil, nil)\n}\n\nfunc InitMain(args []string, exit exitFunc, stderr io.Writer) int {\n\tfs := flag.NewFlagSet(\"yolo-runner-init\", flag.ContinueOnError)\n\tfs.SetOutput(stderr)\n\n\trepoRoot := fs.String(\"repo\", \".\", \"Repository root path\")\n\n\tif err := fs.Parse(args); err != nil {\n\t\tfmt.Fprintln(stderr, err)\n\t\tif exit != nil {\n\t\t\texit(1)\n\t\t}\n\t\treturn 1\n\t}\n\n\tif err := opencode.InitAgent(*repoRoot); err != nil {\n\t\tfmt.Fprintln(stderr, err)\n\t\tif exit != nil {\n\t\t\texit(1)\n\t\t}\n\t\treturn 1\n\t}\n\n\tif exit != nil {\n\t\texit(0)\n\t}\n\treturn 0\n}\n"},"output":"Edit applied successfully.","title":"cmd/yolo-runner/main.go","metadata":{"diagnostics":{"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main.go":[],"/Users/egv/dev/yolo-runner/go.mod":[{"range":{"start":{"line":6,"character":44},"end":{"line":6,"character":55}},"severity":2,"source":"go mod tidy","message":"github.com/charmbracelet/bubbletea should be direct"},{"range":{"start":{"line":19,"character":26},"end":{"line":19,"character":37}},"severity":2,"source":"go mod tidy","message":"golang.org/x/term should be direct"}],"/Users/egv/dev/yolo-runner/internal/opencode/agent.go":[],"/Users/egv/dev/yolo-runner/internal/opencode/client.go":[{"range":{"start":{"line":28,"character":1},"end":{"line":28,"character":18}},"severity":2,"code":"default","codeDescription":{"href":"https://staticcheck.dev/docs/checks/#S1031"},"source":"S1031","message":"unnecessary nil check around range"}],"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go":[],"/Users/egv/dev/yolo-runner/internal/opencode/agent_test.go":[],"/Users/egv/dev/yolo-runner/cmd/yolo-runner/exec.go":[]},"diff":"Index: /Users/egv/dev/yolo-runner/cmd/yolo-runner/main.go\n===================================================================\n--- /Users/egv/dev/yolo-runner/cmd/yolo-runner/main.go\n+++ /Users/egv/dev/yolo-runner/cmd/yolo-runner/main.go\n@@ -245,8 +245,36 @@\n func main() {\n \tRunOnceMain(os.Args[1:], runner.RunOnce, os.Exit, os.Stdout, os.Stderr, nil, nil)\n }\n \n+func InitMain(args []string, exit exitFunc, stderr io.Writer) int {\n+\tfs := flag.NewFlagSet(\"yolo-runner-init\", flag.ContinueOnError)\n+\tfs.SetOutput(stderr)\n+\n+\trepoRoot := fs.String(\"repo\", \".\", \"Repository root path\")\n+\n+\tif err := fs.Parse(args); err != nil {\n+\t\tfmt.Fprintln(stderr, err)\n+\t\tif exit != nil {\n+\t\t\texit(1)\n+\t\t}\n+\t\treturn 1\n+\t}\n+\n+\tif err := opencode.InitAgent(*repoRoot); err != nil {\n+\t\tfmt.Fprintln(stderr, err)\n+\t\tif exit != nil {\n+\t\t\texit(1)\n+\t\t}\n+\t\treturn 1\n+\t}\n+\n+\tif exit != nil {\n+\t\texit(0)\n+\t}\n+\treturn 0\n+}\n+\n type promptBuilder struct{}\n \n func (promptBuilder) Build(issueID string, title string, description string, acceptance string) string {\n \treturn prompt.Build(issueID, title, description, acceptance)\n","filediff":{"file":"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main.go","before":"package main\n\nimport (\n\t\"bufio\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"flag\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\n\t\"yolo-runner/internal/beads\"\n\t\"yolo-runner/internal/logging\"\n\t\"yolo-runner/internal/opencode\"\n\t\"yolo-runner/internal/prompt\"\n\t\"yolo-runner/internal/runner\"\n\t\"yolo-runner/internal/ui/tui\"\n\tgitadapter \"yolo-runner/internal/vcs/git\"\n\n\ttea \"github.com/charmbracelet/bubbletea\"\n\t\"golang.org/x/term\"\n)\n\ntype runOnceFunc func(opts runner.RunOnceOptions, deps runner.RunOnceDeps) (string, error)\n\ntype exitFunc func(code int)\n\ntype beadsRunner interface {\n\tRun(args ...string) (string, error)\n}\n\ntype gitRunner interface {\n\tRun(name string, args ...string) (string, error)\n}\n\ntype openCodeRunner interface {\n\tStart(args []string, env map[string]string, stdoutPath string) (opencode.Process, error)\n}\n\ntype tuiProgram interface {\n\tStart() error\n\tSend(event runner.Event)\n\tQuit()\n}\n\ntype tuiEmitter struct {\n\tprogram tuiProgram\n}\n\nfunc (t tuiEmitter) Emit(event runner.Event) {\n\tif t.program == nil {\n\t\treturn\n\t}\n\tgo t.program.Send(event)\n}\n\ntype bubbleTUIProgram struct {\n\tprogram *tea.Program\n}\n\nfunc (b bubbleTUIProgram) Start() error {\n\tif b.program == nil {\n\t\treturn nil\n\t}\n\treturn b.program.Start()\n}\n\nfunc (b bubbleTUIProgram) Send(event runner.Event) {\n\tif b.program == nil {\n\t\treturn\n\t}\n\tb.program.Send(event)\n}\n\nfunc (b bubbleTUIProgram) Quit() {\n\tif b.program == nil {\n\t\treturn\n\t}\n\tb.program.Quit()\n}\n\nvar isTerminal = func(writer io.Writer) bool {\n\tif file, ok := writer.(*os.File); ok {\n\t\treturn term.IsTerminal(int(file.Fd()))\n\t}\n\treturn false\n}\n\nvar newTUIProgram = func(stdout io.Writer) tuiProgram {\n\tprogram := tea.NewProgram(tui.NewModel(nil), tea.WithInput(nil), tea.WithOutput(stdout))\n\treturn bubbleTUIProgram{program: program}\n}\n\ntype adapterRunner struct{}\n\nfunc (adapterRunner) Run(args ...string) (string, error) {\n\treturn runCommand(args...)\n}\n\ntype adapterGitRunner struct{}\n\nfunc (adapterGitRunner) Run(name string, args ...string) (string, error) {\n\treturn runCommand(append([]string{name}, args...)...)\n}\n\ntype openCodeAdapter struct {\n\trunner openCodeRunner\n}\n\nfunc (o openCodeAdapter) Run(issueID string, repoRoot string, promptText string, model string, configRoot string, configDir string, logPath string) error {\n\treturn opencode.Run(issueID, repoRoot, promptText, model, configRoot, configDir, logPath, o.runner)\n}\n\nfunc RunOnceMain(args []string, runOnce runOnceFunc, exit exitFunc, stdout io.Writer, stderr io.Writer, beadsRunner beadsRunner, gitRunner gitRunner) int {\n\tif len(args) > 0 && args[0] == \"init\" {\n\t\treturn InitMain(args[1:], exit, stderr)\n\t}\n\n\tfs := flag.NewFlagSet(\"yolo-runner\", flag.ContinueOnError)\n\tfs.SetOutput(stderr)\n\n\trepoRoot := fs.String(\"repo\", \".\", \"Repository root path\")\n\trootID := fs.String(\"root\", \"\", \"Root bead/epic ID\")\n\tmodel := fs.String(\"model\", \"\", \"OpenCode model\")\n\tdryRun := fs.Bool(\"dry-run\", false, \"Print task and prompt without executing\")\n\theadless := fs.Bool(\"headless\", false, \"Force plain output without TUI\")\n\tconfigRoot := fs.String(\"config-root\", \"\", \"OpenCode config root\")\n\tconfigDir := fs.String(\"config-dir\", \"\", \"OpenCode config dir\")\n\n\tif err := fs.Parse(args); err != nil {\n\t\tfmt.Fprintln(stderr, err)\n\t\tif exit != nil {\n\t\t\texit(1)\n\t\t}\n\t\treturn 1\n\t}\n\n\tif runOnce == nil {\n\t\trunOnce = runner.RunOnce\n\t}\n\n\tif err := opencode.ValidateAgent(*repoRoot); err != nil {\n\t\tfmt.Fprintln(stderr, err)\n\t\tif exit != nil {\n\t\t\texit(1)\n\t\t}\n\t\treturn 1\n\t}\n\n\tif beadsRunner == nil {\n\t\tbeadsRunner = adapterRunner{}\n\t}\n\tif gitRunner == nil {\n\t\tgitRunner = adapterGitRunner{}\n\t}\n\n\tbeadsAdapter := beads.New(beadsRunner)\n\tgitAdapter := gitadapter.New(gitRunner)\n\topenCodeAdapter := openCodeAdapter{runner: defaultOpenCodeRunner{}}\n\n\tresolvedRootID := *rootID\n\tif resolvedRootID == \"\" {\n\t\tinferredRootID, err := inferDefaultRootID(*repoRoot)\n\t\tif err != nil {\n\t\t\tfmt.Fprintln(stderr, err)\n\t\t\tif exit != nil {\n\t\t\t\texit(1)\n\t\t\t}\n\t\t\treturn 1\n\t\t}\n\t\tresolvedRootID = inferredRootID\n\t}\n\n\tdeps := runner.RunOnceDeps{\n\t\tBeads:    beadsAdapter,\n\t\tPrompt:   promptBuilder{},\n\t\tOpenCode: openCodeAdapter,\n\t\tGit:      gitAdapter,\n\t\tLogger:   runnerLogger{},\n\t}\n\n\tresolvedConfigRoot := *configRoot\n\tresolvedConfigDir := *configDir\n\tif resolvedConfigRoot == \"\" {\n\t\thomeDir := os.Getenv(\"HOME\")\n\t\tif homeDir != \"\" {\n\t\t\tresolvedConfigRoot = filepath.Join(homeDir, \".config\", \"opencode-runner\")\n\t\t}\n\t}\n\tif resolvedConfigDir == \"\" && resolvedConfigRoot != \"\" {\n\t\tresolvedConfigDir = filepath.Join(resolvedConfigRoot, \"opencode\")\n\t}\n\n\toptions := runner.RunOnceOptions{\n\t\tRepoRoot:   *repoRoot,\n\t\tRootID:     resolvedRootID,\n\t\tModel:      *model,\n\t\tConfigRoot: resolvedConfigRoot,\n\t\tConfigDir:  resolvedConfigDir,\n\t\tDryRun:     *dryRun,\n\t\tOut:        stdout,\n\t}\n\n\tif stdout == nil {\n\t\toptions.Out = io.Discard\n\t}\n\tif stderr == nil {\n\t\tstderr = io.Discard\n\t}\n\n\tvar program tuiProgram\n\tif !*headless && isTerminal(stdout) {\n\t\tprogram = newTUIProgram(stdout)\n\t\tdeps.Events = tuiEmitter{program: program}\n\t\tgo func() {\n\t\t\tif err := program.Start(); err != nil {\n\t\t\t\tfmt.Fprintln(stderr, err)\n\t\t\t\tif exit != nil {\n\t\t\t\t\texit(1)\n\t\t\t\t}\n\t\t\t}\n\t\t}()\n\t}\n\n\t_, err := runOnce(options, deps)\n\tif program != nil {\n\t\tprogram.Quit()\n\t}\n\tif err != nil {\n\t\tfmt.Fprintln(stderr, err)\n\t\tif exit != nil {\n\t\t\texit(1)\n\t\t}\n\t\treturn 1\n\t}\n\n\tif exit != nil {\n\t\texit(0)\n\t}\n\treturn 0\n}\n\nfunc main() {\n\tRunOnceMain(os.Args[1:], runner.RunOnce, os.Exit, os.Stdout, os.Stderr, nil, nil)\n}\n\ntype promptBuilder struct{}\n\nfunc (promptBuilder) Build(issueID string, title string, description string, acceptance string) string {\n\treturn prompt.Build(issueID, title, description, acceptance)\n}\n\ntype runnerLogger struct{}\n\nfunc (runnerLogger) AppendRunnerSummary(repoRoot string, issueID string, title string, status string, commitSHA string) error {\n\treturn logging.AppendRunnerSummary(repoRoot, issueID, title, status, commitSHA)\n}\n\ntype defaultOpenCodeRunner struct{}\n\nfunc (defaultOpenCodeRunner) Start(args []string, env map[string]string, stdoutPath string) (opencode.Process, error) {\n\treturn startCommandWithEnv(args, env, stdoutPath)\n}\n\ntype roadmapCandidate struct {\n\tID     string `json:\"id\"`\n\tTitle  string `json:\"title\"`\n\tType   string `json:\"issue_type\"`\n\tStatus string `json:\"status\"`\n}\n\nfunc inferDefaultRootID(repoRoot string) (string, error) {\n\tissuesPath := filepath.Join(repoRoot, \".beads\", \"issues.jsonl\")\n\tfile, err := os.Open(issuesPath)\n\tif err != nil {\n\t\treturn \"\", errors.New(\"missing --root and no readable .beads/issues.jsonl; pass --root explicitly\")\n\t}\n\tdefer file.Close()\n\n\tscanner := bufio.NewScanner(file)\n\tcount := 0\n\tvar match roadmapCandidate\n\tfor scanner.Scan() {\n\t\tline := strings.TrimSpace(scanner.Text())\n\t\tif line == \"\" {\n\t\t\tcontinue\n\t\t}\n\t\tvar item roadmapCandidate\n\t\tif err := json.Unmarshal([]byte(line), &item); err != nil {\n\t\t\tcontinue\n\t\t}\n\t\tif item.Title == \"Roadmap\" && item.Type == \"epic\" && (item.Status == \"open\" || item.Status == \"in_progress\") {\n\t\t\tcount++\n\t\t\tmatch = item\n\t\t}\n\t}\n\tif err := scanner.Err(); err != nil {\n\t\treturn \"\", errors.New(\"missing --root and unable to read .beads/issues.jsonl; pass --root explicitly\")\n\t}\n\tif count == 1 && match.ID != \"\" {\n\t\treturn match.ID, nil\n\t}\n\treturn \"\", errors.New(\"missing --root and no unique Roadmap epic found; pass --root explicitly\")\n}\n","after":"package main\n\nimport (\n\t\"bufio\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"flag\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\n\t\"yolo-runner/internal/beads\"\n\t\"yolo-runner/internal/logging\"\n\t\"yolo-runner/internal/opencode\"\n\t\"yolo-runner/internal/prompt\"\n\t\"yolo-runner/internal/runner\"\n\t\"yolo-runner/internal/ui/tui\"\n\tgitadapter \"yolo-runner/internal/vcs/git\"\n\n\ttea \"github.com/charmbracelet/bubbletea\"\n\t\"golang.org/x/term\"\n)\n\ntype runOnceFunc func(opts runner.RunOnceOptions, deps runner.RunOnceDeps) (string, error)\n\ntype exitFunc func(code int)\n\ntype beadsRunner interface {\n\tRun(args ...string) (string, error)\n}\n\ntype gitRunner interface {\n\tRun(name string, args ...string) (string, error)\n}\n\ntype openCodeRunner interface {\n\tStart(args []string, env map[string]string, stdoutPath string) (opencode.Process, error)\n}\n\ntype tuiProgram interface {\n\tStart() error\n\tSend(event runner.Event)\n\tQuit()\n}\n\ntype tuiEmitter struct {\n\tprogram tuiProgram\n}\n\nfunc (t tuiEmitter) Emit(event runner.Event) {\n\tif t.program == nil {\n\t\treturn\n\t}\n\tgo t.program.Send(event)\n}\n\ntype bubbleTUIProgram struct {\n\tprogram *tea.Program\n}\n\nfunc (b bubbleTUIProgram) Start() error {\n\tif b.program == nil {\n\t\treturn nil\n\t}\n\treturn b.program.Start()\n}\n\nfunc (b bubbleTUIProgram) Send(event runner.Event) {\n\tif b.program == nil {\n\t\treturn\n\t}\n\tb.program.Send(event)\n}\n\nfunc (b bubbleTUIProgram) Quit() {\n\tif b.program == nil {\n\t\treturn\n\t}\n\tb.program.Quit()\n}\n\nvar isTerminal = func(writer io.Writer) bool {\n\tif file, ok := writer.(*os.File); ok {\n\t\treturn term.IsTerminal(int(file.Fd()))\n\t}\n\treturn false\n}\n\nvar newTUIProgram = func(stdout io.Writer) tuiProgram {\n\tprogram := tea.NewProgram(tui.NewModel(nil), tea.WithInput(nil), tea.WithOutput(stdout))\n\treturn bubbleTUIProgram{program: program}\n}\n\ntype adapterRunner struct{}\n\nfunc (adapterRunner) Run(args ...string) (string, error) {\n\treturn runCommand(args...)\n}\n\ntype adapterGitRunner struct{}\n\nfunc (adapterGitRunner) Run(name string, args ...string) (string, error) {\n\treturn runCommand(append([]string{name}, args...)...)\n}\n\ntype openCodeAdapter struct {\n\trunner openCodeRunner\n}\n\nfunc (o openCodeAdapter) Run(issueID string, repoRoot string, promptText string, model string, configRoot string, configDir string, logPath string) error {\n\treturn opencode.Run(issueID, repoRoot, promptText, model, configRoot, configDir, logPath, o.runner)\n}\n\nfunc RunOnceMain(args []string, runOnce runOnceFunc, exit exitFunc, stdout io.Writer, stderr io.Writer, beadsRunner beadsRunner, gitRunner gitRunner) int {\n\tif len(args) > 0 && args[0] == \"init\" {\n\t\treturn InitMain(args[1:], exit, stderr)\n\t}\n\n\tfs := flag.NewFlagSet(\"yolo-runner\", flag.ContinueOnError)\n\tfs.SetOutput(stderr)\n\n\trepoRoot := fs.String(\"repo\", \".\", \"Repository root path\")\n\trootID := fs.String(\"root\", \"\", \"Root bead/epic ID\")\n\tmodel := fs.String(\"model\", \"\", \"OpenCode model\")\n\tdryRun := fs.Bool(\"dry-run\", false, \"Print task and prompt without executing\")\n\theadless := fs.Bool(\"headless\", false, \"Force plain output without TUI\")\n\tconfigRoot := fs.String(\"config-root\", \"\", \"OpenCode config root\")\n\tconfigDir := fs.String(\"config-dir\", \"\", \"OpenCode config dir\")\n\n\tif err := fs.Parse(args); err != nil {\n\t\tfmt.Fprintln(stderr, err)\n\t\tif exit != nil {\n\t\t\texit(1)\n\t\t}\n\t\treturn 1\n\t}\n\n\tif runOnce == nil {\n\t\trunOnce = runner.RunOnce\n\t}\n\n\tif err := opencode.ValidateAgent(*repoRoot); err != nil {\n\t\tfmt.Fprintln(stderr, err)\n\t\tif exit != nil {\n\t\t\texit(1)\n\t\t}\n\t\treturn 1\n\t}\n\n\tif beadsRunner == nil {\n\t\tbeadsRunner = adapterRunner{}\n\t}\n\tif gitRunner == nil {\n\t\tgitRunner = adapterGitRunner{}\n\t}\n\n\tbeadsAdapter := beads.New(beadsRunner)\n\tgitAdapter := gitadapter.New(gitRunner)\n\topenCodeAdapter := openCodeAdapter{runner: defaultOpenCodeRunner{}}\n\n\tresolvedRootID := *rootID\n\tif resolvedRootID == \"\" {\n\t\tinferredRootID, err := inferDefaultRootID(*repoRoot)\n\t\tif err != nil {\n\t\t\tfmt.Fprintln(stderr, err)\n\t\t\tif exit != nil {\n\t\t\t\texit(1)\n\t\t\t}\n\t\t\treturn 1\n\t\t}\n\t\tresolvedRootID = inferredRootID\n\t}\n\n\tdeps := runner.RunOnceDeps{\n\t\tBeads:    beadsAdapter,\n\t\tPrompt:   promptBuilder{},\n\t\tOpenCode: openCodeAdapter,\n\t\tGit:      gitAdapter,\n\t\tLogger:   runnerLogger{},\n\t}\n\n\tresolvedConfigRoot := *configRoot\n\tresolvedConfigDir := *configDir\n\tif resolvedConfigRoot == \"\" {\n\t\thomeDir := os.Getenv(\"HOME\")\n\t\tif homeDir != \"\" {\n\t\t\tresolvedConfigRoot = filepath.Join(homeDir, \".config\", \"opencode-runner\")\n\t\t}\n\t}\n\tif resolvedConfigDir == \"\" && resolvedConfigRoot != \"\" {\n\t\tresolvedConfigDir = filepath.Join(resolvedConfigRoot, \"opencode\")\n\t}\n\n\toptions := runner.RunOnceOptions{\n\t\tRepoRoot:   *repoRoot,\n\t\tRootID:     resolvedRootID,\n\t\tModel:      *model,\n\t\tConfigRoot: resolvedConfigRoot,\n\t\tConfigDir:  resolvedConfigDir,\n\t\tDryRun:     *dryRun,\n\t\tOut:        stdout,\n\t}\n\n\tif stdout == nil {\n\t\toptions.Out = io.Discard\n\t}\n\tif stderr == nil {\n\t\tstderr = io.Discard\n\t}\n\n\tvar program tuiProgram\n\tif !*headless && isTerminal(stdout) {\n\t\tprogram = newTUIProgram(stdout)\n\t\tdeps.Events = tuiEmitter{program: program}\n\t\tgo func() {\n\t\t\tif err := program.Start(); err != nil {\n\t\t\t\tfmt.Fprintln(stderr, err)\n\t\t\t\tif exit != nil {\n\t\t\t\t\texit(1)\n\t\t\t\t}\n\t\t\t}\n\t\t}()\n\t}\n\n\t_, err := runOnce(options, deps)\n\tif program != nil {\n\t\tprogram.Quit()\n\t}\n\tif err != nil {\n\t\tfmt.Fprintln(stderr, err)\n\t\tif exit != nil {\n\t\t\texit(1)\n\t\t}\n\t\treturn 1\n\t}\n\n\tif exit != nil {\n\t\texit(0)\n\t}\n\treturn 0\n}\n\nfunc main() {\n\tRunOnceMain(os.Args[1:], runner.RunOnce, os.Exit, os.Stdout, os.Stderr, nil, nil)\n}\n\nfunc InitMain(args []string, exit exitFunc, stderr io.Writer) int {\n\tfs := flag.NewFlagSet(\"yolo-runner-init\", flag.ContinueOnError)\n\tfs.SetOutput(stderr)\n\n\trepoRoot := fs.String(\"repo\", \".\", \"Repository root path\")\n\n\tif err := fs.Parse(args); err != nil {\n\t\tfmt.Fprintln(stderr, err)\n\t\tif exit != nil {\n\t\t\texit(1)\n\t\t}\n\t\treturn 1\n\t}\n\n\tif err := opencode.InitAgent(*repoRoot); err != nil {\n\t\tfmt.Fprintln(stderr, err)\n\t\tif exit != nil {\n\t\t\texit(1)\n\t\t}\n\t\treturn 1\n\t}\n\n\tif exit != nil {\n\t\texit(0)\n\t}\n\treturn 0\n}\n\ntype promptBuilder struct{}\n\nfunc (promptBuilder) Build(issueID string, title string, description string, acceptance string) string {\n\treturn prompt.Build(issueID, title, description, acceptance)\n}\n\ntype runnerLogger struct{}\n\nfunc (runnerLogger) AppendRunnerSummary(repoRoot string, issueID string, title string, status string, commitSHA string) error {\n\treturn logging.AppendRunnerSummary(repoRoot, issueID, title, status, commitSHA)\n}\n\ntype defaultOpenCodeRunner struct{}\n\nfunc (defaultOpenCodeRunner) Start(args []string, env map[string]string, stdoutPath string) (opencode.Process, error) {\n\treturn startCommandWithEnv(args, env, stdoutPath)\n}\n\ntype roadmapCandidate struct {\n\tID     string `json:\"id\"`\n\tTitle  string `json:\"title\"`\n\tType   string `json:\"issue_type\"`\n\tStatus string `json:\"status\"`\n}\n\nfunc inferDefaultRootID(repoRoot string) (string, error) {\n\tissuesPath := filepath.Join(repoRoot, \".beads\", \"issues.jsonl\")\n\tfile, err := os.Open(issuesPath)\n\tif err != nil {\n\t\treturn \"\", errors.New(\"missing --root and no readable .beads/issues.jsonl; pass --root explicitly\")\n\t}\n\tdefer file.Close()\n\n\tscanner := bufio.NewScanner(file)\n\tcount := 0\n\tvar match roadmapCandidate\n\tfor scanner.Scan() {\n\t\tline := strings.TrimSpace(scanner.Text())\n\t\tif line == \"\" {\n\t\t\tcontinue\n\t\t}\n\t\tvar item roadmapCandidate\n\t\tif err := json.Unmarshal([]byte(line), &item); err != nil {\n\t\t\tcontinue\n\t\t}\n\t\tif item.Title == \"Roadmap\" && item.Type == \"epic\" && (item.Status == \"open\" || item.Status == \"in_progress\") {\n\t\t\tcount++\n\t\t\tmatch = item\n\t\t}\n\t}\n\tif err := scanner.Err(); err != nil {\n\t\treturn \"\", errors.New(\"missing --root and unable to read .beads/issues.jsonl; pass --root explicitly\")\n\t}\n\tif count == 1 && match.ID != \"\" {\n\t\treturn match.ID, nil\n\t}\n\treturn \"\", errors.New(\"missing --root and no unique Roadmap epic found; pass --root explicitly\")\n}\n","additions":28,"deletions":0},"truncated":false},"time":{"start":1768851195576,"end":1768851195735}},"metadata":{"openai":{"itemId":"fc_05891ef722ee84d501696e86f682f88191a6729dd138b2f26a"}}}}
{"type":"step_finish","timestamp":1768851195751,"sessionID":"ses_428432b5cffeiuHqPgEDLEHUBi","part":{"id":"prt_bd7bf4758001hT1VotOVdQq1Ir","sessionID":"ses_428432b5cffeiuHqPgEDLEHUBi","messageID":"msg_bd7bf2bb400145B1WC3ktL6QeZ","type":"step-finish","reason":"tool-calls","snapshot":"b26b81275cc2576880c4c2d843ac550faac9cc65","cost":0,"tokens":{"input":1022,"output":323,"reasoning":0,"cache":{"read":24192,"write":0}}}}
{"type":"step_start","timestamp":1768851196123,"sessionID":"ses_428432b5cffeiuHqPgEDLEHUBi","part":{"id":"prt_bd7bf48db001ncSiL45EQJvdmf","sessionID":"ses_428432b5cffeiuHqPgEDLEHUBi","messageID":"msg_bd7bf477b001G6VbqvQj29nvea","type":"step-start","snapshot":"239b83d154cfeff1ecd43386b1e27569eda9add1"}}
{"type":"tool_use","timestamp":1768851198500,"sessionID":"ses_428432b5cffeiuHqPgEDLEHUBi","part":{"id":"prt_bd7bf4b35001jDnlF8H2AZ4cu5","sessionID":"ses_428432b5cffeiuHqPgEDLEHUBi","messageID":"msg_bd7bf477b001G6VbqvQj29nvea","type":"tool","callID":"call_hPKwMufcvXexEVNPSI6IGVyV","tool":"bash","state":{"status":"completed","input":{"command":"go test ./...","description":"Run full Go test suite"},"output":"ok  \tyolo-runner\t(cached)\nok  \tyolo-runner/cmd/yolo-runner\t0.537s\nok  \tyolo-runner/internal/beads\t(cached)\nok  \tyolo-runner/internal/logging\t(cached)\nok  \tyolo-runner/internal/opencode\t0.838s\nok  \tyolo-runner/internal/prompt\t(cached)\nok  \tyolo-runner/internal/runner\t(cached)\nok  \tyolo-runner/internal/ui/tui\t(cached)\nok  \tyolo-runner/internal/vcs/git\t(cached)\n","title":"Run full Go test suite","metadata":{"output":"ok  \tyolo-runner\t(cached)\nok  \tyolo-runner/cmd/yolo-runner\t0.537s\nok  \tyolo-runner/internal/beads\t(cached)\nok  \tyolo-runner/internal/logging\t(cached)\nok  \tyolo-runner/internal/opencode\t0.838s\nok  \tyolo-runner/internal/prompt\t(cached)\nok  \tyolo-runner/internal/runner\t(cached)\nok  \tyolo-runner/internal/ui/tui\t(cached)\nok  \tyolo-runner/internal/vcs/git\t(cached)\n","exit":0,"description":"Run full Go test suite","truncated":false},"time":{"start":1768851197155,"end":1768851198500}},"metadata":{"openai":{"itemId":"fc_0857731b9b8254d601696e86fca44c81919a108fbe7ab20c54"}}}}
{"type":"step_finish","timestamp":1768851198519,"sessionID":"ses_428432b5cffeiuHqPgEDLEHUBi","part":{"id":"prt_bd7bf52240012VeM4y3jnyuNeN","sessionID":"ses_428432b5cffeiuHqPgEDLEHUBi","messageID":"msg_bd7bf477b001G6VbqvQj29nvea","type":"step-finish","reason":"tool-calls","snapshot":"16484ad628d6733b219bb395ce6a4ac22bfb0180","cost":0,"tokens":{"input":1354,"output":29,"reasoning":0,"cache":{"read":24192,"write":0}}}}
{"type":"step_start","timestamp":1768851198877,"sessionID":"ses_428432b5cffeiuHqPgEDLEHUBi","part":{"id":"prt_bd7bf539c001Qb6Os5hFbyLtUa","sessionID":"ses_428432b5cffeiuHqPgEDLEHUBi","messageID":"msg_bd7bf524d0014MdGCpWLgNuXEe","type":"step-start","snapshot":"207c98352b2c7ea331abff101af497bf9346ca40"}}
{"type":"tool_use","timestamp":1768851202255,"sessionID":"ses_428432b5cffeiuHqPgEDLEHUBi","part":{"id":"prt_bd7bf5feb001mnha2YvlhXOEH4","sessionID":"ses_428432b5cffeiuHqPgEDLEHUBi","messageID":"msg_bd7bf524d0014MdGCpWLgNuXEe","type":"tool","callID":"call_6uamay0Hxq3YXwYjkVC59yEb","tool":"bash","state":{"status":"completed","input":{"command":"git status -sb","description":"Show git status summary"},"output":"## rewind/v1-go-cleanup...origin/rewind/v1-go-cleanup\n M .beads/issues.jsonl\n M cmd/yolo-runner/main.go\n M cmd/yolo-runner/main_test.go\n M internal/opencode/agent.go\n M runner-logs/beads_yolo_runner.jsonl\n?? runner-logs/opencode/yolo-runner-127.4.11.jsonl\n?? runner-logs/opencode/yolo-runner-127.4.11.stderr.log\n","title":"Show git status summary","metadata":{"output":"## rewind/v1-go-cleanup...origin/rewind/v1-go-cleanup\n M .beads/issues.jsonl\n M cmd/yolo-runner/main.go\n M cmd/yolo-runner/main_test.go\n M internal/opencode/agent.go\n M runner-logs/beads_yolo_runner.jsonl\n?? runner-logs/opencode/yolo-runner-127.4.11.jsonl\n?? runner-logs/opencode/yolo-runner-127.4.11.stderr.log\n","exit":0,"description":"Show git status summary","truncated":false},"time":{"start":1768851202243,"end":1768851202255}},"metadata":{"openai":{"itemId":"fc_0e4b3c92faa5d0db01696e8701dc708191bd7f35e236d79b94"}}}}
{"type":"tool_use","timestamp":1768851202581,"sessionID":"ses_428432b5cffeiuHqPgEDLEHUBi","part":{"id":"prt_bd7bf60c4001YUDYx4G66AhSaI","sessionID":"ses_428432b5cffeiuHqPgEDLEHUBi","messageID":"msg_bd7bf524d0014MdGCpWLgNuXEe","type":"tool","callID":"call_vgcmXkSkS6TRkzz7uc9CiMzH","tool":"bash","state":{"status":"completed","input":{"command":"git diff","description":"Show unstaged/staged git diff"},"output":"diff --git a/.beads/issues.jsonl b/.beads/issues.jsonl\nindex c40e60d..4692361 100644\n--- a/.beads/issues.jsonl\n+++ b/.beads/issues.jsonl\n@@ -13,7 +13,7 @@\n {\"id\":\"yolo-runner-127.4\",\"title\":\"v1.1: Observability (TUI + watchdog + init/guards)\",\"description\":\"Make the runner robust and observable before adding molecule traversal.\\n\\nIncludes:\\n- Bubble Tea TUI progress UI (TTY by default, with --headless)\\n- Watchdog to detect and fail-fast on OpenCode stalls, with evidence\\n- Init/guards to ensure YOLO agent is installed and permissions allow non-interactive runs\\n- Fix default --root behavior (avoid hardcoded algi-8bt)\\n\\nAll implementation must be Go.\",\"acceptance_criteria\":\"- Runner does not hang indefinitely on OpenCode stalls (watchdog)\\n- Runner has clear progress output (TUI on TTY, --headless for logs)\\n- Runner refuses to start if YOLO agent missing; init installs it\\n- Default root is inferred or runner errors clearly\\n- go test ./... passes\",\"status\":\"open\",\"priority\":1,\"issue_type\":\"epic\",\"owner\":\"g.evstratov@gmail.com\",\"created_at\":\"2026-01-19T15:55:27.038426+03:00\",\"created_by\":\"Gennady Evstratov\",\"updated_at\":\"2026-01-19T16:24:16.935052+03:00\",\"dependencies\":[{\"issue_id\":\"yolo-runner-127.4\",\"depends_on_id\":\"yolo-runner-127\",\"type\":\"parent-child\",\"created_at\":\"2026-01-19T15:55:27.039062+03:00\",\"created_by\":\"Gennady Evstratov\"}]}\n {\"id\":\"yolo-runner-127.4.1\",\"title\":\"v1.2: Add Bubble Tea dependency\",\"description\":\"Add Bubble Tea dependencies and minimal wiring.\\n\\nFiles:\\n- Modify: go.mod\\n- Modify: go.sum\\n\\nAcceptance:\\n- go test ./... passes\\n- Bubble Tea module is added and buildable\",\"acceptance_criteria\":\"- go test ./... passes\\n- Bubble Tea module is added and buildable\",\"status\":\"closed\",\"priority\":1,\"issue_type\":\"task\",\"owner\":\"g.evstratov@gmail.com\",\"created_at\":\"2026-01-19T15:55:27.195836+03:00\",\"created_by\":\"Gennady Evstratov\",\"updated_at\":\"2026-01-19T18:59:10.354843+03:00\",\"closed_at\":\"2026-01-19T18:59:10.354843+03:00\",\"close_reason\":\"Closed\",\"dependencies\":[{\"issue_id\":\"yolo-runner-127.4.1\",\"depends_on_id\":\"yolo-runner-127.4\",\"type\":\"parent-child\",\"created_at\":\"2026-01-19T15:55:27.196499+03:00\",\"created_by\":\"Gennady Evstratov\"}]}\n {\"id\":\"yolo-runner-127.4.10\",\"title\":\"v1.2: Refuse to run if YOLO agent missing\",\"description\":\"Before selecting any beads task, validate the YOLO agent is installed for this repo.\\n\\nFiles:\\n- Modify: cmd/yolo-runner/main.go\\n- Create: internal/opencode/agent.go\\n- Create: internal/opencode/agent_test.go\\n\\nRules:\\n- Go only\\n\\nAcceptance:\\n- If .opencode/agent/yolo.md does not exist, runner exits non-zero and prints a clear message\\n- If agent file exists but does not contain frontmatter key permission: allow, runner exits non-zero and prints guidance to run init\\n- Validation happens before any bd update / git add / opencode run\\n- go test ./... passes\",\"acceptance_criteria\":\"- Missing agent file fails fast with clear message\\n- Missing permission allow fails fast with guidance\\n- Validation runs before any mutations\\n- go test ./... passes\",\"status\":\"closed\",\"priority\":1,\"issue_type\":\"task\",\"owner\":\"g.evstratov@gmail.com\",\"created_at\":\"2026-01-19T22:14:35.318898+03:00\",\"created_by\":\"Gennady Evstratov\",\"updated_at\":\"2026-01-19T22:28:04.906764+03:00\",\"closed_at\":\"2026-01-19T22:28:04.906764+03:00\",\"close_reason\":\"Closed\",\"dependencies\":[{\"issue_id\":\"yolo-runner-127.4.10\",\"depends_on_id\":\"yolo-runner-127.4\",\"type\":\"parent-child\",\"created_at\":\"2026-01-19T22:14:35.319632+03:00\",\"created_by\":\"Gennady Evstratov\"}]}\n-{\"id\":\"yolo-runner-127.4.11\",\"title\":\"v1.2: Add init subcommand to install YOLO agent\",\"description\":\"Add an init command to the Go runner that installs the YOLO agent into the project OpenCode config.\\n\\nCommand:\\n- yolo-runner init\\n\\nBehavior:\\n- Create .opencode/agent/ if needed\\n- Copy yolo.md -\\u003e .opencode/agent/yolo.md\\n- Overwrite existing .opencode/agent/yolo.md to match yolo.md\\n\\nFiles:\\n- Modify: cmd/yolo-runner/main.go\\n- Modify: cmd/yolo-runner/main_test.go\\n- Modify: internal/opencode/agent.go\\n\\nRules:\\n- Go only\\n\\nAcceptance:\\n- Running yolo-runner init creates/overwrites .opencode/agent/yolo.md\\n- After init, yolo-runner run mode no longer errors on missing agent\\n- go test ./... passes\",\"acceptance_criteria\":\"- init creates/overwrites agent file\\n- run mode passes agent validation after init\\n- go test ./... passes\",\"status\":\"open\",\"priority\":1,\"issue_type\":\"task\",\"owner\":\"g.evstratov@gmail.com\",\"created_at\":\"2026-01-19T22:14:35.744001+03:00\",\"created_by\":\"Gennady Evstratov\",\"updated_at\":\"2026-01-19T22:14:35.861089+03:00\",\"dependencies\":[{\"issue_id\":\"yolo-runner-127.4.11\",\"depends_on_id\":\"yolo-runner-127.4\",\"type\":\"parent-child\",\"created_at\":\"2026-01-19T22:14:35.744669+03:00\",\"created_by\":\"Gennady Evstratov\"}]}\n+{\"id\":\"yolo-runner-127.4.11\",\"title\":\"v1.2: Add init subcommand to install YOLO agent\",\"description\":\"Add an init command to the Go runner that installs the YOLO agent into the project OpenCode config.\\n\\nCommand:\\n- yolo-runner init\\n\\nBehavior:\\n- Create .opencode/agent/ if needed\\n- Copy yolo.md -\\u003e .opencode/agent/yolo.md\\n- Overwrite existing .opencode/agent/yolo.md to match yolo.md\\n\\nFiles:\\n- Modify: cmd/yolo-runner/main.go\\n- Modify: cmd/yolo-runner/main_test.go\\n- Modify: internal/opencode/agent.go\\n\\nRules:\\n- Go only\\n\\nAcceptance:\\n- Running yolo-runner init creates/overwrites .opencode/agent/yolo.md\\n- After init, yolo-runner run mode no longer errors on missing agent\\n- go test ./... passes\",\"acceptance_criteria\":\"- init creates/overwrites agent file\\n- run mode passes agent validation after init\\n- go test ./... passes\",\"status\":\"in_progress\",\"priority\":1,\"issue_type\":\"task\",\"owner\":\"g.evstratov@gmail.com\",\"created_at\":\"2026-01-19T22:14:35.744001+03:00\",\"created_by\":\"Gennady Evstratov\",\"updated_at\":\"2026-01-19T22:30:34.60294+03:00\",\"dependencies\":[{\"issue_id\":\"yolo-runner-127.4.11\",\"depends_on_id\":\"yolo-runner-127.4\",\"type\":\"parent-child\",\"created_at\":\"2026-01-19T22:14:35.744669+03:00\",\"created_by\":\"Gennady Evstratov\"}]}\n {\"id\":\"yolo-runner-127.4.12\",\"title\":\"v1.2: Document init + agent requirements\",\"description\":\"Document how agent installation works and how to recover when the runner refuses to start.\\n\\nFiles:\\n- Modify: README.md\\n\\nAcceptance:\\n- README documents yolo-runner init\\n- README explains why runner refuses to start if agent missing\\n- README includes troubleshooting steps\\n- go test ./... passes\",\"acceptance_criteria\":\"- README includes init usage and troubleshooting\",\"status\":\"open\",\"priority\":2,\"issue_type\":\"task\",\"owner\":\"g.evstratov@gmail.com\",\"created_at\":\"2026-01-19T22:14:36.163844+03:00\",\"created_by\":\"Gennady Evstratov\",\"updated_at\":\"2026-01-19T22:14:36.283427+03:00\",\"dependencies\":[{\"issue_id\":\"yolo-runner-127.4.12\",\"depends_on_id\":\"yolo-runner-127.4\",\"type\":\"parent-child\",\"created_at\":\"2026-01-19T22:14:36.164313+03:00\",\"created_by\":\"Gennady Evstratov\"}]}\n {\"id\":\"yolo-runner-127.4.2\",\"title\":\"v1.2: TUI model for runner status\",\"description\":\"Implement a Bubble Tea model that renders:\\n- current task (id + title)\\n- current phase/state string\\n- spinner that advances when new output is detected\\n- last-output age seconds\\n\\nFiles:\\n- Create: internal/ui/tui/model.go\\n- Create: internal/ui/tui/model_test.go\\n\\nAcceptance:\\n- Given status updates, view output contains task id/title and phase string\\n- Spinner advances when notified of new output\\n- Tests run without requiring a real TTY\\n- go test ./... passes\",\"acceptance_criteria\":\"- Renders task and phase\\n- Spinner advances on output events\\n- Tests are deterministic and non-TTY\\n- go test ./... passes\",\"status\":\"closed\",\"priority\":1,\"issue_type\":\"task\",\"owner\":\"g.evstratov@gmail.com\",\"created_at\":\"2026-01-19T15:55:27.275855+03:00\",\"created_by\":\"Gennady Evstratov\",\"updated_at\":\"2026-01-19T19:02:37.853373+03:00\",\"closed_at\":\"2026-01-19T19:02:37.853373+03:00\",\"close_reason\":\"Closed\",\"dependencies\":[{\"issue_id\":\"yolo-runner-127.4.2\",\"depends_on_id\":\"yolo-runner-127.4\",\"type\":\"parent-child\",\"created_at\":\"2026-01-19T15:55:27.276643+03:00\",\"created_by\":\"Gennady Evstratov\"}]}\n {\"id\":\"yolo-runner-127.4.3\",\"title\":\"v1.2: Wire runner phases into TUI\",\"description\":\"Plumb runner phase/state updates into the TUI.\\n\\nFiles:\\n- Modify: internal/runner/runner.go\\n- Create: internal/runner/events.go\\n\\nAcceptance:\\n- Runner emits structured events for: selecting task, bd update, opencode start/end, git add/status/commit, bd close/verify, bd sync\\n- TUI displays current phase based on latest event\\n- go test ./... passes\",\"acceptance_criteria\":\"- Runner emits phase events\\n- TUI updates from events\\n- go test ./... passes\",\"status\":\"closed\",\"priority\":1,\"issue_type\":\"task\",\"owner\":\"g.evstratov@gmail.com\",\"created_at\":\"2026-01-19T15:55:27.357111+03:00\",\"created_by\":\"Gennady Evstratov\",\"updated_at\":\"2026-01-19T19:24:34.458796+03:00\",\"closed_at\":\"2026-01-19T19:24:34.458796+03:00\",\"close_reason\":\"Closed\",\"dependencies\":[{\"issue_id\":\"yolo-runner-127.4.3\",\"depends_on_id\":\"yolo-runner-127.4\",\"type\":\"parent-child\",\"created_at\":\"2026-01-19T15:55:27.357695+03:00\",\"created_by\":\"Gennady Evstratov\"}]}\ndiff --git a/cmd/yolo-runner/main.go b/cmd/yolo-runner/main.go\nindex befdb9f..34ad51b 100644\n--- a/cmd/yolo-runner/main.go\n+++ b/cmd/yolo-runner/main.go\n@@ -114,6 +114,10 @@ func (o openCodeAdapter) Run(issueID string, repoRoot string, promptText string,\n }\n \n func RunOnceMain(args []string, runOnce runOnceFunc, exit exitFunc, stdout io.Writer, stderr io.Writer, beadsRunner beadsRunner, gitRunner gitRunner) int {\n+\tif len(args) > 0 && args[0] == \"init\" {\n+\t\treturn InitMain(args[1:], exit, stderr)\n+\t}\n+\n \tfs := flag.NewFlagSet(\"yolo-runner\", flag.ContinueOnError)\n \tfs.SetOutput(stderr)\n \n@@ -242,6 +246,34 @@ func main() {\n \tRunOnceMain(os.Args[1:], runner.RunOnce, os.Exit, os.Stdout, os.Stderr, nil, nil)\n }\n \n+func InitMain(args []string, exit exitFunc, stderr io.Writer) int {\n+\tfs := flag.NewFlagSet(\"yolo-runner-init\", flag.ContinueOnError)\n+\tfs.SetOutput(stderr)\n+\n+\trepoRoot := fs.String(\"repo\", \".\", \"Repository root path\")\n+\n+\tif err := fs.Parse(args); err != nil {\n+\t\tfmt.Fprintln(stderr, err)\n+\t\tif exit != nil {\n+\t\t\texit(1)\n+\t\t}\n+\t\treturn 1\n+\t}\n+\n+\tif err := opencode.InitAgent(*repoRoot); err != nil {\n+\t\tfmt.Fprintln(stderr, err)\n+\t\tif exit != nil {\n+\t\t\texit(1)\n+\t\t}\n+\t\treturn 1\n+\t}\n+\n+\tif exit != nil {\n+\t\texit(0)\n+\t}\n+\treturn 0\n+}\n+\n type promptBuilder struct{}\n \n func (promptBuilder) Build(issueID string, title string, description string, acceptance string) string {\ndiff --git a/cmd/yolo-runner/main_test.go b/cmd/yolo-runner/main_test.go\nindex 0252b1e..c4b4139 100644\n--- a/cmd/yolo-runner/main_test.go\n+++ b/cmd/yolo-runner/main_test.go\n@@ -371,6 +371,14 @@ func writeAgentFile(t *testing.T, repoRoot string, payload string) {\n \t}\n }\n \n+func writeRootYoloFile(t *testing.T, repoRoot string, payload string) {\n+\tt.Helper()\n+\tagentPath := filepath.Join(repoRoot, \"yolo.md\")\n+\tif err := os.WriteFile(agentPath, []byte(payload), 0o644); err != nil {\n+\t\tt.Fatalf(\"write yolo.md: %v\", err)\n+\t}\n+}\n+\n func TestRunOnceMainUsesTUIOnTTYByDefault(t *testing.T) {\n \tfakeProgram := newFakeTUIProgram()\n \tprevIsTerminal := isTerminal\n@@ -442,6 +450,80 @@ func TestRunOnceMainHeadlessDisablesTUI(t *testing.T) {\n \t}\n }\n \n+func TestRunOnceMainInitOverwritesAgentFile(t *testing.T) {\n+\ttempDir := t.TempDir()\n+\twriteRootYoloFile(t, tempDir, \"root-agent\")\n+\twriteAgentFile(t, tempDir, \"stale\")\n+\n+\tstdout := &bytes.Buffer{}\n+\tstderr := &bytes.Buffer{}\n+\texit := &fakeExit{}\n+\n+\tcode := RunOnceMain([]string{\"init\", \"--repo\", tempDir}, nil, exit.Exit, stdout, stderr, nil, nil)\n+\n+\tif code != 0 {\n+\t\tt.Fatalf(\"expected exit code 0, got %d\", code)\n+\t}\n+\tif exit.code != 0 {\n+\t\tt.Fatalf(\"expected exit code 0, got %d\", exit.code)\n+\t}\n+\tagentPath := filepath.Join(tempDir, \".opencode\", \"agent\", \"yolo.md\")\n+\tcontent, err := os.ReadFile(agentPath)\n+\tif err != nil {\n+\t\tt.Fatalf(\"read agent file: %v\", err)\n+\t}\n+\tif string(content) != \"root-agent\" {\n+\t\tt.Fatalf(\"expected agent file to be overwritten\")\n+\t}\n+}\n+\n+func TestRunOnceMainInitCreatesAgentDir(t *testing.T) {\n+\ttempDir := t.TempDir()\n+\twriteRootYoloFile(t, tempDir, \"root-agent\")\n+\n+\tstdout := &bytes.Buffer{}\n+\tstderr := &bytes.Buffer{}\n+\texit := &fakeExit{}\n+\n+\tcode := RunOnceMain([]string{\"init\", \"--repo\", tempDir}, nil, exit.Exit, stdout, stderr, nil, nil)\n+\n+\tif code != 0 {\n+\t\tt.Fatalf(\"expected exit code 0, got %d\", code)\n+\t}\n+\tagentPath := filepath.Join(tempDir, \".opencode\", \"agent\", \"yolo.md\")\n+\tcontent, err := os.ReadFile(agentPath)\n+\tif err != nil {\n+\t\tt.Fatalf(\"read agent file: %v\", err)\n+\t}\n+\tif string(content) != \"root-agent\" {\n+\t\tt.Fatalf(\"expected agent file to be created\")\n+\t}\n+}\n+\n+func TestRunOnceMainRunModePassesAfterInit(t *testing.T) {\n+\ttempDir := t.TempDir()\n+\twriteRootYoloFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n+\n+\tstdout := &bytes.Buffer{}\n+\tstderr := &bytes.Buffer{}\n+\texit := &fakeExit{}\n+\n+\tcode := RunOnceMain([]string{\"init\", \"--repo\", tempDir}, nil, exit.Exit, stdout, stderr, nil, nil)\n+\tif code != 0 {\n+\t\tt.Fatalf(\"expected init exit code 0, got %d\", code)\n+\t}\n+\n+\trunOnce := &fakeRunOnce{result: \"no_tasks\"}\n+\tcode = RunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\"}, runOnce.Run, exit.Exit, stdout, stderr, nil, nil)\n+\n+\tif code != 0 {\n+\t\tt.Fatalf(\"expected run mode exit code 0, got %d\", code)\n+\t}\n+\tif !runOnce.called {\n+\t\tt.Fatalf(\"expected run once to be called\")\n+\t}\n+}\n+\n func TestOpenCodeRunDefaultsCreateConfigAndEnv(t *testing.T) {\n \ttempDir := t.TempDir()\n \trepoRoot := filepath.Join(tempDir, \"repo\")\ndiff --git a/internal/opencode/agent.go b/internal/opencode/agent.go\nindex 1b21ece..6eefb4f 100644\n--- a/internal/opencode/agent.go\n+++ b/internal/opencode/agent.go\n@@ -9,7 +9,8 @@ import (\n )\n \n const (\n-\tagentRelativePath = \".opencode/agent/yolo.md\"\n+\tagentRelativePath       = \".opencode/agent/yolo.md\"\n+\tagentSourceRelativePath = \"yolo.md\"\n )\n \n var (\n@@ -32,6 +33,22 @@ func ValidateAgent(repoRoot string) error {\n \treturn nil\n }\n \n+func InitAgent(repoRoot string) error {\n+\tsourcePath := filepath.Join(repoRoot, agentSourceRelativePath)\n+\tsourceContent, err := os.ReadFile(sourcePath)\n+\tif err != nil {\n+\t\treturn fmt.Errorf(\"read yolo agent template: %w\", err)\n+\t}\n+\tdestinationPath := filepath.Join(repoRoot, agentRelativePath)\n+\tif err := os.MkdirAll(filepath.Dir(destinationPath), 0o755); err != nil {\n+\t\treturn fmt.Errorf(\"create agent dir: %w\", err)\n+\t}\n+\tif err := os.WriteFile(destinationPath, sourceContent, 0o644); err != nil {\n+\t\treturn fmt.Errorf(\"write agent file: %w\", err)\n+\t}\n+\treturn nil\n+}\n+\n func hasPermissionAllow(content []byte) bool {\n \tlines := strings.Split(string(content), \"\\n\")\n \tfor _, line := range lines {\ndiff --git a/runner-logs/beads_yolo_runner.jsonl b/runner-logs/beads_yolo_runner.jsonl\nindex dd2a92a..4664b67 100644\n--- a/runner-logs/beads_yolo_runner.jsonl\n+++ b/runner-logs/beads_yolo_runner.jsonl\n@@ -14,3 +14,4 @@\n {\"timestamp\": \"2026-01-19T19:24:34Z\", \"issue_id\": \"yolo-runner-127.4.3\", \"title\": \"v1.2: Wire runner phases into TUI\", \"status\": \"completed\", \"commit_sha\": \"0585becefcbb776410c255013e4bac8bb0056e22\"}\n {\"timestamp\": \"2026-01-19T19:48:09Z\", \"issue_id\": \"yolo-runner-127.4.7\", \"title\": \"v1.2: Detect default root (avoid hardcoded algi-8bt)\", \"status\": \"blocked\", \"commit_sha\": \"361277ed2e0f8f9ae1a7b1adf09ae2c7168c4c26\"}\n {\"timestamp\": \"2026-01-19T19:52:41Z\", \"issue_id\": \"yolo-runner-127.4.5\", \"title\": \"v1.2: Detect OpenCode log growth for heartbeat\", \"status\": \"completed\", \"commit_sha\": \"03cc0beaae40d47e575620c0cbd3a425255c9568\"}\n+{\"timestamp\":\"2026-01-19T19:28:04Z\",\"issue_id\":\"yolo-runner-127.4.10\",\"title\":\"v1.2: Refuse to run if YOLO agent missing\",\"status\":\"completed\",\"commit_sha\":\"99c95de457a573c2a086076f513573951323f0ec\\n\"}\n","title":"Show unstaged/staged git diff","metadata":{"output":"diff --git a/.beads/issues.jsonl b/.beads/issues.jsonl\nindex c40e60d..4692361 100644\n--- a/.beads/issues.jsonl\n+++ b/.beads/issues.jsonl\n@@ -13,7 +13,7 @@\n {\"id\":\"yolo-runner-127.4\",\"title\":\"v1.1: Observability (TUI + watchdog + init/guards)\",\"description\":\"Make the runner robust and observable before adding molecule traversal.\\n\\nIncludes:\\n- Bubble Tea TUI progress UI (TTY by default, with --headless)\\n- Watchdog to detect and fail-fast on OpenCode stalls, with evidence\\n- Init/guards to ensure YOLO agent is installed and permissions allow non-interactive runs\\n- Fix default --root behavior (avoid hardcoded algi-8bt)\\n\\nAll implementation must be Go.\",\"acceptance_criteria\":\"- Runner does not hang indefinitely on OpenCode stalls (watchdog)\\n- Runner has clear progress output (TUI on TTY, --headless for logs)\\n- Runner refuses to start if YOLO agent missing; init installs it\\n- Default root is inferred or runner errors clearly\\n- go test ./... passes\",\"status\":\"open\",\"priority\":1,\"issue_type\":\"epic\",\"owner\":\"g.evstratov@gmail.com\",\"created_at\":\"2026-01-19T15:55:27.038426+03:00\",\"created_by\":\"Gennady Evstratov\",\"updated_at\":\"2026-01-19T16:24:16.935052+03:00\",\"dependencies\":[{\"issue_id\":\"yolo-runner-127.4\",\"depends_on_id\":\"yolo-runner-127\",\"type\":\"parent-child\",\"created_at\":\"2026-01-19T15:55:27.039062+03:00\",\"created_by\":\"Gennady Evstratov\"}]}\n {\"id\":\"yolo-runner-127.4.1\",\"title\":\"v1.2: Add Bubble Tea dependency\",\"description\":\"Add Bubble Tea dependencies and minimal wiring.\\n\\nFiles:\\n- Modify: go.mod\\n- Modify: go.sum\\n\\nAcceptance:\\n- go test ./... passes\\n- Bubble Tea module is added and buildable\",\"acceptance_criteria\":\"- go test ./... passes\\n- Bubble Tea module is added and buildable\",\"status\":\"closed\",\"priority\":1,\"issue_type\":\"task\",\"owner\":\"g.evstratov@gmail.com\",\"created_at\":\"2026-01-19T15:55:27.195836+03:00\",\"created_by\":\"Gennady Evstratov\",\"updated_at\":\"2026-01-19T18:59:10.354843+03:00\",\"closed_at\":\"2026-01-19T18:59:10.354843+03:00\",\"close_reason\":\"Closed\",\"dependencies\":[{\"issue_id\":\"yolo-runner-127.4.1\",\"depends_on_id\":\"yolo-runner-127.4\",\"type\":\"parent-child\",\"created_at\":\"2026-01-19T15:55:27.196499+03:00\",\"created_by\":\"Gennady Evstratov\"}]}\n {\"id\":\"yolo-runner-127.4.10\",\"title\":\"v1.2: Refuse to run if YOLO agent missing\",\"description\":\"Before selecting any beads task, validate the YOLO agent is installed for this repo.\\n\\nFiles:\\n- Modify: cmd/yolo-runner/main.go\\n- Create: internal/opencode/agent.go\\n- Create: internal/opencode/agent_test.go\\n\\nRules:\\n- Go only\\n\\nAcceptance:\\n- If .opencode/agent/yolo.md does not exist, runner exits non-zero and prints a clear message\\n- If agent file exists but does not contain frontmatter key permission: allow, runner exits non-zero and prints guidance to run init\\n- Validation happens before any bd update / git add / opencode run\\n- go test ./... passes\",\"acceptance_criteria\":\"- Missing agent file fails fast with clear message\\n- Missing permission allow fails fast with guidance\\n- Validation runs before any mutations\\n- go test ./... passes\",\"status\":\"closed\",\"priority\":1,\"issue_type\":\"task\",\"owner\":\"g.evstratov@gmail.com\",\"created_at\":\"2026-01-19T22:14:35.318898+03:00\",\"created_by\":\"Gennady Evstratov\",\"updated_at\":\"2026-01-19T22:28:04.906764+03:00\",\"closed_at\":\"2026-01-19T22:28:04.906764+03:00\",\"close_reason\":\"Closed\",\"dependencies\":[{\"issue_id\":\"yolo-runner-127.4.10\",\"depends_on_id\":\"yolo-runner-127.4\",\"type\":\"parent-child\",\"created_at\":\"2026-01-19T22:14:35.319632+03:00\",\"created_by\":\"Gennady Evstratov\"}]}\n-{\"id\":\"yolo-runner-127.4.11\",\"title\":\"v1.2: Add init subcommand to install YOLO agent\",\"description\":\"Add an init command to the Go runner that installs the YOLO agent into the project OpenCode config.\\n\\nCommand:\\n- yolo-runner init\\n\\nBehavior:\\n- Create .opencode/agent/ if needed\\n- Copy yolo.md -\\u003e .opencode/agent/yolo.md\\n- Overwrite existing .opencode/agent/yolo.md to match yolo.md\\n\\nFiles:\\n- Modify: cmd/yolo-runner/main.go\\n- Modify: cmd/yolo-runner/main_test.go\\n- Modify: internal/opencode/agent.go\\n\\nRules:\\n- Go only\\n\\nAcceptance:\\n- Running yolo-runner init creates/overwrites .opencode/agent/yolo.md\\n- After init, yolo-runner run mode no longer errors on missing agent\\n- go test ./... passes\",\"acceptance_criteria\":\"- init creates/overwrites agent file\\n- run mode passes agent validation after init\\n- go test ./... passes\",\"status\":\"open\",\"priority\":1,\"issue_type\":\"task\",\"owner\":\"g.evstratov@gmail.com\",\"created_at\":\"2026-01-19T22:14:35.744001+03:00\",\"created_by\":\"Gennady Evstratov\",\"updated_at\":\"2026-01-19T22:14:35.861089+03:00\",\"dependencies\":[{\"issue_id\":\"yolo-runner-127.4.11\",\"depends_on_id\":\"yolo-runner-127.4\",\"type\":\"parent-child\",\"created_at\":\"2026-01-19T22:14:35.744669+03:00\",\"created_by\":\"Gennady Evstratov\"}]}\n+{\"id\":\"yolo-runner-127.4.11\",\"title\":\"v1.2: Add init subcommand to install YOLO agent\",\"description\":\"Add an init command to the Go runner that installs the YOLO agent into the project OpenCode config.\\n\\nCommand:\\n- yolo-runner init\\n\\nBehavior:\\n- Create .opencode/agent/ if needed\\n- Copy yolo.md -\\u003e .opencode/agent/yolo.md\\n- Overwrite existing .opencode/agent/yolo.md to match yolo.md\\n\\nFiles:\\n- Modify: cmd/yolo-runner/main.go\\n- Modify: cmd/yolo-runner/main_test.go\\n- Modify: internal/opencode/agent.go\\n\\nRules:\\n- Go only\\n\\nAcceptance:\\n- Running yolo-runner init creates/overwrites .opencode/agent/yolo.md\\n- After init, yolo-runner run mode no longer errors on missing agent\\n- go test ./... passes\",\"acceptance_criteria\":\"- init creates/overwrites agent file\\n- run mode passes agent validation after init\\n- go test ./... passes\",\"status\":\"in_progress\",\"priority\":1,\"issue_type\":\"task\",\"owner\":\"g.evstratov@gmail.com\",\"created_at\":\"2026-01-19T22:14:35.744001+03:00\",\"created_by\":\"Gennady Evstratov\",\"updated_at\":\"2026-01-19T22:30:34.60294+03:00\",\"dependencies\":[{\"issue_id\":\"yolo-runner-127.4.11\",\"depends_on_id\":\"yolo-runner-127.4\",\"type\":\"parent-child\",\"created_at\":\"2026-01-19T22:14:35.744669+03:00\",\"created_by\":\"Gennady Evstratov\"}]}\n {\"id\":\"yolo-runner-127.4.12\",\"title\":\"v1.2: Document init + agent requirements\",\"description\":\"Document how agent installation works and how to recover when the runner refuses to start.\\n\\nFiles:\\n- Modify: README.md\\n\\nAcceptance:\\n- README documents yolo-runner init\\n- README explains why runner refuses to start if agent missing\\n- README includes troubleshooting steps\\n- go test ./... passes\",\"acceptance_criteria\":\"- README includes init usage and troubleshooting\",\"status\":\"open\",\"priority\":2,\"issue_type\":\"task\",\"owner\":\"g.evstratov@gmail.com\",\"created_at\":\"2026-01-19T22:14:36.163844+03:00\",\"created_by\":\"Gennady Evstratov\",\"updated_at\":\"2026-01-19T22:14:36.283427+03:00\",\"dependencies\":[{\"issue_id\":\"yolo-runner-127.4.12\",\"depends_on_id\":\"yolo-runner-127.4\",\"type\":\"parent-child\",\"created_at\":\"2026-01-19T22:14:36.164313+03:00\",\"created_by\":\"Gennady Evstratov\"}]}\n {\"id\":\"yolo-runner-127.4.2\",\"title\":\"v1.2: TUI model for runner status\",\"description\":\"Implement a Bubble Tea model that renders:\\n- current task (id + title)\\n- current phase/state string\\n- spinner that advances when new output is detected\\n- last-output age seconds\\n\\nFiles:\\n- Create: internal/ui/tui/model.go\\n- Create: internal/ui/tui/model_test.go\\n\\nAcceptance:\\n- Given status updates, view output contains task id/title and phase string\\n- Spinner advances when notified of new output\\n- Tests run without requiring a real TTY\\n- go test ./... passes\",\"acceptance_criteria\":\"- Renders task and phase\\n- Spinner advances on output events\\n- Tests are deterministic and non-TTY\\n- go test ./... passes\",\"status\":\"closed\",\"priority\":1,\"issue_type\":\"task\",\"owner\":\"g.evstratov@gmail.com\",\"created_at\":\"2026-01-19T15:55:27.275855+03:00\",\"created_by\":\"Gennady Evstratov\",\"updated_at\":\"2026-01-19T19:02:37.853373+03:00\",\"closed_at\":\"2026-01-19T19:02:37.853373+03:00\",\"close_reason\":\"Closed\",\"dependencies\":[{\"issue_id\":\"yolo-runner-127.4.2\",\"depends_on_id\":\"yolo-runner-127.4\",\"type\":\"parent-child\",\"created_at\":\"2026-01-19T15:55:27.276643+03:00\",\"created_by\":\"Gennady Evstratov\"}]}\n {\"id\":\"yolo-runner-127.4.3\",\"title\":\"v1.2: Wire runner phases into TUI\",\"description\":\"Plumb runner phase/state updates into the TUI.\\n\\nFiles:\\n- Modify: internal/runner/runner.go\\n- Create: internal/runner/events.go\\n\\nAcceptance:\\n- Runner emits structured events for: selecting task, bd update, opencode start/end, git add/status/commit, bd close/verify, bd sync\\n- TUI displays current phase based on latest event\\n- go test ./... passes\",\"acceptance_criteria\":\"- Runner emits phase events\\n- TUI updates from events\\n- go test ./... passes\",\"status\":\"closed\",\"priority\":1,\"issue_type\":\"task\",\"owner\":\"g.evstratov@gmail.com\",\"created_at\":\"2026-01-19T15:55:27.357111+03:00\",\"created_by\":\"Gennady Evstratov\",\"updated_at\":\"2026-01-19T19:24:34.458796+03:00\",\"closed_at\":\"2026-01-19T19:24:34.458796+03:00\",\"close_reason\":\"Closed\",\"dependencies\":[{\"issue_id\":\"yolo-runner-127.4.3\",\"depends_on_id\":\"yolo-runner-127.4\",\"type\":\"parent-child\",\"created_at\":\"2026-01-19T15:55:27.357695+03:00\",\"created_by\":\"Gennady Evstratov\"}]}\ndiff --git a/cmd/yolo-runner/main.go b/cmd/yolo-runner/main.go\nindex befdb9f..34ad51b 100644\n--- a/cmd/yolo-runner/main.go\n+++ b/cmd/yolo-runner/main.go\n@@ -114,6 +114,10 @@ func (o openCodeAdapter) Run(issueID string, repoRoot string, promptText string,\n }\n \n func RunOnceMain(args []string, runOnce runOnceFunc, exit exitFunc, stdout io.Writer, stderr io.Writer, beadsRunner beadsRunner, gitRunner gitRunner) int {\n+\tif len(args) > 0 && args[0] == \"init\" {\n+\t\treturn InitMain(args[1:], exit, stderr)\n+\t}\n+\n \tfs := flag.NewFlagSet(\"yolo-runner\", flag.ContinueOnError)\n \tfs.SetOutput(stderr)\n \n@@ -242,6 +246,34 @@ func main() {\n \tRunOnceMain(os.Args[1:], runner.RunOnce, os.Exit, os.Stdout, os.Stderr, nil, nil)\n }\n \n+func InitMain(args []string, exit exitFunc, stderr io.Writer) int {\n+\tfs := flag.NewFlagSet(\"yolo-runner-init\", flag.ContinueOnError)\n+\tfs.SetOutput(stderr)\n+\n+\trepoRoot := fs.String(\"repo\", \".\", \"Repository root path\")\n+\n+\tif err := fs.Parse(args); err != nil {\n+\t\tfmt.Fprintln(stderr, err)\n+\t\tif exit != nil {\n+\t\t\texit(1)\n+\t\t}\n+\t\treturn 1\n+\t}\n+\n+\tif err := opencode.InitAgent(*repoRoot); err != nil {\n+\t\tfmt.Fprintln(stderr, err)\n+\t\tif exit != nil {\n+\t\t\texit(1)\n+\t\t}\n+\t\treturn 1\n+\t}\n+\n+\tif exit != nil {\n+\t\texit(0)\n+\t}\n+\treturn 0\n+}\n+\n type promptBuilder struct{}\n \n func (promptBuilder) Build(issueID string, title string, description string, acceptance string) string {\ndiff --git a/cmd/yolo-runner/main_test.go b/cmd/yolo-runner/main_test.go\nindex 0252b1e..c4b4139 100644\n--- a/cmd/yolo-runner/main_test.go\n+++ b/cmd/yolo-runner/main_test.go\n@@ -371,6 +371,14 @@ func writeAgentFile(t *testing.T, repoRoot string, payload string) {\n \t}\n }\n \n+func writeRootYoloFile(t *testing.T, repoRoot string, payload string) {\n+\tt.Helper()\n+\tagentPath := filepath.Join(repoRoot, \"yolo.md\")\n+\tif err := os.WriteFile(agentPath, []byte(payload), 0o644); err != nil {\n+\t\tt.Fatalf(\"write yolo.md: %v\", err)\n+\t}\n+}\n+\n func TestRunOnceMainUsesTUIOnTTYByDefault(t *testing.T) {\n \tfakeProgram := newFakeTUIProgram()\n \tprevIsTerminal := isTerminal\n@@ -442,6 +450,80 @@ func TestRunOnceMainHeadlessDisablesTUI(t *testing.T) {\n \t}\n }\n \n+func TestRunOnceMainInitOverwritesAgentFile(t *testing.T) {\n+\ttempDir := t.TempDir()\n+\twriteRootYoloFile(t, tempDir, \"root-agent\")\n+\twriteAgentFile(t, tempDir, \"stale\")\n+\n+\tstdout := &bytes.Buffer{}\n+\tstderr := &bytes.Buffer{}\n+\texit := &fakeExit{}\n+\n+\tcode := RunOnceMain([]string{\"init\", \"--repo\", tempDir}, nil, exit.Exit, stdout, stderr, nil, nil)\n+\n+\tif code != 0 {\n+\t\tt.Fatalf(\"expected exit code 0, got %d\", code)\n+\t}\n+\tif exit.code != 0 {\n+\t\tt.Fatalf(\"expected exit code 0, got %d\", exit.code)\n+\t}\n+\tagentPath := filepath.Join(tempDir, \".opencode\", \"agent\", \"yolo.md\")\n+\tcontent, err := os.ReadFile(agentPath)\n+\tif err != nil {\n+\t\tt.Fatalf(\"read agent file: %v\", err)\n+\t}\n+\tif string(content) != \"root-agent\" {\n+\t\tt.Fatalf(\"expected agent file to be overwritten\")\n+\t}\n+}\n+\n+func TestRunOnceMainInitCreatesAgentDir(t *testing.T) {\n+\ttempDir := t.TempDir()\n+\twriteRootYoloFile(t, tempDir, \"root-agent\")\n+\n+\tstdout := &bytes.Buffer{}\n+\tstderr := &bytes.Buffer{}\n+\texit := &fakeExit{}\n+\n+\tcode := RunOnceMain([]string{\"init\", \"--repo\", tempDir}, nil, exit.Exit, stdout, stderr, nil, nil)\n+\n+\tif code != 0 {\n+\t\tt.Fatalf(\"expected exit code 0, got %d\", code)\n+\t}\n+\tagentPath := filepath.Join(tempDir, \".opencode\", \"agent\", \"yolo.md\")\n+\tcontent, err := os.ReadFile(agentPath)\n+\tif err != nil {\n+\t\tt.Fatalf(\"read agent file: %v\", err)\n+\t}\n+\tif string(content) != \"root-agent\" {\n+\t\tt.Fatalf(\"expected agent file to be created\")\n+\t}\n+}\n+\n+func TestRunOnceMainRunModePassesAfterInit(t *testing.T) {\n+\ttempDir := t.TempDir()\n+\twriteRootYoloFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n+\n+\tstdout := &bytes.Buffer{}\n+\tstderr := &bytes.Buffer{}\n+\texit := &fakeExit{}\n+\n+\tcode := RunOnceMain([]string{\"init\", \"--repo\", tempDir}, nil, exit.Exit, stdout, stderr, nil, nil)\n+\tif code != 0 {\n+\t\tt.Fatalf(\"expected init exit code 0, got %d\", code)\n+\t}\n+\n+\trunOnce := &fakeRunOnce{result: \"no_tasks\"}\n+\tcode = RunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\"}, runOnce.Run, exit.Exit, stdout, stderr, nil, nil)\n+\n+\tif code != 0 {\n+\t\tt.Fatalf(\"expected run mode exit code 0, got %d\", code)\n+\t}\n+\tif !runOnce.called {\n+\t\tt.Fatalf(\"expected run once to be called\")\n+\t}\n+}\n+\n func TestOpenCodeRunDefaultsCreateConfigAndEnv(t *testing.T) {\n \ttempDir := t.TempDir()\n \trepoRoot := filepath.Join(tempDir, \"repo\")\ndiff --git a/internal/opencode/agent.go b/internal/opencode/agent.go\nindex 1b21ece..6eefb4f 100644\n--- a/internal/opencode/agent.go\n+++ b/internal/opencode/agent.go\n@@ -9,7 +9,8 @@ import (\n )\n \n const (\n-\tagentRelativePath = \".opencode/agent/yolo.md\"\n+\tagentRelativePath       = \".opencode/agent/yolo.md\"\n+\tagentSourceRelativePath = \"yolo.md\"\n )\n \n var (\n@@ -32,6 +33,22 @@ func ValidateAgent(repoRoot string) error {\n \treturn nil\n }\n \n+func InitAgent(repoRoot string) error {\n+\tsourcePath := filepath.Join(repoRoot, agentSourceRelativePath)\n+\tsourceContent, err := os.ReadFile(sourcePath)\n+\tif err != nil {\n+\t\treturn fmt.Errorf(\"read yolo agent template: %w\", err)\n+\t}\n+\tdestinationPath := filepath.Join(repoRoot, agentRelativePath)\n+\tif err := os.MkdirAll(filepath.Dir(destinationPath), 0o755); err != nil {\n+\t\treturn fmt.Errorf(\"create agent dir: %w\", err)\n+\t}\n+\tif err := os.WriteFile(destinationPath, sourceContent, 0o644); err != nil {\n+\t\treturn fmt.Errorf(\"write agent file: %w\", err)\n+\t}\n+\treturn nil\n+}\n+\n func hasPermissionAllow(content []byte) bool {\n \tlines := strings.Split(string(content), \"\\n\")\n \tfor _, line := range lines {\ndiff --git a/runner-logs/beads_yolo_runner.jsonl b/runner-logs/beads_yolo_runner.jsonl\nindex dd2a92a..4664b67 100644\n--- a/runner-logs/beads_yolo_runner.jsonl\n+++ b/runner-logs/beads_yolo_runner.jsonl\n@@ -14,3 +14,4 @@\n {\"timestamp\": \"2026-01-19T19:24:34Z\", \"issue_id\": \"yolo-runner-127.4.3\", \"title\": \"v1.2: Wire runner phases into TUI\", \"status\": \"completed\", \"commit_sha\": \"0585becefcbb776410c255013e4bac8bb0056e22\"}\n {\"timestamp\": \"2026-01-19T19:48:09Z\", \"issue_id\": \"yolo-runner-127.4.7\", \"title\": \"v1.2: Detect default root (avoid hardcoded algi-8bt)\", \"status\": \"blocked\", \"commit_sha\": \"361277ed2e0f8f9ae1a7b1adf09ae2c7168c4c26\"}\n {\"timestamp\": \"2026-01-19T19:52:41Z\", \"issue_id\": \"yolo-runner-127.4.5\", \"title\": \"v1.2: Detect OpenCode log growth for heartbeat\", \"status\": \"completed\", \"commit_sha\": \"03cc0beaae40d47e575620c0cbd3a425255c9568\"}\n+{\"timestamp\":\"2026-01-19T19:28:04Z\",\"issue_id\":\"yolo-runner-127.4.10\",\"title\":\"v1.2: Refuse to run if YOLO agent missing\",\"status\":\"completed\",\"commit_sha\":\"99c95de457a573c2a086076f513573951323f0ec\\n\"}\n","exit":0,"description":"Show unstaged/staged git diff","truncated":false},"time":{"start":1768851202568,"end":1768851202580}},"metadata":{"openai":{"itemId":"fc_0e4b3c92faa5d0db01696e870239f481918f2bf4fafe357547"}}}}
{"type":"tool_use","timestamp":1768851203056,"sessionID":"ses_428432b5cffeiuHqPgEDLEHUBi","part":{"id":"prt_bd7bf620e001dQ6uIR49V545og","sessionID":"ses_428432b5cffeiuHqPgEDLEHUBi","messageID":"msg_bd7bf524d0014MdGCpWLgNuXEe","type":"tool","callID":"call_Q0VN8iCSeNL7X0ylEXor36si","tool":"bash","state":{"status":"completed","input":{"command":"git log -5 --oneline","description":"Show recent git commits"},"output":"178b05d bd sync: 2026-01-19 22:28:07\n99c95de feat: v1.2: refuse to run if yolo agent missing\n02d9e77 feat: yolo-runner-127.4.10\nefb9689 bd sync: 2026-01-19 22:14:50\ne232b17 bd sync: 2026-01-19 22:14:36\n","title":"Show recent git commits","metadata":{"output":"178b05d bd sync: 2026-01-19 22:28:07\n99c95de feat: v1.2: refuse to run if yolo agent missing\n02d9e77 feat: yolo-runner-127.4.10\nefb9689 bd sync: 2026-01-19 22:14:50\ne232b17 bd sync: 2026-01-19 22:14:36\n","exit":0,"description":"Show recent git commits","truncated":false},"time":{"start":1768851203046,"end":1768851203056}},"metadata":{"openai":{"itemId":"fc_0e4b3c92faa5d0db01696e87028d208191a0ef323a10db2d36"}}}}
{"type":"step_finish","timestamp":1768851203104,"sessionID":"ses_428432b5cffeiuHqPgEDLEHUBi","part":{"id":"prt_bd7bf6410001LegSC1tmEbIgfD","sessionID":"ses_428432b5cffeiuHqPgEDLEHUBi","messageID":"msg_bd7bf524d0014MdGCpWLgNuXEe","type":"step-finish","reason":"tool-calls","snapshot":"a5326001771a0d970ced0064eeec416fd9397312","cost":0,"tokens":{"input":120,"output":161,"reasoning":64,"cache":{"read":8448,"write":0}}}}
{"type":"step_start","timestamp":1768851203556,"sessionID":"ses_428432b5cffeiuHqPgEDLEHUBi","part":{"id":"prt_bd7bf65e30013Teo0TT95ThgNn","sessionID":"ses_428432b5cffeiuHqPgEDLEHUBi","messageID":"msg_bd7bf64330014P1NnfL5KLX0ES","type":"step-start","snapshot":"9fdf1a1e8bff739d199698245b1d81a92b3dd99f"}}
{"type":"tool_use","timestamp":1768851208648,"sessionID":"ses_428432b5cffeiuHqPgEDLEHUBi","part":{"id":"prt_bd7bf7504001556Rc5w5R5D0jj","sessionID":"ses_428432b5cffeiuHqPgEDLEHUBi","messageID":"msg_bd7bf64330014P1NnfL5KLX0ES","type":"tool","callID":"call_3L5rhid2q2JWHh9zWg32b8Yu","tool":"bash","state":{"status":"completed","input":{"command":"git add cmd/yolo-runner/main.go cmd/yolo-runner/main_test.go internal/opencode/agent.go && git commit -m \"feat: add init subcommand for yolo agent\" && git status -sb","description":"Stage changes, commit, and show status"},"output":"[rewind/v1-go-cleanup 444c734] feat: add init subcommand for yolo agent\n 4 files changed, 133 insertions(+), 2 deletions(-)\n## rewind/v1-go-cleanup...origin/rewind/v1-go-cleanup [ahead 1]\n M runner-logs/beads_yolo_runner.jsonl\n?? runner-logs/opencode/yolo-runner-127.4.11.jsonl\n?? runner-logs/opencode/yolo-runner-127.4.11.stderr.log\n","title":"Stage changes, commit, and show status","metadata":{"output":"[rewind/v1-go-cleanup 444c734] feat: add init subcommand for yolo agent\n 4 files changed, 133 insertions(+), 2 deletions(-)\n## rewind/v1-go-cleanup...origin/rewind/v1-go-cleanup [ahead 1]\n M runner-logs/beads_yolo_runner.jsonl\n?? runner-logs/opencode/yolo-runner-127.4.11.jsonl\n?? runner-logs/opencode/yolo-runner-127.4.11.stderr.log\n","exit":0,"description":"Stage changes, commit, and show status","truncated":false},"time":{"start":1768851208342,"end":1768851208648}},"metadata":{"openai":{"itemId":"fc_07e39f29644b0bee01696e870769ac8191b880d373d7df3018"}}}}
{"type":"step_finish","timestamp":1768851208665,"sessionID":"ses_428432b5cffeiuHqPgEDLEHUBi","part":{"id":"prt_bd7bf79c8001KHZMzgs0zjDAd4","sessionID":"ses_428432b5cffeiuHqPgEDLEHUBi","messageID":"msg_bd7bf64330014P1NnfL5KLX0ES","type":"step-finish","reason":"tool-calls","snapshot":"404761121aa25690fc867b0b73495840a3feecb8","cost":0,"tokens":{"input":5789,"output":203,"reasoning":128,"cache":{"read":25216,"write":0}}}}
{"type":"step_start","timestamp":1768851209152,"sessionID":"ses_428432b5cffeiuHqPgEDLEHUBi","part":{"id":"prt_bd7bf7bbf0010PVfgKzk7AaXDM","sessionID":"ses_428432b5cffeiuHqPgEDLEHUBi","messageID":"msg_bd7bf79ee001Y2Q2xX63D4EGoX","type":"step-start","snapshot":"67942cb8bf4feffb3d23f2821c8d0c0174f0662d"}}
{"type":"text","timestamp":1768851212734,"sessionID":"ses_428432b5cffeiuHqPgEDLEHUBi","part":{"id":"prt_bd7bf7d900012v1RdPjVxzh5aG","sessionID":"ses_428432b5cffeiuHqPgEDLEHUBi","messageID":"msg_bd7bf79ee001Y2Q2xX63D4EGoX","type":"text","text":"Added `yolo-runner init` that installs the repos `yolo.md` into `.opencode/agent/yolo.md`, creating the agent directory and overwriting existing content, then verified run mode succeeds after init via new tests.\n\nContext and changes\n- New init entrypoint wires through `RunOnceMain` and delegates to `opencode.InitAgent` in `cmd/yolo-runner/main.go`.\n- Agent installer added in `internal/opencode/agent.go` that copies the repo `yolo.md` into `.opencode/agent/yolo.md`, creating directories as needed.\n- Tests added in `cmd/yolo-runner/main_test.go` covering overwrite, create, and run-mode validation after init.\n\nTests\n- `go test ./...`\n\nNext steps\n1. If you want, I can clean up the unrelated `runner-logs` changes.","time":{"start":1768851212733,"end":1768851212733},"metadata":{"openai":{"itemId":"msg_014a5225cb18696b01696e870995d481918be66d8193cc796c"}}}}
{"type":"step_finish","timestamp":1768851212993,"sessionID":"ses_428432b5cffeiuHqPgEDLEHUBi","part":{"id":"prt_bd7bf8ab3001O1TWIT6N0UVeIQ","sessionID":"ses_428432b5cffeiuHqPgEDLEHUBi","messageID":"msg_bd7bf79ee001Y2Q2xX63D4EGoX","type":"step-finish","reason":"stop","snapshot":"8cdeb44165841260de4312132c3c257eb56b89fd","cost":0,"tokens":{"input":863,"output":182,"reasoning":0,"cache":{"read":30336,"write":0}}}}
