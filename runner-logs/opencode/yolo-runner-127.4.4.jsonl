{"type":"step_start","timestamp":1768839881920,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd712a4bf0012zvR0KxrAaRtNv","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd712a027001WBh7WIZ5dCY8XD","type":"step-start","snapshot":"00560f6e50bab0d0f57dadecccda30f1602cd321"}}
{"type":"tool_use","timestamp":1768839884025,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd712ac33001KKN2oKUk0egL1Z","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd712a027001WBh7WIZ5dCY8XD","type":"tool","callID":"call_E6nIbhnpdUThBW4egMP48hk0","tool":"glob","state":{"status":"completed","input":{"pattern":"cmd/yolo-runner/*"},"output":"/Users/egv/dev/yolo-runner/cmd/yolo-runner/exec.go\n/Users/egv/dev/yolo-runner/cmd/yolo-runner/exec_test.go\n/Users/egv/dev/yolo-runner/cmd/yolo-runner/main.go\n/Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go","title":"","metadata":{"count":4,"truncated":false},"time":{"start":1768839884017,"end":1768839884024}},"metadata":{"openai":{"itemId":"fc_0d8b586f4259b63c01696e5acbd7dc8191b4068d9bc0991f67"}}}}
{"type":"tool_use","timestamp":1768839884538,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd712acf2001hSYMlhh2ZMBdDH","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd712a027001WBh7WIZ5dCY8XD","type":"tool","callID":"call_APBTW7RKeJQ3G96FNYkBIzVI","tool":"read","state":{"status":"completed","input":{"filePath":"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main.go"},"output":"<file>\n00001| package main\n00002| \n00003| import (\n00004| \t\"flag\"\n00005| \t\"fmt\"\n00006| \t\"io\"\n00007| \t\"os\"\n00008| \t\"path/filepath\"\n00009| \n00010| \t\"yolo-runner/internal/beads\"\n00011| \t\"yolo-runner/internal/logging\"\n00012| \t\"yolo-runner/internal/opencode\"\n00013| \t\"yolo-runner/internal/prompt\"\n00014| \t\"yolo-runner/internal/runner\"\n00015| \tgitadapter \"yolo-runner/internal/vcs/git\"\n00016| )\n00017| \n00018| type runOnceFunc func(opts runner.RunOnceOptions, deps runner.RunOnceDeps) (string, error)\n00019| \n00020| type exitFunc func(code int)\n00021| \n00022| type beadsRunner interface {\n00023| \tRun(args ...string) (string, error)\n00024| }\n00025| \n00026| type gitRunner interface {\n00027| \tRun(name string, args ...string) (string, error)\n00028| }\n00029| \n00030| type openCodeRunner interface {\n00031| \tStart(args []string, env map[string]string, stdoutPath string) (opencode.Process, error)\n00032| }\n00033| \n00034| type adapterRunner struct{}\n00035| \n00036| func (adapterRunner) Run(args ...string) (string, error) {\n00037| \treturn runCommand(args...)\n00038| }\n00039| \n00040| type adapterGitRunner struct{}\n00041| \n00042| func (adapterGitRunner) Run(name string, args ...string) (string, error) {\n00043| \treturn runCommand(append([]string{name}, args...)...)\n00044| }\n00045| \n00046| type openCodeAdapter struct {\n00047| \trunner openCodeRunner\n00048| }\n00049| \n00050| func (o openCodeAdapter) Run(issueID string, repoRoot string, promptText string, model string, configRoot string, configDir string, logPath string) error {\n00051| \treturn opencode.Run(issueID, repoRoot, promptText, model, configRoot, configDir, logPath, o.runner)\n00052| }\n00053| \n00054| func RunOnceMain(args []string, runOnce runOnceFunc, exit exitFunc, stdout io.Writer, stderr io.Writer, beadsRunner beadsRunner, gitRunner gitRunner) int {\n00055| \tfs := flag.NewFlagSet(\"yolo-runner\", flag.ContinueOnError)\n00056| \tfs.SetOutput(stderr)\n00057| \n00058| \trepoRoot := fs.String(\"repo\", \".\", \"Repository root path\")\n00059| \trootID := fs.String(\"root\", \"algi-8bt\", \"Root bead/epic ID\")\n00060| \tmodel := fs.String(\"model\", \"\", \"OpenCode model\")\n00061| \tdryRun := fs.Bool(\"dry-run\", false, \"Print task and prompt without executing\")\n00062| \tconfigRoot := fs.String(\"config-root\", \"\", \"OpenCode config root\")\n00063| \tconfigDir := fs.String(\"config-dir\", \"\", \"OpenCode config dir\")\n00064| \n00065| \tif err := fs.Parse(args); err != nil {\n00066| \t\tfmt.Fprintln(stderr, err)\n00067| \t\tif exit != nil {\n00068| \t\t\texit(1)\n00069| \t\t}\n00070| \t\treturn 1\n00071| \t}\n00072| \n00073| \tif runOnce == nil {\n00074| \t\trunOnce = runner.RunOnce\n00075| \t}\n00076| \n00077| \tif beadsRunner == nil {\n00078| \t\tbeadsRunner = adapterRunner{}\n00079| \t}\n00080| \tif gitRunner == nil {\n00081| \t\tgitRunner = adapterGitRunner{}\n00082| \t}\n00083| \n00084| \tbeadsAdapter := beads.New(beadsRunner)\n00085| \tgitAdapter := gitadapter.New(gitRunner)\n00086| \topenCodeAdapter := openCodeAdapter{runner: defaultOpenCodeRunner{}}\n00087| \n00088| \tdeps := runner.RunOnceDeps{\n00089| \t\tBeads:    beadsAdapter,\n00090| \t\tPrompt:   promptBuilder{},\n00091| \t\tOpenCode: openCodeAdapter,\n00092| \t\tGit:      gitAdapter,\n00093| \t\tLogger:   runnerLogger{},\n00094| \t}\n00095| \n00096| \tresolvedConfigRoot := *configRoot\n00097| \tresolvedConfigDir := *configDir\n00098| \tif resolvedConfigRoot == \"\" {\n00099| \t\thomeDir := os.Getenv(\"HOME\")\n00100| \t\tif homeDir != \"\" {\n00101| \t\t\tresolvedConfigRoot = filepath.Join(homeDir, \".config\", \"opencode-runner\")\n00102| \t\t}\n00103| \t}\n00104| \tif resolvedConfigDir == \"\" && resolvedConfigRoot != \"\" {\n00105| \t\tresolvedConfigDir = filepath.Join(resolvedConfigRoot, \"opencode\")\n00106| \t}\n00107| \n00108| \toptions := runner.RunOnceOptions{\n00109| \t\tRepoRoot:   *repoRoot,\n00110| \t\tRootID:     *rootID,\n00111| \t\tModel:      *model,\n00112| \t\tConfigRoot: resolvedConfigRoot,\n00113| \t\tConfigDir:  resolvedConfigDir,\n00114| \t\tDryRun:     *dryRun,\n00115| \t\tOut:        stdout,\n00116| \t}\n00117| \n00118| \tif stdout == nil {\n00119| \t\toptions.Out = io.Discard\n00120| \t}\n00121| \tif stderr == nil {\n00122| \t\tstderr = io.Discard\n00123| \t}\n00124| \n00125| \t_, err := runOnce(options, deps)\n00126| \tif err != nil {\n00127| \t\tfmt.Fprintln(stderr, err)\n00128| \t\tif exit != nil {\n00129| \t\t\texit(1)\n00130| \t\t}\n00131| \t\treturn 1\n00132| \t}\n00133| \n00134| \tif exit != nil {\n00135| \t\texit(0)\n00136| \t}\n00137| \treturn 0\n00138| }\n00139| \n00140| func main() {\n00141| \tRunOnceMain(os.Args[1:], runner.RunOnce, os.Exit, os.Stdout, os.Stderr, nil, nil)\n00142| }\n00143| \n00144| type promptBuilder struct{}\n00145| \n00146| func (promptBuilder) Build(issueID string, title string, description string, acceptance string) string {\n00147| \treturn prompt.Build(issueID, title, description, acceptance)\n00148| }\n00149| \n00150| type runnerLogger struct{}\n00151| \n00152| func (runnerLogger) AppendRunnerSummary(repoRoot string, issueID string, title string, status string, commitSHA string) error {\n00153| \treturn logging.AppendRunnerSummary(repoRoot, issueID, title, status, commitSHA)\n00154| }\n00155| \n00156| type defaultOpenCodeRunner struct{}\n00157| \n00158| func (defaultOpenCodeRunner) Start(args []string, env map[string]string, stdoutPath string) (opencode.Process, error) {\n00159| \treturn startCommandWithEnv(args, env, stdoutPath)\n00160| }\n00161| \n\n(End of file - total 161 lines)\n</file>","title":"cmd/yolo-runner/main.go","metadata":{"preview":"package main\n\nimport (\n\t\"flag\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n\n\t\"yolo-runner/internal/beads\"\n\t\"yolo-runner/internal/logging\"\n\t\"yolo-runner/internal/opencode\"\n\t\"yolo-runner/internal/prompt\"\n\t\"yolo-runner/internal/runner\"\n\tgitadapter \"yolo-runner/internal/vcs/git\"\n)\n\ntype runOnceFunc func(opts runner.RunOnceOptions, deps runner.RunOnceDeps) (string, error)\n\ntype exitFunc func(code int)","truncated":false},"time":{"start":1768839884533,"end":1768839884538}},"metadata":{"openai":{"itemId":"fc_0d8b586f4259b63c01696e5acc083c81919137a82da2110119"}}}}
{"type":"step_finish","timestamp":1768839884680,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd712af7b001kZeI2eNwbc2GMS","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd712a027001WBh7WIZ5dCY8XD","type":"step-finish","reason":"tool-calls","snapshot":"b684ea0f50752f57b352fa821fd3abe17233ceab","cost":0,"tokens":{"input":4744,"output":70,"reasoning":0,"cache":{"read":0,"write":0}}}}
{"type":"step_start","timestamp":1768839885080,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd712b118001GGJ5OgCXBYdU37","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd712af99001377imXQrq0gvt1","type":"step-start","snapshot":"be566922d1d66d3edaff21eea75f9807aacf3f45"}}
{"type":"tool_use","timestamp":1768839885965,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd712b26d0012gMorNtELoG3sZ","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd712af99001377imXQrq0gvt1","type":"tool","callID":"call_mAz2ENeAuDtz4WiAARh1aatC","tool":"read","state":{"status":"completed","input":{"filePath":"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go"},"output":"<file>\n00001| package main\n00002| \n00003| import (\n00004| \t\"bytes\"\n00005| \t\"errors\"\n00006| \t\"os\"\n00007| \t\"path/filepath\"\n00008| \t\"strings\"\n00009| \t\"testing\"\n00010| \n00011| \t\"yolo-runner/internal/opencode\"\n00012| \t\"yolo-runner/internal/runner\"\n00013| )\n00014| \n00015| type fakeRunner struct {\n00016| \tcalls []string\n00017| }\n00018| \n00019| func (f *fakeRunner) Run(args ...string) (string, error) {\n00020| \tf.calls = append(f.calls, strings.Join(args, \" \"))\n00021| \treturn \"\", nil\n00022| }\n00023| \n00024| type fakeOpenCodeRunLogger struct {\n00025| \tcalled     bool\n00026| \tissueID    string\n00027| \trepoRoot   string\n00028| \tprompt     string\n00029| \tmodel      string\n00030| \tconfigRoot string\n00031| \tconfigDir  string\n00032| \tlogPath    string\n00033| }\n00034| \n00035| func (f *fakeOpenCodeRunLogger) Run(issueID string, repoRoot string, prompt string, model string, configRoot string, configDir string, logPath string) error {\n00036| \tf.called = true\n00037| \tf.issueID = issueID\n00038| \tf.repoRoot = repoRoot\n00039| \tf.prompt = prompt\n00040| \tf.model = model\n00041| \tf.configRoot = configRoot\n00042| \tf.configDir = configDir\n00043| \tf.logPath = logPath\n00044| \treturn nil\n00045| }\n00046| \n00047| type fakeOpenCodeRunner struct {\n00048| \tenv map[string]string\n00049| }\n00050| \n00051| type fakeOpenCodeProcess struct{}\n00052| \n00053| func (fakeOpenCodeProcess) Wait() error { return nil }\n00054| \n00055| func (fakeOpenCodeProcess) Kill() error { return nil }\n00056| \n00057| func (f *fakeOpenCodeRunner) Start(args []string, env map[string]string, stdoutPath string) (opencode.Process, error) {\n00058| \tf.env = env\n00059| \treturn fakeOpenCodeProcess{}, nil\n00060| }\n00061| \n00062| type fakeGitRunner struct {\n00063| \tcalls  []string\n00064| \toutput string\n00065| \terr    error\n00066| }\n00067| \n00068| func (f *fakeGitRunner) Run(name string, args ...string) (string, error) {\n00069| \tf.calls = append(f.calls, name+\" \"+strings.Join(args, \" \"))\n00070| \treturn f.output, f.err\n00071| }\n00072| \n00073| type fakeExit struct {\n00074| \tcode int\n00075| }\n00076| \n00077| func (f *fakeExit) Exit(code int) {\n00078| \tf.code = code\n00079| }\n00080| \n00081| type fakeRunOnce struct {\n00082| \tcalled bool\n00083| \topts   runner.RunOnceOptions\n00084| \tdeps   runner.RunOnceDeps\n00085| \tresult string\n00086| \terr    error\n00087| }\n00088| \n00089| func (f *fakeRunOnce) Run(opts runner.RunOnceOptions, deps runner.RunOnceDeps) (string, error) {\n00090| \n00091| \tf.called = true\n00092| \tf.opts = opts\n00093| \tf.deps = deps\n00094| \treturn f.result, f.err\n00095| }\n00096| \n00097| func TestRunOnceMainReturnsErrorCodeOnFailure(t *testing.T) {\n00098| \trunner := &fakeRunOnce{err: errors.New(\"boom\")}\n00099| \texit := &fakeExit{}\n00100| \tout := &bytes.Buffer{}\n00101| \n00102| \tcode := RunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\"}, runner.Run, exit.Exit, out, out, nil, nil)\n00103| \n00104| \tif code != 1 {\n00105| \t\tt.Fatalf(\"expected exit code 1, got %d\", code)\n00106| \t}\n00107| \tif exit.code != 1 {\n00108| \t\tt.Fatalf(\"expected exit to be called with 1, got %d\", exit.code)\n00109| \t}\n00110| \tif !strings.Contains(out.String(), \"boom\") {\n00111| \t\tt.Fatalf(\"expected error output, got %q\", out.String())\n00112| \t}\n00113| }\n00114| \n00115| func TestRunOnceMainWiresDependencies(t *testing.T) {\n00116| \trunner := &fakeRunOnce{result: \"no_tasks\"}\n00117| \texit := &fakeExit{}\n00118| \tout := &bytes.Buffer{}\n00119| \tbeadsRunner := &fakeRunner{}\n00120| \tgitRunner := &fakeGitRunner{}\n00121| \n00122| \tRunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\", \"--model\", \"model\", \"--dry-run\"}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n00123| \n00124| \tif !runner.called {\n00125| \t\tt.Fatalf(\"expected run once to be called\")\n00126| \t}\n00127| \tif runner.opts.RepoRoot != \"/repo\" || runner.opts.RootID != \"root\" || runner.opts.Model != \"model\" || !runner.opts.DryRun {\n00128| \t\tt.Fatalf(\"unexpected options: %#v\", runner.opts)\n00129| \t}\n00130| \tif runner.opts.Out == nil {\n00131| \t\tt.Fatalf(\"expected output writer\")\n00132| \t}\n00133| \tif runner.deps.Beads == nil || runner.deps.Git == nil || runner.deps.Prompt == nil || runner.deps.OpenCode == nil || runner.deps.Logger == nil {\n00134| \t\tt.Fatalf(\"expected deps to be wired\")\n00135| \t}\n00136| \tif exit.code != 0 {\n00137| \t\tt.Fatalf(\"expected exit code 0, got %d\", exit.code)\n00138| \t}\n00139| }\n00140| \n00141| func TestRunOnceMainDefaultsConfigPaths(t *testing.T) {\n00142| \trunner := &fakeRunOnce{result: \"no_tasks\"}\n00143| \texit := &fakeExit{}\n00144| \tout := &bytes.Buffer{}\n00145| \tbeadsRunner := &fakeRunner{}\n00146| \tgitRunner := &fakeGitRunner{}\n00147| \n00148| \tt.Setenv(\"HOME\", \"/home/user\")\n00149| \n00150| \tRunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\"}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n00151| \n00152| \tif !runner.called {\n00153| \t\tt.Fatalf(\"expected run once to be called\")\n00154| \t}\n00155| \tif runner.opts.ConfigRoot == \"\" {\n00156| \t\tt.Fatalf(\"expected config root to be set\")\n00157| \t}\n00158| \tif runner.opts.ConfigDir == \"\" {\n00159| \t\tt.Fatalf(\"expected config dir to be set\")\n00160| \t}\n00161| \texpectedConfigRoot := filepath.Join(\"/home/user\", \".config\", \"opencode-runner\")\n00162| \tif runner.opts.ConfigRoot != expectedConfigRoot {\n00163| \t\tt.Fatalf(\"expected config root %q, got %q\", expectedConfigRoot, runner.opts.ConfigRoot)\n00164| \t}\n00165| \texpectedConfigDir := filepath.Join(expectedConfigRoot, \"opencode\")\n00166| \tif runner.opts.ConfigDir != expectedConfigDir {\n00167| \t\tt.Fatalf(\"expected config dir %q, got %q\", expectedConfigDir, runner.opts.ConfigDir)\n00168| \t}\n00169| \tif exit.code != 0 {\n00170| \t\tt.Fatalf(\"expected exit code 0, got %d\", exit.code)\n00171| \t}\n00172| }\n00173| \n00174| func TestOpenCodeRunDefaultsCreateConfigAndEnv(t *testing.T) {\n00175| \ttempDir := t.TempDir()\n00176| \trepoRoot := filepath.Join(tempDir, \"repo\")\n00177| \tif err := os.MkdirAll(repoRoot, 0o755); err != nil {\n00178| \t\tt.Fatalf(\"mkdir repo: %v\", err)\n00179| \t}\n00180| \tt.Setenv(\"HOME\", tempDir)\n00181| \n00182| \topenCodeRunner := &fakeOpenCodeRunner{}\n00183| \topenCodeAdapter := openCodeAdapter{runner: openCodeRunner}\n00184| \n00185| \tconfigRoot := filepath.Join(tempDir, \".config\", \"opencode-runner\")\n00186| \tconfigDir := filepath.Join(configRoot, \"opencode\")\n00187| \tlogPath := filepath.Join(tempDir, \"runner-logs\", \"opencode\", \"issue-1.jsonl\")\n00188| \n00189| \tif err := openCodeAdapter.Run(\"issue-1\", repoRoot, \"prompt\", \"\", configRoot, configDir, logPath); err != nil {\n00190| \t\tt.Fatalf(\"open code run error: %v\", err)\n00191| \t}\n00192| \n00193| \tconfigFile := filepath.Join(configDir, \"opencode.json\")\n00194| \tif _, err := os.Stat(configFile); err != nil {\n00195| \t\tt.Fatalf(\"expected opencode.json to exist: %v\", err)\n00196| \t}\n00197| \texpectedConfigFile := filepath.Join(configDir, \"opencode.json\")\n00198| \tif openCodeRunner.env[\"XDG_CONFIG_HOME\"] != configRoot {\n00199| \t\tt.Fatalf(\"expected XDG_CONFIG_HOME set\")\n00200| \t}\n00201| \tif openCodeRunner.env[\"OPENCODE_CONFIG_DIR\"] != configDir {\n00202| \t\tt.Fatalf(\"expected OPENCODE_CONFIG_DIR set\")\n00203| \t}\n00204| \tif openCodeRunner.env[\"OPENCODE_CONFIG\"] != expectedConfigFile {\n00205| \t\tt.Fatalf(\"expected OPENCODE_CONFIG set\")\n00206| \t}\n00207| \tif openCodeRunner.env[\"OPENCODE_CONFIG_CONTENT\"] != \"{}\" {\n00208| \t\tt.Fatalf(\"expected OPENCODE_CONFIG_CONTENT set\")\n00209| \t}\n00210| }\n00211| \n\n(End of file - total 211 lines)\n</file>","title":"cmd/yolo-runner/main_test.go","metadata":{"preview":"package main\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"yolo-runner/internal/opencode\"\n\t\"yolo-runner/internal/runner\"\n)\n\ntype fakeRunner struct {\n\tcalls []string\n}\n\nfunc (f *fakeRunner) Run(args ...string) (string, error) {\n\tf.calls = append(f.calls, strings.Join(args, \" \"))","truncated":false},"time":{"start":1768839885964,"end":1768839885965}},"metadata":{"openai":{"itemId":"fc_0652d2916dd18dff01696e5acd729c8191acd7d70aab695636"}}}}
{"type":"step_finish","timestamp":1768839885985,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd712b494001F6SF1JnNkDygu3","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd712af99001377imXQrq0gvt1","type":"step-finish","reason":"tool-calls","snapshot":"3881d5bdad1561dc4ad5449ba5e891e45438cfb7","cost":0,"tokens":{"input":2001,"output":36,"reasoning":0,"cache":{"read":9344,"write":0}}}}
{"type":"step_start","timestamp":1768839886319,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd712b5ee001XFkhMw53w2KJzp","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd712b4ae00143aM24HlxXEi7P","type":"step-start","snapshot":"e2423e5c5dd20d2c94afd83557be94733863d04b"}}
{"type":"tool_use","timestamp":1768839889435,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd712bfdd001lE3b0uSi0FmxzC","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd712b4ae00143aM24HlxXEi7P","type":"tool","callID":"call_M2DTOsVQGzfRRI9BPjAYXzGm","tool":"glob","state":{"status":"completed","input":{"pattern":"**/*tui*","path":"/Users/egv/dev/yolo-runner"},"output":"No files found","title":"","metadata":{"count":0,"truncated":false},"time":{"start":1768839889428,"end":1768839889435}},"metadata":{"openai":{"itemId":"fc_04feca4b4b75d9ff01696e5ad0d3e881919e6b0fa63d93d91e"}}}}
{"type":"step_finish","timestamp":1768839889461,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd712c225001LdngVVdVJ3f4Lo","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd712b4ae00143aM24HlxXEi7P","type":"step-finish","reason":"tool-calls","snapshot":"232197f30b157bb454c3649f04f571383751adb3","cost":0,"tokens":{"input":2524,"output":36,"reasoning":0,"cache":{"read":11264,"write":0}}}}
{"type":"step_start","timestamp":1768839889713,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd712c330001bSuNtXcIB9wN28","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd712c242001Jcn8g5okDEUY5b","type":"step-start","snapshot":"2543798f8ef56ab5b9b7a4d290cbe7a91b563100"}}
{"type":"tool_use","timestamp":1768839890768,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd712c561001BtsTHCRDND4XQm","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd712c242001Jcn8g5okDEUY5b","type":"tool","callID":"call_pKHvaUAnBDYlbJV7n9mnQbGq","tool":"glob","state":{"status":"completed","input":{"pattern":"**/*bubble*","path":"/Users/egv/dev/yolo-runner"},"output":"/Users/egv/dev/yolo-runner/bubbletea_test.go","title":"","metadata":{"count":1,"truncated":false},"time":{"start":1768839890760,"end":1768839890767}},"metadata":{"openai":{"itemId":"fc_0cd4d0c40b9e48a101696e5ad24d6081918ffe3047d7209176"}}}}
{"type":"step_finish","timestamp":1768839890783,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd712c751001JXSvI2rdneT8cq","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd712c242001Jcn8g5okDEUY5b","type":"step-finish","reason":"tool-calls","snapshot":"ede468ddcf3ca872129bcc38f381b7de11306785","cost":0,"tokens":{"input":136,"output":33,"reasoning":0,"cache":{"read":13696,"write":0}}}}
{"type":"step_start","timestamp":1768839891058,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd712c872001eKUDYPmjJvudEe","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd712c76c001FLWs1zEVEakII9","type":"step-start","snapshot":"93d4d5136c2fa00c7b9f04950960856c7823fb9a"}}
{"type":"tool_use","timestamp":1768839892158,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd712ca6f001Lt3wD2BHo53RoB","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd712c76c001FLWs1zEVEakII9","type":"tool","callID":"call_BsZsMsI96hXXzsp18drLnbYI","tool":"read","state":{"status":"completed","input":{"filePath":"/Users/egv/dev/yolo-runner/bubbletea_test.go"},"output":"<file>\n00001| package yolo_runner\n00002| \n00003| import (\n00004| \t\"testing\"\n00005| \n00006| \ttea \"github.com/charmbracelet/bubbletea\"\n00007| )\n00008| \n00009| type testModel struct{}\n00010| \n00011| func (testModel) Init() tea.Cmd {\n00012| \treturn nil\n00013| }\n00014| \n00015| func (testModel) Update(msg tea.Msg) (tea.Model, tea.Cmd) {\n00016| \treturn testModel{}, nil\n00017| }\n00018| \n00019| func (testModel) View() string {\n00020| \treturn \"\"\n00021| }\n00022| \n00023| func TestBubbleTeaProgramIsBuildable(t *testing.T) {\n00024| \tprogram := tea.NewProgram(testModel{})\n00025| \tif program == nil {\n00026| \t\tt.Fatal(\"expected bubble tea program to be buildable\")\n00027| \t}\n00028| }\n00029| \n\n(End of file - total 29 lines)\n</file>","title":"bubbletea_test.go","metadata":{"preview":"package yolo_runner\n\nimport (\n\t\"testing\"\n\n\ttea \"github.com/charmbracelet/bubbletea\"\n)\n\ntype testModel struct{}\n\nfunc (testModel) Init() tea.Cmd {\n\treturn nil\n}\n\nfunc (testModel) Update(msg tea.Msg) (tea.Model, tea.Cmd) {\n\treturn testModel{}, nil\n}\n\nfunc (testModel) View() string {\n\treturn \"\"","truncated":false},"time":{"start":1768839892157,"end":1768839892158}},"metadata":{"openai":{"itemId":"fc_0a78202104f9fb4101696e5ad37ef8819192e5a40a0cb6f7c8"}}}}
{"type":"step_finish","timestamp":1768839892173,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd712ccc0001Np8PKjxOaXWTh6","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd712c76c001FLWs1zEVEakII9","type":"step-finish","reason":"tool-calls","snapshot":"618b14fcc53d068814979ec9dc6b174ccf944db9","cost":0,"tokens":{"input":191,"output":32,"reasoning":0,"cache":{"read":13696,"write":0}}}}
{"type":"step_start","timestamp":1768839892544,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd712ce3f00170igwLVBbrWQl3","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd712ccdb001nSjgXrbwHLzSna","type":"step-start","snapshot":"991086780d9bc80964d758b932dd0af256e1d6ba"}}
{"type":"tool_use","timestamp":1768839894257,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd712d15c001133NXiAHO6jGiu","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd712ccdb001nSjgXrbwHLzSna","type":"tool","callID":"call_BMGsRHBnb31vzw0lswUVf8ks","tool":"grep","state":{"status":"completed","input":{"pattern":"Bubble|bubble|tea.NewProgram|TUI|tty|isatty","path":"/Users/egv/dev/yolo-runner","include":"*.go"},"output":"Found 5 matches\n/Users/egv/dev/yolo-runner/internal/ui/tui/model.go:\n  Line 7: \ttea \"github.com/charmbracelet/bubbletea\"\n\n/Users/egv/dev/yolo-runner/bubbletea_test.go:\n  Line 6: \ttea \"github.com/charmbracelet/bubbletea\"\n  Line 23: func TestBubbleTeaProgramIsBuildable(t *testing.T) {\n  Line 24: \tprogram := tea.NewProgram(testModel{})\n  Line 26: \t\tt.Fatal(\"expected bubble tea program to be buildable\")","title":"Bubble|bubble|tea.NewProgram|TUI|tty|isatty","metadata":{"matches":5,"truncated":false},"time":{"start":1768839894241,"end":1768839894257}},"metadata":{"openai":{"itemId":"fc_0f12f9e1207f64b501696e5ad55dfc8191aab626edadfe50d2"}}}}
{"type":"step_finish","timestamp":1768839894270,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd712d4f3001tE3fmeJzDVzMIp","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd712ccdb001nSjgXrbwHLzSna","type":"step-finish","reason":"tool-calls","snapshot":"07c9fc26f2dc7b7368ca1016bf86687a16eab6ba","cost":0,"tokens":{"input":473,"output":52,"reasoning":0,"cache":{"read":13696,"write":0}}}}
{"type":"step_start","timestamp":1768839894641,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd712d670001iAJpHlPzvtO21A","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd712d50d001wOb33HWEDk4HMX","type":"step-start","snapshot":"d18889c97fed3b2feaf70b1b5301479d0dfcf290"}}
{"type":"tool_use","timestamp":1768839895538,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd712d921001k0DXsRUYPg3nKO","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd712d50d001wOb33HWEDk4HMX","type":"tool","callID":"call_yxMpMKJ7tUXQpNZLHgj1euYN","tool":"read","state":{"status":"completed","input":{"filePath":"/Users/egv/dev/yolo-runner/internal/ui/tui/model.go"},"output":"<file>\n00001| package tui\n00002| \n00003| import (\n00004| \t\"fmt\"\n00005| \t\"time\"\n00006| \n00007| \ttea \"github.com/charmbracelet/bubbletea\"\n00008| \n00009| \t\"yolo-runner/internal/runner\"\n00010| )\n00011| \n00012| type Model struct {\n00013| \ttaskID       string\n00014| \ttaskTitle    string\n00015| \tphase        string\n00016| \tlastOutputAt time.Time\n00017| \tnow          func() time.Time\n00018| \tspinnerIndex int\n00019| }\n00020| \n00021| type OutputMsg struct{}\n00022| \n00023| func NewModel(now func() time.Time) Model {\n00024| \tif now == nil {\n00025| \t\tnow = time.Now\n00026| \t}\n00027| \treturn Model{now: now}\n00028| }\n00029| \n00030| func (m Model) Init() tea.Cmd {\n00031| \treturn nil\n00032| }\n00033| \n00034| func (m Model) Update(msg tea.Msg) (tea.Model, tea.Cmd) {\n00035| \tswitch typed := msg.(type) {\n00036| \tcase runner.Event:\n00037| \t\tm.taskID = typed.IssueID\n00038| \t\tm.taskTitle = typed.Title\n00039| \t\tm.phase = typed.Phase\n00040| \t\tm.lastOutputAt = typed.EmittedAt\n00041| \tcase OutputMsg:\n00042| \t\tm.spinnerIndex = (m.spinnerIndex + 1) % len(spinnerFrames)\n00043| \t\tif m.lastOutputAt.IsZero() {\n00044| \t\t\tm.lastOutputAt = m.now()\n00045| \t\t}\n00046| \t}\n00047| \treturn m, nil\n00048| }\n00049| \n00050| func (m Model) View() string {\n00051| \tspinner := spinnerFrames[m.spinnerIndex%len(spinnerFrames)]\n00052| \tage := m.lastOutputAge()\n00053| \treturn fmt.Sprintf(\"%s %s - %s\\nphase: %s\\nlast output %s\\n\", spinner, m.taskID, m.taskTitle, m.phase, age)\n00054| }\n00055| \n00056| func (m Model) lastOutputAge() string {\n00057| \tif m.lastOutputAt.IsZero() {\n00058| \t\treturn \"n/a\"\n00059| \t}\n00060| \tage := m.now().Sub(m.lastOutputAt).Round(time.Second)\n00061| \treturn fmt.Sprintf(\"%ds\", int(age.Seconds()))\n00062| }\n00063| \n00064| var spinnerFrames = []string{\"-\", \"\\\\\", \"|\", \"/\"}\n00065| \n\n(End of file - total 65 lines)\n</file>","title":"internal/ui/tui/model.go","metadata":{"preview":"package tui\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\ttea \"github.com/charmbracelet/bubbletea\"\n\n\t\"yolo-runner/internal/runner\"\n)\n\ntype Model struct {\n\ttaskID       string\n\ttaskTitle    string\n\tphase        string\n\tlastOutputAt time.Time\n\tnow          func() time.Time\n\tspinnerIndex int\n}\n","truncated":false},"time":{"start":1768839895538,"end":1768839895538}},"metadata":{"openai":{"itemId":"fc_048f3d440b716c7a01696e5ad70f7c81919522af3341ce698d"}}}}
{"type":"step_finish","timestamp":1768839895572,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd712da05001qrDYmWLWtcMCOK","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd712d50d001wOb33HWEDk4HMX","type":"step-finish","reason":"tool-calls","snapshot":"3b830dff4c13192483bf047f1da234117303d043","cost":0,"tokens":{"input":274,"output":33,"reasoning":0,"cache":{"read":14080,"write":0}}}}
{"type":"step_start","timestamp":1768839896043,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd712dbeb0017CG4Ak3Pf6fH5N","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd712da25001LGkg5L31TB0Lec","type":"step-start","snapshot":"74c0de54b5b6db27590dece4f7ae955dbe524762"}}
{"type":"tool_use","timestamp":1768839897417,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd712de13001iPdHIsnyk6kDTR","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd712da25001LGkg5L31TB0Lec","type":"tool","callID":"call_qo4wo3MC0igCQASVZhV4q5IE","tool":"grep","state":{"status":"completed","input":{"pattern":"RunOnce|tui|TUI|stdout|tty|isatty","path":"/Users/egv/dev/yolo-runner","include":"*.go"},"output":"Found 97 matches\n/Users/egv/dev/yolo-runner/internal/runner/runner_test.go:\n  Line 168: func TestRunOnceNoTasks(t *testing.T) {\n  Line 174: \tdeps := RunOnceDeps{\n  Line 181: \topts := RunOnceOptions{RepoRoot: \"/repo\", RootID: \"root\", Out: &bytes.Buffer{}}\n  Line 183: \tresult, err := RunOnce(opts, deps)\n  Line 195: func TestRunOnceDryRun(t *testing.T) {\n  Line 208: \tdeps := RunOnceDeps{\n  Line 215: \topts := RunOnceOptions{RepoRoot: \"/repo\", RootID: \"root\", DryRun: true, Out: output}\n  Line 217: \tresult, err := RunOnce(opts, deps)\n  Line 240: func TestRunOnceNoChangesBlocksTask(t *testing.T) {\n  Line 251: \tdeps := RunOnceDeps{\n  Line 259: \topts := RunOnceOptions{RepoRoot: \"/repo\", RootID: \"root\", Out: &bytes.Buffer{}}\n  Line 261: \tresult, err := RunOnce(opts, deps)\n  Line 288: func TestRunOnceChangesCommitCloseSync(t *testing.T) {\n  Line 300: \tdeps := RunOnceDeps{\n  Line 309: \topts := RunOnceOptions{RepoRoot: \"/repo\", RootID: \"root\", Out: &bytes.Buffer{}}\n  Line 311: \tresult, err := RunOnce(opts, deps)\n  Line 353: func TestRunOnceUsesFallbackCommitMessage(t *testing.T) {\n  Line 364: \tdeps := RunOnceDeps{\n  Line 373: \topts := RunOnceOptions{RepoRoot: \"/repo\", RootID: \"root\", Out: &bytes.Buffer{}}\n  Line 375: \t_, err := RunOnce(opts, deps)\n\n/Users/egv/dev/yolo-runner/internal/runner/runner_watchdog_test.go:\n  Line 11: func TestRunOnceMarksBlockedOnStall(t *testing.T) {\n  Line 19: \tdeps := RunOnceDeps{\n  Line 27: \topts := RunOnceOptions{RepoRoot: \"/repo\", RootID: \"root\", Out: &bytes.Buffer{}}\n  Line 29: \tresult, err := RunOnce(opts, deps)\n\n/Users/egv/dev/yolo-runner/internal/ui/tui/model.go:\n  Line 1: package tui\n\n/Users/egv/dev/yolo-runner/internal/runner/runner.go:\n  Line 48: type RunOnceDeps struct {\n  Line 57: type RunOnceOptions struct {\n  Line 68: func RunOnce(opts RunOnceOptions, deps RunOnceDeps) (string, error) {\n  Line 203: func RunLoop(opts RunOnceOptions, deps RunOnceDeps, max int, runOnce func(RunOnceOptions, RunOnceDeps) (string, error)) (int, error) {\n  Line 205: \t\trunOnce = RunOnce\n\n/Users/egv/dev/yolo-runner/internal/ui/tui/model_test.go:\n  Line 1: package tui\n\n/Users/egv/dev/yolo-runner/cmd/yolo-runner/exec.go:\n  Line 19: \tstdoutFile *os.File\n  Line 25: \tif process.stdoutFile != nil {\n  Line 26: \t\t_ = process.stdoutFile.Close()\n  Line 36: \t\tif process.stdoutFile != nil {\n  Line 37: \t\t\t_ = process.stdoutFile.Close()\n  Line 45: \tif process.stdoutFile != nil {\n  Line 46: \t\t_ = process.stdoutFile.Close()\n  Line 54: func startCommandWithEnv(args []string, env map[string]string, stdoutPath string) (opencode.Process, error) {\n  Line 60: \tstdoutFile, err := os.Create(stdoutPath)\n  Line 64: \tstderrPath := strings.TrimSuffix(stdoutPath, \".jsonl\") + \".stderr.log\"\n  Line 67: \t\t_ = stdoutFile.Close()\n  Line 70: \tcmd.Stdout = stdoutFile\n  Line 73: \t\t_ = stdoutFile.Close()\n  Line 77: \treturn cmdProcess{cmd: cmd, stdoutFile: stdoutFile, stderrFile: stderrFile}, nil\n\n/Users/egv/dev/yolo-runner/cmd/yolo-runner/exec_test.go:\n  Line 12: \tstdoutPath := filepath.Join(tempDir, \"output.jsonl\")\n  Line 15: \tprocess, err := startCommandWithEnv(args, nil, stdoutPath)\n  Line 23: \tstdoutContent, err := os.ReadFile(stdoutPath)\n  Line 25: \t\tt.Fatalf(\"read stdout log: %v\", err)\n  Line 27: \tif string(stdoutContent) != \"{\\\"ok\\\":true}\\n\" {\n  Line 28: \t\tt.Fatalf(\"unexpected stdout log: %q\", string(stdoutContent))\n  Line 31: \tstderrPath := strings.TrimSuffix(stdoutPath, \".jsonl\") + \".stderr.log\"\n\n/Users/egv/dev/yolo-runner/cmd/yolo-runner/main.go:\n  Line 18: type runOnceFunc func(opts runner.RunOnceOptions, deps runner.RunOnceDeps) (string, error)\n  Line 31: \tStart(args []string, env map[string]string, stdoutPath string) (opencode.Process, error)\n  Line 54: func RunOnceMain(args []string, runOnce runOnceFunc, exit exitFunc, stdout io.Writer, stderr io.Writer, beadsRunner beadsRunner, gitRunner gitRunner) int {\n  Line 74: \t\trunOnce = runner.RunOnce\n  Line 88: \tdeps := runner.RunOnceDeps{\n  Line 108: \toptions := runner.RunOnceOptions{\n  Line 115: \t\tOut:        stdout,\n  Line 118: \tif stdout == nil {\n  Line 141: \tRunOnceMain(os.Args[1:], runner.RunOnce, os.Exit, os.Stdout, os.Stderr, nil, nil)\n  Line 158: func (defaultOpenCodeRunner) Start(args []string, env map[string]string, stdoutPath string) (opencode.Process, error) {\n  Line 159: \treturn startCommandWithEnv(args, env, stdoutPath)\n\n/Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go:\n  Line 57: func (f *fakeOpenCodeRunner) Start(args []string, env map[string]string, stdoutPath string) (opencode.Process, error) {\n  Line 81: type fakeRunOnce struct {\n  Line 83: \topts   runner.RunOnceOptions\n  Line 84: \tdeps   runner.RunOnceDeps\n  Line 89: func (f *fakeRunOnce) Run(opts runner.RunOnceOptions, deps runner.RunOnceDeps) (string, error) {\n  Line 97: func TestRunOnceMainReturnsErrorCodeOnFailure(t *testing.T) {\n  Line 98: \trunner := &fakeRunOnce{err: errors.New(\"boom\")}\n  Line 102: \tcode := RunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\"}, runner.Run, exit.Exit, out, out, nil, nil)\n  Line 115: func TestRunOnceMainWiresDependencies(t *testing.T) {\n  Line 116: \trunner := &fakeRunOnce{result: \"no_tasks\"}\n  Line 122: \tRunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\", \"--model\", \"model\", \"--dry-run\"}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n  Line 141: func TestRunOnceMainDefaultsConfigPaths(t *testing.T) {\n  Line 142: \trunner := &fakeRunOnce{result: \"no_tasks\"}\n  Line 150: \tRunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\"}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n/Users/egv/dev/yolo-runner/internal/opencode/client.go:\n  Line 9: \tStart(args []string, env map[string]string, stdoutPath string) (Process, error)\n  Line 12: type RunnerFunc func(args []string, env map[string]string, stdoutPath string) (Process, error)\n  Line 14: func (runner RunnerFunc) Start(args []string, env map[string]string, stdoutPath string) (Process, error) {\n  Line 15: \treturn runner(args, env, stdoutPath)\n\n/Users/egv/dev/yolo-runner/internal/opencode/client_test.go:\n  Line 72: \trunner := RunnerFunc(func(args []string, env map[string]string, stdoutPath string) (Process, error) {\n  Line 78: \t\tcapturedPath = stdoutPath\n  Line 79: \t\tif err := os.WriteFile(stdoutPath, []byte(\"{\\\"ok\\\":true}\\n\"), 0o644); err != nil {\n  Line 155: \trunner := RunnerFunc(func(args []string, env map[string]string, stdoutPath string) (Process, error) {\n  Line 156: \t\tcapturedPath = stdoutPath\n  Line 157: \t\tif err := os.WriteFile(stdoutPath, []byte(\"{\\\"ok\\\":true}\\n\"), 0o644); err != nil {\n\n/Users/egv/dev/yolo-runner/internal/runner/loop_test.go:\n  Line 7: \trunOnce := func(opts RunOnceOptions, deps RunOnceDeps) (string, error) {\n  Line 12: \tcount, err := RunLoop(RunOnceOptions{}, RunOnceDeps{}, 2, runOnce)\n  Line 27: \trunOnce := func(opts RunOnceOptions, deps RunOnceDeps) (string, error) {\n  Line 36: \tcount, err := RunLoop(RunOnceOptions{}, RunOnceDeps{}, 0, runOnce)\n\n/Users/egv/dev/yolo-runner/opencode_adapter_v1.go:\n  Line 12: type openCodeRunner func(args []string, env map[string]string, stdoutPath string) error\n\n/Users/egv/dev/yolo-runner/opencode_adapter_v1_test.go:\n  Line 65: \trunner := func(args []string, env map[string]string, stdoutPath string) error {\n  Line 71: \t\tif err := os.WriteFile(stdoutPath, []byte(\"{\\\"ok\\\":true}\\n\"), 0o644); err != nil {\n  Line 131: \trunner := func(args []string, env map[string]string, stdoutPath string) error {\n  Line 132: \t\tcapturedPath = stdoutPath\n  Line 133: \t\tif err := os.WriteFile(stdoutPath, []byte(\"{\\\"ok\\\":true}\\n\"), 0o644); err != nil {","title":"RunOnce|tui|TUI|stdout|tty|isatty","metadata":{"matches":97,"truncated":false},"time":{"start":1768839897400,"end":1768839897417}},"metadata":{"openai":{"itemId":"fc_06b0e5fa32f8eb4c01696e5ad89e5481918440dfc5ee766f84"}}}}
{"type":"step_finish","timestamp":1768839897440,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd712e153001v6cU8Jq7YVLh4H","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd712da25001LGkg5L31TB0Lec","type":"step-finish","reason":"tool-calls","snapshot":"ec2b2bda5a97377ffa59c0526f891dbd9faae67b","cost":0,"tokens":{"input":818,"output":50,"reasoning":0,"cache":{"read":14208,"write":0}}}}
{"type":"step_start","timestamp":1768839897949,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd712e35c001AelUYZbFjzDW89","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd712e16f001chFLyEncjPxuYt","type":"step-start","snapshot":"d0b781e47a43027471079b781ede083e672dd086"}}
{"type":"tool_use","timestamp":1768839899012,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd712e4ea001e5jlUo9Ser8SDF","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd712e16f001chFLyEncjPxuYt","type":"tool","callID":"call_WbEghtN7hir6Bpnr6BlApRUC","tool":"read","state":{"status":"completed","input":{"filePath":"/Users/egv/dev/yolo-runner/internal/runner/runner.go"},"output":"<file>\n00001| package runner\n00002| \n00003| import (\n00004| \t\"fmt\"\n00005| \t\"io\"\n00006| \t\"strings\"\n00007| \t\"time\"\n00008| \n00009| \t\"yolo-runner/internal/opencode\"\n00010| )\n00011| \n00012| type Bead struct {\n00013| \tID                 string\n00014| \tTitle              string\n00015| \tDescription        string\n00016| \tAcceptanceCriteria string\n00017| \tStatus             string\n00018| }\n00019| \n00020| type BeadsClient interface {\n00021| \tReady(rootID string) (Issue, error)\n00022| \tShow(id string) (Bead, error)\n00023| \tUpdateStatus(id string, status string) error\n00024| \tUpdateStatusWithReason(id string, status string, reason string) error\n00025| \tClose(id string) error\n00026| \tSync() error\n00027| }\n00028| \n00029| type PromptBuilder interface {\n00030| \tBuild(issueID string, title string, description string, acceptance string) string\n00031| }\n00032| \n00033| type OpenCodeRunner interface {\n00034| \tRun(issueID string, repoRoot string, prompt string, model string, configRoot string, configDir string, logPath string) error\n00035| }\n00036| \n00037| type GitClient interface {\n00038| \tAddAll() error\n00039| \tIsDirty() (bool, error)\n00040| \tCommit(message string) error\n00041| \tRevParseHead() (string, error)\n00042| }\n00043| \n00044| type Logger interface {\n00045| \tAppendRunnerSummary(repoRoot string, issueID string, title string, status string, commitSHA string) error\n00046| }\n00047| \n00048| type RunOnceDeps struct {\n00049| \tBeads    BeadsClient\n00050| \tPrompt   PromptBuilder\n00051| \tOpenCode OpenCodeRunner\n00052| \tGit      GitClient\n00053| \tLogger   Logger\n00054| \tEvents   EventEmitter\n00055| }\n00056| \n00057| type RunOnceOptions struct {\n00058| \tRepoRoot   string\n00059| \tRootID     string\n00060| \tModel      string\n00061| \tConfigRoot string\n00062| \tConfigDir  string\n00063| \tLogPath    string\n00064| \tDryRun     bool\n00065| \tOut        io.Writer\n00066| }\n00067| \n00068| func RunOnce(opts RunOnceOptions, deps RunOnceDeps) (string, error) {\n00069| \tout := opts.Out\n00070| \tif out == nil {\n00071| \t\tout = io.Discard\n00072| \t}\n00073| \n00074| \troot, err := deps.Beads.Ready(opts.RootID)\n00075| \tif err != nil {\n00076| \t\treturn \"\", err\n00077| \t}\n00078| \n00079| \tleafID := SelectFirstOpenLeafTaskID(root)\n00080| \tif leafID == \"\" {\n00081| \t\treturn \"no_tasks\", nil\n00082| \t}\n00083| \n00084| \tbead, err := deps.Beads.Show(leafID)\n00085| \tif err != nil {\n00086| \t\treturn \"\", err\n00087| \t}\n00088| \n00089| \temitPhase(deps.Events, EventSelectTask, leafID, bead.Title)\n00090| \n00091| \tprompt := deps.Prompt.Build(leafID, bead.Title, bead.Description, bead.AcceptanceCriteria)\n00092| \tcommand := opencode.BuildArgs(opts.RepoRoot, prompt, opts.Model)\n00093| \n00094| \tif opts.DryRun {\n00095| \t\tfmt.Fprintf(out, \"Task: %s - %s\\n\", leafID, bead.Title)\n00096| \t\tfmt.Fprintln(out, prompt)\n00097| \t\tfmt.Fprintf(out, \"Command: %s\\n\", strings.Join(command, \" \"))\n00098| \t\treturn \"dry_run\", nil\n00099| \t}\n00100| \n00101| \temitPhase(deps.Events, EventBeadsUpdate, leafID, bead.Title)\n00102| \tif err := deps.Beads.UpdateStatus(leafID, \"in_progress\"); err != nil {\n00103| \t\treturn \"\", err\n00104| \t}\n00105| \n00106| \temitPhase(deps.Events, EventOpenCodeStart, leafID, bead.Title)\n00107| \tif err := deps.OpenCode.Run(leafID, opts.RepoRoot, prompt, opts.Model, opts.ConfigRoot, opts.ConfigDir, opts.LogPath); err != nil {\n00108| \t\tif stall, ok := err.(*opencode.StallError); ok {\n00109| \t\t\treason := stall.Error()\n00110| \t\t\tif err := deps.Beads.UpdateStatusWithReason(leafID, \"blocked\", reason); err != nil {\n00111| \t\t\t\treturn \"\", err\n00112| \t\t\t}\n00113| \t\t\treturn \"blocked\", err\n00114| \t\t}\n00115| \t\treturn \"\", err\n00116| \t}\n00117| \temitPhase(deps.Events, EventOpenCodeEnd, leafID, bead.Title)\n00118| \n00119| \temitPhase(deps.Events, EventGitAdd, leafID, bead.Title)\n00120| \tif err := deps.Git.AddAll(); err != nil {\n00121| \t\treturn \"\", err\n00122| \t}\n00123| \n00124| \temitPhase(deps.Events, EventGitStatus, leafID, bead.Title)\n00125| \tdirty, err := deps.Git.IsDirty()\n00126| \tif err != nil {\n00127| \t\treturn \"\", err\n00128| \t}\n00129| \n00130| \tif !dirty {\n00131| \t\tcommitSHA, err := deps.Git.RevParseHead()\n00132| \t\tif err != nil {\n00133| \t\t\treturn \"\", err\n00134| \t\t}\n00135| \t\tif err := deps.Logger.AppendRunnerSummary(opts.RepoRoot, leafID, bead.Title, \"blocked\", commitSHA); err != nil {\n00136| \t\t\treturn \"\", err\n00137| \t\t}\n00138| \t\tif err := deps.Beads.UpdateStatus(leafID, \"blocked\"); err != nil {\n00139| \t\t\treturn \"\", err\n00140| \t\t}\n00141| \t\treturn \"blocked\", nil\n00142| \t}\n00143| \n00144| \tcommitMessage := \"feat: complete bead task\"\n00145| \tif bead.Title != \"\" {\n00146| \t\tcommitMessage = \"feat: \" + strings.ToLower(bead.Title)\n00147| \t}\n00148| \n00149| \temitPhase(deps.Events, EventGitCommit, leafID, bead.Title)\n00150| \tif err := deps.Git.Commit(commitMessage); err != nil {\n00151| \t\treturn \"\", err\n00152| \t}\n00153| \n00154| \tcommitSHA, err := deps.Git.RevParseHead()\n00155| \tif err != nil {\n00156| \t\treturn \"\", err\n00157| \t}\n00158| \tif err := deps.Logger.AppendRunnerSummary(opts.RepoRoot, leafID, bead.Title, \"completed\", commitSHA); err != nil {\n00159| \t\treturn \"\", err\n00160| \t}\n00161| \n00162| \temitPhase(deps.Events, EventBeadsClose, leafID, bead.Title)\n00163| \tif err := deps.Beads.Close(leafID); err != nil {\n00164| \t\treturn \"\", err\n00165| \t}\n00166| \n00167| \temitPhase(deps.Events, EventBeadsVerify, leafID, bead.Title)\n00168| \tclosed, err := deps.Beads.Show(leafID)\n00169| \tif err != nil {\n00170| \t\treturn \"\", err\n00171| \t}\n00172| \tif closed.Status != \"closed\" {\n00173| \t\tif err := deps.Logger.AppendRunnerSummary(opts.RepoRoot, leafID, bead.Title, \"blocked\", commitSHA); err != nil {\n00174| \t\t\treturn \"\", err\n00175| \t\t}\n00176| \t\tif err := deps.Beads.UpdateStatus(leafID, \"blocked\"); err != nil {\n00177| \t\t\treturn \"\", err\n00178| \t\t}\n00179| \t\treturn \"blocked\", nil\n00180| \t}\n00181| \n00182| \temitPhase(deps.Events, EventBeadsSync, leafID, bead.Title)\n00183| \tif err := deps.Beads.Sync(); err != nil {\n00184| \t\treturn \"\", err\n00185| \t}\n00186| \n00187| \treturn \"completed\", nil\n00188| }\n00189| \n00190| func emitPhase(emitter EventEmitter, eventType EventType, issueID string, title string) {\n00191| \tif emitter == nil {\n00192| \t\treturn\n00193| \t}\n00194| \temitter.Emit(Event{\n00195| \t\tType:      eventType,\n00196| \t\tIssueID:   issueID,\n00197| \t\tTitle:     title,\n00198| \t\tPhase:     string(eventType),\n00199| \t\tEmittedAt: time.Now(),\n00200| \t})\n00201| }\n00202| \n00203| func RunLoop(opts RunOnceOptions, deps RunOnceDeps, max int, runOnce func(RunOnceOptions, RunOnceDeps) (string, error)) (int, error) {\n00204| \tif runOnce == nil {\n00205| \t\trunOnce = RunOnce\n00206| \t}\n00207| \n00208| \tcompleted := 0\n00209| \tfor {\n00210| \t\tresult, err := runOnce(opts, deps)\n00211| \t\tif err != nil {\n00212| \t\t\treturn completed, err\n00213| \t\t}\n00214| \t\tif result == \"completed\" {\n00215| \t\t\tcompleted++\n00216| \t\t}\n00217| \t\tif result == \"no_tasks\" {\n00218| \t\t\treturn completed, nil\n00219| \t\t}\n00220| \t\tif max > 0 && completed >= max {\n00221| \t\t\treturn completed, nil\n00222| \t\t}\n00223| \t\tif result != \"completed\" {\n00224| \t\t\treturn completed, nil\n00225| \t\t}\n00226| \t}\n00227| }\n00228| \n\n(End of file - total 228 lines)\n</file>","title":"internal/runner/runner.go","metadata":{"preview":"package runner\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"strings\"\n\t\"time\"\n\n\t\"yolo-runner/internal/opencode\"\n)\n\ntype Bead struct {\n\tID                 string\n\tTitle              string\n\tDescription        string\n\tAcceptanceCriteria string\n\tStatus             string\n}\n\ntype BeadsClient interface {","truncated":false},"time":{"start":1768839899011,"end":1768839899012}},"metadata":{"openai":{"itemId":"fc_0fee4b9e54c8ddeb01696e5ada5e448191827216340db6db51"}}}}
{"type":"step_finish","timestamp":1768839899063,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd712e7a9001FxvNDoJnhcTvvv","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd712e16f001chFLyEncjPxuYt","type":"step-finish","reason":"tool-calls","snapshot":"a8793af0d9d303e4326b6ccdc861d3f623fbfca2","cost":0,"tokens":{"input":2573,"output":33,"reasoning":0,"cache":{"read":14848,"write":0}}}}
{"type":"step_start","timestamp":1768839899362,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd712e8e2001krb3gbAKn8mnYQ","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd712e7c7001LN8scJsXlTg18d","type":"step-start","snapshot":"5b53cf06c49de3691f435fb48bd4cf0259a89447"}}
{"type":"tool_use","timestamp":1768839900466,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd712ea7a001DFH7ZVv4egdeOq","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd712e7c7001LN8scJsXlTg18d","type":"tool","callID":"call_MpGMNZEysbtW1gmYJq48tCwK","tool":"grep","state":{"status":"completed","input":{"pattern":"tui|headless|tty|isatty","path":"/Users/egv/dev/yolo-runner","include":"*.go"},"output":"Found 2 matches\n/Users/egv/dev/yolo-runner/internal/ui/tui/model.go:\n  Line 1: package tui\n\n/Users/egv/dev/yolo-runner/internal/ui/tui/model_test.go:\n  Line 1: package tui","title":"tui|headless|tty|isatty","metadata":{"matches":2,"truncated":false},"time":{"start":1768839900452,"end":1768839900465}},"metadata":{"openai":{"itemId":"fc_09e340806cd0ebc201696e5adbcc288191be06758aa4e2a6d8"}}}}
{"type":"step_finish","timestamp":1768839900662,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd712ede9001uHBw4AXg1fVv3x","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd712e7c7001LN8scJsXlTg18d","type":"step-finish","reason":"tool-calls","snapshot":"757b409332adef1a8a8b1d4be597149fb1437055","cost":0,"tokens":{"input":2559,"output":45,"reasoning":0,"cache":{"read":17280,"write":0}}}}
{"type":"step_start","timestamp":1768839901140,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd712efd4001kN0uHlvxCYcjoF","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd712ee04001iKpXWPliRjTuwK","type":"step-start","snapshot":"a7212984edb1241f079cd8ffc063b4e4ade0319a"}}
{"type":"tool_use","timestamp":1768839902080,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd712f102001nWhZmgsE2z4rr9","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd712ee04001iKpXWPliRjTuwK","type":"tool","callID":"call_PTS5BFXRqSrimdUHTOaBexrF","tool":"read","state":{"status":"completed","input":{"filePath":"/Users/egv/dev/yolo-runner/internal/ui/tui/model_test.go"},"output":"<file>\n00001| package tui\n00002| \n00003| import (\n00004| \t\"strings\"\n00005| \t\"testing\"\n00006| \t\"time\"\n00007| \n00008| \t\"yolo-runner/internal/runner\"\n00009| )\n00010| \n00011| func TestModelRendersTaskAndPhase(t *testing.T) {\n00012| \tfixedNow := time.Date(2026, 1, 19, 12, 0, 10, 0, time.UTC)\n00013| \tm := NewModel(func() time.Time { return fixedNow })\n00014| \tupdated, _ := m.Update(runner.Event{\n00015| \t\tType:      runner.EventSelectTask,\n00016| \t\tIssueID:   \"task-1\",\n00017| \t\tTitle:     \"Example Task\",\n00018| \t\tPhase:     \"running\",\n00019| \t\tEmittedAt: fixedNow.Add(-5 * time.Second),\n00020| \t})\n00021| \tm = updated.(Model)\n00022| \n00023| \tview := m.View()\n00024| \tif !strings.Contains(view, \"task-1 - Example Task\") {\n00025| \t\tt.Fatalf(\"expected task id and title in view, got %q\", view)\n00026| \t}\n00027| \tif !strings.Contains(view, \"running\") {\n00028| \t\tt.Fatalf(\"expected phase in view, got %q\", view)\n00029| \t}\n00030| \tif !strings.Contains(view, \"last output 5s\") {\n00031| \t\tt.Fatalf(\"expected last output age in view, got %q\", view)\n00032| \t}\n00033| }\n00034| \n00035| func TestSpinnerAdvancesOnOutput(t *testing.T) {\n00036| \tm := NewModel(func() time.Time { return time.Unix(0, 0) })\n00037| \tupdated, _ := m.Update(OutputMsg{})\n00038| \tm = updated.(Model)\n00039| \tfirst := m.View()\n00040| \tupdated, _ = m.Update(OutputMsg{})\n00041| \tm = updated.(Model)\n00042| \tsecond := m.View()\n00043| \n00044| \tif first == second {\n00045| \t\tt.Fatalf(\"expected spinner to advance, got %q\", second)\n00046| \t}\n00047| }\n00048| \n\n(End of file - total 48 lines)\n</file>","title":"internal/ui/tui/model_test.go","metadata":{"preview":"package tui\n\nimport (\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"yolo-runner/internal/runner\"\n)\n\nfunc TestModelRendersTaskAndPhase(t *testing.T) {\n\tfixedNow := time.Date(2026, 1, 19, 12, 0, 10, 0, time.UTC)\n\tm := NewModel(func() time.Time { return fixedNow })\n\tupdated, _ := m.Update(runner.Event{\n\t\tType:      runner.EventSelectTask,\n\t\tIssueID:   \"task-1\",\n\t\tTitle:     \"Example Task\",\n\t\tPhase:     \"running\",\n\t\tEmittedAt: fixedNow.Add(-5 * time.Second),\n\t})","truncated":false},"time":{"start":1768839902079,"end":1768839902080}},"metadata":{"openai":{"itemId":"fc_02120f100d19a7af01696e5add6a148191ab60515e12811115"}}}}
{"type":"step_finish","timestamp":1768839902163,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd712f3c4001IqzeCZgFeLK7G7","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd712ee04001iKpXWPliRjTuwK","type":"step-finish","reason":"tool-calls","snapshot":"6ba696d97d091aae21b771d606e4f3432fa2e01f","cost":0,"tokens":{"input":235,"output":34,"reasoning":0,"cache":{"read":19712,"write":0}}}}
{"type":"step_start","timestamp":1768839902563,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd712f56300126zk2jnjUv2h40","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd712f3e6001kBP2vae1Y61K7M","type":"step-start","snapshot":"1b4164a7312d5cbf07831c178fc140b703a082b3"}}
{"type":"tool_use","timestamp":1768839905383,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd712fe91001fI3ARQoKIRaW7j","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd712f3e6001kBP2vae1Y61K7M","type":"tool","callID":"call_oXpbuYhKM6D3Z3Uq9HPnqPFF","tool":"glob","state":{"status":"completed","input":{"pattern":"**/ui/**/*.go","path":"/Users/egv/dev/yolo-runner"},"output":"/Users/egv/dev/yolo-runner/internal/ui/tui/model.go\n/Users/egv/dev/yolo-runner/internal/ui/tui/model_test.go","title":"","metadata":{"count":2,"truncated":false},"time":{"start":1768839905376,"end":1768839905383}},"metadata":{"openai":{"itemId":"fc_00be1601067f803201696e5ae0eecc819188a44b6023af311c"}}}}
{"type":"step_finish","timestamp":1768839905507,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd71300d4001ZUueL4a1ETM47C","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd712f3e6001kBP2vae1Y61K7M","type":"step-finish","reason":"tool-calls","snapshot":"688f093c69f264a3eafe4fc1aed0862b47bdd488","cost":0,"tokens":{"input":693,"output":100,"reasoning":64,"cache":{"read":19840,"write":0}}}}
{"type":"step_start","timestamp":1768839905843,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd7130232001ROe8itTU5f5CPQ","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd71300f1001ih3hPwZJFMwZ16","type":"step-start","snapshot":"f25892a8a97c9384e2234bf0b38271ac171cc884"}}
{"type":"tool_use","timestamp":1768839907218,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd7130406001Wp1X85EWwdBIX5","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd71300f1001ih3hPwZJFMwZ16","type":"tool","callID":"call_AQ23l76QMT6f2aN08dFqh2jP","tool":"grep","state":{"status":"completed","input":{"pattern":"RunLoop|RunOnceMain|RunOnce","path":"/Users/egv/dev/yolo-runner/cmd/yolo-runner","include":"*.go"},"output":"Found 19 matches\n/Users/egv/dev/yolo-runner/cmd/yolo-runner/main.go:\n  Line 18: type runOnceFunc func(opts runner.RunOnceOptions, deps runner.RunOnceDeps) (string, error)\n  Line 54: func RunOnceMain(args []string, runOnce runOnceFunc, exit exitFunc, stdout io.Writer, stderr io.Writer, beadsRunner beadsRunner, gitRunner gitRunner) int {\n  Line 74: \t\trunOnce = runner.RunOnce\n  Line 88: \tdeps := runner.RunOnceDeps{\n  Line 108: \toptions := runner.RunOnceOptions{\n  Line 141: \tRunOnceMain(os.Args[1:], runner.RunOnce, os.Exit, os.Stdout, os.Stderr, nil, nil)\n\n/Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go:\n  Line 81: type fakeRunOnce struct {\n  Line 83: \topts   runner.RunOnceOptions\n  Line 84: \tdeps   runner.RunOnceDeps\n  Line 89: func (f *fakeRunOnce) Run(opts runner.RunOnceOptions, deps runner.RunOnceDeps) (string, error) {\n  Line 97: func TestRunOnceMainReturnsErrorCodeOnFailure(t *testing.T) {\n  Line 98: \trunner := &fakeRunOnce{err: errors.New(\"boom\")}\n  Line 102: \tcode := RunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\"}, runner.Run, exit.Exit, out, out, nil, nil)\n  Line 115: func TestRunOnceMainWiresDependencies(t *testing.T) {\n  Line 116: \trunner := &fakeRunOnce{result: \"no_tasks\"}\n  Line 122: \tRunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\", \"--model\", \"model\", \"--dry-run\"}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n  Line 141: func TestRunOnceMainDefaultsConfigPaths(t *testing.T) {\n  Line 142: \trunner := &fakeRunOnce{result: \"no_tasks\"}\n  Line 150: \tRunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\"}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)","title":"RunLoop|RunOnceMain|RunOnce","metadata":{"matches":19,"truncated":false},"time":{"start":1768839907211,"end":1768839907218}},"metadata":{"openai":{"itemId":"fc_08313356f1ed902a01696e5ae256708191bdd82a22346c77f5"}}}}
{"type":"step_finish","timestamp":1768839907234,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd7130795001SK8kuIO2f5BiRd","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd71300f1001ih3hPwZJFMwZ16","type":"step-finish","reason":"tool-calls","snapshot":"02f3859b2d7c85bc1465e1eb35989691ce9f3722","cost":0,"tokens":{"input":256,"output":51,"reasoning":0,"cache":{"read":20352,"write":0}}}}
{"type":"step_start","timestamp":1768839907604,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd7130913001FCmn0FdhbLBmzK","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd71307b2001Fs9xlSH5rk0gnP","type":"step-start","snapshot":"df685118aa18cd9759b30fa2211c4d3a70e419fc"}}
{"type":"tool_use","timestamp":1768839908654,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd7130aaf0016RTsblU5jnZfI0","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd71307b2001Fs9xlSH5rk0gnP","type":"tool","callID":"call_XXtJvSPeTFB8VHF6ggDJyU4q","tool":"grep","state":{"status":"completed","input":{"pattern":"bubbletea|tui","path":"/Users/egv/dev/yolo-runner","include":"*.go"},"output":"Found 4 matches\n/Users/egv/dev/yolo-runner/internal/ui/tui/model.go:\n  Line 1: package tui\n  Line 7: \ttea \"github.com/charmbracelet/bubbletea\"\n\n/Users/egv/dev/yolo-runner/internal/ui/tui/model_test.go:\n  Line 1: package tui\n\n/Users/egv/dev/yolo-runner/bubbletea_test.go:\n  Line 6: \ttea \"github.com/charmbracelet/bubbletea\"","title":"bubbletea|tui","metadata":{"matches":4,"truncated":false},"time":{"start":1768839908639,"end":1768839908654}},"metadata":{"openai":{"itemId":"fc_0edeb29aa4d8677701696e5ae3f96c8191bee8a1aab9981e78"}}}}
{"type":"step_finish","timestamp":1768839908797,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd7130dad001kzj4EVZN1Bx9vj","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd71307b2001Fs9xlSH5rk0gnP","type":"step-finish","reason":"tool-calls","snapshot":"5138a3a2ad7cb225ade6220ece65d8c9ec80f06a","cost":0,"tokens":{"input":692,"output":40,"reasoning":0,"cache":{"read":20480,"write":0}}}}
{"type":"step_start","timestamp":1768839909414,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd7131026001d6TEf9TuytjEB8","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd7130dcb001nOEPnZNv9m8Tn0","type":"step-start","snapshot":"32fb67bdfa04ea91230785b9d016dd0791089cff"}}
{"type":"tool_use","timestamp":1768839910719,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd713131a001NlbY78VJow84em","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd7130dcb001nOEPnZNv9m8Tn0","type":"tool","callID":"call_1gtgifyKCR52US4xedc2CN6b","tool":"glob","state":{"status":"completed","input":{"pattern":"**/*.go","path":"/Users/egv/dev/yolo-runner"},"output":"/Users/egv/dev/yolo-runner/internal/runner/runner_test.go\n/Users/egv/dev/yolo-runner/internal/runner/runner_watchdog_test.go\n/Users/egv/dev/yolo-runner/internal/ui/tui/model.go\n/Users/egv/dev/yolo-runner/internal/runner/runner.go\n/Users/egv/dev/yolo-runner/internal/runner/events.go\n/Users/egv/dev/yolo-runner/internal/ui/tui/model_test.go\n/Users/egv/dev/yolo-runner/bubbletea_test.go\n/Users/egv/dev/yolo-runner/build_docs_test.go\n/Users/egv/dev/yolo-runner/cmd/yolo-runner/exec.go\n/Users/egv/dev/yolo-runner/cmd/yolo-runner/exec_test.go\n/Users/egv/dev/yolo-runner/cmd/yolo-runner/main.go\n/Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go\n/Users/egv/dev/yolo-runner/internal/opencode/client.go\n/Users/egv/dev/yolo-runner/internal/opencode/watchdog.go\n/Users/egv/dev/yolo-runner/internal/beads/beads_test.go\n/Users/egv/dev/yolo-runner/internal/beads/beads.go\n/Users/egv/dev/yolo-runner/internal/opencode/client_test.go\n/Users/egv/dev/yolo-runner/internal/opencode/watchdog_test.go\n/Users/egv/dev/yolo-runner/internal/runner/loop_test.go\n/Users/egv/dev/yolo-runner/internal/runner/select.go\n/Users/egv/dev/yolo-runner/internal/prompt/prompt.go\n/Users/egv/dev/yolo-runner/internal/prompt/prompt_test.go\n/Users/egv/dev/yolo-runner/internal/logging/jsonl.go\n/Users/egv/dev/yolo-runner/internal/logging/jsonl_test.go\n/Users/egv/dev/yolo-runner/internal/vcs/git/git.go\n/Users/egv/dev/yolo-runner/internal/vcs/git/git_test.go\n/Users/egv/dev/yolo-runner/internal/runner/select_test.go\n/Users/egv/dev/yolo-runner/opencode_adapter_v1.go\n/Users/egv/dev/yolo-runner/runner_logging_v1_test.go\n/Users/egv/dev/yolo-runner/opencode_adapter_v1_test.go","title":"","metadata":{"count":30,"truncated":false},"time":{"start":1768839910710,"end":1768839910719}},"metadata":{"openai":{"itemId":"fc_08fa65502995aa5601696e5ae6326c8191a79fb97ea2324d52"}}}}
{"type":"step_finish","timestamp":1768839910743,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd7131549001LHP0YWAXH4NDou","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd7130dcb001nOEPnZNv9m8Tn0","type":"step-finish","reason":"tool-calls","snapshot":"0304fc06e5fc66174c5ad5d49a3e14a67bd7e9a0","cost":0,"tokens":{"input":1233,"output":32,"reasoning":0,"cache":{"read":20096,"write":0}}}}
{"type":"step_start","timestamp":1768839911089,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd71316b0001wK5023seeW9wgT","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd7131567001nXTM0Uk7MVkQ4H","type":"step-start","snapshot":"16136d2e3d2aa4c1abb7837e97fd417bb389034e"}}
{"type":"tool_use","timestamp":1768839912096,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd7131834001zoqjHhUNYuVcKr","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd7131567001nXTM0Uk7MVkQ4H","type":"tool","callID":"call_z7DB4xxlRPuj75UQmEJo1opA","tool":"read","state":{"status":"completed","input":{"filePath":"/Users/egv/dev/yolo-runner/internal/runner/events.go"},"output":"<file>\n00001| package runner\n00002| \n00003| import \"time\"\n00004| \n00005| type EventType string\n00006| \n00007| const (\n00008| \tEventSelectTask    EventType = \"select_task\"\n00009| \tEventBeadsUpdate   EventType = \"beads_update\"\n00010| \tEventOpenCodeStart EventType = \"opencode_start\"\n00011| \tEventOpenCodeEnd   EventType = \"opencode_end\"\n00012| \tEventGitAdd        EventType = \"git_add\"\n00013| \tEventGitStatus     EventType = \"git_status\"\n00014| \tEventGitCommit     EventType = \"git_commit\"\n00015| \tEventBeadsClose    EventType = \"beads_close\"\n00016| \tEventBeadsVerify   EventType = \"beads_verify\"\n00017| \tEventBeadsSync     EventType = \"beads_sync\"\n00018| )\n00019| \n00020| type Event struct {\n00021| \tType      EventType `json:\"type\"`\n00022| \tIssueID   string    `json:\"issue_id\"`\n00023| \tTitle     string    `json:\"title\"`\n00024| \tPhase     string    `json:\"phase\"`\n00025| \tEmittedAt time.Time `json:\"emitted_at\"`\n00026| }\n00027| \n00028| type EventEmitter interface {\n00029| \tEmit(event Event)\n00030| }\n00031| \n\n(End of file - total 31 lines)\n</file>","title":"internal/runner/events.go","metadata":{"preview":"package runner\n\nimport \"time\"\n\ntype EventType string\n\nconst (\n\tEventSelectTask    EventType = \"select_task\"\n\tEventBeadsUpdate   EventType = \"beads_update\"\n\tEventOpenCodeStart EventType = \"opencode_start\"\n\tEventOpenCodeEnd   EventType = \"opencode_end\"\n\tEventGitAdd        EventType = \"git_add\"\n\tEventGitStatus     EventType = \"git_status\"\n\tEventGitCommit     EventType = \"git_commit\"\n\tEventBeadsClose    EventType = \"beads_close\"\n\tEventBeadsVerify   EventType = \"beads_verify\"\n\tEventBeadsSync     EventType = \"beads_sync\"\n)\n\ntype Event struct {","truncated":false},"time":{"start":1768839912095,"end":1768839912096}},"metadata":{"openai":{"itemId":"fc_06fe576579645cc901696e5ae780cc819186c259256dc338c4"}}}}
{"type":"step_finish","timestamp":1768839912151,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd7131ac8001SgQUpoOqBvSVpV","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd7131567001nXTM0Uk7MVkQ4H","type":"step-finish","reason":"tool-calls","snapshot":"49a72c51f3aa9a55b6ba982829c879b709c8888a","cost":0,"tokens":{"input":648,"output":32,"reasoning":0,"cache":{"read":21248,"write":0}}}}
{"type":"step_start","timestamp":1768839912470,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd7131c16001l5HupgXXZj4oZg","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd7131ae9001sREhXndzz16Ff6","type":"step-start","snapshot":"9927db730df41176deeaf4343d2b0da3f8651433"}}
{"type":"tool_use","timestamp":1768839914380,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd713222a001auhM3p1IMkyS9Q","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd7131ae9001sREhXndzz16Ff6","type":"tool","callID":"call_t375yowHT37xzkgmb5FjNNJH","tool":"grep","state":{"status":"completed","input":{"pattern":"RunLoop","path":"/Users/egv/dev/yolo-runner","include":"*.go"},"output":"Found 5 matches\n/Users/egv/dev/yolo-runner/internal/runner/runner.go:\n  Line 203: func RunLoop(opts RunOnceOptions, deps RunOnceDeps, max int, runOnce func(RunOnceOptions, RunOnceDeps) (string, error)) (int, error) {\n\n/Users/egv/dev/yolo-runner/internal/runner/loop_test.go:\n  Line 5: func TestRunLoopStopsAfterMaxCompletions(t *testing.T) {\n  Line 12: \tcount, err := RunLoop(RunOnceOptions{}, RunOnceDeps{}, 2, runOnce)\n  Line 24: func TestRunLoopStopsOnNoTasks(t *testing.T) {\n  Line 36: \tcount, err := RunLoop(RunOnceOptions{}, RunOnceDeps{}, 0, runOnce)","title":"RunLoop","metadata":{"matches":5,"truncated":false},"time":{"start":1768839914365,"end":1768839914379}},"metadata":{"openai":{"itemId":"fc_0c048996608be8c801696e5ae9f9108191beeb0199504cfe86"}}}}
{"type":"step_finish","timestamp":1768839914415,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd71323a0001SQs1EamK81dyPb","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd7131ae9001sREhXndzz16Ff6","type":"step-finish","reason":"tool-calls","snapshot":"cee3067168067705e7d4cc567d98c1af6d470bd5","cost":0,"tokens":{"input":512,"output":39,"reasoning":0,"cache":{"read":21760,"write":0}}}}
{"type":"step_start","timestamp":1768839914727,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd71324e6001NSFWcEBdsMBmei","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd71323c3001Mqulbz4FaTCquG","type":"step-start","snapshot":"b470219cfaf89088462baf5235b8a665b83dada7"}}
{"type":"tool_use","timestamp":1768839915709,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd7132640001lUQhiaPCwl4G92","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd71323c3001Mqulbz4FaTCquG","type":"tool","callID":"call_IwSyO11eQjYVfRaIgLRY8lX6","tool":"read","state":{"status":"completed","input":{"filePath":"/Users/egv/dev/yolo-runner/internal/runner/loop_test.go"},"output":"<file>\n00001| package runner\n00002| \n00003| import \"testing\"\n00004| \n00005| func TestRunLoopStopsAfterMaxCompletions(t *testing.T) {\n00006| \tcalls := 0\n00007| \trunOnce := func(opts RunOnceOptions, deps RunOnceDeps) (string, error) {\n00008| \t\tcalls++\n00009| \t\treturn \"completed\", nil\n00010| \t}\n00011| \n00012| \tcount, err := RunLoop(RunOnceOptions{}, RunOnceDeps{}, 2, runOnce)\n00013| \tif err != nil {\n00014| \t\tt.Fatalf(\"unexpected error: %v\", err)\n00015| \t}\n00016| \tif count != 2 {\n00017| \t\tt.Fatalf(\"expected count 2, got %d\", count)\n00018| \t}\n00019| \tif calls != 2 {\n00020| \t\tt.Fatalf(\"expected 2 runs, got %d\", calls)\n00021| \t}\n00022| }\n00023| \n00024| func TestRunLoopStopsOnNoTasks(t *testing.T) {\n00025| \tcalls := 0\n00026| \tresults := []string{\"completed\", \"no_tasks\", \"completed\"}\n00027| \trunOnce := func(opts RunOnceOptions, deps RunOnceDeps) (string, error) {\n00028| \t\tif calls >= len(results) {\n00029| \t\t\tt.Fatalf(\"unexpected run %d\", calls+1)\n00030| \t\t}\n00031| \t\tresult := results[calls]\n00032| \t\tcalls++\n00033| \t\treturn result, nil\n00034| \t}\n00035| \n00036| \tcount, err := RunLoop(RunOnceOptions{}, RunOnceDeps{}, 0, runOnce)\n00037| \tif err != nil {\n00038| \t\tt.Fatalf(\"unexpected error: %v\", err)\n00039| \t}\n00040| \tif count != 1 {\n00041| \t\tt.Fatalf(\"expected count 1, got %d\", count)\n00042| \t}\n00043| \tif calls != 2 {\n00044| \t\tt.Fatalf(\"expected 2 runs, got %d\", calls)\n00045| \t}\n00046| }\n00047| \n\n(End of file - total 47 lines)\n</file>","title":"internal/runner/loop_test.go","metadata":{"preview":"package runner\n\nimport \"testing\"\n\nfunc TestRunLoopStopsAfterMaxCompletions(t *testing.T) {\n\tcalls := 0\n\trunOnce := func(opts RunOnceOptions, deps RunOnceDeps) (string, error) {\n\t\tcalls++\n\t\treturn \"completed\", nil\n\t}\n\n\tcount, err := RunLoop(RunOnceOptions{}, RunOnceDeps{}, 2, runOnce)\n\tif err != nil {\n\t\tt.Fatalf(\"unexpected error: %v\", err)\n\t}\n\tif count != 2 {\n\t\tt.Fatalf(\"expected count 2, got %d\", count)\n\t}\n\tif calls != 2 {\n\t\tt.Fatalf(\"expected 2 runs, got %d\", calls)","truncated":false},"time":{"start":1768839915709,"end":1768839915709}},"metadata":{"openai":{"itemId":"fc_05b74fcee287841c01696e5aeb161c81918cc09d350145339b"}}}}
{"type":"step_finish","timestamp":1768839915747,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd71328d5001fa3dvsbiDnVFp7","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd71323c3001Mqulbz4FaTCquG","type":"step-finish","reason":"tool-calls","snapshot":"d98189dc12dd0a065a79caa1a7b5ffb36469fa63","cost":0,"tokens":{"input":350,"output":34,"reasoning":0,"cache":{"read":22144,"write":0}}}}
{"type":"step_start","timestamp":1768839916137,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd7132a680015w8Lto7jTCPioS","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd71328f4001jOjQl2w6pzHQ4G","type":"step-start","snapshot":"2ac244ccac3744f4e4820ab2469d2a6eccd75a4b"}}
{"type":"tool_use","timestamp":1768839918237,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd7132f230012X0GYeadp1UkVb","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd71328f4001jOjQl2w6pzHQ4G","type":"tool","callID":"call_hz5vyzPvrltq9w2YQ8kfMRfj","tool":"grep","state":{"status":"completed","input":{"pattern":"tea.NewProgram|tui|Bubble|bubble|TTY|isatty|term","path":"/Users/egv/dev/yolo-runner","include":"*.go"},"output":"Found 7 matches\n/Users/egv/dev/yolo-runner/internal/ui/tui/model.go:\n  Line 1: package tui\n  Line 7: \ttea \"github.com/charmbracelet/bubbletea\"\n\n/Users/egv/dev/yolo-runner/internal/ui/tui/model_test.go:\n  Line 1: package tui\n\n/Users/egv/dev/yolo-runner/bubbletea_test.go:\n  Line 6: \ttea \"github.com/charmbracelet/bubbletea\"\n  Line 23: func TestBubbleTeaProgramIsBuildable(t *testing.T) {\n  Line 24: \tprogram := tea.NewProgram(testModel{})\n  Line 26: \t\tt.Fatal(\"expected bubble tea program to be buildable\")","title":"tea.NewProgram|tui|Bubble|bubble|TTY|isatty|term","metadata":{"matches":7,"truncated":false},"time":{"start":1768839918220,"end":1768839918236}},"metadata":{"openai":{"itemId":"fc_0baa1f38bd8ec8fc01696e5aed5da881918e5e57ced67452e7"}}}}
{"type":"step_finish","timestamp":1768839918249,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd713329c001rNVvR9SirgGyUN","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd71328f4001jOjQl2w6pzHQ4G","type":"step-finish","reason":"tool-calls","snapshot":"782e5faa2a02cbf7031ba3150cd912fc949efcd0","cost":0,"tokens":{"input":652,"output":54,"reasoning":0,"cache":{"read":22400,"write":0}}}}
{"type":"step_start","timestamp":1768839918603,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd713340a0012YZVG2K6aTEkyF","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd71332b9001fZvKrAR490XiQQ","type":"step-start","snapshot":"68966c905e253741c9923de7a35636ab43ce6275"}}
{"type":"tool_use","timestamp":1768839933210,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd7136947001ufgvuNKzjAwQwC","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd71332b9001fZvKrAR490XiQQ","type":"tool","callID":"call_Id6Wtufs35I8ezpwB5Bqvpfg","tool":"grep","state":{"status":"completed","input":{"pattern":"term.IsTerminal|isatty|IsTerminal","path":"/Users/egv/dev/yolo-runner","include":"*.go"},"output":"No files found","title":"term.IsTerminal|isatty|IsTerminal","metadata":{"matches":0,"truncated":false},"time":{"start":1768839933196,"end":1768839933210}},"metadata":{"openai":{"itemId":"fc_08040db8011478c801696e5afc411c8191b6b8ed796db22a70"}}}}
{"type":"step_finish","timestamp":1768839933250,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd7136d33001xMQ4vLheRjW9E5","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd71332b9001fZvKrAR490XiQQ","type":"step-finish","reason":"tool-calls","snapshot":"62930a59ed3705b970af160ae7634944dae01783","cost":0,"tokens":{"input":1129,"output":622,"reasoning":576,"cache":{"read":22144,"write":0}}}}
{"type":"step_start","timestamp":1768839933539,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd7136e62001mRxqzegYnh4K3D","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd7136d53001kJDxD274NPEaGv","type":"step-start","snapshot":"e6f4066f222ccd3377e5bd72de2105ea441cfb1f"}}
{"type":"tool_use","timestamp":1768839937522,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd7137c48001SVjYGIVRU7uYj8","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd7136d53001kJDxD274NPEaGv","type":"tool","callID":"call_cm25y1WFxtOPvQoo3xyqrq2g","tool":"grep","state":{"status":"completed","input":{"pattern":"Emit\\(","path":"/Users/egv/dev/yolo-runner","include":"*.go"},"output":"Found 3 matches\n/Users/egv/dev/yolo-runner/internal/runner/runner_test.go:\n  Line 141: func (e *eventRecorder) Emit(event Event) {\n\n/Users/egv/dev/yolo-runner/internal/runner/runner.go:\n  Line 194: \temitter.Emit(Event{\n\n/Users/egv/dev/yolo-runner/internal/runner/events.go:\n  Line 29: \tEmit(event Event)","title":"Emit\\(","metadata":{"matches":3,"truncated":false},"time":{"start":1768839937506,"end":1768839937521}},"metadata":{"openai":{"itemId":"fc_0a3700e0cbe9b66b01696e5b011cb48191a238de063065f583"}}}}
{"type":"step_finish","timestamp":1768839937634,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd7137e53001U0A2vaHgkTb1tB","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd7136d53001kJDxD274NPEaGv","type":"step-finish","reason":"tool-calls","snapshot":"9838413a81cceed4628ff0f4aac2ff4c090b1d1e","cost":0,"tokens":{"input":160,"output":167,"reasoning":128,"cache":{"read":23168,"write":0}}}}
{"type":"step_start","timestamp":1768839938015,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd7137fde001JnQ2Je4njI63Ti","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd7137e75001HJDupPNXztP5Vc","type":"step-start","snapshot":"b2738057d814ce145a5e37a92a2daa40a8a36404"}}
{"type":"tool_use","timestamp":1768839939360,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd7138185001wl9yXtqPksdQkn","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd7137e75001HJDupPNXztP5Vc","type":"tool","callID":"call_jEOnS5unTeOFVUrStA6TqtoR","tool":"read","state":{"status":"completed","input":{"filePath":"/Users/egv/dev/yolo-runner/internal/runner/runner_test.go","offset":120,"limit":120},"output":"<file>\n00121| func (f *fakeGit) RevParseHead() (string, error) {\n00122| \tif f.recorder != nil {\n00123| \t\tf.recorder.record(\"git.rev-parse\")\n00124| \t}\n00125| \treturn f.rev, nil\n00126| }\n00127| \n00128| type fakeLogger struct {\n00129| \trecorder *callRecorder\n00130| \tentries  []logEntry\n00131| }\n00132| \n00133| type logEntry struct {\n00134| \tstatus string\n00135| }\n00136| \n00137| type eventRecorder struct {\n00138| \tevents []Event\n00139| }\n00140| \n00141| func (e *eventRecorder) Emit(event Event) {\n00142| \te.events = append(e.events, event)\n00143| }\n00144| \n00145| func assertEvents(t *testing.T, events []Event, expected ...EventType) {\n00146| \tt.Helper()\n00147| \tif len(events) != len(expected) {\n00148| \t\tt.Fatalf(\"expected %d events, got %d\", len(expected), len(events))\n00149| \t}\n00150| \tfor i, event := range events {\n00151| \t\tif event.Type != expected[i] {\n00152| \t\t\tt.Fatalf(\"event %d expected %q, got %q\", i, expected[i], event.Type)\n00153| \t\t}\n00154| \t\tif event.Phase == \"\" {\n00155| \t\t\tt.Fatalf(\"event %d expected phase\", i)\n00156| \t\t}\n00157| \t}\n00158| }\n00159| \n00160| func (f *fakeLogger) AppendRunnerSummary(repoRoot string, issueID string, title string, status string, commitSHA string) error {\n00161| \tif f.recorder != nil {\n00162| \t\tf.recorder.record(\"log.append:\" + status)\n00163| \t}\n00164| \tf.entries = append(f.entries, logEntry{status: status})\n00165| \treturn nil\n00166| }\n00167| \n00168| func TestRunOnceNoTasks(t *testing.T) {\n00169| \trecorder := &callRecorder{}\n00170| \tbeads := &fakeBeads{\n00171| \t\trecorder:   recorder,\n00172| \t\treadyIssue: Issue{ID: \"root\", IssueType: \"epic\", Status: \"open\"},\n00173| \t}\n00174| \tdeps := RunOnceDeps{\n00175| \t\tBeads:    beads,\n00176| \t\tPrompt:   &fakePrompt{recorder: recorder, prompt: \"PROMPT\"},\n00177| \t\tOpenCode: &fakeOpenCode{recorder: recorder},\n00178| \t\tGit:      &fakeGit{recorder: recorder},\n00179| \t\tLogger:   &fakeLogger{recorder: recorder},\n00180| \t}\n00181| \topts := RunOnceOptions{RepoRoot: \"/repo\", RootID: \"root\", Out: &bytes.Buffer{}}\n00182| \n00183| \tresult, err := RunOnce(opts, deps)\n00184| \tif err != nil {\n00185| \t\tt.Fatalf(\"unexpected error: %v\", err)\n00186| \t}\n00187| \tif result != \"no_tasks\" {\n00188| \t\tt.Fatalf(\"expected no_tasks, got %q\", result)\n00189| \t}\n00190| \tif strings.Join(recorder.calls, \",\") != \"beads.ready\" {\n00191| \t\tt.Fatalf(\"unexpected calls: %v\", recorder.calls)\n00192| \t}\n00193| }\n00194| \n00195| func TestRunOnceDryRun(t *testing.T) {\n00196| \trecorder := &callRecorder{}\n00197| \tbeads := &fakeBeads{\n00198| \t\trecorder:   recorder,\n00199| \t\treadyIssue: Issue{ID: \"task-1\", IssueType: \"task\", Status: \"open\"},\n00200| \t\tshowQueue: []Bead{{\n00201| \t\t\tID:                 \"task-1\",\n00202| \t\t\tTitle:              \"Test Task\",\n00203| \t\t\tDescription:        \"Desc\",\n00204| \t\t\tAcceptanceCriteria: \"Acceptance\",\n00205| \t\t}},\n00206| \t}\n00207| \toutput := &bytes.Buffer{}\n00208| \tdeps := RunOnceDeps{\n00209| \t\tBeads:    beads,\n00210| \t\tPrompt:   &fakePrompt{recorder: recorder, prompt: \"PROMPT\"},\n00211| \t\tOpenCode: &fakeOpenCode{recorder: recorder},\n00212| \t\tGit:      &fakeGit{recorder: recorder},\n00213| \t\tLogger:   &fakeLogger{recorder: recorder},\n00214| \t}\n00215| \topts := RunOnceOptions{RepoRoot: \"/repo\", RootID: \"root\", DryRun: true, Out: output}\n00216| \n00217| \tresult, err := RunOnce(opts, deps)\n00218| \tif err != nil {\n00219| \t\tt.Fatalf(\"unexpected error: %v\", err)\n00220| \t}\n00221| \tif result != \"dry_run\" {\n00222| \t\tt.Fatalf(\"expected dry_run, got %q\", result)\n00223| \t}\n00224| \tprinted := output.String()\n00225| \tif !strings.Contains(printed, \"Task: task-1 - Test Task\") {\n00226| \t\tt.Fatalf(\"expected task line in output, got %q\", printed)\n00227| \t}\n00228| \tif !strings.Contains(printed, \"PROMPT\") {\n00229| \t\tt.Fatalf(\"expected prompt in output, got %q\", printed)\n00230| \t}\n00231| \tif !strings.Contains(printed, \"Command: opencode run PROMPT --agent yolo --format json /repo\") {\n00232| \t\tt.Fatalf(\"expected command in output, got %q\", printed)\n00233| \t}\n00234| \texpectedCalls := \"beads.ready,beads.show,prompt.build\"\n00235| \tif strings.Join(recorder.calls, \",\") != expectedCalls {\n00236| \t\tt.Fatalf(\"unexpected calls: %v\", recorder.calls)\n00237| \t}\n00238| }\n00239| \n00240| func TestRunOnceNoChangesBlocksTask(t *testing.T) {\n\n(File has more lines. Use 'offset' parameter to read beyond line 240)\n</file>","title":"internal/runner/runner_test.go","metadata":{"preview":"func (f *fakeGit) RevParseHead() (string, error) {\n\tif f.recorder != nil {\n\t\tf.recorder.record(\"git.rev-parse\")\n\t}\n\treturn f.rev, nil\n}\n\ntype fakeLogger struct {\n\trecorder *callRecorder\n\tentries  []logEntry\n}\n\ntype logEntry struct {\n\tstatus string\n}\n\ntype eventRecorder struct {\n\tevents []Event\n}\n","truncated":true},"time":{"start":1768839939359,"end":1768839939360}},"metadata":{"openai":{"itemId":"fc_06301a73f928950801696e5b02762c8191a87cc3106ac64492"}}}}
{"type":"step_finish","timestamp":1768839939393,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd7138535001cKEkKKSFXDj90l","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd7137e75001HJDupPNXztP5Vc","type":"step-finish","reason":"tool-calls","snapshot":"23180ddbc4ebbc4cf5f9fff144b9c57bc6cdc1ef","cost":0,"tokens":{"input":299,"output":42,"reasoning":0,"cache":{"read":23168,"write":0}}}}
{"type":"step_start","timestamp":1768839939731,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd7138693001SLeSXLlU3hHyHX","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd7138552001pKaPVr47zeRRpR","type":"step-start","snapshot":"eb193998d9100e1bfbfc1dbef8034ff4a976daf4"}}
{"type":"tool_use","timestamp":1768839941634,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd7138a9d001IWnEYpapEjsVwB","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd7138552001pKaPVr47zeRRpR","type":"tool","callID":"call_NuL1tq7fOZz4KABdO4E0kcHL","tool":"grep","state":{"status":"completed","input":{"pattern":"internal/ui/tui|tui.New|tui.Model|EventEmitter|tea.NewProgram","path":"/Users/egv/dev/yolo-runner","include":"*.go"},"output":"Found 4 matches\n/Users/egv/dev/yolo-runner/internal/runner/runner.go:\n  Line 54: \tEvents   EventEmitter\n  Line 190: func emitPhase(emitter EventEmitter, eventType EventType, issueID string, title string) {\n\n/Users/egv/dev/yolo-runner/internal/runner/events.go:\n  Line 28: type EventEmitter interface {\n\n/Users/egv/dev/yolo-runner/bubbletea_test.go:\n  Line 24: \tprogram := tea.NewProgram(testModel{})","title":"internal/ui/tui|tui.New|tui.Model|EventEmitter|tea.NewProgram","metadata":{"matches":4,"truncated":false},"time":{"start":1768839941617,"end":1768839941633}},"metadata":{"openai":{"itemId":"fc_090f4d5da7ed044601696e5b04c760819193d18ac826d49a17"}}}}
{"type":"step_finish","timestamp":1768839941649,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd7138e02001e9cBi5WT2yxYaq","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd7138552001pKaPVr47zeRRpR","type":"step-finish","reason":"tool-calls","snapshot":"d2fb4531f1e4568b88e548a9c3699ed8c6429e0e","cost":0,"tokens":{"input":1780,"output":56,"reasoning":0,"cache":{"read":23168,"write":0}}}}
{"type":"step_start","timestamp":1768839942174,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd713901e001Ot6qhkXPUH0DDI","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd7138e270016dvM9NIx6v53Ac","type":"step-start","snapshot":"ad1a626b82b30dfe098c8da99305f928388748ba"}}
{"type":"tool_use","timestamp":1768839959978,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd713d458001cZ2f25pv9gdE1A","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd7138e270016dvM9NIx6v53Ac","type":"tool","callID":"call_4G7WHsP0B0vKaTknCTP28Lf9","tool":"read","state":{"status":"completed","input":{"filePath":"/Users/egv/dev/yolo-runner/go.mod"},"output":"<file>\n00001| module yolo-runner\n00002| \n00003| go 1.21\n00004| \n00005| require (\n00006| \tgithub.com/aymanbagabas/go-osc52/v2 v2.0.1 // indirect\n00007| \tgithub.com/charmbracelet/bubbletea v0.25.0 // indirect\n00008| \tgithub.com/containerd/console v1.0.4-0.20230313162750-1ae8d489ac81 // indirect\n00009| \tgithub.com/lucasb-eyer/go-colorful v1.2.0 // indirect\n00010| \tgithub.com/mattn/go-isatty v0.0.18 // indirect\n00011| \tgithub.com/mattn/go-localereader v0.0.1 // indirect\n00012| \tgithub.com/mattn/go-runewidth v0.0.14 // indirect\n00013| \tgithub.com/muesli/ansi v0.0.0-20211018074035-2e021307bc4b // indirect\n00014| \tgithub.com/muesli/cancelreader v0.2.2 // indirect\n00015| \tgithub.com/muesli/reflow v0.3.0 // indirect\n00016| \tgithub.com/muesli/termenv v0.15.2 // indirect\n00017| \tgithub.com/rivo/uniseg v0.2.0 // indirect\n00018| \tgolang.org/x/sync v0.1.0 // indirect\n00019| \tgolang.org/x/sys v0.7.0 // indirect\n00020| \tgolang.org/x/term v0.6.0 // indirect\n00021| \tgolang.org/x/text v0.3.8 // indirect\n00022| )\n00023| \n\n(End of file - total 23 lines)\n</file>","title":"go.mod","metadata":{"preview":"module yolo-runner\n\ngo 1.21\n\nrequire (\n\tgithub.com/aymanbagabas/go-osc52/v2 v2.0.1 // indirect\n\tgithub.com/charmbracelet/bubbletea v0.25.0 // indirect\n\tgithub.com/containerd/console v1.0.4-0.20230313162750-1ae8d489ac81 // indirect\n\tgithub.com/lucasb-eyer/go-colorful v1.2.0 // indirect\n\tgithub.com/mattn/go-isatty v0.0.18 // indirect\n\tgithub.com/mattn/go-localereader v0.0.1 // indirect\n\tgithub.com/mattn/go-runewidth v0.0.14 // indirect\n\tgithub.com/muesli/ansi v0.0.0-20211018074035-2e021307bc4b // indirect\n\tgithub.com/muesli/cancelreader v0.2.2 // indirect\n\tgithub.com/muesli/reflow v0.3.0 // indirect\n\tgithub.com/muesli/termenv v0.15.2 // indirect\n\tgithub.com/rivo/uniseg v0.2.0 // indirect\n\tgolang.org/x/sync v0.1.0 // indirect\n\tgolang.org/x/sys v0.7.0 // indirect\n\tgolang.org/x/term v0.6.0 // indirect","truncated":false},"time":{"start":1768839959977,"end":1768839959978}},"metadata":{"openai":{"itemId":"fc_0fac77c2fa23b87601696e5b17a31c8191aa7851612605353b"}}}}
{"type":"step_finish","timestamp":1768839960032,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd713d5d1001m2NkGn2Q2qweN2","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd7138e270016dvM9NIx6v53Ac","type":"step-finish","reason":"tool-calls","snapshot":"ef6d14f631275abf5eccaf3fb771fa6b41d5805f","cost":0,"tokens":{"input":933,"output":799,"reasoning":768,"cache":{"read":24192,"write":0}}}}
{"type":"step_start","timestamp":1768839960358,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd713d726001Qm4LM7sNpaFKVs","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd713d5f6001652fzkf2clyKGB","type":"step-start","snapshot":"8d3d322746a0c99ad596f88c6e1723d8b11e3239"}}
{"type":"tool_use","timestamp":1768839969616,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd713f934001rQusqb12ermJmt","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd713d5f6001652fzkf2clyKGB","type":"tool","callID":"call_jAEQ98knpNO936rAjb3nlYth","tool":"grep","state":{"status":"completed","input":{"pattern":"EventEmitter|Emit\\(","path":"/Users/egv/dev/yolo-runner","include":"*.go"},"output":"Found 6 matches\n/Users/egv/dev/yolo-runner/internal/runner/runner_test.go:\n  Line 141: func (e *eventRecorder) Emit(event Event) {\n\n/Users/egv/dev/yolo-runner/internal/runner/runner.go:\n  Line 54: \tEvents   EventEmitter\n  Line 190: func emitPhase(emitter EventEmitter, eventType EventType, issueID string, title string) {\n  Line 194: \temitter.Emit(Event{\n\n/Users/egv/dev/yolo-runner/internal/runner/events.go:\n  Line 28: type EventEmitter interface {\n  Line 29: \tEmit(event Event)","title":"EventEmitter|Emit\\(","metadata":{"matches":6,"truncated":false},"time":{"start":1768839969603,"end":1768839969616}},"metadata":{"openai":{"itemId":"fc_0604f764365a0c4e01696e5b210ddc8191b76c1c2f9a4a07f5"}}}}
{"type":"step_finish","timestamp":1768839969654,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd713fb66001D93n61vnVPiJwR","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd713d5f6001652fzkf2clyKGB","type":"step-finish","reason":"tool-calls","snapshot":"103f4dfb6fdb0e2328d5e20b457efe544f06579a","cost":0,"tokens":{"input":1400,"output":428,"reasoning":384,"cache":{"read":24192,"write":0}}}}
{"type":"step_start","timestamp":1768839970013,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd713fcdc001MCpxYOL4RFPL81","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd713fb8c001GgEufKk3M6pByt","type":"step-start","snapshot":"fa6b3b7f59edb4d46f2528a2cf2c2d5438922fee"}}
{"type":"tool_use","timestamp":1768839971185,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd713fe930016Kx1gDOcEYzSYf","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd713fb8c001GgEufKk3M6pByt","type":"tool","callID":"call_w4O9hZuu4xw8d5bgC5fiM3cP","tool":"grep","state":{"status":"completed","input":{"pattern":"Events:","path":"/Users/egv/dev/yolo-runner","include":"*.go"},"output":"Found 3 matches\n/Users/egv/dev/yolo-runner/internal/runner/runner_test.go:\n  Line 306: \t\tEvents:   events,\n  Line 370: \t\tEvents:   &eventRecorder{},\n\n/Users/egv/dev/yolo-runner/internal/runner/runner_watchdog_test.go:\n  Line 25: \t\tEvents:   &eventRecorder{},","title":"Events:","metadata":{"matches":3,"truncated":false},"time":{"start":1768839971177,"end":1768839971185}},"metadata":{"openai":{"itemId":"fc_0db9f061ad43347601696e5b227acc8191a02730b6f0ed1da8"}}}}
{"type":"step_finish","timestamp":1768839971204,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd714017700195umk1zlianlR8","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd713fb8c001GgEufKk3M6pByt","type":"step-finish","reason":"tool-calls","snapshot":"6338eab50cf29281a0a4086c3505de85bee01131","cost":0,"tokens":{"input":566,"output":38,"reasoning":0,"cache":{"read":25216,"write":0}}}}
{"type":"step_start","timestamp":1768839971546,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd71402d9001T2Y0Cp2Xw02F1e","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd7140197001JoPJe36h86v5yk","type":"step-start","snapshot":"9fdc0f08d1d0f4bc44d9de17765131a83dc4689d"}}
{"type":"tool_use","timestamp":1768839972984,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd71405b8001Rwjo6WVVxanqWl","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd7140197001JoPJe36h86v5yk","type":"tool","callID":"call_4y87jmZYpMYMmKS0Dm3PADNt","tool":"read","state":{"status":"completed","input":{"filePath":"/Users/egv/dev/yolo-runner/internal/runner/runner_test.go","offset":280,"limit":120},"output":"<file>\n00281| \t\tt.Fatalf(\"unexpected calls: %v\", recorder.calls)\n00282| \t}\n00283| \tif len(logger.entries) != 1 || logger.entries[0].status != \"blocked\" {\n00284| \t\tt.Fatalf(\"expected blocked log entry, got %#v\", logger.entries)\n00285| \t}\n00286| }\n00287| \n00288| func TestRunOnceChangesCommitCloseSync(t *testing.T) {\n00289| \trecorder := &callRecorder{}\n00290| \tbeads := &fakeBeads{\n00291| \t\trecorder:   recorder,\n00292| \t\treadyIssue: Issue{ID: \"task-1\", IssueType: \"task\", Status: \"open\"},\n00293| \t\tshowQueue: []Bead{\n00294| \t\t\t{ID: \"task-1\", Title: \"My Task\", Status: \"open\"},\n00295| \t\t\t{ID: \"task-1\", Status: \"closed\"},\n00296| \t\t},\n00297| \t}\n00298| \tlogger := &fakeLogger{recorder: recorder}\n00299| \tevents := &eventRecorder{}\n00300| \tdeps := RunOnceDeps{\n00301| \t\tBeads:    beads,\n00302| \t\tPrompt:   &fakePrompt{recorder: recorder, prompt: \"PROMPT\"},\n00303| \t\tOpenCode: &fakeOpenCode{recorder: recorder},\n00304| \t\tGit:      &fakeGit{recorder: recorder, dirty: true, rev: \"deadbeef\"},\n00305| \t\tLogger:   logger,\n00306| \t\tEvents:   events,\n00307| \t}\n00308| \n00309| \topts := RunOnceOptions{RepoRoot: \"/repo\", RootID: \"root\", Out: &bytes.Buffer{}}\n00310| \n00311| \tresult, err := RunOnce(opts, deps)\n00312| \tif err != nil {\n00313| \t\tt.Fatalf(\"unexpected error: %v\", err)\n00314| \t}\n00315| \tif result != \"completed\" {\n00316| \t\tt.Fatalf(\"expected completed, got %q\", result)\n00317| \t}\n00318| \texpectedCalls := []string{\n00319| \t\t\"beads.ready\",\n00320| \t\t\"beads.show\",\n00321| \t\t\"prompt.build\",\n00322| \t\t\"beads.update:in_progress\",\n00323| \t\t\"opencode.run\",\n00324| \t\t\"git.add\",\n00325| \t\t\"git.dirty\",\n00326| \t\t\"git.commit:feat: my task\",\n00327| \t\t\"git.rev-parse\",\n00328| \t\t\"log.append:completed\",\n00329| \t\t\"beads.close\",\n00330| \t\t\"beads.show\",\n00331| \t\t\"beads.sync\",\n00332| \t}\n00333| \tif strings.Join(recorder.calls, \",\") != strings.Join(expectedCalls, \",\") {\n00334| \t\tt.Fatalf(\"unexpected calls: %v\", recorder.calls)\n00335| \t}\n00336| \tif len(logger.entries) != 1 || logger.entries[0].status != \"completed\" {\n00337| \t\tt.Fatalf(\"expected completed log entry, got %#v\", logger.entries)\n00338| \t}\n00339| \tassertEvents(t, events.events,\n00340| \t\tEventSelectTask,\n00341| \t\tEventBeadsUpdate,\n00342| \t\tEventOpenCodeStart,\n00343| \t\tEventOpenCodeEnd,\n00344| \t\tEventGitAdd,\n00345| \t\tEventGitStatus,\n00346| \t\tEventGitCommit,\n00347| \t\tEventBeadsClose,\n00348| \t\tEventBeadsVerify,\n00349| \t\tEventBeadsSync,\n00350| \t)\n00351| }\n00352| \n00353| func TestRunOnceUsesFallbackCommitMessage(t *testing.T) {\n00354| \trecorder := &callRecorder{}\n00355| \tbeads := &fakeBeads{\n00356| \t\trecorder:   recorder,\n00357| \t\treadyIssue: Issue{ID: \"task-1\", IssueType: \"task\", Status: \"open\"},\n00358| \t\tshowQueue: []Bead{\n00359| \t\t\t{ID: \"task-1\", Title: \"\", Status: \"open\"},\n00360| \t\t\t{ID: \"task-1\", Status: \"closed\"},\n00361| \t\t},\n00362| \t}\n00363| \tlogger := &fakeLogger{recorder: recorder}\n00364| \tdeps := RunOnceDeps{\n00365| \t\tBeads:    beads,\n00366| \t\tPrompt:   &fakePrompt{recorder: recorder, prompt: \"PROMPT\"},\n00367| \t\tOpenCode: &fakeOpenCode{recorder: recorder},\n00368| \t\tGit:      &fakeGit{recorder: recorder, dirty: true, rev: \"abc123\"},\n00369| \t\tLogger:   logger,\n00370| \t\tEvents:   &eventRecorder{},\n00371| \t}\n00372| \n00373| \topts := RunOnceOptions{RepoRoot: \"/repo\", RootID: \"root\", Out: &bytes.Buffer{}}\n00374| \n00375| \t_, err := RunOnce(opts, deps)\n00376| \tif err != nil {\n00377| \t\tt.Fatalf(\"unexpected error: %v\", err)\n00378| \t}\n00379| \tfound := false\n00380| \tfor _, call := range recorder.calls {\n00381| \t\tif call == \"git.commit:feat: complete bead task\" {\n00382| \t\t\tfound = true\n00383| \t\t}\n00384| \t}\n00385| \tif !found {\n00386| \t\tt.Fatalf(\"expected fallback commit message, got %v\", recorder.calls)\n00387| \t}\n00388| }\n00389| \n\n(End of file - total 389 lines)\n</file>","title":"internal/runner/runner_test.go","metadata":{"preview":"\t\tt.Fatalf(\"unexpected calls: %v\", recorder.calls)\n\t}\n\tif len(logger.entries) != 1 || logger.entries[0].status != \"blocked\" {\n\t\tt.Fatalf(\"expected blocked log entry, got %#v\", logger.entries)\n\t}\n}\n\nfunc TestRunOnceChangesCommitCloseSync(t *testing.T) {\n\trecorder := &callRecorder{}\n\tbeads := &fakeBeads{\n\t\trecorder:   recorder,\n\t\treadyIssue: Issue{ID: \"task-1\", IssueType: \"task\", Status: \"open\"},\n\t\tshowQueue: []Bead{\n\t\t\t{ID: \"task-1\", Title: \"My Task\", Status: \"open\"},\n\t\t\t{ID: \"task-1\", Status: \"closed\"},\n\t\t},\n\t}\n\tlogger := &fakeLogger{recorder: recorder}\n\tevents := &eventRecorder{}\n\tdeps := RunOnceDeps{","truncated":false},"time":{"start":1768839972983,"end":1768839972984}},"metadata":{"openai":{"itemId":"fc_0384c605ca150c9701696e5b244e3881919e6b0fe89cd9893d"}}}}
{"type":"step_finish","timestamp":1768839973028,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd7140897001JsuCsDJLN0lMAH","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd7140197001JoPJe36h86v5yk","type":"step-finish","reason":"tool-calls","snapshot":"8dafd92f077673bb985cd615f0f005a6e668050d","cost":0,"tokens":{"input":695,"output":42,"reasoning":0,"cache":{"read":25216,"write":0}}}}
{"type":"step_start","timestamp":1768839973395,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd7140a130019UwuOWjoKtlR4H","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd71408b90012EJQHY6TkOGmsM","type":"step-start","snapshot":"753c405b5a816b65ddcfeb5d6057bc38b05a51d8"}}
{"type":"tool_use","timestamp":1768840123047,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd7165057001MhVYJBJryBqPrV","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd71408b90012EJQHY6TkOGmsM","type":"tool","callID":"call_peSUsDomiLDmbEmJZDFkrPNJ","tool":"bash","state":{"status":"completed","input":{"command":"go env GOPATH","description":"Shows GOPATH value"},"output":"/Users/egv/go\n","title":"Shows GOPATH value","metadata":{"output":"/Users/egv/go\n","exit":0,"description":"Shows GOPATH value","truncated":false},"time":{"start":1768840123026,"end":1768840123047}},"metadata":{"openai":{"itemId":"fc_05f1d833964f7b3401696e5bba697c8191bf802548f08e53bc"}}}}
{"type":"step_finish","timestamp":1768840123111,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd71652d9001L75WA913097acZ","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd71408b90012EJQHY6TkOGmsM","type":"step-finish","reason":"tool-calls","snapshot":"3eb82b176b39f13a33c01a5cb45cba4e228435b7","cost":0,"tokens":{"input":1534,"output":6814,"reasoning":6784,"cache":{"read":25728,"write":0}}}}
{"type":"step_start","timestamp":1768840123530,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd7165489001w5N6ejD78MHPfj","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd71652fc001w969uZT1cnl8qi","type":"step-start","snapshot":"ae6bb7ac078d152b525d3760897850c43632b842"}}
{"type":"tool_use","timestamp":1768840166118,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd716f756001B4izspIEQOVC4L","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd71652fc001w969uZT1cnl8qi","type":"tool","callID":"call_IN11d60z7AXMGfwfLDibkAai","tool":"glob","state":{"status":"completed","input":{"pattern":"**/bubbletea@*/program.go","path":"/Users/egv/go/pkg/mod"},"output":"No files found","title":"../../go/pkg/mod","metadata":{"count":0,"truncated":false},"time":{"start":1768840165844,"end":1768840166117}},"metadata":{"openai":{"itemId":"fc_093180cf4236da5101696e5be539148191abe2c7cc0ce78aed"}}}}
{"type":"step_finish","timestamp":1768840166138,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd716fae6001MQqTdiZ2be1u6H","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd71652fc001w969uZT1cnl8qi","type":"step-finish","reason":"tool-calls","snapshot":"0aa3c0d5ac1d659b7caa30116119419ebf18e9d4","cost":0,"tokens":{"input":1065,"output":1829,"reasoning":1792,"cache":{"read":26240,"write":0}}}}
{"type":"step_start","timestamp":1768840166665,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd716fd09001hSUTzSJDq6tez0","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd716fb0e001CWRa5rF3LFuBtY","type":"step-start","snapshot":"bb026246a31acedec967ec84b663aa1e3c7cfc5c"}}
{"type":"tool_use","timestamp":1768840168774,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd717007c001RadPropNoAub46","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd716fb0e001CWRa5rF3LFuBtY","type":"tool","callID":"call_O7AMdcE5eSc20zPNE5i2x0mw","tool":"glob","state":{"status":"completed","input":{"pattern":"**/bubbletea@*/","path":"/Users/egv/go/pkg/mod"},"output":"No files found","title":"../../go/pkg/mod","metadata":{"count":0,"truncated":false},"time":{"start":1768840168582,"end":1768840168774}},"metadata":{"openai":{"itemId":"fc_08c92b2e7369cccf01696e5be77c208191a67b29b2ccf10b11"}}}}
{"type":"step_finish","timestamp":1768840168788,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd7170546001yEl5tdvRQHY8nb","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd716fb0e001CWRa5rF3LFuBtY","type":"step-finish","reason":"tool-calls","snapshot":"435ec7807b3f1edd5d08b63dcd93b2c61c8fe022","cost":0,"tokens":{"input":1110,"output":33,"reasoning":0,"cache":{"read":26240,"write":0}}}}
{"type":"step_start","timestamp":1768840169175,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd71706d7001ipjPoQ1aEevRYs","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd7170568001FpBI0A8XOoHve8","type":"step-start","snapshot":"1af6d69637d9277668e0988a2e03ba42f9a72cbe"}}
{"type":"tool_use","timestamp":1768840171244,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd7170b25001bUoOTPyLcUNSqd","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd7170568001FpBI0A8XOoHve8","type":"tool","callID":"call_b5pOjob9KmLa1sWO6YzCFjgr","tool":"glob","state":{"status":"completed","input":{"pattern":"github.com/charmbracelet/bubbletea@v0.25.0/**","path":"/Users/egv/go/pkg/mod"},"output":"/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/tea_test.go\n/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/tty_windows.go\n/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/tty_unix.go\n/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/tea.go\n/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/standard_renderer.go\n/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/tty.go\n/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/signals_unix.go\n/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/options_test.go\n/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/screen_test.go\n/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/signals_windows.go\n/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/mouse.go\n/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/renderer.go\n/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/logging_test.go\n/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/key_test.go\n/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/screen.go\n/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/logging.go\n/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/options.go\n/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/nil_renderer_test.go\n/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/nil_renderer.go\n/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/mouse_test.go\n/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/key_sequences.go\n/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/commands.go\n/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/CONTRIBUTING.md\n/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/.golangci-soft.yml\n/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/README.md\n/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/.golangci.yml\n/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/key.go\n/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/go.sum\n/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/exec.go\n/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/commands_test.go\n/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/LICENSE\n/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/exec_test.go\n/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/go.mod\n/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/.github/dependabot.yml\n/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/.github/ISSUE_TEMPLATE/config.yml\n/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/.github/ISSUE_TEMPLATE/bug_report.md\n/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/.github/ISSUE_TEMPLATE/feature_request.md\n/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/.github/ISSUE_TEMPLATE/bug.yml\n/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/.github/workflows/build.yml\n/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/.github/workflows/lint-soft.yml\n/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/.github/workflows/examples.yml\n/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/.github/workflows/lint.yml\n/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/.github/workflows/coverage.yml\n/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/.gitignore\n/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/.gitattributes","title":"../../go/pkg/mod","metadata":{"count":45,"truncated":false},"time":{"start":1768840171055,"end":1768840171243}},"metadata":{"openai":{"itemId":"fc_0546b8caa686269901696e5bea4c288191bee22bb218999210"}}}}
{"type":"step_finish","timestamp":1768840171258,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd7170eec001CkGsypPwpOUYj7","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd7170568001FpBI0A8XOoHve8","type":"step-finish","reason":"tool-calls","snapshot":"e51551afe13596bfd2670e7f2bd49a7c0a9fb5d0","cost":0,"tokens":{"input":129,"output":46,"reasoning":0,"cache":{"read":27264,"write":0}}}}
{"type":"step_start","timestamp":1768840171621,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd7171065001kvnkdWuPAzVUx9","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd7170f0d001EwNcTz4AV83KRM","type":"step-start","snapshot":"2f8b12ab4f4a17ea1d63d5ba5095a72ccc40ab9a"}}
{"type":"tool_use","timestamp":1768840173070,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd7171244001pPmrMAb8k94o33","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd7170f0d001EwNcTz4AV83KRM","type":"tool","callID":"call_PURDgAmc42AeVXOGq4QWy52B","tool":"read","state":{"status":"completed","input":{"filePath":"/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/tea.go","offset":1,"limit":200},"output":"<file>\n00002| // based on the paradigms of The Elm Architecture. It's well-suited for simple\n00003| // and complex terminal applications, either inline, full-window, or a mix of\n00004| // both. It's been battle-tested in several large projects and is\n00005| // production-ready.\n00006| //\n00007| // A tutorial is available at https://github.com/charmbracelet/bubbletea/tree/master/tutorials\n00008| //\n00009| // Example programs can be found at https://github.com/charmbracelet/bubbletea/tree/master/examples\n00010| package tea\n00011| \n00012| import (\n00013| \t\"context\"\n00014| \t\"errors\"\n00015| \t\"fmt\"\n00016| \t\"io\"\n00017| \t\"os\"\n00018| \t\"os/signal\"\n00019| \t\"runtime/debug\"\n00020| \t\"sync\"\n00021| \t\"sync/atomic\"\n00022| \t\"syscall\"\n00023| \n00024| \t\"github.com/containerd/console\"\n00025| \tisatty \"github.com/mattn/go-isatty\"\n00026| \t\"github.com/muesli/cancelreader\"\n00027| \t\"github.com/muesli/termenv\"\n00028| \t\"golang.org/x/sync/errgroup\"\n00029| )\n00030| \n00031| // ErrProgramKilled is returned by [Program.Run] when the program got killed.\n00032| var ErrProgramKilled = errors.New(\"program was killed\")\n00033| \n00034| // Msg contain data from the result of a IO operation. Msgs trigger the update\n00035| // function and, henceforth, the UI.\n00036| type Msg interface{}\n00037| \n00038| // Model contains the program's state as well as its core functions.\n00039| type Model interface {\n00040| \t// Init is the first function that will be called. It returns an optional\n00041| \t// initial command. To not perform an initial command return nil.\n00042| \tInit() Cmd\n00043| \n00044| \t// Update is called when a message is received. Use it to inspect messages\n00045| \t// and, in response, update the model and/or send a command.\n00046| \tUpdate(Msg) (Model, Cmd)\n00047| \n00048| \t// View renders the program's UI, which is just a string. The view is\n00049| \t// rendered after every Update.\n00050| \tView() string\n00051| }\n00052| \n00053| // Cmd is an IO operation that returns a message when it's complete. If it's\n00054| // nil it's considered a no-op. Use it for things like HTTP requests, timers,\n00055| // saving and loading from disk, and so on.\n00056| //\n00057| // Note that there's almost never a reason to use a command to send a message\n00058| // to another part of your program. That can almost always be done in the\n00059| // update function.\n00060| type Cmd func() Msg\n00061| \n00062| type inputType int\n00063| \n00064| const (\n00065| \tdefaultInput inputType = iota\n00066| \tttyInput\n00067| \tcustomInput\n00068| )\n00069| \n00070| // String implements the stringer interface for [inputType]. It is inteded to\n00071| // be used in testing.\n00072| func (i inputType) String() string {\n00073| \treturn [...]string{\n00074| \t\t\"default input\",\n00075| \t\t\"tty input\",\n00076| \t\t\"custom input\",\n00077| \t}[i]\n00078| }\n00079| \n00080| // Options to customize the program during its initialization. These are\n00081| // generally set with ProgramOptions.\n00082| //\n00083| // The options here are treated as bits.\n00084| type startupOptions byte\n00085| \n00086| func (s startupOptions) has(option startupOptions) bool {\n00087| \treturn s&option != 0\n00088| }\n00089| \n00090| const (\n00091| \twithAltScreen startupOptions = 1 << iota\n00092| \twithMouseCellMotion\n00093| \twithMouseAllMotion\n00094| \twithANSICompressor\n00095| \twithoutSignalHandler\n00096| \n00097| \t// Catching panics is incredibly useful for restoring the terminal to a\n00098| \t// usable state after a panic occurs. When this is set, Bubble Tea will\n00099| \t// recover from panics, print the stack trace, and disable raw mode. This\n00100| \t// feature is on by default.\n00101| \twithoutCatchPanics\n00102| )\n00103| \n00104| // handlers manages series of channels returned by various processes. It allows\n00105| // us to wait for those processes to terminate before exiting the program.\n00106| type handlers []chan struct{}\n00107| \n00108| // Adds a channel to the list of handlers. We wait for all handlers to terminate\n00109| // gracefully on shutdown.\n00110| func (h *handlers) add(ch chan struct{}) {\n00111| \t*h = append(*h, ch)\n00112| }\n00113| \n00114| // shutdown waits for all handlers to terminate.\n00115| func (h handlers) shutdown() {\n00116| \tvar wg sync.WaitGroup\n00117| \tfor _, ch := range h {\n00118| \t\twg.Add(1)\n00119| \t\tgo func(ch chan struct{}) {\n00120| \t\t\t<-ch\n00121| \t\t\twg.Done()\n00122| \t\t}(ch)\n00123| \t}\n00124| \twg.Wait()\n00125| }\n00126| \n00127| // Program is a terminal user interface.\n00128| type Program struct {\n00129| \tinitialModel Model\n00130| \n00131| \t// Configuration options that will set as the program is initializing,\n00132| \t// treated as bits. These options can be set via various ProgramOptions.\n00133| \tstartupOptions startupOptions\n00134| \n00135| \tinputType inputType\n00136| \n00137| \tctx    context.Context\n00138| \tcancel context.CancelFunc\n00139| \n00140| \tmsgs     chan Msg\n00141| \terrs     chan error\n00142| \tfinished chan struct{}\n00143| \n00144| \t// where to send output, this will usually be os.Stdout.\n00145| \toutput        *termenv.Output\n00146| \trestoreOutput func() error\n00147| \trenderer      renderer\n00148| \n00149| \t// where to read inputs from, this will usually be os.Stdin.\n00150| \tinput        io.Reader\n00151| \tcancelReader cancelreader.CancelReader\n00152| \treadLoopDone chan struct{}\n00153| \tconsole      console.Console\n00154| \n00155| \t// was the altscreen active before releasing the terminal?\n00156| \taltScreenWasActive bool\n00157| \tignoreSignals      uint32\n00158| \n00159| \t// Stores the original reference to stdin for cases where input is not a\n00160| \t// TTY on windows and we've automatically opened CONIN$ to receive input.\n00161| \t// When the program exits this will be restored.\n00162| \t//\n00163| \t// Lint ignore note: the linter will find false positive on unix systems\n00164| \t// as this value only comes into play on Windows, hence the ignore comment\n00165| \t// below.\n00166| \twindowsStdin *os.File //nolint:golint,structcheck,unused\n00167| \n00168| \tfilter func(Model, Msg) Msg\n00169| \n00170| \t// fps is the frames per second we should set on the renderer, if\n00171| \t// applicable,\n00172| \tfps int\n00173| }\n00174| \n00175| // Quit is a special command that tells the Bubble Tea program to exit.\n00176| func Quit() Msg {\n00177| \treturn QuitMsg{}\n00178| }\n00179| \n00180| // QuitMsg signals that the program should quit. You can send a QuitMsg with\n00181| // Quit.\n00182| type QuitMsg struct{}\n00183| \n00184| // NewProgram creates a new Program.\n00185| func NewProgram(model Model, opts ...ProgramOption) *Program {\n00186| \tp := &Program{\n00187| \t\tinitialModel: model,\n00188| \t\tmsgs:         make(chan Msg),\n00189| \t}\n00190| \n00191| \t// Apply all options to the program.\n00192| \tfor _, opt := range opts {\n00193| \t\topt(p)\n00194| \t}\n00195| \n00196| \t// A context can be provided with a ProgramOption, but if none was provided\n00197| \t// we'll use the default background context.\n00198| \tif p.ctx == nil {\n00199| \t\tp.ctx = context.Background()\n00200| \t}\n00201| \t// Initialize context and teardown channel.\n\n(File has more lines. Use 'offset' parameter to read beyond line 201)\n</file>","title":"../../go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/tea.go","metadata":{"preview":"// based on the paradigms of The Elm Architecture. It's well-suited for simple\n// and complex terminal applications, either inline, full-window, or a mix of\n// both. It's been battle-tested in several large projects and is\n// production-ready.\n//\n// A tutorial is available at https://github.com/charmbracelet/bubbletea/tree/master/tutorials\n//\n// Example programs can be found at https://github.com/charmbracelet/bubbletea/tree/master/examples\npackage tea\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"os/signal\"\n\t\"runtime/debug\"\n\t\"sync\"\n\t\"sync/atomic\"","truncated":true},"time":{"start":1768840173069,"end":1768840173070}},"metadata":{"openai":{"itemId":"fc_0d1c93bb2cfbd78101696e5bec20dc8191a71119a7ada045c4"}}}}
{"type":"step_finish","timestamp":1768840173134,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd717163d0017UU8QPtMslXSSp","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd7170f0d001EwNcTz4AV83KRM","type":"step-finish","reason":"tool-calls","snapshot":"b5a6e6599218213f6162e3065d671564cea5d2fb","cost":0,"tokens":{"input":1505,"output":52,"reasoning":0,"cache":{"read":27264,"write":0}}}}
{"type":"step_start","timestamp":1768840173484,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd71717ac001mcACXShsJWGc5t","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd7171663001JGcwJwewVurnKA","type":"step-start","snapshot":"3ce8941fc0b1d2eb4db1ae7caf93061cb8cac2c7"}}
{"type":"tool_use","timestamp":1768840174969,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd717193d0013xqF1K1cVFPPbw","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd7171663001JGcwJwewVurnKA","type":"tool","callID":"call_VpHbK4c2bLVI6SNYYtVfbU4h","tool":"read","state":{"status":"completed","input":{"filePath":"/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/tty_unix.go","offset":1,"limit":160},"output":"<file>\n00002| // +build darwin dragonfly freebsd linux netbsd openbsd solaris aix\n00003| \n00004| package tea\n00005| \n00006| import (\n00007| \t\"fmt\"\n00008| \t\"os\"\n00009| \n00010| \t\"github.com/containerd/console\"\n00011| )\n00012| \n00013| func (p *Program) initInput() error {\n00014| \t// If input's a file, use console to manage it\n00015| \tif f, ok := p.input.(*os.File); ok {\n00016| \t\tc, err := console.ConsoleFromFile(f)\n00017| \t\tif err != nil {\n00018| \t\t\treturn nil //nolint:nilerr // ignore error, this was just a test\n00019| \t\t}\n00020| \t\tp.console = c\n00021| \t}\n00022| \n00023| \treturn nil\n00024| }\n00025| \n00026| // On unix systems, RestoreInput closes any TTYs we opened for input. Note that\n00027| // we don't do this on Windows as it causes the prompt to not be drawn until\n00028| // the terminal receives a keypress rather than appearing promptly after the\n00029| // program exits.\n00030| func (p *Program) restoreInput() error {\n00031| \tif p.console != nil {\n00032| \t\tif err := p.console.Reset(); err != nil {\n00033| \t\t\treturn fmt.Errorf(\"error restoring console: %w\", err)\n00034| \t\t}\n00035| \t}\n00036| \treturn nil\n00037| }\n00038| \n00039| func openInputTTY() (*os.File, error) {\n00040| \tf, err := os.Open(\"/dev/tty\")\n00041| \tif err != nil {\n00042| \t\treturn nil, fmt.Errorf(\"could not open a new TTY: %w\", err)\n00043| \t}\n00044| \treturn f, nil\n00045| }\n00046| \n\n(End of file - total 46 lines)\n</file>","title":"../../go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/tty_unix.go","metadata":{"preview":"// +build darwin dragonfly freebsd linux netbsd openbsd solaris aix\n\npackage tea\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\n\t\"github.com/containerd/console\"\n)\n\nfunc (p *Program) initInput() error {\n\t// If input's a file, use console to manage it\n\tif f, ok := p.input.(*os.File); ok {\n\t\tc, err := console.ConsoleFromFile(f)\n\t\tif err != nil {\n\t\t\treturn nil //nolint:nilerr // ignore error, this was just a test\n\t\t}\n\t\tp.console = c\n\t}","truncated":false},"time":{"start":1768840174968,"end":1768840174969}},"metadata":{"openai":{"itemId":"fc_014582f2d136101901696e5bede7e08191bfb020f125b5749d"}}}}
{"type":"step_finish","timestamp":1768840175033,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd7171da9001otdF2Ilg6f5siF","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd7171663001JGcwJwewVurnKA","type":"step-finish","reason":"tool-calls","snapshot":"395dc519b01b93b4de6c0144b830ca14276c382b","cost":0,"tokens":{"input":2252,"output":54,"reasoning":0,"cache":{"read":28672,"write":0}}}}
{"type":"step_start","timestamp":1768840175573,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd7171fd400141RpPKmWVNwCOC","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd7171dd0001NMtCWi1FzIU8z7","type":"step-start","snapshot":"be0636690b87c210a748c6f041fd11e28940d1b0"}}
{"type":"tool_use","timestamp":1768840177285,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd71720e7001tKxH4D8Iar8L7S","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd7171dd0001NMtCWi1FzIU8z7","type":"tool","callID":"call_oD70Y5MtlqaK0peEhpdanOui","tool":"read","state":{"status":"completed","input":{"filePath":"/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/tty.go","offset":1,"limit":200},"output":"<file>\n00002| \n00003| import (\n00004| \t\"errors\"\n00005| \t\"fmt\"\n00006| \t\"io\"\n00007| \t\"os\"\n00008| \t\"time\"\n00009| \n00010| \tisatty \"github.com/mattn/go-isatty\"\n00011| \tlocalereader \"github.com/mattn/go-localereader\"\n00012| \t\"github.com/muesli/cancelreader\"\n00013| \t\"golang.org/x/term\"\n00014| )\n00015| \n00016| func (p *Program) initTerminal() error {\n00017| \terr := p.initInput()\n00018| \tif err != nil {\n00019| \t\treturn err\n00020| \t}\n00021| \n00022| \tif p.console != nil {\n00023| \t\terr = p.console.SetRaw()\n00024| \t\tif err != nil {\n00025| \t\t\treturn fmt.Errorf(\"error entering raw mode: %w\", err)\n00026| \t\t}\n00027| \t}\n00028| \n00029| \tp.renderer.hideCursor()\n00030| \treturn nil\n00031| }\n00032| \n00033| // restoreTerminalState restores the terminal to the state prior to running the\n00034| // Bubble Tea program.\n00035| func (p *Program) restoreTerminalState() error {\n00036| \tif p.renderer != nil {\n00037| \t\tp.renderer.showCursor()\n00038| \t\tp.disableMouse()\n00039| \n00040| \t\tif p.renderer.altScreen() {\n00041| \t\t\tp.renderer.exitAltScreen()\n00042| \n00043| \t\t\t// give the terminal a moment to catch up\n00044| \t\t\ttime.Sleep(time.Millisecond * 10) //nolint:gomnd\n00045| \t\t}\n00046| \t}\n00047| \n00048| \tif p.console != nil {\n00049| \t\terr := p.console.Reset()\n00050| \t\tif err != nil {\n00051| \t\t\treturn fmt.Errorf(\"error restoring terminal state: %w\", err)\n00052| \t\t}\n00053| \t}\n00054| \n00055| \treturn p.restoreInput()\n00056| }\n00057| \n00058| // initCancelReader (re)commences reading inputs.\n00059| func (p *Program) initCancelReader() error {\n00060| \tvar err error\n00061| \tp.cancelReader, err = cancelreader.NewReader(p.input)\n00062| \tif err != nil {\n00063| \t\treturn fmt.Errorf(\"error creating cancelreader: %w\", err)\n00064| \t}\n00065| \n00066| \tp.readLoopDone = make(chan struct{})\n00067| \tgo p.readLoop()\n00068| \n00069| \treturn nil\n00070| }\n00071| \n00072| func (p *Program) readLoop() {\n00073| \tdefer close(p.readLoopDone)\n00074| \n00075| \tinput := localereader.NewReader(p.cancelReader)\n00076| \terr := readInputs(p.ctx, p.msgs, input)\n00077| \tif !errors.Is(err, io.EOF) && !errors.Is(err, cancelreader.ErrCanceled) {\n00078| \t\tselect {\n00079| \t\tcase <-p.ctx.Done():\n00080| \t\tcase p.errs <- err:\n00081| \t\t}\n00082| \t}\n00083| }\n00084| \n00085| // waitForReadLoop waits for the cancelReader to finish its read loop.\n00086| func (p *Program) waitForReadLoop() {\n00087| \tselect {\n00088| \tcase <-p.readLoopDone:\n00089| \tcase <-time.After(500 * time.Millisecond): //nolint:gomnd\n00090| \t\t// The read loop hangs, which means the input\n00091| \t\t// cancelReader's cancel function has returned true even\n00092| \t\t// though it was not able to cancel the read.\n00093| \t}\n00094| }\n00095| \n00096| // checkResize detects the current size of the output and informs the program\n00097| // via a WindowSizeMsg.\n00098| func (p *Program) checkResize() {\n00099| \tf, ok := p.output.TTY().(*os.File)\n00100| \tif !ok || !isatty.IsTerminal(f.Fd()) {\n00101| \t\t// can't query window size\n00102| \t\treturn\n00103| \t}\n00104| \n00105| \tw, h, err := term.GetSize(int(f.Fd()))\n00106| \tif err != nil {\n00107| \t\tselect {\n00108| \t\tcase <-p.ctx.Done():\n00109| \t\tcase p.errs <- err:\n00110| \t\t}\n00111| \n00112| \t\treturn\n00113| \t}\n00114| \n00115| \tp.Send(WindowSizeMsg{\n00116| \t\tWidth:  w,\n00117| \t\tHeight: h,\n00118| \t})\n00119| }\n00120| \n\n(End of file - total 120 lines)\n</file>","title":"../../go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/tty.go","metadata":{"preview":"\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"time\"\n\n\tisatty \"github.com/mattn/go-isatty\"\n\tlocalereader \"github.com/mattn/go-localereader\"\n\t\"github.com/muesli/cancelreader\"\n\t\"golang.org/x/term\"\n)\n\nfunc (p *Program) initTerminal() error {\n\terr := p.initInput()\n\tif err != nil {\n\t\treturn err\n\t}\n","truncated":false},"time":{"start":1768840177284,"end":1768840177285}},"metadata":{"openai":{"itemId":"fc_02fb756b710ae67a01696e5befe04c8191a150053f5fa705b6"}}}}
{"type":"step_finish","timestamp":1768840177332,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd71726a7001cKeGD8Pvtd68eN","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd7171dd0001NMtCWi1FzIU8z7","type":"step-finish","reason":"tool-calls","snapshot":"a12310e33c289713d25dd07cd6c6cf0b99c0100c","cost":0,"tokens":{"input":600,"output":52,"reasoning":0,"cache":{"read":30848,"write":0}}}}
{"type":"step_start","timestamp":1768840177771,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd717286a001aCM0v0m03nyeC0","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd71726c8001jXdcnZwBJfknd6","type":"step-start","snapshot":"c209c50c0feaa0425370b8d39db48e4893e206dd"}}
{"type":"tool_use","timestamp":1768840222656,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd717d5b7001Ffh6rHByAtT7Sk","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd71726c8001jXdcnZwBJfknd6","type":"tool","callID":"call_NkAODa5ltWo70Mu6tnEyAlUp","tool":"read","state":{"status":"completed","input":{"filePath":"/Users/egv/dev/yolo-runner/internal/opencode/watchdog.go"},"output":"<file>\n00001| package opencode\n00002| \n00003| import (\n00004| \t\"bufio\"\n00005| \t\"errors\"\n00006| \t\"fmt\"\n00007| \t\"os\"\n00008| \t\"path/filepath\"\n00009| \t\"strings\"\n00010| \t\"time\"\n00011| )\n00012| \n00013| const defaultWatchdogTimeout = 10 * time.Minute\n00014| const defaultWatchdogInterval = 5 * time.Second\n00015| const defaultWatchdogLogTail = 20\n00016| \n00017| var defaultHomeDir = os.UserHomeDir\n00018| \n00019| const (\n00020| \tstallPermission = \"permission\"\n00021| \tstallQuestion   = \"question\"\n00022| \tstallNoOutput   = \"no_output\"\n00023| )\n00024| \n00025| type Process interface {\n00026| \tWait() error\n00027| \tKill() error\n00028| }\n00029| \n00030| type WatchdogConfig struct {\n00031| \tLogPath        string\n00032| \tOpenCodeLogDir string\n00033| \tTimeout        time.Duration\n00034| \tInterval       time.Duration\n00035| \tTailLines      int\n00036| \tNow            func() time.Time\n00037| }\n00038| \n00039| type Watchdog struct {\n00040| \tconfig WatchdogConfig\n00041| }\n00042| \n00043| type StallError struct {\n00044| \tCategory      string\n00045| \tOpenCodeLog   string\n00046| \tSessionID     string\n00047| \tLogPath       string\n00048| \tLastOutputAge time.Duration\n00049| \tTail          []string\n00050| }\n00051| \n00052| func (err *StallError) Error() string {\n00053| \tparts := []string{\n00054| \t\t\"opencode stall\",\n00055| \t\t\"category=\" + err.Category,\n00056| \t}\n00057| \tif err.LogPath != \"\" {\n00058| \t\tparts = append(parts, \"runner_log=\"+err.LogPath)\n00059| \t}\n00060| \tif err.OpenCodeLog != \"\" {\n00061| \t\tparts = append(parts, \"opencode_log=\"+err.OpenCodeLog)\n00062| \t}\n00063| \tif err.SessionID != \"\" {\n00064| \t\tparts = append(parts, \"session=\"+err.SessionID)\n00065| \t}\n00066| \tif err.LastOutputAge > 0 {\n00067| \t\tparts = append(parts, fmt.Sprintf(\"last_output_age=%s\", err.LastOutputAge))\n00068| \t}\n00069| \tif len(err.Tail) > 0 {\n00070| \t\tparts = append(parts, \"opencode_tail=\"+strings.Join(err.Tail, \" | \"))\n00071| \t}\n00072| \treturn strings.Join(parts, \" \")\n00073| }\n00074| \n00075| func NewWatchdog(config WatchdogConfig) *Watchdog {\n00076| \treturn &Watchdog{config: config}\n00077| }\n00078| \n00079| func (watchdog *Watchdog) Monitor(process Process) error {\n00080| \tif process == nil {\n00081| \t\treturn errors.New(\"watchdog requires process\")\n00082| \t}\n00083| \tconfig := watchdog.config\n00084| \tif config.Timeout <= 0 {\n00085| \t\tconfig.Timeout = defaultWatchdogTimeout\n00086| \t}\n00087| \tif config.Interval <= 0 {\n00088| \t\tconfig.Interval = defaultWatchdogInterval\n00089| \t}\n00090| \tif config.TailLines <= 0 {\n00091| \t\tconfig.TailLines = defaultWatchdogLogTail\n00092| \t}\n00093| \tif config.Now == nil {\n00094| \t\tconfig.Now = time.Now\n00095| \t}\n00096| \tif config.OpenCodeLogDir == \"\" {\n00097| \t\thome, err := defaultHomeDir()\n00098| \t\tif err == nil {\n00099| \t\t\tconfig.OpenCodeLogDir = filepath.Join(home, \".local\", \"share\", \"opencode\", \"log\")\n00100| \t\t}\n00101| \t}\n00102| \n00103| \tlastOutput, err := fileModTime(config.LogPath)\n00104| \tif err != nil {\n00105| \t\tlastOutput = config.Now()\n00106| \t}\n00107| \tlastSize := fileSize(config.LogPath)\n00108| \tstartTime := config.Now()\n00109| \tif config.LogPath == \"\" {\n00110| \t\tlastOutput = startTime\n00111| \t}\n00112| \n00113| \tdone := make(chan error, 1)\n00114| \tgo func() {\n00115| \t\tdone <- process.Wait()\n00116| \t}()\n00117| \n00118| \tticker := time.NewTicker(config.Interval)\n00119| \tdefer ticker.Stop()\n00120| \n00121| \tfor {\n00122| \t\tselect {\n00123| \t\tcase err := <-done:\n00124| \t\t\treturn err\n00125| \t\tcase <-ticker.C:\n00126| \t\t\tcurrentTime := config.Now()\n00127| \t\t\tcurrentSize := fileSize(config.LogPath)\n00128| \t\t\tif currentSize > lastSize {\n00129| \t\t\t\tlastSize = currentSize\n00130| \t\t\t\tif modTime, modErr := fileModTime(config.LogPath); modErr == nil {\n00131| \t\t\t\t\tlastOutput = modTime\n00132| \t\t\t\t} else {\n00133| \t\t\t\t\tlastOutput = currentTime\n00134| \t\t\t\t}\n00135| \t\t\t}\n00136| \t\t\tif currentTime.Sub(lastOutput) > config.Timeout {\n00137| \t\t\t\tstall := classifyStall(config, currentTime, lastOutput)\n00138| \t\t\t\t_ = process.Kill()\n00139| \t\t\t\treturn stall\n00140| \t\t\t}\n00141| \t\t}\n00142| \t}\n00143| }\n00144| \n00145| func classifyStall(config WatchdogConfig, now time.Time, lastOutput time.Time) *StallError {\n00146| \tlatestLog := latestLogPath(config.OpenCodeLogDir)\n00147| \tlines := tailLines(latestLog, config.TailLines)\n00148| \tcategory := stallNoOutput\n00149| \tfor _, line := range lines {\n00150| \t\tif strings.Contains(line, \"service=permission\") || strings.Contains(line, \"permission=doom_loop\") {\n00151| \t\t\tcategory = stallPermission\n00152| \t\t\tbreak\n00153| \t\t}\n00154| \t\tif strings.Contains(line, \"service=question\") || strings.Contains(line, \"permission=question\") {\n00155| \t\t\tcategory = stallQuestion\n00156| \t\t\tbreak\n00157| \t\t}\n00158| \t}\n00159| \tstall := &StallError{\n00160| \t\tCategory:      category,\n00161| \t\tOpenCodeLog:   latestLog,\n00162| \t\tSessionID:     extractSessionID(lines),\n00163| \t\tLogPath:       config.LogPath,\n00164| \t\tLastOutputAge: now.Sub(lastOutput),\n00165| \t\tTail:          lines,\n00166| \t}\n00167| \treturn stall\n00168| }\n00169| \n00170| func latestLogPath(dir string) string {\n00171| \tif dir == \"\" {\n00172| \t\treturn \"\"\n00173| \t}\n00174| \tentries, err := os.ReadDir(dir)\n00175| \tif err != nil {\n00176| \t\treturn \"\"\n00177| \t}\n00178| \tvar latest string\n00179| \tvar latestTime time.Time\n00180| \tfor _, entry := range entries {\n00181| \t\tif entry.IsDir() {\n00182| \t\t\tcontinue\n00183| \t\t}\n00184| \t\tinfo, err := entry.Info()\n00185| \t\tif err != nil {\n00186| \t\t\tcontinue\n00187| \t\t}\n00188| \t\tmod := info.ModTime()\n00189| \t\tif latest == \"\" || mod.After(latestTime) {\n00190| \t\t\tlatest = filepath.Join(dir, entry.Name())\n00191| \t\t\tlatestTime = mod\n00192| \t\t}\n00193| \t}\n00194| \treturn latest\n00195| }\n00196| \n00197| func tailLines(path string, limit int) []string {\n00198| \tif path == \"\" || limit <= 0 {\n00199| \t\treturn nil\n00200| \t}\n00201| \tfile, err := os.Open(path)\n00202| \tif err != nil {\n00203| \t\treturn nil\n00204| \t}\n00205| \tdefer file.Close()\n00206| \tlines := []string{}\n00207| \tscanner := bufio.NewScanner(file)\n00208| \tbuf := make([]byte, 0, 64*1024)\n00209| \tscanner.Buffer(buf, 1024*1024)\n00210| \tfor scanner.Scan() {\n00211| \t\tlines = append(lines, scanner.Text())\n00212| \t\tif len(lines) > limit {\n00213| \t\t\tlines = lines[1:]\n00214| \t\t}\n00215| \t}\n00216| \treturn lines\n00217| }\n00218| \n00219| func extractSessionID(lines []string) string {\n00220| \tfor _, line := range lines {\n00221| \t\tif strings.Contains(line, \"sessionID=\") {\n00222| \t\t\tparts := strings.Split(line, \"sessionID=\")\n00223| \t\t\tif len(parts) > 1 {\n00224| \t\t\t\trest := parts[1]\n00225| \t\t\t\tfor i, r := range rest {\n00226| \t\t\t\t\tif r == ' ' || r == '\\t' || r == ',' {\n00227| \t\t\t\t\t\treturn rest[:i]\n00228| \t\t\t\t\t}\n00229| \t\t\t\t}\n00230| \t\t\t\treturn rest\n00231| \t\t\t}\n00232| \t\t}\n00233| \t\tif strings.Contains(line, \"session id=\") {\n00234| \t\t\tparts := strings.Split(line, \"session id=\")\n00235| \t\t\tif len(parts) > 1 {\n00236| \t\t\t\trest := parts[1]\n00237| \t\t\t\tfor i, r := range rest {\n00238| \t\t\t\t\tif r == ' ' || r == '\\t' || r == ',' {\n00239| \t\t\t\t\t\treturn rest[:i]\n00240| \t\t\t\t\t}\n00241| \t\t\t\t}\n00242| \t\t\t\treturn rest\n00243| \t\t\t}\n00244| \t\t}\n00245| \t}\n00246| \treturn \"\"\n00247| }\n00248| \n00249| func fileSize(path string) int64 {\n00250| \tinfo, err := os.Stat(path)\n00251| \tif err != nil {\n00252| \t\treturn 0\n00253| \t}\n00254| \treturn info.Size()\n00255| }\n00256| \n00257| func fileModTime(path string) (time.Time, error) {\n00258| \tinfo, err := os.Stat(path)\n00259| \tif err != nil {\n00260| \t\treturn time.Time{}, err\n00261| \t}\n00262| \treturn info.ModTime(), nil\n00263| }\n00264| \n\n(End of file - total 264 lines)\n</file>","title":"internal/opencode/watchdog.go","metadata":{"preview":"package opencode\n\nimport (\n\t\"bufio\"\n\t\"errors\"\n\t\"fmt\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"time\"\n)\n\nconst defaultWatchdogTimeout = 10 * time.Minute\nconst defaultWatchdogInterval = 5 * time.Second\nconst defaultWatchdogLogTail = 20\n\nvar defaultHomeDir = os.UserHomeDir\n\nconst (\n\tstallPermission = \"permission\"","truncated":false},"time":{"start":1768840222655,"end":1768840222656}},"metadata":{"openai":{"itemId":"fc_096b8a89c4bf487201696e5c1e254c819191d5f07d236a509a"}}}}
{"type":"step_finish","timestamp":1768840222757,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd717d818001cZhTIx2G3VXqbe","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd71726c8001jXdcnZwBJfknd6","type":"step-finish","reason":"tool-calls","snapshot":"407649b98fec30b52807c01c8fcc672336290a31","cost":0,"tokens":{"input":1273,"output":1891,"reasoning":1856,"cache":{"read":31360,"write":0}}}}
{"type":"step_start","timestamp":1768840223181,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd717d9cc001QRUWn3sBPsYL42","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd717d84000197CNBOh5PkVu3Y","type":"step-start","snapshot":"2c61b2a8fee3eed8fd4a323f0766d8c43f1455f4"}}
{"type":"tool_use","timestamp":1768840228927,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd717eae80010CgFh2qu0D0zen","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd717d84000197CNBOh5PkVu3Y","type":"tool","callID":"call_8FPSmV2sanbhU8SLVHaPEkb9","tool":"grep","state":{"status":"completed","input":{"pattern":"type .*EventEmitter|struct .*Emitter|Emit\\(event","path":"/Users/egv/dev/yolo-runner","include":"*.go"},"output":"Found 3 matches\n/Users/egv/dev/yolo-runner/internal/runner/runner_test.go:\n  Line 141: func (e *eventRecorder) Emit(event Event) {\n\n/Users/egv/dev/yolo-runner/internal/runner/events.go:\n  Line 28: type EventEmitter interface {\n  Line 29: \tEmit(event Event)","title":"type .*EventEmitter|struct .*Emitter|Emit\\(event","metadata":{"matches":3,"truncated":false},"time":{"start":1768840228911,"end":1768840228926}},"metadata":{"openai":{"itemId":"fc_057e19d662690c1201696e5c2387448191988f2d6cfc91e84c"}}}}
{"type":"step_finish","timestamp":1768840228980,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd717f066001n954iarcelFEKM","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd717d84000197CNBOh5PkVu3Y","type":"step-finish","reason":"tool-calls","snapshot":"51250edea4248fbaab1552905557cec0091291d7","cost":0,"tokens":{"input":2796,"output":178,"reasoning":128,"cache":{"read":32384,"write":0}}}}
{"type":"step_start","timestamp":1768840230203,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd717f53a001giN0US1HBy0qqQ","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd717f08a001Tg0aZwEvLG9ROZ","type":"step-start","snapshot":"8acfe069f54204b471048af8d91f00aab96b9364"}}
{"type":"tool_use","timestamp":1768840360742,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd719effa001gZet5rFPgiXEHS","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd717f08a001Tg0aZwEvLG9ROZ","type":"tool","callID":"call_F9kSPcPIrWWLLwYUmggyQJ3B","tool":"grep","state":{"status":"completed","input":{"pattern":"func \\(p \\*Program\\) Start","path":"/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0","include":"*.go"},"output":"Found 2 matches\n/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/tea.go:\n  Line 578: func (p *Program) StartReturningModel() (Model, error) {\n  Line 587: func (p *Program) Start() error {","title":"func \\(p \\*Program\\) Start","metadata":{"matches":2,"truncated":false},"time":{"start":1768840360735,"end":1768840360742}},"metadata":{"openai":{"itemId":"fc_0f7aa48290e616c701696e5ca7eb3c8191803bc9c322743fb6"}}}}
{"type":"step_finish","timestamp":1768840360844,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd719f37a001hzQDkMcHMZyN0x","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd717f08a001Tg0aZwEvLG9ROZ","type":"step-finish","reason":"tool-calls","snapshot":"78edcae2c47b6e3ae6499d30ea637641f2b2eada","cost":0,"tokens":{"input":880,"output":6013,"reasoning":5952,"cache":{"read":34432,"write":0}}}}
{"type":"step_start","timestamp":1768840361277,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd719f53d001WNz3RuTJ24maCX","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd719f3a1001gfEAFkv0yJQ5yF","type":"step-start","snapshot":"aa184eed215bbf37a750d390416bca0e52b8bc6d"}}
{"type":"tool_use","timestamp":1768840362639,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd719f6b800107eqRZ1vbPP3qm","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd719f3a1001gfEAFkv0yJQ5yF","type":"tool","callID":"call_mZkmL07R4s7Tikqy2yuD3bnG","tool":"read","state":{"status":"completed","input":{"filePath":"/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/tea.go","offset":560,"limit":80},"output":"<file>\n00561| \t\t_ = p.cancelReader.Close()\n00562| \t}\n00563| \n00564| \t// Wait for all handlers to finish.\n00565| \thandlers.shutdown()\n00566| \n00567| \t// Restore terminal state.\n00568| \tp.shutdown(killed)\n00569| \n00570| \treturn model, err\n00571| }\n00572| \n00573| // StartReturningModel initializes the program and runs its event loops,\n00574| // blocking until it gets terminated by either [Program.Quit], [Program.Kill],\n00575| // or its signal handler. Returns the final model.\n00576| //\n00577| // Deprecated: please use [Program.Run] instead.\n00578| func (p *Program) StartReturningModel() (Model, error) {\n00579| \treturn p.Run()\n00580| }\n00581| \n00582| // Start initializes the program and runs its event loops, blocking until it\n00583| // gets terminated by either [Program.Quit], [Program.Kill], or its signal\n00584| // handler.\n00585| //\n00586| // Deprecated: please use [Program.Run] instead.\n00587| func (p *Program) Start() error {\n00588| \t_, err := p.Run()\n00589| \treturn err\n00590| }\n00591| \n00592| // Send sends a message to the main update function, effectively allowing\n00593| // messages to be injected from outside the program for interoperability\n00594| // purposes.\n00595| //\n00596| // If the program hasn't started yet this will be a blocking operation.\n00597| // If the program has already been terminated this will be a no-op, so it's safe\n00598| // to send messages after the program has exited.\n00599| func (p *Program) Send(msg Msg) {\n00600| \tselect {\n00601| \tcase <-p.ctx.Done():\n00602| \tcase p.msgs <- msg:\n00603| \t}\n00604| }\n00605| \n00606| // Quit is a convenience function for quitting Bubble Tea programs. Use it\n00607| // when you need to shut down a Bubble Tea program from the outside.\n00608| //\n00609| // If you wish to quit from within a Bubble Tea program use the Quit command.\n00610| //\n00611| // If the program is not running this will be a no-op, so it's safe to call\n00612| // if the program is unstarted or has already exited.\n00613| func (p *Program) Quit() {\n00614| \tp.Send(Quit())\n00615| }\n00616| \n00617| // Kill stops the program immediately and restores the former terminal state.\n00618| // The final render that you would normally see when quitting will be skipped.\n00619| // [program.Run] returns a [ErrProgramKilled] error.\n00620| func (p *Program) Kill() {\n00621| \tp.cancel()\n00622| }\n00623| \n00624| // Wait waits/blocks until the underlying Program finished shutting down.\n00625| func (p *Program) Wait() {\n00626| \t<-p.finished\n00627| }\n00628| \n00629| // shutdown performs operations to free up resources and restore the terminal\n00630| // to its original state.\n00631| func (p *Program) shutdown(kill bool) {\n00632| \tif p.renderer != nil {\n00633| \t\tif kill {\n00634| \t\t\tp.renderer.kill()\n00635| \t\t} else {\n00636| \t\t\tp.renderer.stop()\n00637| \t\t}\n00638| \t}\n00639| \n00640| \t_ = p.restoreTerminalState()\n\n(File has more lines. Use 'offset' parameter to read beyond line 640)\n</file>","title":"../../go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/tea.go","metadata":{"preview":"\t\t_ = p.cancelReader.Close()\n\t}\n\n\t// Wait for all handlers to finish.\n\thandlers.shutdown()\n\n\t// Restore terminal state.\n\tp.shutdown(killed)\n\n\treturn model, err\n}\n\n// StartReturningModel initializes the program and runs its event loops,\n// blocking until it gets terminated by either [Program.Quit], [Program.Kill],\n// or its signal handler. Returns the final model.\n//\n// Deprecated: please use [Program.Run] instead.\nfunc (p *Program) StartReturningModel() (Model, error) {\n\treturn p.Run()\n}","truncated":true},"time":{"start":1768840362638,"end":1768840362639}},"metadata":{"openai":{"itemId":"fc_09d9af394f93b46401696e5ca9abe881919f91826892eeb3f4"}}}}
{"type":"step_finish","timestamp":1768840362706,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd719fac2001PgKz1CrFqAP5Vj","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd719f3a1001gfEAFkv0yJQ5yF","type":"step-finish","reason":"tool-calls","snapshot":"cb03217aff23f2e45f59b1110d398626e6e1ef7c","cost":0,"tokens":{"input":1016,"output":52,"reasoning":0,"cache":{"read":34432,"write":0}}}}
{"type":"step_start","timestamp":1768840363073,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd719fc41001hP1fAIIYg1XQ6g","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd719faea001gduu7IQrLuR5Wh","type":"step-start","snapshot":"d90acff940cbd96fe692625494b8128a17d5534f"}}
{"type":"tool_use","timestamp":1768840365890,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd71a0385001k0CHqYhh5Q6hSY","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd719faea001gduu7IQrLuR5Wh","type":"tool","callID":"call_CLYSshON4a09lZznsWBo17O4","tool":"grep","state":{"status":"completed","input":{"pattern":"NewProgram","path":"/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0","include":"*.go"},"output":"Found 28 matches\n/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/tea_test.go:\n  Line 49: \tp := NewProgram(&testModel{}, WithInput(&in), WithOutput(&buf))\n  Line 64: \tp := NewProgram(m, WithInput(&in), WithOutput(&buf))\n  Line 92: \tp := NewProgram(m,\n  Line 126: \tp := NewProgram(m, WithInput(&in), WithOutput(&buf))\n  Line 148: \tp := NewProgram(m, WithContext(ctx), WithInput(&in), WithOutput(&buf))\n  Line 173: \tp := NewProgram(m, WithInput(&in), WithOutput(&buf))\n  Line 205: \tp := NewProgram(m, WithInput(&in), WithOutput(&buf))\n  Line 229: \tp := NewProgram(m, WithInput(&in), WithOutput(&buf))\n  Line 246: \tp := NewProgram(m, WithInput(&in), WithOutput(&buf))\n  Line 264: \tNewProgram(m, WithInput(&in), WithOutput(&buf))\n\n/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/tea.go:\n  Line 184: // NewProgram creates a new Program.\n  Line 185: func NewProgram(model Model, opts ...ProgramOption) *Program {\n\n/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/options_test.go:\n  Line 12: \t\tp := NewProgram(nil, WithOutput(&b))\n  Line 20: \t\tp := NewProgram(nil, WithInput(&b))\n  Line 30: \t\tp := NewProgram(nil, WithoutRenderer())\n  Line 40: \t\tp := NewProgram(nil, WithoutSignals())\n  Line 47: \t\tp := NewProgram(nil, WithFilter(func(_ Model, msg Msg) Msg { return msg }))\n  Line 55: \t\t\tp := NewProgram(nil, opt)\n  Line 74: \t\t\tp := NewProgram(nil, opt)\n  Line 97: \t\t\tp := NewProgram(nil, WithMouseAllMotion(), WithMouseCellMotion())\n  Line 107: \t\t\tp := NewProgram(nil, WithMouseCellMotion(), WithMouseAllMotion())\n  Line 118: \t\tp := NewProgram(nil, WithMouseAllMotion(), WithAltScreen(), WithInputTTY())\n\n/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/screen_test.go:\n  Line 62: \t\t\tp := NewProgram(m, WithInput(&in), WithOutput(&buf))\n\n/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/options.go:\n  Line 16: //\tp := NewProgram(model, WithInput(someInput), WithOutput(someOutput))\n  Line 43: //\tp := NewProgram(model, WithInput(nil))\n  Line 90: //\tp := tea.NewProgram(Model{}, tea.WithAltScreen())\n  Line 199: //\tp := tea.NewProgram(Model{}, tea.WithFilter(filter));\n\n/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/exec_test.go:\n  Line 68: \t\t\tp := NewProgram(m, WithInput(&in), WithOutput(&buf))","title":"NewProgram","metadata":{"matches":28,"truncated":false},"time":{"start":1768840365882,"end":1768840365890}},"metadata":{"openai":{"itemId":"fc_0a1536a45a8a956001696e5cacf04481919e56a4d5c503899a"}}}}
{"type":"step_finish","timestamp":1768840365905,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd71a0742001t3mOA59QLOF0c4","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd719faea001gduu7IQrLuR5Wh","type":"step-finish","reason":"tool-calls","snapshot":"3d3f0339c221c79575d5137bfd13b3ab11d250f0","cost":0,"tokens":{"input":1008,"output":51,"reasoning":0,"cache":{"read":35328,"write":0}}}}
{"type":"step_start","timestamp":1768840368165,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd71a1024001j1143XrfCYI3Md","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd71a0767001obVgXA06LoTwoM","type":"step-start","snapshot":"1830b9cce8b39d1155f49030da8de77cc1527847"}}
{"type":"tool_use","timestamp":1768840369654,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd71a11f4001SRF1AyMqiCcvUn","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd71a0767001obVgXA06LoTwoM","type":"tool","callID":"call_DMNVUKdWmQeVLI15brdp7F7L","tool":"read","state":{"status":"completed","input":{"filePath":"/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/options.go","offset":1,"limit":120},"output":"<file>\n00002| \n00003| import (\n00004| \t\"context\"\n00005| \t\"io\"\n00006| \t\"sync/atomic\"\n00007| \n00008| \t\"github.com/muesli/termenv\"\n00009| )\n00010| \n00011| // ProgramOption is used to set options when initializing a Program. Program can\n00012| // accept a variable number of options.\n00013| //\n00014| // Example usage:\n00015| //\n00016| //\tp := NewProgram(model, WithInput(someInput), WithOutput(someOutput))\n00017| type ProgramOption func(*Program)\n00018| \n00019| // WithContext lets you specify a context in which to run the Program. This is\n00020| // useful if you want to cancel the execution from outside. When a Program gets\n00021| // cancelled it will exit with an error ErrProgramKilled.\n00022| func WithContext(ctx context.Context) ProgramOption {\n00023| \treturn func(p *Program) {\n00024| \t\tp.ctx = ctx\n00025| \t}\n00026| }\n00027| \n00028| // WithOutput sets the output which, by default, is stdout. In most cases you\n00029| // won't need to use this.\n00030| func WithOutput(output io.Writer) ProgramOption {\n00031| \treturn func(p *Program) {\n00032| \t\tif o, ok := output.(*termenv.Output); ok {\n00033| \t\t\tp.output = o\n00034| \t\t} else {\n00035| \t\t\tp.output = termenv.NewOutput(output, termenv.WithColorCache(true))\n00036| \t\t}\n00037| \t}\n00038| }\n00039| \n00040| // WithInput sets the input which, by default, is stdin. In most cases you\n00041| // won't need to use this. To disable input entirely pass nil.\n00042| //\n00043| //\tp := NewProgram(model, WithInput(nil))\n00044| func WithInput(input io.Reader) ProgramOption {\n00045| \treturn func(p *Program) {\n00046| \t\tp.input = input\n00047| \t\tp.inputType = customInput\n00048| \t}\n00049| }\n00050| \n00051| // WithInputTTY opens a new TTY for input (or console input device on Windows).\n00052| func WithInputTTY() ProgramOption {\n00053| \treturn func(p *Program) {\n00054| \t\tp.inputType = ttyInput\n00055| \t}\n00056| }\n00057| \n00058| // WithoutSignalHandler disables the signal handler that Bubble Tea sets up for\n00059| // Programs. This is useful if you want to handle signals yourself.\n00060| func WithoutSignalHandler() ProgramOption {\n00061| \treturn func(p *Program) {\n00062| \t\tp.startupOptions |= withoutSignalHandler\n00063| \t}\n00064| }\n00065| \n00066| // WithoutCatchPanics disables the panic catching that Bubble Tea does by\n00067| // default. If panic catching is disabled the terminal will be in a fairly\n00068| // unusable state after a panic because Bubble Tea will not perform its usual\n00069| // cleanup on exit.\n00070| func WithoutCatchPanics() ProgramOption {\n00071| \treturn func(p *Program) {\n00072| \t\tp.startupOptions |= withoutCatchPanics\n00073| \t}\n00074| }\n00075| \n00076| // WithoutSignals will ignore OS signals.\n00077| // This is mainly useful for testing.\n00078| func WithoutSignals() ProgramOption {\n00079| \treturn func(p *Program) {\n00080| \t\tatomic.StoreUint32(&p.ignoreSignals, 1)\n00081| \t}\n00082| }\n00083| \n00084| // WithAltScreen starts the program with the alternate screen buffer enabled\n00085| // (i.e. the program starts in full window mode). Note that the altscreen will\n00086| // be automatically exited when the program quits.\n00087| //\n00088| // Example:\n00089| //\n00090| //\tp := tea.NewProgram(Model{}, tea.WithAltScreen())\n00091| //\tif _, err := p.Run(); err != nil {\n00092| //\t    fmt.Println(\"Error running program:\", err)\n00093| //\t    os.Exit(1)\n00094| //\t}\n00095| //\n00096| // To enter the altscreen once the program has already started running use the\n00097| // EnterAltScreen command.\n00098| func WithAltScreen() ProgramOption {\n00099| \treturn func(p *Program) {\n00100| \t\tp.startupOptions |= withAltScreen\n00101| \t}\n00102| }\n00103| \n00104| // WithMouseCellMotion starts the program with the mouse enabled in \"cell\n00105| // motion\" mode.\n00106| //\n00107| // Cell motion mode enables mouse click, release, and wheel events. Mouse\n00108| // movement events are also captured if a mouse button is pressed (i.e., drag\n00109| // events). Cell motion mode is better supported than all motion mode.\n00110| //\n00111| // This will try to enable the mouse in extended mode (SGR), if that is not\n00112| // supported by the terminal it will fall back to normal mode (X10).\n00113| //\n00114| // To enable mouse cell motion once the program has already started running use\n00115| // the EnableMouseCellMotion command. To disable the mouse when the program is\n00116| // running use the DisableMouse command.\n00117| //\n00118| // The mouse will be automatically disabled when the program exits.\n00119| func WithMouseCellMotion() ProgramOption {\n00120| \treturn func(p *Program) {\n00121| \t\tp.startupOptions |= withMouseCellMotion // set\n\n(File has more lines. Use 'offset' parameter to read beyond line 121)\n</file>","title":"../../go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/options.go","metadata":{"preview":"\nimport (\n\t\"context\"\n\t\"io\"\n\t\"sync/atomic\"\n\n\t\"github.com/muesli/termenv\"\n)\n\n// ProgramOption is used to set options when initializing a Program. Program can\n// accept a variable number of options.\n//\n// Example usage:\n//\n//\tp := NewProgram(model, WithInput(someInput), WithOutput(someOutput))\ntype ProgramOption func(*Program)\n\n// WithContext lets you specify a context in which to run the Program. This is\n// useful if you want to cancel the execution from outside. When a Program gets\n// cancelled it will exit with an error ErrProgramKilled.","truncated":true},"time":{"start":1768840369653,"end":1768840369654}},"metadata":{"openai":{"itemId":"fc_035b81b45d2503c301696e5cb0a7e481919e774040fdff0285"}}}}
{"type":"step_finish","timestamp":1768840369667,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd71a15f6001RoDuH5gOGjtYji","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd71a0767001obVgXA06LoTwoM","type":"step-finish","reason":"tool-calls","snapshot":"f479cf7966d3307bf91bccaa192d0367f9458ff8","cost":0,"tokens":{"input":898,"output":51,"reasoning":0,"cache":{"read":36224,"write":0}}}}
{"type":"step_start","timestamp":1768840369994,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd71a1749001kMan19528gryDP","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd71a161a001RspsL9KWzbeD3B","type":"step-start","snapshot":"3c215026e6d35ed3e487d960effada39f90f12d9"}}
{"type":"tool_use","timestamp":1768840371485,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd71a1a66001I8aGNlmKnl4fTk","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd71a161a001RspsL9KWzbeD3B","type":"tool","callID":"call_ozk4IkheKVixY5eE5sVCy95z","tool":"grep","state":{"status":"completed","input":{"pattern":"initInput","path":"/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0","include":"*.go"},"output":"Found 3 matches\n/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/tty_windows.go:\n  Line 12: func (p *Program) initInput() error {\n\n/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/tty_unix.go:\n  Line 13: func (p *Program) initInput() error {\n\n/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/tty.go:\n  Line 17: \terr := p.initInput()","title":"initInput","metadata":{"matches":3,"truncated":false},"time":{"start":1768840371479,"end":1768840371485}},"metadata":{"openai":{"itemId":"fc_0ada2ba32349248801696e5cb2bad881918dced4e6d795b6b3"}}}}
{"type":"step_finish","timestamp":1768840371524,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd71a1d32001iMg9QSr4MjRK5I","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd71a161a001RspsL9KWzbeD3B","type":"step-finish","reason":"tool-calls","snapshot":"7218737aef6f3637de0665d2bebc1abf83a013ee","cost":0,"tokens":{"input":1497,"output":51,"reasoning":0,"cache":{"read":36992,"write":0}}}}
{"type":"step_start","timestamp":1768840371898,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd71a1eb900169IocKMXvE8zeX","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd71a1d58001RdXhzTtVjZo3VL","type":"step-start","snapshot":"fc10f928540f1a5fc835071bd0425028b0c104bf"}}
{"type":"tool_use","timestamp":1768840373323,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd71a20be001fyAM7ju0c8fihl","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd71a1d58001RdXhzTtVjZo3VL","type":"tool","callID":"call_Z8qqfNie6irlOJUOUkchE8Yf","tool":"read","state":{"status":"completed","input":{"filePath":"/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/tty_windows.go","offset":1,"limit":160},"output":"<file>\n00002| // +build windows\n00003| \n00004| package tea\n00005| \n00006| import (\n00007| \t\"os\"\n00008| \n00009| \t\"github.com/containerd/console\"\n00010| )\n00011| \n00012| func (p *Program) initInput() error {\n00013| \t// If input's a file, use console to manage it\n00014| \tif f, ok := p.input.(*os.File); ok {\n00015| \t\t// Save a reference to the current stdin then replace stdin with our\n00016| \t\t// input. We do this so we can hand input off to containerd/console to\n00017| \t\t// set raw mode, and do it in this fashion because the method\n00018| \t\t// console.ConsoleFromFile isn't supported on Windows.\n00019| \t\tp.windowsStdin = os.Stdin\n00020| \t\tos.Stdin = f\n00021| \n00022| \t\t// Note: this will panic if it fails.\n00023| \t\tc := console.Current()\n00024| \t\tp.console = c\n00025| \t}\n00026| \n00027| \treturn nil\n00028| }\n00029| \n00030| // restoreInput restores stdout in the event that we placed it aside to handle\n00031| // input with CONIN$, above.\n00032| func (p *Program) restoreInput() error {\n00033| \tif p.windowsStdin != nil {\n00034| \t\tos.Stdin = p.windowsStdin\n00035| \t}\n00036| \n00037| \treturn nil\n00038| }\n00039| \n00040| // Open the Windows equivalent of a TTY.\n00041| func openInputTTY() (*os.File, error) {\n00042| \tf, err := os.OpenFile(\"CONIN$\", os.O_RDWR, 0644)\n00043| \tif err != nil {\n00044| \t\treturn nil, err\n00045| \t}\n00046| \treturn f, nil\n00047| }\n00048| \n\n(End of file - total 48 lines)\n</file>","title":"../../go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/tty_windows.go","metadata":{"preview":"// +build windows\n\npackage tea\n\nimport (\n\t\"os\"\n\n\t\"github.com/containerd/console\"\n)\n\nfunc (p *Program) initInput() error {\n\t// If input's a file, use console to manage it\n\tif f, ok := p.input.(*os.File); ok {\n\t\t// Save a reference to the current stdin then replace stdin with our\n\t\t// input. We do this so we can hand input off to containerd/console to\n\t\t// set raw mode, and do it in this fashion because the method\n\t\t// console.ConsoleFromFile isn't supported on Windows.\n\t\tp.windowsStdin = os.Stdin\n\t\tos.Stdin = f\n","truncated":false},"time":{"start":1768840373323,"end":1768840373323}},"metadata":{"openai":{"itemId":"fc_0789717c498d4d1b01696e5cb470908191a9f9eefc1665c448"}}}}
{"type":"step_finish","timestamp":1768840373338,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd71a244c001LW02pw7rCPP0S2","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd71a1d58001RdXhzTtVjZo3VL","type":"step-finish","reason":"tool-calls","snapshot":"56157fd8c824f402c2365e153b020840491aa441","cost":0,"tokens":{"input":282,"output":53,"reasoning":0,"cache":{"read":38400,"write":0}}}}
{"type":"step_start","timestamp":1768840373686,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd71a25b6001eZU2KTRc6t3IDi","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd71a2470001jnRTc9tvD1K2dJ","type":"step-start","snapshot":"81bb1a0bfb98bba89d5f059fbfb786b2295e2ed7"}}
{"type":"tool_use","timestamp":1768840375537,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd71a27d0001tsZwr2Rh7cRRt9","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd71a2470001jnRTc9tvD1K2dJ","type":"tool","callID":"call_kSFJjBmJC1kJwvFTLHc8il5w","tool":"grep","state":{"status":"completed","input":{"pattern":"startProgram|ProgramOption|NewProgram|runOnce","path":"/Users/egv/dev/yolo-runner","include":"*.go"},"output":"Found 14 matches\n/Users/egv/dev/yolo-runner/internal/runner/runner.go:\n  Line 203: func RunLoop(opts RunOnceOptions, deps RunOnceDeps, max int, runOnce func(RunOnceOptions, RunOnceDeps) (string, error)) (int, error) {\n  Line 204: \tif runOnce == nil {\n  Line 205: \t\trunOnce = RunOnce\n  Line 210: \t\tresult, err := runOnce(opts, deps)\n\n/Users/egv/dev/yolo-runner/bubbletea_test.go:\n  Line 24: \tprogram := tea.NewProgram(testModel{})\n\n/Users/egv/dev/yolo-runner/cmd/yolo-runner/main.go:\n  Line 18: type runOnceFunc func(opts runner.RunOnceOptions, deps runner.RunOnceDeps) (string, error)\n  Line 54: func RunOnceMain(args []string, runOnce runOnceFunc, exit exitFunc, stdout io.Writer, stderr io.Writer, beadsRunner beadsRunner, gitRunner gitRunner) int {\n  Line 73: \tif runOnce == nil {\n  Line 74: \t\trunOnce = runner.RunOnce\n  Line 125: \t_, err := runOnce(options, deps)\n\n/Users/egv/dev/yolo-runner/internal/runner/loop_test.go:\n  Line 7: \trunOnce := func(opts RunOnceOptions, deps RunOnceDeps) (string, error) {\n  Line 12: \tcount, err := RunLoop(RunOnceOptions{}, RunOnceDeps{}, 2, runOnce)\n  Line 27: \trunOnce := func(opts RunOnceOptions, deps RunOnceDeps) (string, error) {\n  Line 36: \tcount, err := RunLoop(RunOnceOptions{}, RunOnceDeps{}, 0, runOnce)","title":"startProgram|ProgramOption|NewProgram|runOnce","metadata":{"matches":14,"truncated":false},"time":{"start":1768840375523,"end":1768840375537}},"metadata":{"openai":{"itemId":"fc_05208293edc6946301696e5cb640548191b05935f011c33f7f"}}}}
{"type":"step_finish","timestamp":1768840375572,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd71a2d070019rO3CT4wlJ6uDe","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd71a2470001jnRTc9tvD1K2dJ","type":"step-finish","reason":"tool-calls","snapshot":"a6ec7343d7a72f4930d03538a062980f68fd874c","cost":0,"tokens":{"input":686,"output":46,"reasoning":0,"cache":{"read":38528,"write":0}}}}
{"type":"step_start","timestamp":1768840375959,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd71a2e97001aZ4W8Qou4ZzZfw","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd71a2d2d001FgUlnj3uWx5ywo","type":"step-start","snapshot":"e71aa7a28fc891ea8afc2e9de373b6933e1f1c28"}}
{"type":"step_finish","timestamp":1768840466865,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd71b919f001CMOXa72E7IBFNl","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd71a2d2d001FgUlnj3uWx5ywo","type":"step-finish","reason":"tool-calls","snapshot":"e5a9f76437c73499ba8e80457601b56c7d063022","cost":0,"tokens":{"input":1129,"output":3984,"reasoning":3904,"cache":{"read":38528,"write":0}}}}
{"type":"step_start","timestamp":1768840467241,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd71b9328001Dvn6Nx2TOn5Rqi","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd71b91ce001Eaq80JYO1EIrXf","type":"step-start","snapshot":"f40bd0f37cfd1cce67e35a6f6f6f293759a91ec1"}}
{"type":"tool_use","timestamp":1768840488386,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd71b9908001vrjMzZOEM86eNY","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd71b91ce001Eaq80JYO1EIrXf","type":"tool","callID":"call_mOJnrgtjmuWj101Hpa0mupFJ","tool":"edit","state":{"status":"completed","input":{"filePath":"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go","oldString":"func TestRunOnceMainDefaultsConfigPaths(t *testing.T) {\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tt.Setenv(\"HOME\", \"/home/user\")\n\n\tRunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\"}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif !runner.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n\tif runner.opts.ConfigRoot == \"\" {\n\t\tt.Fatalf(\"expected config root to be set\")\n\t}\n\tif runner.opts.ConfigDir == \"\" {\n\t\tt.Fatalf(\"expected config dir to be set\")\n\t}\n\texpectedConfigRoot := filepath.Join(\"/home/user\", \".config\", \"opencode-runner\")\n\tif runner.opts.ConfigRoot != expectedConfigRoot {\n\t\tt.Fatalf(\"expected config root %q, got %q\", expectedConfigRoot, runner.opts.ConfigRoot)\n\t}\n\texpectedConfigDir := filepath.Join(expectedConfigRoot, \"opencode\")\n\tif runner.opts.ConfigDir != expectedConfigDir {\n\t\tt.Fatalf(\"expected config dir %q, got %q\", expectedConfigDir, runner.opts.ConfigDir)\n\t}\n\tif exit.code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", exit.code)\n\t}\n}\n\nfunc TestOpenCodeRunDefaultsCreateConfigAndEnv(t *testing.T) {\n","newString":"func TestRunOnceMainDefaultsConfigPaths(t *testing.T) {\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tt.Setenv(\"HOME\", \"/home/user\")\n\n\tRunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\"}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif !runner.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n\tif runner.opts.ConfigRoot == \"\" {\n\t\tt.Fatalf(\"expected config root to be set\")\n\t}\n\tif runner.opts.ConfigDir == \"\" {\n\t\tt.Fatalf(\"expected config dir to be set\")\n\t}\n\texpectedConfigRoot := filepath.Join(\"/home/user\", \".config\", \"opencode-runner\")\n\tif runner.opts.ConfigRoot != expectedConfigRoot {\n\t\tt.Fatalf(\"expected config root %q, got %q\", expectedConfigRoot, runner.opts.ConfigRoot)\n\t}\n\texpectedConfigDir := filepath.Join(expectedConfigRoot, \"opencode\")\n\tif runner.opts.ConfigDir != expectedConfigDir {\n\t\tt.Fatalf(\"expected config dir %q, got %q\", expectedConfigDir, runner.opts.ConfigDir)\n\t}\n\tif exit.code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", exit.code)\n\t}\n}\n\ntype fakeEmitter struct {\n\tevents []runner.Event\n}\n\nfunc (f *fakeEmitter) Emit(event runner.Event) {\n\tf.events = append(f.events, event)\n}\n\nfunc TestRunOnceMainUsesTUIOnTTYByDefault(t *testing.T) {\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\"}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", code)\n\t}\n\tif runner.deps.Events != nil {\n\t\tt.Fatalf(\"expected no events emitter by default\")\n\t}\n}\n\nfunc TestRunOnceMainHeadlessDisablesTUI(t *testing.T) {\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\tstderr := &bytes.Buffer{}\n\temitter := &fakeEmitter{}\n\n\tRunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\", \"--headless\"}, runner.Run, exit.Exit, out, stderr, beadsRunner, gitRunner)\n\n\tif runner.deps.Events == nil {\n\t\tt.Fatalf(\"expected event emitter when headless\")\n\t}\n\trunner.deps.Events.Emit(runner.Event{Type: runner.EventSelectTask})\n\tif len(emitter.events) != 0 {\n\t\tt.Fatalf(\"unexpected events recorded by fake emitter\")\n\t}\n}\n\nfunc TestOpenCodeRunDefaultsCreateConfigAndEnv(t *testing.T) {\n"},"output":"Edit applied successfully.\n\nLSP errors detected in this file, please fix:\n<diagnostics file=\"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go\">\nERROR [213:33] runner.Event is not a type\nERROR [213:52] runner.EventSelectTask undefined (type *fakeRunOnce has no field or method EventSelectTask)\n</diagnostics>","title":"cmd/yolo-runner/main_test.go","metadata":{"diagnostics":{"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main.go":[],"/Users/egv/dev/yolo-runner/go.mod":[{"range":{"start":{"line":6,"character":44},"end":{"line":6,"character":55}},"severity":2,"source":"go mod tidy","message":"github.com/charmbracelet/bubbletea should be direct"}],"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go":[{"range":{"start":{"line":212,"character":32},"end":{"line":212,"character":37}},"severity":1,"code":"NotAType","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#NotAType"},"source":"compiler","message":"runner.Event is not a type"},{"range":{"start":{"line":212,"character":51},"end":{"line":212,"character":66}},"severity":1,"code":"MissingFieldOrMethod","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#MissingFieldOrMethod"},"source":"compiler","message":"runner.EventSelectTask undefined (type *fakeRunOnce has no field or method EventSelectTask)"}],"/Users/egv/dev/yolo-runner/bubbletea_test.go":[],"/Users/egv/dev/yolo-runner/opencode_adapter_v1.go":[{"range":{"start":{"line":24,"character":1},"end":{"line":24,"character":18}},"severity":2,"code":"default","codeDescription":{"href":"https://staticcheck.dev/docs/checks/#S1031"},"source":"S1031","message":"unnecessary nil check around range"}],"/Users/egv/dev/yolo-runner/internal/ui/tui/model.go":[],"/Users/egv/dev/yolo-runner/internal/runner/runner.go":[],"/Users/egv/dev/yolo-runner/internal/ui/tui/model_test.go":[],"/Users/egv/dev/yolo-runner/internal/runner/events.go":[],"/Users/egv/dev/yolo-runner/internal/runner/loop_test.go":[],"/Users/egv/dev/yolo-runner/internal/runner/runner_test.go":[],"/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/tea.go":[],"/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/tty_unix.go":[],"/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/tty.go":[],"/Users/egv/dev/yolo-runner/internal/opencode/watchdog.go":[],"/Users/egv/dev/yolo-runner/internal/opencode/client.go":[{"range":{"start":{"line":28,"character":1},"end":{"line":28,"character":18}},"severity":2,"code":"default","codeDescription":{"href":"https://staticcheck.dev/docs/checks/#S1031"},"source":"S1031","message":"unnecessary nil check around range"}],"/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/options.go":[],"/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/tty_windows.go":[{"range":{"start":{"line":3,"character":8},"end":{"line":3,"character":11}},"severity":2,"source":"go list","message":"This file is within module \"../../go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0\", which is not included in your workspace.\nTo fix this problem, you can add a go.work file that uses this directory.\nSee the documentation for more information on setting up your workspace:\nhttps://github.com/golang/tools/blob/master/gopls/doc/workspace.md.","data":{"Actions":[{"title":"Add a go.work file using this module","kind":"quickfix","command":{"title":"Run `go work init && go work use`","command":"gopls.run_go_work_command","arguments":[{"ViewID":"1","InitFirst":true,"Args":["use","../../go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0"]}]}}]}}]},"diff":"Index: /Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go\n===================================================================\n--- /Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go\n+++ /Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go\n@@ -170,8 +170,53 @@\n \t\tt.Fatalf(\"expected exit code 0, got %d\", exit.code)\n \t}\n }\n \n+type fakeEmitter struct {\n+\tevents []runner.Event\n+}\n+\n+func (f *fakeEmitter) Emit(event runner.Event) {\n+\tf.events = append(f.events, event)\n+}\n+\n+func TestRunOnceMainUsesTUIOnTTYByDefault(t *testing.T) {\n+\trunner := &fakeRunOnce{result: \"no_tasks\"}\n+\texit := &fakeExit{}\n+\tout := &bytes.Buffer{}\n+\tbeadsRunner := &fakeRunner{}\n+\tgitRunner := &fakeGitRunner{}\n+\n+\tcode := RunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\"}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n+\n+\tif code != 0 {\n+\t\tt.Fatalf(\"expected exit code 0, got %d\", code)\n+\t}\n+\tif runner.deps.Events != nil {\n+\t\tt.Fatalf(\"expected no events emitter by default\")\n+\t}\n+}\n+\n+func TestRunOnceMainHeadlessDisablesTUI(t *testing.T) {\n+\trunner := &fakeRunOnce{result: \"no_tasks\"}\n+\texit := &fakeExit{}\n+\tout := &bytes.Buffer{}\n+\tbeadsRunner := &fakeRunner{}\n+\tgitRunner := &fakeGitRunner{}\n+\tstderr := &bytes.Buffer{}\n+\temitter := &fakeEmitter{}\n+\n+\tRunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\", \"--headless\"}, runner.Run, exit.Exit, out, stderr, beadsRunner, gitRunner)\n+\n+\tif runner.deps.Events == nil {\n+\t\tt.Fatalf(\"expected event emitter when headless\")\n+\t}\n+\trunner.deps.Events.Emit(runner.Event{Type: runner.EventSelectTask})\n+\tif len(emitter.events) != 0 {\n+\t\tt.Fatalf(\"unexpected events recorded by fake emitter\")\n+\t}\n+}\n+\n func TestOpenCodeRunDefaultsCreateConfigAndEnv(t *testing.T) {\n \ttempDir := t.TempDir()\n \trepoRoot := filepath.Join(tempDir, \"repo\")\n \tif err := os.MkdirAll(repoRoot, 0o755); err != nil {\n","filediff":{"file":"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go","before":"package main\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"yolo-runner/internal/opencode\"\n\t\"yolo-runner/internal/runner\"\n)\n\ntype fakeRunner struct {\n\tcalls []string\n}\n\nfunc (f *fakeRunner) Run(args ...string) (string, error) {\n\tf.calls = append(f.calls, strings.Join(args, \" \"))\n\treturn \"\", nil\n}\n\ntype fakeOpenCodeRunLogger struct {\n\tcalled     bool\n\tissueID    string\n\trepoRoot   string\n\tprompt     string\n\tmodel      string\n\tconfigRoot string\n\tconfigDir  string\n\tlogPath    string\n}\n\nfunc (f *fakeOpenCodeRunLogger) Run(issueID string, repoRoot string, prompt string, model string, configRoot string, configDir string, logPath string) error {\n\tf.called = true\n\tf.issueID = issueID\n\tf.repoRoot = repoRoot\n\tf.prompt = prompt\n\tf.model = model\n\tf.configRoot = configRoot\n\tf.configDir = configDir\n\tf.logPath = logPath\n\treturn nil\n}\n\ntype fakeOpenCodeRunner struct {\n\tenv map[string]string\n}\n\ntype fakeOpenCodeProcess struct{}\n\nfunc (fakeOpenCodeProcess) Wait() error { return nil }\n\nfunc (fakeOpenCodeProcess) Kill() error { return nil }\n\nfunc (f *fakeOpenCodeRunner) Start(args []string, env map[string]string, stdoutPath string) (opencode.Process, error) {\n\tf.env = env\n\treturn fakeOpenCodeProcess{}, nil\n}\n\ntype fakeGitRunner struct {\n\tcalls  []string\n\toutput string\n\terr    error\n}\n\nfunc (f *fakeGitRunner) Run(name string, args ...string) (string, error) {\n\tf.calls = append(f.calls, name+\" \"+strings.Join(args, \" \"))\n\treturn f.output, f.err\n}\n\ntype fakeExit struct {\n\tcode int\n}\n\nfunc (f *fakeExit) Exit(code int) {\n\tf.code = code\n}\n\ntype fakeRunOnce struct {\n\tcalled bool\n\topts   runner.RunOnceOptions\n\tdeps   runner.RunOnceDeps\n\tresult string\n\terr    error\n}\n\nfunc (f *fakeRunOnce) Run(opts runner.RunOnceOptions, deps runner.RunOnceDeps) (string, error) {\n\n\tf.called = true\n\tf.opts = opts\n\tf.deps = deps\n\treturn f.result, f.err\n}\n\nfunc TestRunOnceMainReturnsErrorCodeOnFailure(t *testing.T) {\n\trunner := &fakeRunOnce{err: errors.New(\"boom\")}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\n\tcode := RunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\"}, runner.Run, exit.Exit, out, out, nil, nil)\n\n\tif code != 1 {\n\t\tt.Fatalf(\"expected exit code 1, got %d\", code)\n\t}\n\tif exit.code != 1 {\n\t\tt.Fatalf(\"expected exit to be called with 1, got %d\", exit.code)\n\t}\n\tif !strings.Contains(out.String(), \"boom\") {\n\t\tt.Fatalf(\"expected error output, got %q\", out.String())\n\t}\n}\n\nfunc TestRunOnceMainWiresDependencies(t *testing.T) {\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tRunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\", \"--model\", \"model\", \"--dry-run\"}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif !runner.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n\tif runner.opts.RepoRoot != \"/repo\" || runner.opts.RootID != \"root\" || runner.opts.Model != \"model\" || !runner.opts.DryRun {\n\t\tt.Fatalf(\"unexpected options: %#v\", runner.opts)\n\t}\n\tif runner.opts.Out == nil {\n\t\tt.Fatalf(\"expected output writer\")\n\t}\n\tif runner.deps.Beads == nil || runner.deps.Git == nil || runner.deps.Prompt == nil || runner.deps.OpenCode == nil || runner.deps.Logger == nil {\n\t\tt.Fatalf(\"expected deps to be wired\")\n\t}\n\tif exit.code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", exit.code)\n\t}\n}\n\nfunc TestRunOnceMainDefaultsConfigPaths(t *testing.T) {\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tt.Setenv(\"HOME\", \"/home/user\")\n\n\tRunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\"}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif !runner.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n\tif runner.opts.ConfigRoot == \"\" {\n\t\tt.Fatalf(\"expected config root to be set\")\n\t}\n\tif runner.opts.ConfigDir == \"\" {\n\t\tt.Fatalf(\"expected config dir to be set\")\n\t}\n\texpectedConfigRoot := filepath.Join(\"/home/user\", \".config\", \"opencode-runner\")\n\tif runner.opts.ConfigRoot != expectedConfigRoot {\n\t\tt.Fatalf(\"expected config root %q, got %q\", expectedConfigRoot, runner.opts.ConfigRoot)\n\t}\n\texpectedConfigDir := filepath.Join(expectedConfigRoot, \"opencode\")\n\tif runner.opts.ConfigDir != expectedConfigDir {\n\t\tt.Fatalf(\"expected config dir %q, got %q\", expectedConfigDir, runner.opts.ConfigDir)\n\t}\n\tif exit.code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", exit.code)\n\t}\n}\n\nfunc TestOpenCodeRunDefaultsCreateConfigAndEnv(t *testing.T) {\n\ttempDir := t.TempDir()\n\trepoRoot := filepath.Join(tempDir, \"repo\")\n\tif err := os.MkdirAll(repoRoot, 0o755); err != nil {\n\t\tt.Fatalf(\"mkdir repo: %v\", err)\n\t}\n\tt.Setenv(\"HOME\", tempDir)\n\n\topenCodeRunner := &fakeOpenCodeRunner{}\n\topenCodeAdapter := openCodeAdapter{runner: openCodeRunner}\n\n\tconfigRoot := filepath.Join(tempDir, \".config\", \"opencode-runner\")\n\tconfigDir := filepath.Join(configRoot, \"opencode\")\n\tlogPath := filepath.Join(tempDir, \"runner-logs\", \"opencode\", \"issue-1.jsonl\")\n\n\tif err := openCodeAdapter.Run(\"issue-1\", repoRoot, \"prompt\", \"\", configRoot, configDir, logPath); err != nil {\n\t\tt.Fatalf(\"open code run error: %v\", err)\n\t}\n\n\tconfigFile := filepath.Join(configDir, \"opencode.json\")\n\tif _, err := os.Stat(configFile); err != nil {\n\t\tt.Fatalf(\"expected opencode.json to exist: %v\", err)\n\t}\n\texpectedConfigFile := filepath.Join(configDir, \"opencode.json\")\n\tif openCodeRunner.env[\"XDG_CONFIG_HOME\"] != configRoot {\n\t\tt.Fatalf(\"expected XDG_CONFIG_HOME set\")\n\t}\n\tif openCodeRunner.env[\"OPENCODE_CONFIG_DIR\"] != configDir {\n\t\tt.Fatalf(\"expected OPENCODE_CONFIG_DIR set\")\n\t}\n\tif openCodeRunner.env[\"OPENCODE_CONFIG\"] != expectedConfigFile {\n\t\tt.Fatalf(\"expected OPENCODE_CONFIG set\")\n\t}\n\tif openCodeRunner.env[\"OPENCODE_CONFIG_CONTENT\"] != \"{}\" {\n\t\tt.Fatalf(\"expected OPENCODE_CONFIG_CONTENT set\")\n\t}\n}\n","after":"package main\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"yolo-runner/internal/opencode\"\n\t\"yolo-runner/internal/runner\"\n)\n\ntype fakeRunner struct {\n\tcalls []string\n}\n\nfunc (f *fakeRunner) Run(args ...string) (string, error) {\n\tf.calls = append(f.calls, strings.Join(args, \" \"))\n\treturn \"\", nil\n}\n\ntype fakeOpenCodeRunLogger struct {\n\tcalled     bool\n\tissueID    string\n\trepoRoot   string\n\tprompt     string\n\tmodel      string\n\tconfigRoot string\n\tconfigDir  string\n\tlogPath    string\n}\n\nfunc (f *fakeOpenCodeRunLogger) Run(issueID string, repoRoot string, prompt string, model string, configRoot string, configDir string, logPath string) error {\n\tf.called = true\n\tf.issueID = issueID\n\tf.repoRoot = repoRoot\n\tf.prompt = prompt\n\tf.model = model\n\tf.configRoot = configRoot\n\tf.configDir = configDir\n\tf.logPath = logPath\n\treturn nil\n}\n\ntype fakeOpenCodeRunner struct {\n\tenv map[string]string\n}\n\ntype fakeOpenCodeProcess struct{}\n\nfunc (fakeOpenCodeProcess) Wait() error { return nil }\n\nfunc (fakeOpenCodeProcess) Kill() error { return nil }\n\nfunc (f *fakeOpenCodeRunner) Start(args []string, env map[string]string, stdoutPath string) (opencode.Process, error) {\n\tf.env = env\n\treturn fakeOpenCodeProcess{}, nil\n}\n\ntype fakeGitRunner struct {\n\tcalls  []string\n\toutput string\n\terr    error\n}\n\nfunc (f *fakeGitRunner) Run(name string, args ...string) (string, error) {\n\tf.calls = append(f.calls, name+\" \"+strings.Join(args, \" \"))\n\treturn f.output, f.err\n}\n\ntype fakeExit struct {\n\tcode int\n}\n\nfunc (f *fakeExit) Exit(code int) {\n\tf.code = code\n}\n\ntype fakeRunOnce struct {\n\tcalled bool\n\topts   runner.RunOnceOptions\n\tdeps   runner.RunOnceDeps\n\tresult string\n\terr    error\n}\n\nfunc (f *fakeRunOnce) Run(opts runner.RunOnceOptions, deps runner.RunOnceDeps) (string, error) {\n\n\tf.called = true\n\tf.opts = opts\n\tf.deps = deps\n\treturn f.result, f.err\n}\n\nfunc TestRunOnceMainReturnsErrorCodeOnFailure(t *testing.T) {\n\trunner := &fakeRunOnce{err: errors.New(\"boom\")}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\n\tcode := RunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\"}, runner.Run, exit.Exit, out, out, nil, nil)\n\n\tif code != 1 {\n\t\tt.Fatalf(\"expected exit code 1, got %d\", code)\n\t}\n\tif exit.code != 1 {\n\t\tt.Fatalf(\"expected exit to be called with 1, got %d\", exit.code)\n\t}\n\tif !strings.Contains(out.String(), \"boom\") {\n\t\tt.Fatalf(\"expected error output, got %q\", out.String())\n\t}\n}\n\nfunc TestRunOnceMainWiresDependencies(t *testing.T) {\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tRunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\", \"--model\", \"model\", \"--dry-run\"}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif !runner.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n\tif runner.opts.RepoRoot != \"/repo\" || runner.opts.RootID != \"root\" || runner.opts.Model != \"model\" || !runner.opts.DryRun {\n\t\tt.Fatalf(\"unexpected options: %#v\", runner.opts)\n\t}\n\tif runner.opts.Out == nil {\n\t\tt.Fatalf(\"expected output writer\")\n\t}\n\tif runner.deps.Beads == nil || runner.deps.Git == nil || runner.deps.Prompt == nil || runner.deps.OpenCode == nil || runner.deps.Logger == nil {\n\t\tt.Fatalf(\"expected deps to be wired\")\n\t}\n\tif exit.code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", exit.code)\n\t}\n}\n\nfunc TestRunOnceMainDefaultsConfigPaths(t *testing.T) {\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tt.Setenv(\"HOME\", \"/home/user\")\n\n\tRunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\"}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif !runner.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n\tif runner.opts.ConfigRoot == \"\" {\n\t\tt.Fatalf(\"expected config root to be set\")\n\t}\n\tif runner.opts.ConfigDir == \"\" {\n\t\tt.Fatalf(\"expected config dir to be set\")\n\t}\n\texpectedConfigRoot := filepath.Join(\"/home/user\", \".config\", \"opencode-runner\")\n\tif runner.opts.ConfigRoot != expectedConfigRoot {\n\t\tt.Fatalf(\"expected config root %q, got %q\", expectedConfigRoot, runner.opts.ConfigRoot)\n\t}\n\texpectedConfigDir := filepath.Join(expectedConfigRoot, \"opencode\")\n\tif runner.opts.ConfigDir != expectedConfigDir {\n\t\tt.Fatalf(\"expected config dir %q, got %q\", expectedConfigDir, runner.opts.ConfigDir)\n\t}\n\tif exit.code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", exit.code)\n\t}\n}\n\ntype fakeEmitter struct {\n\tevents []runner.Event\n}\n\nfunc (f *fakeEmitter) Emit(event runner.Event) {\n\tf.events = append(f.events, event)\n}\n\nfunc TestRunOnceMainUsesTUIOnTTYByDefault(t *testing.T) {\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\"}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", code)\n\t}\n\tif runner.deps.Events != nil {\n\t\tt.Fatalf(\"expected no events emitter by default\")\n\t}\n}\n\nfunc TestRunOnceMainHeadlessDisablesTUI(t *testing.T) {\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\tstderr := &bytes.Buffer{}\n\temitter := &fakeEmitter{}\n\n\tRunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\", \"--headless\"}, runner.Run, exit.Exit, out, stderr, beadsRunner, gitRunner)\n\n\tif runner.deps.Events == nil {\n\t\tt.Fatalf(\"expected event emitter when headless\")\n\t}\n\trunner.deps.Events.Emit(runner.Event{Type: runner.EventSelectTask})\n\tif len(emitter.events) != 0 {\n\t\tt.Fatalf(\"unexpected events recorded by fake emitter\")\n\t}\n}\n\nfunc TestOpenCodeRunDefaultsCreateConfigAndEnv(t *testing.T) {\n\ttempDir := t.TempDir()\n\trepoRoot := filepath.Join(tempDir, \"repo\")\n\tif err := os.MkdirAll(repoRoot, 0o755); err != nil {\n\t\tt.Fatalf(\"mkdir repo: %v\", err)\n\t}\n\tt.Setenv(\"HOME\", tempDir)\n\n\topenCodeRunner := &fakeOpenCodeRunner{}\n\topenCodeAdapter := openCodeAdapter{runner: openCodeRunner}\n\n\tconfigRoot := filepath.Join(tempDir, \".config\", \"opencode-runner\")\n\tconfigDir := filepath.Join(configRoot, \"opencode\")\n\tlogPath := filepath.Join(tempDir, \"runner-logs\", \"opencode\", \"issue-1.jsonl\")\n\n\tif err := openCodeAdapter.Run(\"issue-1\", repoRoot, \"prompt\", \"\", configRoot, configDir, logPath); err != nil {\n\t\tt.Fatalf(\"open code run error: %v\", err)\n\t}\n\n\tconfigFile := filepath.Join(configDir, \"opencode.json\")\n\tif _, err := os.Stat(configFile); err != nil {\n\t\tt.Fatalf(\"expected opencode.json to exist: %v\", err)\n\t}\n\texpectedConfigFile := filepath.Join(configDir, \"opencode.json\")\n\tif openCodeRunner.env[\"XDG_CONFIG_HOME\"] != configRoot {\n\t\tt.Fatalf(\"expected XDG_CONFIG_HOME set\")\n\t}\n\tif openCodeRunner.env[\"OPENCODE_CONFIG_DIR\"] != configDir {\n\t\tt.Fatalf(\"expected OPENCODE_CONFIG_DIR set\")\n\t}\n\tif openCodeRunner.env[\"OPENCODE_CONFIG\"] != expectedConfigFile {\n\t\tt.Fatalf(\"expected OPENCODE_CONFIG set\")\n\t}\n\tif openCodeRunner.env[\"OPENCODE_CONFIG_CONTENT\"] != \"{}\" {\n\t\tt.Fatalf(\"expected OPENCODE_CONFIG_CONTENT set\")\n\t}\n}\n","additions":45,"deletions":0},"truncated":false},"time":{"start":1768840488212,"end":1768840488385}},"metadata":{"openai":{"itemId":"fc_08691fb0811085d601696e5d14b5f48191b8505bd957298acb"}}}}
{"type":"step_finish","timestamp":1768840488405,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd71be5c2001MALdSj0IF90OZ3","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd71b91ce001Eaq80JYO1EIrXf","type":"step-finish","reason":"tool-calls","snapshot":"878cbff54257c22da30b23cfcf2fa31480b7aeb6","cost":0,"tokens":{"input":200,"output":1238,"reasoning":0,"cache":{"read":39552,"write":0}}}}
{"type":"step_start","timestamp":1768840488831,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd71be77f0017HJ6iZjTuNq3om","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd71be5f0001GuthIhQDhThx7z","type":"step-start","snapshot":"f67dd7ca6fe32f7e20e62fa519c9383b5e9b0db4"}}
{"type":"tool_use","timestamp":1768840522349,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd71c683e001OatUDqxSSfsNlk","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd71be5f0001GuthIhQDhThx7z","type":"tool","callID":"call_fqYXQU0MkXQHt7U8kTmdh7sK","tool":"read","state":{"status":"completed","input":{"filePath":"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go","offset":120,"limit":120},"output":"<file>\n00121| \n00122| \tRunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\", \"--model\", \"model\", \"--dry-run\"}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n00123| \n00124| \tif !runner.called {\n00125| \t\tt.Fatalf(\"expected run once to be called\")\n00126| \t}\n00127| \tif runner.opts.RepoRoot != \"/repo\" || runner.opts.RootID != \"root\" || runner.opts.Model != \"model\" || !runner.opts.DryRun {\n00128| \t\tt.Fatalf(\"unexpected options: %#v\", runner.opts)\n00129| \t}\n00130| \tif runner.opts.Out == nil {\n00131| \t\tt.Fatalf(\"expected output writer\")\n00132| \t}\n00133| \tif runner.deps.Beads == nil || runner.deps.Git == nil || runner.deps.Prompt == nil || runner.deps.OpenCode == nil || runner.deps.Logger == nil {\n00134| \t\tt.Fatalf(\"expected deps to be wired\")\n00135| \t}\n00136| \tif exit.code != 0 {\n00137| \t\tt.Fatalf(\"expected exit code 0, got %d\", exit.code)\n00138| \t}\n00139| }\n00140| \n00141| func TestRunOnceMainDefaultsConfigPaths(t *testing.T) {\n00142| \trunner := &fakeRunOnce{result: \"no_tasks\"}\n00143| \texit := &fakeExit{}\n00144| \tout := &bytes.Buffer{}\n00145| \tbeadsRunner := &fakeRunner{}\n00146| \tgitRunner := &fakeGitRunner{}\n00147| \n00148| \tt.Setenv(\"HOME\", \"/home/user\")\n00149| \n00150| \tRunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\"}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n00151| \n00152| \tif !runner.called {\n00153| \t\tt.Fatalf(\"expected run once to be called\")\n00154| \t}\n00155| \tif runner.opts.ConfigRoot == \"\" {\n00156| \t\tt.Fatalf(\"expected config root to be set\")\n00157| \t}\n00158| \tif runner.opts.ConfigDir == \"\" {\n00159| \t\tt.Fatalf(\"expected config dir to be set\")\n00160| \t}\n00161| \texpectedConfigRoot := filepath.Join(\"/home/user\", \".config\", \"opencode-runner\")\n00162| \tif runner.opts.ConfigRoot != expectedConfigRoot {\n00163| \t\tt.Fatalf(\"expected config root %q, got %q\", expectedConfigRoot, runner.opts.ConfigRoot)\n00164| \t}\n00165| \texpectedConfigDir := filepath.Join(expectedConfigRoot, \"opencode\")\n00166| \tif runner.opts.ConfigDir != expectedConfigDir {\n00167| \t\tt.Fatalf(\"expected config dir %q, got %q\", expectedConfigDir, runner.opts.ConfigDir)\n00168| \t}\n00169| \tif exit.code != 0 {\n00170| \t\tt.Fatalf(\"expected exit code 0, got %d\", exit.code)\n00171| \t}\n00172| }\n00173| \n00174| type fakeEmitter struct {\n00175| \tevents []runner.Event\n00176| }\n00177| \n00178| func (f *fakeEmitter) Emit(event runner.Event) {\n00179| \tf.events = append(f.events, event)\n00180| }\n00181| \n00182| func TestRunOnceMainUsesTUIOnTTYByDefault(t *testing.T) {\n00183| \trunner := &fakeRunOnce{result: \"no_tasks\"}\n00184| \texit := &fakeExit{}\n00185| \tout := &bytes.Buffer{}\n00186| \tbeadsRunner := &fakeRunner{}\n00187| \tgitRunner := &fakeGitRunner{}\n00188| \n00189| \tcode := RunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\"}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n00190| \n00191| \tif code != 0 {\n00192| \t\tt.Fatalf(\"expected exit code 0, got %d\", code)\n00193| \t}\n00194| \tif runner.deps.Events != nil {\n00195| \t\tt.Fatalf(\"expected no events emitter by default\")\n00196| \t}\n00197| }\n00198| \n00199| func TestRunOnceMainHeadlessDisablesTUI(t *testing.T) {\n00200| \trunner := &fakeRunOnce{result: \"no_tasks\"}\n00201| \texit := &fakeExit{}\n00202| \tout := &bytes.Buffer{}\n00203| \tbeadsRunner := &fakeRunner{}\n00204| \tgitRunner := &fakeGitRunner{}\n00205| \tstderr := &bytes.Buffer{}\n00206| \temitter := &fakeEmitter{}\n00207| \n00208| \tRunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\", \"--headless\"}, runner.Run, exit.Exit, out, stderr, beadsRunner, gitRunner)\n00209| \n00210| \tif runner.deps.Events == nil {\n00211| \t\tt.Fatalf(\"expected event emitter when headless\")\n00212| \t}\n00213| \trunner.deps.Events.Emit(runner.Event{Type: runner.EventSelectTask})\n00214| \tif len(emitter.events) != 0 {\n00215| \t\tt.Fatalf(\"unexpected events recorded by fake emitter\")\n00216| \t}\n00217| }\n00218| \n00219| func TestOpenCodeRunDefaultsCreateConfigAndEnv(t *testing.T) {\n00220| \ttempDir := t.TempDir()\n00221| \trepoRoot := filepath.Join(tempDir, \"repo\")\n00222| \tif err := os.MkdirAll(repoRoot, 0o755); err != nil {\n00223| \t\tt.Fatalf(\"mkdir repo: %v\", err)\n00224| \t}\n00225| \tt.Setenv(\"HOME\", tempDir)\n00226| \n00227| \topenCodeRunner := &fakeOpenCodeRunner{}\n00228| \topenCodeAdapter := openCodeAdapter{runner: openCodeRunner}\n00229| \n00230| \tconfigRoot := filepath.Join(tempDir, \".config\", \"opencode-runner\")\n00231| \tconfigDir := filepath.Join(configRoot, \"opencode\")\n00232| \tlogPath := filepath.Join(tempDir, \"runner-logs\", \"opencode\", \"issue-1.jsonl\")\n00233| \n00234| \tif err := openCodeAdapter.Run(\"issue-1\", repoRoot, \"prompt\", \"\", configRoot, configDir, logPath); err != nil {\n00235| \t\tt.Fatalf(\"open code run error: %v\", err)\n00236| \t}\n00237| \n00238| \tconfigFile := filepath.Join(configDir, \"opencode.json\")\n00239| \tif _, err := os.Stat(configFile); err != nil {\n00240| \t\tt.Fatalf(\"expected opencode.json to exist: %v\", err)\n\n(File has more lines. Use 'offset' parameter to read beyond line 240)\n</file>","title":"cmd/yolo-runner/main_test.go","metadata":{"preview":"\n\tRunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\", \"--model\", \"model\", \"--dry-run\"}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif !runner.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n\tif runner.opts.RepoRoot != \"/repo\" || runner.opts.RootID != \"root\" || runner.opts.Model != \"model\" || !runner.opts.DryRun {\n\t\tt.Fatalf(\"unexpected options: %#v\", runner.opts)\n\t}\n\tif runner.opts.Out == nil {\n\t\tt.Fatalf(\"expected output writer\")\n\t}\n\tif runner.deps.Beads == nil || runner.deps.Git == nil || runner.deps.Prompt == nil || runner.deps.OpenCode == nil || runner.deps.Logger == nil {\n\t\tt.Fatalf(\"expected deps to be wired\")\n\t}\n\tif exit.code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", exit.code)\n\t}\n}\n","truncated":true},"time":{"start":1768840522348,"end":1768840522349}},"metadata":{"openai":{"itemId":"fc_083bc20f05d6d55601696e5d49cd7081919a29cfe1179a7e74"}}}}
{"type":"step_finish","timestamp":1768840522404,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd71c6a95001Cz8TBLpowaZw0F","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd71be5f0001GuthIhQDhThx7z","type":"step-finish","reason":"tool-calls","snapshot":"5d86f289f3fce3fb066efa43ead70202737dcc9f","cost":0,"tokens":{"input":1525,"output":1454,"reasoning":1408,"cache":{"read":39552,"write":0}}}}
{"type":"step_start","timestamp":1768840522805,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd71c6c34001agvqp10nqTJbxf","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd71c6abd001hBrE09EUOOW4ET","type":"step-start","snapshot":"3913b9f25041796f5312534ee544a71819e4359d"}}
{"type":"tool_use","timestamp":1768840648128,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd71e2f1d001OMxqgG3qqFvG42","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd71c6abd001hBrE09EUOOW4ET","type":"tool","callID":"call_D5wzO68mgKFacR4UwjRm13r4","tool":"edit","state":{"status":"completed","input":{"filePath":"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go","oldString":"type fakeEmitter struct {\n\tevents []runner.Event\n}\n\nfunc (f *fakeEmitter) Emit(event runner.Event) {\n\tf.events = append(f.events, event)\n}\n\nfunc TestRunOnceMainUsesTUIOnTTYByDefault(t *testing.T) {\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\"}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", code)\n\t}\n\tif runner.deps.Events != nil {\n\t\tt.Fatalf(\"expected no events emitter by default\")\n\t}\n}\n\nfunc TestRunOnceMainHeadlessDisablesTUI(t *testing.T) {\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\tstderr := &bytes.Buffer{}\n\temitter := &fakeEmitter{}\n\n\tRunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\", \"--headless\"}, runner.Run, exit.Exit, out, stderr, beadsRunner, gitRunner)\n\n\tif runner.deps.Events == nil {\n\t\tt.Fatalf(\"expected event emitter when headless\")\n\t}\n\trunner.deps.Events.Emit(runner.Event{Type: runner.EventSelectTask})\n\tif len(emitter.events) != 0 {\n\t\tt.Fatalf(\"unexpected events recorded by fake emitter\")\n\t}\n}\n","newString":"type fakeTUIProgram struct {\n\tstarted chan struct{}\n\tquit    chan struct{}\n\tevents  []runner.Event\n}\n\nfunc newFakeTUIProgram() *fakeTUIProgram {\n\treturn &fakeTUIProgram{\n\t\tstarted: make(chan struct{}),\n\t\tquit:    make(chan struct{}),\n\t}\n}\n\nfunc (f *fakeTUIProgram) Start() error {\n\tclose(f.started)\n\treturn nil\n}\n\nfunc (f *fakeTUIProgram) Send(event runner.Event) {\n\tf.events = append(f.events, event)\n}\n\nfunc (f *fakeTUIProgram) Quit() {\n\tclose(f.quit)\n}\n\nfunc waitForSignal(t *testing.T, signal chan struct{}, label string) {\n\tt.Helper()\n\tselect {\n\tcase <-signal:\n\t\treturn\n\tcase <-time.After(100 * time.Millisecond):\n\t\tt.Fatalf(\"expected %s\", label)\n\t}\n}\n\nfunc TestRunOnceMainUsesTUIOnTTYByDefault(t *testing.T) {\n\tfakeProgram := newFakeTUIProgram()\n\tprevIsTerminal := isTerminal\n\tprevNewTUIProgram := newTUIProgram\n\tisTerminal = func(io.Writer) bool { return true }\n\tnewTUIProgram = func(stdout io.Writer) tuiProgram { return fakeProgram }\n\tt.Cleanup(func() {\n\t\tisTerminal = prevIsTerminal\n\t\tnewTUIProgram = prevNewTUIProgram\n\t})\n\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\"}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", code)\n\t}\n\tif runner.deps.Events == nil {\n\t\tt.Fatalf(\"expected events emitter to be set\")\n\t}\n\trunner.deps.Events.Emit(runner.Event{Type: runner.EventSelectTask})\n\tif len(fakeProgram.events) != 1 {\n\t\tt.Fatalf(\"expected event to be forwarded to TUI\")\n\t}\n\twaitForSignal(t, fakeProgram.started, \"tui start\")\n\twaitForSignal(t, fakeProgram.quit, \"tui quit\")\n}\n\nfunc TestRunOnceMainHeadlessDisablesTUI(t *testing.T) {\n\tcalled := false\n\tprevIsTerminal := isTerminal\n\tprevNewTUIProgram := newTUIProgram\n\tisTerminal = func(io.Writer) bool { return true }\n\tnewTUIProgram = func(stdout io.Writer) tuiProgram {\n\t\tcalled = true\n\t\treturn newFakeTUIProgram()\n\t}\n\tt.Cleanup(func() {\n\t\tisTerminal = prevIsTerminal\n\t\tnewTUIProgram = prevNewTUIProgram\n\t})\n\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\tstderr := &bytes.Buffer{}\n\n\tRunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\", \"--headless\"}, runner.Run, exit.Exit, out, stderr, beadsRunner, gitRunner)\n\n\tif called {\n\t\tt.Fatalf(\"expected TUI program not to start\")\n\t}\n\tif runner.deps.Events != nil {\n\t\tt.Fatalf(\"expected no events emitter in headless mode\")\n\t}\n}\n"},"output":"Edit applied successfully.\n\nLSP errors detected in this file, please fix:\n<diagnostics file=\"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go\">\nERROR [205:9] undefined: time\nERROR [205:26] undefined: time\nERROR [212:20] undefined: isTerminal\nERROR [213:23] undefined: newTUIProgram\nERROR [214:2] undefined: isTerminal\nERROR [214:20] undefined: io\nERROR [215:2] undefined: newTUIProgram\nERROR [215:30] undefined: io\nERROR [215:41] undefined: tuiProgram\nERROR [217:3] undefined: isTerminal\nERROR [218:3] undefined: newTUIProgram\nERROR [235:33] runner.Event is not a type\nERROR [235:52] runner.EventSelectTask undefined (type *fakeRunOnce has no field or method EventSelectTask)\nERROR [245:20] undefined: isTerminal\nERROR [246:23] undefined: newTUIProgram\nERROR [247:2] undefined: isTerminal\nERROR [247:20] undefined: io\nERROR [248:2] undefined: newTUIProgram\nERROR [248:30] undefined: io\nERROR [248:41] undefined: tuiProgram\n... and 2 more\n</diagnostics>","title":"cmd/yolo-runner/main_test.go","metadata":{"diagnostics":{"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main.go":[],"/Users/egv/dev/yolo-runner/go.mod":[{"range":{"start":{"line":6,"character":44},"end":{"line":6,"character":55}},"severity":2,"source":"go mod tidy","message":"github.com/charmbracelet/bubbletea should be direct"}],"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go":[{"range":{"start":{"line":204,"character":8},"end":{"line":204,"character":12}},"severity":1,"code":"UndeclaredName","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UndeclaredName"},"source":"compiler","message":"undefined: time"},{"range":{"start":{"line":204,"character":25},"end":{"line":204,"character":29}},"severity":1,"code":"UndeclaredName","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UndeclaredName"},"source":"compiler","message":"undefined: time"},{"range":{"start":{"line":211,"character":19},"end":{"line":211,"character":29}},"severity":1,"code":"UndeclaredName","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UndeclaredName"},"source":"compiler","message":"undefined: isTerminal"},{"range":{"start":{"line":212,"character":22},"end":{"line":212,"character":35}},"severity":1,"code":"UndeclaredName","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UndeclaredName"},"source":"compiler","message":"undefined: newTUIProgram"},{"range":{"start":{"line":213,"character":1},"end":{"line":213,"character":11}},"severity":1,"code":"UndeclaredName","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UndeclaredName"},"source":"compiler","message":"undefined: isTerminal"},{"range":{"start":{"line":213,"character":19},"end":{"line":213,"character":21}},"severity":1,"code":"UndeclaredName","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UndeclaredName"},"source":"compiler","message":"undefined: io"},{"range":{"start":{"line":214,"character":1},"end":{"line":214,"character":14}},"severity":1,"code":"UndeclaredName","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UndeclaredName"},"source":"compiler","message":"undefined: newTUIProgram"},{"range":{"start":{"line":214,"character":29},"end":{"line":214,"character":31}},"severity":1,"code":"UndeclaredName","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UndeclaredName"},"source":"compiler","message":"undefined: io"},{"range":{"start":{"line":214,"character":40},"end":{"line":214,"character":50}},"severity":1,"code":"UndeclaredName","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UndeclaredName"},"source":"compiler","message":"undefined: tuiProgram"},{"range":{"start":{"line":216,"character":2},"end":{"line":216,"character":12}},"severity":1,"code":"UndeclaredName","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UndeclaredName"},"source":"compiler","message":"undefined: isTerminal"},{"range":{"start":{"line":217,"character":2},"end":{"line":217,"character":15}},"severity":1,"code":"UndeclaredName","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UndeclaredName"},"source":"compiler","message":"undefined: newTUIProgram"},{"range":{"start":{"line":234,"character":32},"end":{"line":234,"character":37}},"severity":1,"code":"NotAType","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#NotAType"},"source":"compiler","message":"runner.Event is not a type"},{"range":{"start":{"line":234,"character":51},"end":{"line":234,"character":66}},"severity":1,"code":"MissingFieldOrMethod","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#MissingFieldOrMethod"},"source":"compiler","message":"runner.EventSelectTask undefined (type *fakeRunOnce has no field or method EventSelectTask)"},{"range":{"start":{"line":244,"character":19},"end":{"line":244,"character":29}},"severity":1,"code":"UndeclaredName","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UndeclaredName"},"source":"compiler","message":"undefined: isTerminal"},{"range":{"start":{"line":245,"character":22},"end":{"line":245,"character":35}},"severity":1,"code":"UndeclaredName","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UndeclaredName"},"source":"compiler","message":"undefined: newTUIProgram"},{"range":{"start":{"line":246,"character":1},"end":{"line":246,"character":11}},"severity":1,"code":"UndeclaredName","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UndeclaredName"},"source":"compiler","message":"undefined: isTerminal"},{"range":{"start":{"line":246,"character":19},"end":{"line":246,"character":21}},"severity":1,"code":"UndeclaredName","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UndeclaredName"},"source":"compiler","message":"undefined: io"},{"range":{"start":{"line":247,"character":1},"end":{"line":247,"character":14}},"severity":1,"code":"UndeclaredName","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UndeclaredName"},"source":"compiler","message":"undefined: newTUIProgram"},{"range":{"start":{"line":247,"character":29},"end":{"line":247,"character":31}},"severity":1,"code":"UndeclaredName","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UndeclaredName"},"source":"compiler","message":"undefined: io"},{"range":{"start":{"line":247,"character":40},"end":{"line":247,"character":50}},"severity":1,"code":"UndeclaredName","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UndeclaredName"},"source":"compiler","message":"undefined: tuiProgram"},{"range":{"start":{"line":252,"character":2},"end":{"line":252,"character":12}},"severity":1,"code":"UndeclaredName","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UndeclaredName"},"source":"compiler","message":"undefined: isTerminal"},{"range":{"start":{"line":253,"character":2},"end":{"line":253,"character":15}},"severity":1,"code":"UndeclaredName","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UndeclaredName"},"source":"compiler","message":"undefined: newTUIProgram"}],"/Users/egv/dev/yolo-runner/bubbletea_test.go":[],"/Users/egv/dev/yolo-runner/opencode_adapter_v1.go":[{"range":{"start":{"line":24,"character":1},"end":{"line":24,"character":18}},"severity":2,"code":"default","codeDescription":{"href":"https://staticcheck.dev/docs/checks/#S1031"},"source":"S1031","message":"unnecessary nil check around range"}],"/Users/egv/dev/yolo-runner/internal/ui/tui/model.go":[],"/Users/egv/dev/yolo-runner/internal/runner/runner.go":[],"/Users/egv/dev/yolo-runner/internal/ui/tui/model_test.go":[],"/Users/egv/dev/yolo-runner/internal/runner/events.go":[],"/Users/egv/dev/yolo-runner/internal/runner/loop_test.go":[],"/Users/egv/dev/yolo-runner/internal/runner/runner_test.go":[],"/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/tea.go":[],"/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/tty_unix.go":[],"/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/tty.go":[],"/Users/egv/dev/yolo-runner/internal/opencode/watchdog.go":[],"/Users/egv/dev/yolo-runner/internal/opencode/client.go":[{"range":{"start":{"line":28,"character":1},"end":{"line":28,"character":18}},"severity":2,"code":"default","codeDescription":{"href":"https://staticcheck.dev/docs/checks/#S1031"},"source":"S1031","message":"unnecessary nil check around range"}],"/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/options.go":[],"/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/tty_windows.go":[{"range":{"start":{"line":3,"character":8},"end":{"line":3,"character":11}},"severity":2,"source":"go list","message":"This file is within module \"../../go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0\", which is not included in your workspace.\nTo fix this problem, you can add a go.work file that uses this directory.\nSee the documentation for more information on setting up your workspace:\nhttps://github.com/golang/tools/blob/master/gopls/doc/workspace.md.","data":{"Actions":[{"title":"Add a go.work file using this module","kind":"quickfix","command":{"title":"Run `go work init && go work use`","command":"gopls.run_go_work_command","arguments":[{"ViewID":"1","InitFirst":true,"Args":["use","../../go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0"]}]}}]}}]},"diff":"Index: /Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go\n===================================================================\n--- /Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go\n+++ /Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go\n@@ -170,17 +170,55 @@\n \t\tt.Fatalf(\"expected exit code 0, got %d\", exit.code)\n \t}\n }\n \n-type fakeEmitter struct {\n-\tevents []runner.Event\n+type fakeTUIProgram struct {\n+\tstarted chan struct{}\n+\tquit    chan struct{}\n+\tevents  []runner.Event\n }\n \n-func (f *fakeEmitter) Emit(event runner.Event) {\n+func newFakeTUIProgram() *fakeTUIProgram {\n+\treturn &fakeTUIProgram{\n+\t\tstarted: make(chan struct{}),\n+\t\tquit:    make(chan struct{}),\n+\t}\n+}\n+\n+func (f *fakeTUIProgram) Start() error {\n+\tclose(f.started)\n+\treturn nil\n+}\n+\n+func (f *fakeTUIProgram) Send(event runner.Event) {\n \tf.events = append(f.events, event)\n }\n \n+func (f *fakeTUIProgram) Quit() {\n+\tclose(f.quit)\n+}\n+\n+func waitForSignal(t *testing.T, signal chan struct{}, label string) {\n+\tt.Helper()\n+\tselect {\n+\tcase <-signal:\n+\t\treturn\n+\tcase <-time.After(100 * time.Millisecond):\n+\t\tt.Fatalf(\"expected %s\", label)\n+\t}\n+}\n+\n func TestRunOnceMainUsesTUIOnTTYByDefault(t *testing.T) {\n+\tfakeProgram := newFakeTUIProgram()\n+\tprevIsTerminal := isTerminal\n+\tprevNewTUIProgram := newTUIProgram\n+\tisTerminal = func(io.Writer) bool { return true }\n+\tnewTUIProgram = func(stdout io.Writer) tuiProgram { return fakeProgram }\n+\tt.Cleanup(func() {\n+\t\tisTerminal = prevIsTerminal\n+\t\tnewTUIProgram = prevNewTUIProgram\n+\t})\n+\n \trunner := &fakeRunOnce{result: \"no_tasks\"}\n \texit := &fakeExit{}\n \tout := &bytes.Buffer{}\n \tbeadsRunner := &fakeRunner{}\n@@ -190,30 +228,47 @@\n \n \tif code != 0 {\n \t\tt.Fatalf(\"expected exit code 0, got %d\", code)\n \t}\n-\tif runner.deps.Events != nil {\n-\t\tt.Fatalf(\"expected no events emitter by default\")\n+\tif runner.deps.Events == nil {\n+\t\tt.Fatalf(\"expected events emitter to be set\")\n \t}\n+\trunner.deps.Events.Emit(runner.Event{Type: runner.EventSelectTask})\n+\tif len(fakeProgram.events) != 1 {\n+\t\tt.Fatalf(\"expected event to be forwarded to TUI\")\n+\t}\n+\twaitForSignal(t, fakeProgram.started, \"tui start\")\n+\twaitForSignal(t, fakeProgram.quit, \"tui quit\")\n }\n \n func TestRunOnceMainHeadlessDisablesTUI(t *testing.T) {\n+\tcalled := false\n+\tprevIsTerminal := isTerminal\n+\tprevNewTUIProgram := newTUIProgram\n+\tisTerminal = func(io.Writer) bool { return true }\n+\tnewTUIProgram = func(stdout io.Writer) tuiProgram {\n+\t\tcalled = true\n+\t\treturn newFakeTUIProgram()\n+\t}\n+\tt.Cleanup(func() {\n+\t\tisTerminal = prevIsTerminal\n+\t\tnewTUIProgram = prevNewTUIProgram\n+\t})\n+\n \trunner := &fakeRunOnce{result: \"no_tasks\"}\n \texit := &fakeExit{}\n \tout := &bytes.Buffer{}\n \tbeadsRunner := &fakeRunner{}\n \tgitRunner := &fakeGitRunner{}\n \tstderr := &bytes.Buffer{}\n-\temitter := &fakeEmitter{}\n \n \tRunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\", \"--headless\"}, runner.Run, exit.Exit, out, stderr, beadsRunner, gitRunner)\n \n-\tif runner.deps.Events == nil {\n-\t\tt.Fatalf(\"expected event emitter when headless\")\n+\tif called {\n+\t\tt.Fatalf(\"expected TUI program not to start\")\n \t}\n-\trunner.deps.Events.Emit(runner.Event{Type: runner.EventSelectTask})\n-\tif len(emitter.events) != 0 {\n-\t\tt.Fatalf(\"unexpected events recorded by fake emitter\")\n+\tif runner.deps.Events != nil {\n+\t\tt.Fatalf(\"expected no events emitter in headless mode\")\n \t}\n }\n \n func TestOpenCodeRunDefaultsCreateConfigAndEnv(t *testing.T) {\n","filediff":{"file":"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go","before":"package main\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"yolo-runner/internal/opencode\"\n\t\"yolo-runner/internal/runner\"\n)\n\ntype fakeRunner struct {\n\tcalls []string\n}\n\nfunc (f *fakeRunner) Run(args ...string) (string, error) {\n\tf.calls = append(f.calls, strings.Join(args, \" \"))\n\treturn \"\", nil\n}\n\ntype fakeOpenCodeRunLogger struct {\n\tcalled     bool\n\tissueID    string\n\trepoRoot   string\n\tprompt     string\n\tmodel      string\n\tconfigRoot string\n\tconfigDir  string\n\tlogPath    string\n}\n\nfunc (f *fakeOpenCodeRunLogger) Run(issueID string, repoRoot string, prompt string, model string, configRoot string, configDir string, logPath string) error {\n\tf.called = true\n\tf.issueID = issueID\n\tf.repoRoot = repoRoot\n\tf.prompt = prompt\n\tf.model = model\n\tf.configRoot = configRoot\n\tf.configDir = configDir\n\tf.logPath = logPath\n\treturn nil\n}\n\ntype fakeOpenCodeRunner struct {\n\tenv map[string]string\n}\n\ntype fakeOpenCodeProcess struct{}\n\nfunc (fakeOpenCodeProcess) Wait() error { return nil }\n\nfunc (fakeOpenCodeProcess) Kill() error { return nil }\n\nfunc (f *fakeOpenCodeRunner) Start(args []string, env map[string]string, stdoutPath string) (opencode.Process, error) {\n\tf.env = env\n\treturn fakeOpenCodeProcess{}, nil\n}\n\ntype fakeGitRunner struct {\n\tcalls  []string\n\toutput string\n\terr    error\n}\n\nfunc (f *fakeGitRunner) Run(name string, args ...string) (string, error) {\n\tf.calls = append(f.calls, name+\" \"+strings.Join(args, \" \"))\n\treturn f.output, f.err\n}\n\ntype fakeExit struct {\n\tcode int\n}\n\nfunc (f *fakeExit) Exit(code int) {\n\tf.code = code\n}\n\ntype fakeRunOnce struct {\n\tcalled bool\n\topts   runner.RunOnceOptions\n\tdeps   runner.RunOnceDeps\n\tresult string\n\terr    error\n}\n\nfunc (f *fakeRunOnce) Run(opts runner.RunOnceOptions, deps runner.RunOnceDeps) (string, error) {\n\n\tf.called = true\n\tf.opts = opts\n\tf.deps = deps\n\treturn f.result, f.err\n}\n\nfunc TestRunOnceMainReturnsErrorCodeOnFailure(t *testing.T) {\n\trunner := &fakeRunOnce{err: errors.New(\"boom\")}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\n\tcode := RunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\"}, runner.Run, exit.Exit, out, out, nil, nil)\n\n\tif code != 1 {\n\t\tt.Fatalf(\"expected exit code 1, got %d\", code)\n\t}\n\tif exit.code != 1 {\n\t\tt.Fatalf(\"expected exit to be called with 1, got %d\", exit.code)\n\t}\n\tif !strings.Contains(out.String(), \"boom\") {\n\t\tt.Fatalf(\"expected error output, got %q\", out.String())\n\t}\n}\n\nfunc TestRunOnceMainWiresDependencies(t *testing.T) {\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tRunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\", \"--model\", \"model\", \"--dry-run\"}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif !runner.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n\tif runner.opts.RepoRoot != \"/repo\" || runner.opts.RootID != \"root\" || runner.opts.Model != \"model\" || !runner.opts.DryRun {\n\t\tt.Fatalf(\"unexpected options: %#v\", runner.opts)\n\t}\n\tif runner.opts.Out == nil {\n\t\tt.Fatalf(\"expected output writer\")\n\t}\n\tif runner.deps.Beads == nil || runner.deps.Git == nil || runner.deps.Prompt == nil || runner.deps.OpenCode == nil || runner.deps.Logger == nil {\n\t\tt.Fatalf(\"expected deps to be wired\")\n\t}\n\tif exit.code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", exit.code)\n\t}\n}\n\nfunc TestRunOnceMainDefaultsConfigPaths(t *testing.T) {\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tt.Setenv(\"HOME\", \"/home/user\")\n\n\tRunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\"}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif !runner.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n\tif runner.opts.ConfigRoot == \"\" {\n\t\tt.Fatalf(\"expected config root to be set\")\n\t}\n\tif runner.opts.ConfigDir == \"\" {\n\t\tt.Fatalf(\"expected config dir to be set\")\n\t}\n\texpectedConfigRoot := filepath.Join(\"/home/user\", \".config\", \"opencode-runner\")\n\tif runner.opts.ConfigRoot != expectedConfigRoot {\n\t\tt.Fatalf(\"expected config root %q, got %q\", expectedConfigRoot, runner.opts.ConfigRoot)\n\t}\n\texpectedConfigDir := filepath.Join(expectedConfigRoot, \"opencode\")\n\tif runner.opts.ConfigDir != expectedConfigDir {\n\t\tt.Fatalf(\"expected config dir %q, got %q\", expectedConfigDir, runner.opts.ConfigDir)\n\t}\n\tif exit.code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", exit.code)\n\t}\n}\n\ntype fakeEmitter struct {\n\tevents []runner.Event\n}\n\nfunc (f *fakeEmitter) Emit(event runner.Event) {\n\tf.events = append(f.events, event)\n}\n\nfunc TestRunOnceMainUsesTUIOnTTYByDefault(t *testing.T) {\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\"}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", code)\n\t}\n\tif runner.deps.Events != nil {\n\t\tt.Fatalf(\"expected no events emitter by default\")\n\t}\n}\n\nfunc TestRunOnceMainHeadlessDisablesTUI(t *testing.T) {\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\tstderr := &bytes.Buffer{}\n\temitter := &fakeEmitter{}\n\n\tRunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\", \"--headless\"}, runner.Run, exit.Exit, out, stderr, beadsRunner, gitRunner)\n\n\tif runner.deps.Events == nil {\n\t\tt.Fatalf(\"expected event emitter when headless\")\n\t}\n\trunner.deps.Events.Emit(runner.Event{Type: runner.EventSelectTask})\n\tif len(emitter.events) != 0 {\n\t\tt.Fatalf(\"unexpected events recorded by fake emitter\")\n\t}\n}\n\nfunc TestOpenCodeRunDefaultsCreateConfigAndEnv(t *testing.T) {\n\ttempDir := t.TempDir()\n\trepoRoot := filepath.Join(tempDir, \"repo\")\n\tif err := os.MkdirAll(repoRoot, 0o755); err != nil {\n\t\tt.Fatalf(\"mkdir repo: %v\", err)\n\t}\n\tt.Setenv(\"HOME\", tempDir)\n\n\topenCodeRunner := &fakeOpenCodeRunner{}\n\topenCodeAdapter := openCodeAdapter{runner: openCodeRunner}\n\n\tconfigRoot := filepath.Join(tempDir, \".config\", \"opencode-runner\")\n\tconfigDir := filepath.Join(configRoot, \"opencode\")\n\tlogPath := filepath.Join(tempDir, \"runner-logs\", \"opencode\", \"issue-1.jsonl\")\n\n\tif err := openCodeAdapter.Run(\"issue-1\", repoRoot, \"prompt\", \"\", configRoot, configDir, logPath); err != nil {\n\t\tt.Fatalf(\"open code run error: %v\", err)\n\t}\n\n\tconfigFile := filepath.Join(configDir, \"opencode.json\")\n\tif _, err := os.Stat(configFile); err != nil {\n\t\tt.Fatalf(\"expected opencode.json to exist: %v\", err)\n\t}\n\texpectedConfigFile := filepath.Join(configDir, \"opencode.json\")\n\tif openCodeRunner.env[\"XDG_CONFIG_HOME\"] != configRoot {\n\t\tt.Fatalf(\"expected XDG_CONFIG_HOME set\")\n\t}\n\tif openCodeRunner.env[\"OPENCODE_CONFIG_DIR\"] != configDir {\n\t\tt.Fatalf(\"expected OPENCODE_CONFIG_DIR set\")\n\t}\n\tif openCodeRunner.env[\"OPENCODE_CONFIG\"] != expectedConfigFile {\n\t\tt.Fatalf(\"expected OPENCODE_CONFIG set\")\n\t}\n\tif openCodeRunner.env[\"OPENCODE_CONFIG_CONTENT\"] != \"{}\" {\n\t\tt.Fatalf(\"expected OPENCODE_CONFIG_CONTENT set\")\n\t}\n}\n","after":"package main\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"yolo-runner/internal/opencode\"\n\t\"yolo-runner/internal/runner\"\n)\n\ntype fakeRunner struct {\n\tcalls []string\n}\n\nfunc (f *fakeRunner) Run(args ...string) (string, error) {\n\tf.calls = append(f.calls, strings.Join(args, \" \"))\n\treturn \"\", nil\n}\n\ntype fakeOpenCodeRunLogger struct {\n\tcalled     bool\n\tissueID    string\n\trepoRoot   string\n\tprompt     string\n\tmodel      string\n\tconfigRoot string\n\tconfigDir  string\n\tlogPath    string\n}\n\nfunc (f *fakeOpenCodeRunLogger) Run(issueID string, repoRoot string, prompt string, model string, configRoot string, configDir string, logPath string) error {\n\tf.called = true\n\tf.issueID = issueID\n\tf.repoRoot = repoRoot\n\tf.prompt = prompt\n\tf.model = model\n\tf.configRoot = configRoot\n\tf.configDir = configDir\n\tf.logPath = logPath\n\treturn nil\n}\n\ntype fakeOpenCodeRunner struct {\n\tenv map[string]string\n}\n\ntype fakeOpenCodeProcess struct{}\n\nfunc (fakeOpenCodeProcess) Wait() error { return nil }\n\nfunc (fakeOpenCodeProcess) Kill() error { return nil }\n\nfunc (f *fakeOpenCodeRunner) Start(args []string, env map[string]string, stdoutPath string) (opencode.Process, error) {\n\tf.env = env\n\treturn fakeOpenCodeProcess{}, nil\n}\n\ntype fakeGitRunner struct {\n\tcalls  []string\n\toutput string\n\terr    error\n}\n\nfunc (f *fakeGitRunner) Run(name string, args ...string) (string, error) {\n\tf.calls = append(f.calls, name+\" \"+strings.Join(args, \" \"))\n\treturn f.output, f.err\n}\n\ntype fakeExit struct {\n\tcode int\n}\n\nfunc (f *fakeExit) Exit(code int) {\n\tf.code = code\n}\n\ntype fakeRunOnce struct {\n\tcalled bool\n\topts   runner.RunOnceOptions\n\tdeps   runner.RunOnceDeps\n\tresult string\n\terr    error\n}\n\nfunc (f *fakeRunOnce) Run(opts runner.RunOnceOptions, deps runner.RunOnceDeps) (string, error) {\n\n\tf.called = true\n\tf.opts = opts\n\tf.deps = deps\n\treturn f.result, f.err\n}\n\nfunc TestRunOnceMainReturnsErrorCodeOnFailure(t *testing.T) {\n\trunner := &fakeRunOnce{err: errors.New(\"boom\")}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\n\tcode := RunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\"}, runner.Run, exit.Exit, out, out, nil, nil)\n\n\tif code != 1 {\n\t\tt.Fatalf(\"expected exit code 1, got %d\", code)\n\t}\n\tif exit.code != 1 {\n\t\tt.Fatalf(\"expected exit to be called with 1, got %d\", exit.code)\n\t}\n\tif !strings.Contains(out.String(), \"boom\") {\n\t\tt.Fatalf(\"expected error output, got %q\", out.String())\n\t}\n}\n\nfunc TestRunOnceMainWiresDependencies(t *testing.T) {\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tRunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\", \"--model\", \"model\", \"--dry-run\"}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif !runner.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n\tif runner.opts.RepoRoot != \"/repo\" || runner.opts.RootID != \"root\" || runner.opts.Model != \"model\" || !runner.opts.DryRun {\n\t\tt.Fatalf(\"unexpected options: %#v\", runner.opts)\n\t}\n\tif runner.opts.Out == nil {\n\t\tt.Fatalf(\"expected output writer\")\n\t}\n\tif runner.deps.Beads == nil || runner.deps.Git == nil || runner.deps.Prompt == nil || runner.deps.OpenCode == nil || runner.deps.Logger == nil {\n\t\tt.Fatalf(\"expected deps to be wired\")\n\t}\n\tif exit.code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", exit.code)\n\t}\n}\n\nfunc TestRunOnceMainDefaultsConfigPaths(t *testing.T) {\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tt.Setenv(\"HOME\", \"/home/user\")\n\n\tRunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\"}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif !runner.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n\tif runner.opts.ConfigRoot == \"\" {\n\t\tt.Fatalf(\"expected config root to be set\")\n\t}\n\tif runner.opts.ConfigDir == \"\" {\n\t\tt.Fatalf(\"expected config dir to be set\")\n\t}\n\texpectedConfigRoot := filepath.Join(\"/home/user\", \".config\", \"opencode-runner\")\n\tif runner.opts.ConfigRoot != expectedConfigRoot {\n\t\tt.Fatalf(\"expected config root %q, got %q\", expectedConfigRoot, runner.opts.ConfigRoot)\n\t}\n\texpectedConfigDir := filepath.Join(expectedConfigRoot, \"opencode\")\n\tif runner.opts.ConfigDir != expectedConfigDir {\n\t\tt.Fatalf(\"expected config dir %q, got %q\", expectedConfigDir, runner.opts.ConfigDir)\n\t}\n\tif exit.code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", exit.code)\n\t}\n}\n\ntype fakeTUIProgram struct {\n\tstarted chan struct{}\n\tquit    chan struct{}\n\tevents  []runner.Event\n}\n\nfunc newFakeTUIProgram() *fakeTUIProgram {\n\treturn &fakeTUIProgram{\n\t\tstarted: make(chan struct{}),\n\t\tquit:    make(chan struct{}),\n\t}\n}\n\nfunc (f *fakeTUIProgram) Start() error {\n\tclose(f.started)\n\treturn nil\n}\n\nfunc (f *fakeTUIProgram) Send(event runner.Event) {\n\tf.events = append(f.events, event)\n}\n\nfunc (f *fakeTUIProgram) Quit() {\n\tclose(f.quit)\n}\n\nfunc waitForSignal(t *testing.T, signal chan struct{}, label string) {\n\tt.Helper()\n\tselect {\n\tcase <-signal:\n\t\treturn\n\tcase <-time.After(100 * time.Millisecond):\n\t\tt.Fatalf(\"expected %s\", label)\n\t}\n}\n\nfunc TestRunOnceMainUsesTUIOnTTYByDefault(t *testing.T) {\n\tfakeProgram := newFakeTUIProgram()\n\tprevIsTerminal := isTerminal\n\tprevNewTUIProgram := newTUIProgram\n\tisTerminal = func(io.Writer) bool { return true }\n\tnewTUIProgram = func(stdout io.Writer) tuiProgram { return fakeProgram }\n\tt.Cleanup(func() {\n\t\tisTerminal = prevIsTerminal\n\t\tnewTUIProgram = prevNewTUIProgram\n\t})\n\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\"}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", code)\n\t}\n\tif runner.deps.Events == nil {\n\t\tt.Fatalf(\"expected events emitter to be set\")\n\t}\n\trunner.deps.Events.Emit(runner.Event{Type: runner.EventSelectTask})\n\tif len(fakeProgram.events) != 1 {\n\t\tt.Fatalf(\"expected event to be forwarded to TUI\")\n\t}\n\twaitForSignal(t, fakeProgram.started, \"tui start\")\n\twaitForSignal(t, fakeProgram.quit, \"tui quit\")\n}\n\nfunc TestRunOnceMainHeadlessDisablesTUI(t *testing.T) {\n\tcalled := false\n\tprevIsTerminal := isTerminal\n\tprevNewTUIProgram := newTUIProgram\n\tisTerminal = func(io.Writer) bool { return true }\n\tnewTUIProgram = func(stdout io.Writer) tuiProgram {\n\t\tcalled = true\n\t\treturn newFakeTUIProgram()\n\t}\n\tt.Cleanup(func() {\n\t\tisTerminal = prevIsTerminal\n\t\tnewTUIProgram = prevNewTUIProgram\n\t})\n\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\tstderr := &bytes.Buffer{}\n\n\tRunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\", \"--headless\"}, runner.Run, exit.Exit, out, stderr, beadsRunner, gitRunner)\n\n\tif called {\n\t\tt.Fatalf(\"expected TUI program not to start\")\n\t}\n\tif runner.deps.Events != nil {\n\t\tt.Fatalf(\"expected no events emitter in headless mode\")\n\t}\n}\n\nfunc TestOpenCodeRunDefaultsCreateConfigAndEnv(t *testing.T) {\n\ttempDir := t.TempDir()\n\trepoRoot := filepath.Join(tempDir, \"repo\")\n\tif err := os.MkdirAll(repoRoot, 0o755); err != nil {\n\t\tt.Fatalf(\"mkdir repo: %v\", err)\n\t}\n\tt.Setenv(\"HOME\", tempDir)\n\n\topenCodeRunner := &fakeOpenCodeRunner{}\n\topenCodeAdapter := openCodeAdapter{runner: openCodeRunner}\n\n\tconfigRoot := filepath.Join(tempDir, \".config\", \"opencode-runner\")\n\tconfigDir := filepath.Join(configRoot, \"opencode\")\n\tlogPath := filepath.Join(tempDir, \"runner-logs\", \"opencode\", \"issue-1.jsonl\")\n\n\tif err := openCodeAdapter.Run(\"issue-1\", repoRoot, \"prompt\", \"\", configRoot, configDir, logPath); err != nil {\n\t\tt.Fatalf(\"open code run error: %v\", err)\n\t}\n\n\tconfigFile := filepath.Join(configDir, \"opencode.json\")\n\tif _, err := os.Stat(configFile); err != nil {\n\t\tt.Fatalf(\"expected opencode.json to exist: %v\", err)\n\t}\n\texpectedConfigFile := filepath.Join(configDir, \"opencode.json\")\n\tif openCodeRunner.env[\"XDG_CONFIG_HOME\"] != configRoot {\n\t\tt.Fatalf(\"expected XDG_CONFIG_HOME set\")\n\t}\n\tif openCodeRunner.env[\"OPENCODE_CONFIG_DIR\"] != configDir {\n\t\tt.Fatalf(\"expected OPENCODE_CONFIG_DIR set\")\n\t}\n\tif openCodeRunner.env[\"OPENCODE_CONFIG\"] != expectedConfigFile {\n\t\tt.Fatalf(\"expected OPENCODE_CONFIG set\")\n\t}\n\tif openCodeRunner.env[\"OPENCODE_CONFIG_CONTENT\"] != \"{}\" {\n\t\tt.Fatalf(\"expected OPENCODE_CONFIG_CONTENT set\")\n\t}\n}\n","additions":66,"deletions":11},"truncated":false},"time":{"start":1768840647965,"end":1768840648127}},"metadata":{"openai":{"itemId":"fc_04037e3ba050dce801696e5dbe34608191b09a4afe74602e6b"}}}}
{"type":"step_finish","timestamp":1768840648142,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd71e55c0001NO8H0p4muVetEN","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd71c6abd001hBrE09EUOOW4ET","type":"step-finish","reason":"tool-calls","snapshot":"a7de4533d6db3df3dde53cef4fcc0792b15b638f","cost":0,"tokens":{"input":2121,"output":6476,"reasoning":5120,"cache":{"read":40576,"write":0}}}}
{"type":"step_start","timestamp":1768840648611,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd71e57a2001AO2cyP3xHvq7N5","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd71e55eb001xe8PyFas8dnuWe","type":"step-start","snapshot":"8eae3dd7d0976db94c6724f12a62885e8ba4b891"}}
{"type":"tool_use","timestamp":1768840653615,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd71e61d5001rRycQJO3A7PToL","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd71e55eb001xe8PyFas8dnuWe","type":"tool","callID":"call_WGtxGooXqV10XnwSckFZVQdB","tool":"edit","state":{"status":"completed","input":{"filePath":"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go","oldString":"import (\n\t\"bytes\"\n\t\"errors\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"yolo-runner/internal/opencode\"\n\t\"yolo-runner/internal/runner\"\n)\n","newString":"import (\n\t\"bytes\"\n\t\"errors\"\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"yolo-runner/internal/opencode\"\n\t\"yolo-runner/internal/runner\"\n)\n"},"output":"Edit applied successfully.\n\nLSP errors detected in this file, please fix:\n<diagnostics file=\"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go\">\nERROR [214:20] undefined: isTerminal\nERROR [215:23] undefined: newTUIProgram\nERROR [216:2] undefined: isTerminal\nERROR [217:2] undefined: newTUIProgram\nERROR [217:41] undefined: tuiProgram\nERROR [219:3] undefined: isTerminal\nERROR [220:3] undefined: newTUIProgram\nERROR [237:33] runner.Event is not a type\nERROR [237:52] runner.EventSelectTask undefined (type *fakeRunOnce has no field or method EventSelectTask)\nERROR [247:20] undefined: isTerminal\nERROR [248:23] undefined: newTUIProgram\nERROR [249:2] undefined: isTerminal\nERROR [250:2] undefined: newTUIProgram\nERROR [250:41] undefined: tuiProgram\nERROR [255:3] undefined: isTerminal\nERROR [256:3] undefined: newTUIProgram\n</diagnostics>","title":"cmd/yolo-runner/main_test.go","metadata":{"diagnostics":{"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main.go":[],"/Users/egv/dev/yolo-runner/go.mod":[{"range":{"start":{"line":6,"character":44},"end":{"line":6,"character":55}},"severity":2,"source":"go mod tidy","message":"github.com/charmbracelet/bubbletea should be direct"}],"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go":[{"range":{"start":{"line":213,"character":19},"end":{"line":213,"character":29}},"severity":1,"code":"UndeclaredName","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UndeclaredName"},"source":"compiler","message":"undefined: isTerminal"},{"range":{"start":{"line":214,"character":22},"end":{"line":214,"character":35}},"severity":1,"code":"UndeclaredName","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UndeclaredName"},"source":"compiler","message":"undefined: newTUIProgram"},{"range":{"start":{"line":215,"character":1},"end":{"line":215,"character":11}},"severity":1,"code":"UndeclaredName","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UndeclaredName"},"source":"compiler","message":"undefined: isTerminal"},{"range":{"start":{"line":216,"character":1},"end":{"line":216,"character":14}},"severity":1,"code":"UndeclaredName","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UndeclaredName"},"source":"compiler","message":"undefined: newTUIProgram"},{"range":{"start":{"line":216,"character":40},"end":{"line":216,"character":50}},"severity":1,"code":"UndeclaredName","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UndeclaredName"},"source":"compiler","message":"undefined: tuiProgram"},{"range":{"start":{"line":218,"character":2},"end":{"line":218,"character":12}},"severity":1,"code":"UndeclaredName","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UndeclaredName"},"source":"compiler","message":"undefined: isTerminal"},{"range":{"start":{"line":219,"character":2},"end":{"line":219,"character":15}},"severity":1,"code":"UndeclaredName","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UndeclaredName"},"source":"compiler","message":"undefined: newTUIProgram"},{"range":{"start":{"line":236,"character":32},"end":{"line":236,"character":37}},"severity":1,"code":"NotAType","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#NotAType"},"source":"compiler","message":"runner.Event is not a type"},{"range":{"start":{"line":236,"character":51},"end":{"line":236,"character":66}},"severity":1,"code":"MissingFieldOrMethod","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#MissingFieldOrMethod"},"source":"compiler","message":"runner.EventSelectTask undefined (type *fakeRunOnce has no field or method EventSelectTask)"},{"range":{"start":{"line":246,"character":19},"end":{"line":246,"character":29}},"severity":1,"code":"UndeclaredName","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UndeclaredName"},"source":"compiler","message":"undefined: isTerminal"},{"range":{"start":{"line":247,"character":22},"end":{"line":247,"character":35}},"severity":1,"code":"UndeclaredName","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UndeclaredName"},"source":"compiler","message":"undefined: newTUIProgram"},{"range":{"start":{"line":248,"character":1},"end":{"line":248,"character":11}},"severity":1,"code":"UndeclaredName","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UndeclaredName"},"source":"compiler","message":"undefined: isTerminal"},{"range":{"start":{"line":249,"character":1},"end":{"line":249,"character":14}},"severity":1,"code":"UndeclaredName","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UndeclaredName"},"source":"compiler","message":"undefined: newTUIProgram"},{"range":{"start":{"line":249,"character":40},"end":{"line":249,"character":50}},"severity":1,"code":"UndeclaredName","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UndeclaredName"},"source":"compiler","message":"undefined: tuiProgram"},{"range":{"start":{"line":254,"character":2},"end":{"line":254,"character":12}},"severity":1,"code":"UndeclaredName","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UndeclaredName"},"source":"compiler","message":"undefined: isTerminal"},{"range":{"start":{"line":255,"character":2},"end":{"line":255,"character":15}},"severity":1,"code":"UndeclaredName","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UndeclaredName"},"source":"compiler","message":"undefined: newTUIProgram"}],"/Users/egv/dev/yolo-runner/bubbletea_test.go":[],"/Users/egv/dev/yolo-runner/opencode_adapter_v1.go":[{"range":{"start":{"line":24,"character":1},"end":{"line":24,"character":18}},"severity":2,"code":"default","codeDescription":{"href":"https://staticcheck.dev/docs/checks/#S1031"},"source":"S1031","message":"unnecessary nil check around range"}],"/Users/egv/dev/yolo-runner/internal/ui/tui/model.go":[],"/Users/egv/dev/yolo-runner/internal/runner/runner.go":[],"/Users/egv/dev/yolo-runner/internal/ui/tui/model_test.go":[],"/Users/egv/dev/yolo-runner/internal/runner/events.go":[],"/Users/egv/dev/yolo-runner/internal/runner/loop_test.go":[],"/Users/egv/dev/yolo-runner/internal/runner/runner_test.go":[],"/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/tea.go":[],"/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/tty_unix.go":[],"/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/tty.go":[],"/Users/egv/dev/yolo-runner/internal/opencode/watchdog.go":[],"/Users/egv/dev/yolo-runner/internal/opencode/client.go":[{"range":{"start":{"line":28,"character":1},"end":{"line":28,"character":18}},"severity":2,"code":"default","codeDescription":{"href":"https://staticcheck.dev/docs/checks/#S1031"},"source":"S1031","message":"unnecessary nil check around range"}],"/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/options.go":[],"/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/tty_windows.go":[{"range":{"start":{"line":3,"character":8},"end":{"line":3,"character":11}},"severity":2,"source":"go list","message":"This file is within module \"../../go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0\", which is not included in your workspace.\nTo fix this problem, you can add a go.work file that uses this directory.\nSee the documentation for more information on setting up your workspace:\nhttps://github.com/golang/tools/blob/master/gopls/doc/workspace.md.","data":{"Actions":[{"title":"Add a go.work file using this module","kind":"quickfix","command":{"title":"Run `go work init && go work use`","command":"gopls.run_go_work_command","arguments":[{"ViewID":"1","InitFirst":true,"Args":["use","../../go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0"]}]}}]}}]},"diff":"Index: /Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go\n===================================================================\n--- /Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go\n+++ /Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go\n@@ -2,12 +2,14 @@\n \n import (\n \t\"bytes\"\n \t\"errors\"\n+\t\"io\"\n \t\"os\"\n \t\"path/filepath\"\n \t\"strings\"\n \t\"testing\"\n+\t\"time\"\n \n \t\"yolo-runner/internal/opencode\"\n \t\"yolo-runner/internal/runner\"\n )\n","filediff":{"file":"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go","before":"package main\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"yolo-runner/internal/opencode\"\n\t\"yolo-runner/internal/runner\"\n)\n\ntype fakeRunner struct {\n\tcalls []string\n}\n\nfunc (f *fakeRunner) Run(args ...string) (string, error) {\n\tf.calls = append(f.calls, strings.Join(args, \" \"))\n\treturn \"\", nil\n}\n\ntype fakeOpenCodeRunLogger struct {\n\tcalled     bool\n\tissueID    string\n\trepoRoot   string\n\tprompt     string\n\tmodel      string\n\tconfigRoot string\n\tconfigDir  string\n\tlogPath    string\n}\n\nfunc (f *fakeOpenCodeRunLogger) Run(issueID string, repoRoot string, prompt string, model string, configRoot string, configDir string, logPath string) error {\n\tf.called = true\n\tf.issueID = issueID\n\tf.repoRoot = repoRoot\n\tf.prompt = prompt\n\tf.model = model\n\tf.configRoot = configRoot\n\tf.configDir = configDir\n\tf.logPath = logPath\n\treturn nil\n}\n\ntype fakeOpenCodeRunner struct {\n\tenv map[string]string\n}\n\ntype fakeOpenCodeProcess struct{}\n\nfunc (fakeOpenCodeProcess) Wait() error { return nil }\n\nfunc (fakeOpenCodeProcess) Kill() error { return nil }\n\nfunc (f *fakeOpenCodeRunner) Start(args []string, env map[string]string, stdoutPath string) (opencode.Process, error) {\n\tf.env = env\n\treturn fakeOpenCodeProcess{}, nil\n}\n\ntype fakeGitRunner struct {\n\tcalls  []string\n\toutput string\n\terr    error\n}\n\nfunc (f *fakeGitRunner) Run(name string, args ...string) (string, error) {\n\tf.calls = append(f.calls, name+\" \"+strings.Join(args, \" \"))\n\treturn f.output, f.err\n}\n\ntype fakeExit struct {\n\tcode int\n}\n\nfunc (f *fakeExit) Exit(code int) {\n\tf.code = code\n}\n\ntype fakeRunOnce struct {\n\tcalled bool\n\topts   runner.RunOnceOptions\n\tdeps   runner.RunOnceDeps\n\tresult string\n\terr    error\n}\n\nfunc (f *fakeRunOnce) Run(opts runner.RunOnceOptions, deps runner.RunOnceDeps) (string, error) {\n\n\tf.called = true\n\tf.opts = opts\n\tf.deps = deps\n\treturn f.result, f.err\n}\n\nfunc TestRunOnceMainReturnsErrorCodeOnFailure(t *testing.T) {\n\trunner := &fakeRunOnce{err: errors.New(\"boom\")}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\n\tcode := RunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\"}, runner.Run, exit.Exit, out, out, nil, nil)\n\n\tif code != 1 {\n\t\tt.Fatalf(\"expected exit code 1, got %d\", code)\n\t}\n\tif exit.code != 1 {\n\t\tt.Fatalf(\"expected exit to be called with 1, got %d\", exit.code)\n\t}\n\tif !strings.Contains(out.String(), \"boom\") {\n\t\tt.Fatalf(\"expected error output, got %q\", out.String())\n\t}\n}\n\nfunc TestRunOnceMainWiresDependencies(t *testing.T) {\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tRunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\", \"--model\", \"model\", \"--dry-run\"}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif !runner.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n\tif runner.opts.RepoRoot != \"/repo\" || runner.opts.RootID != \"root\" || runner.opts.Model != \"model\" || !runner.opts.DryRun {\n\t\tt.Fatalf(\"unexpected options: %#v\", runner.opts)\n\t}\n\tif runner.opts.Out == nil {\n\t\tt.Fatalf(\"expected output writer\")\n\t}\n\tif runner.deps.Beads == nil || runner.deps.Git == nil || runner.deps.Prompt == nil || runner.deps.OpenCode == nil || runner.deps.Logger == nil {\n\t\tt.Fatalf(\"expected deps to be wired\")\n\t}\n\tif exit.code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", exit.code)\n\t}\n}\n\nfunc TestRunOnceMainDefaultsConfigPaths(t *testing.T) {\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tt.Setenv(\"HOME\", \"/home/user\")\n\n\tRunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\"}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif !runner.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n\tif runner.opts.ConfigRoot == \"\" {\n\t\tt.Fatalf(\"expected config root to be set\")\n\t}\n\tif runner.opts.ConfigDir == \"\" {\n\t\tt.Fatalf(\"expected config dir to be set\")\n\t}\n\texpectedConfigRoot := filepath.Join(\"/home/user\", \".config\", \"opencode-runner\")\n\tif runner.opts.ConfigRoot != expectedConfigRoot {\n\t\tt.Fatalf(\"expected config root %q, got %q\", expectedConfigRoot, runner.opts.ConfigRoot)\n\t}\n\texpectedConfigDir := filepath.Join(expectedConfigRoot, \"opencode\")\n\tif runner.opts.ConfigDir != expectedConfigDir {\n\t\tt.Fatalf(\"expected config dir %q, got %q\", expectedConfigDir, runner.opts.ConfigDir)\n\t}\n\tif exit.code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", exit.code)\n\t}\n}\n\ntype fakeTUIProgram struct {\n\tstarted chan struct{}\n\tquit    chan struct{}\n\tevents  []runner.Event\n}\n\nfunc newFakeTUIProgram() *fakeTUIProgram {\n\treturn &fakeTUIProgram{\n\t\tstarted: make(chan struct{}),\n\t\tquit:    make(chan struct{}),\n\t}\n}\n\nfunc (f *fakeTUIProgram) Start() error {\n\tclose(f.started)\n\treturn nil\n}\n\nfunc (f *fakeTUIProgram) Send(event runner.Event) {\n\tf.events = append(f.events, event)\n}\n\nfunc (f *fakeTUIProgram) Quit() {\n\tclose(f.quit)\n}\n\nfunc waitForSignal(t *testing.T, signal chan struct{}, label string) {\n\tt.Helper()\n\tselect {\n\tcase <-signal:\n\t\treturn\n\tcase <-time.After(100 * time.Millisecond):\n\t\tt.Fatalf(\"expected %s\", label)\n\t}\n}\n\nfunc TestRunOnceMainUsesTUIOnTTYByDefault(t *testing.T) {\n\tfakeProgram := newFakeTUIProgram()\n\tprevIsTerminal := isTerminal\n\tprevNewTUIProgram := newTUIProgram\n\tisTerminal = func(io.Writer) bool { return true }\n\tnewTUIProgram = func(stdout io.Writer) tuiProgram { return fakeProgram }\n\tt.Cleanup(func() {\n\t\tisTerminal = prevIsTerminal\n\t\tnewTUIProgram = prevNewTUIProgram\n\t})\n\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\"}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", code)\n\t}\n\tif runner.deps.Events == nil {\n\t\tt.Fatalf(\"expected events emitter to be set\")\n\t}\n\trunner.deps.Events.Emit(runner.Event{Type: runner.EventSelectTask})\n\tif len(fakeProgram.events) != 1 {\n\t\tt.Fatalf(\"expected event to be forwarded to TUI\")\n\t}\n\twaitForSignal(t, fakeProgram.started, \"tui start\")\n\twaitForSignal(t, fakeProgram.quit, \"tui quit\")\n}\n\nfunc TestRunOnceMainHeadlessDisablesTUI(t *testing.T) {\n\tcalled := false\n\tprevIsTerminal := isTerminal\n\tprevNewTUIProgram := newTUIProgram\n\tisTerminal = func(io.Writer) bool { return true }\n\tnewTUIProgram = func(stdout io.Writer) tuiProgram {\n\t\tcalled = true\n\t\treturn newFakeTUIProgram()\n\t}\n\tt.Cleanup(func() {\n\t\tisTerminal = prevIsTerminal\n\t\tnewTUIProgram = prevNewTUIProgram\n\t})\n\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\tstderr := &bytes.Buffer{}\n\n\tRunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\", \"--headless\"}, runner.Run, exit.Exit, out, stderr, beadsRunner, gitRunner)\n\n\tif called {\n\t\tt.Fatalf(\"expected TUI program not to start\")\n\t}\n\tif runner.deps.Events != nil {\n\t\tt.Fatalf(\"expected no events emitter in headless mode\")\n\t}\n}\n\nfunc TestOpenCodeRunDefaultsCreateConfigAndEnv(t *testing.T) {\n\ttempDir := t.TempDir()\n\trepoRoot := filepath.Join(tempDir, \"repo\")\n\tif err := os.MkdirAll(repoRoot, 0o755); err != nil {\n\t\tt.Fatalf(\"mkdir repo: %v\", err)\n\t}\n\tt.Setenv(\"HOME\", tempDir)\n\n\topenCodeRunner := &fakeOpenCodeRunner{}\n\topenCodeAdapter := openCodeAdapter{runner: openCodeRunner}\n\n\tconfigRoot := filepath.Join(tempDir, \".config\", \"opencode-runner\")\n\tconfigDir := filepath.Join(configRoot, \"opencode\")\n\tlogPath := filepath.Join(tempDir, \"runner-logs\", \"opencode\", \"issue-1.jsonl\")\n\n\tif err := openCodeAdapter.Run(\"issue-1\", repoRoot, \"prompt\", \"\", configRoot, configDir, logPath); err != nil {\n\t\tt.Fatalf(\"open code run error: %v\", err)\n\t}\n\n\tconfigFile := filepath.Join(configDir, \"opencode.json\")\n\tif _, err := os.Stat(configFile); err != nil {\n\t\tt.Fatalf(\"expected opencode.json to exist: %v\", err)\n\t}\n\texpectedConfigFile := filepath.Join(configDir, \"opencode.json\")\n\tif openCodeRunner.env[\"XDG_CONFIG_HOME\"] != configRoot {\n\t\tt.Fatalf(\"expected XDG_CONFIG_HOME set\")\n\t}\n\tif openCodeRunner.env[\"OPENCODE_CONFIG_DIR\"] != configDir {\n\t\tt.Fatalf(\"expected OPENCODE_CONFIG_DIR set\")\n\t}\n\tif openCodeRunner.env[\"OPENCODE_CONFIG\"] != expectedConfigFile {\n\t\tt.Fatalf(\"expected OPENCODE_CONFIG set\")\n\t}\n\tif openCodeRunner.env[\"OPENCODE_CONFIG_CONTENT\"] != \"{}\" {\n\t\tt.Fatalf(\"expected OPENCODE_CONFIG_CONTENT set\")\n\t}\n}\n","after":"package main\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"yolo-runner/internal/opencode\"\n\t\"yolo-runner/internal/runner\"\n)\n\ntype fakeRunner struct {\n\tcalls []string\n}\n\nfunc (f *fakeRunner) Run(args ...string) (string, error) {\n\tf.calls = append(f.calls, strings.Join(args, \" \"))\n\treturn \"\", nil\n}\n\ntype fakeOpenCodeRunLogger struct {\n\tcalled     bool\n\tissueID    string\n\trepoRoot   string\n\tprompt     string\n\tmodel      string\n\tconfigRoot string\n\tconfigDir  string\n\tlogPath    string\n}\n\nfunc (f *fakeOpenCodeRunLogger) Run(issueID string, repoRoot string, prompt string, model string, configRoot string, configDir string, logPath string) error {\n\tf.called = true\n\tf.issueID = issueID\n\tf.repoRoot = repoRoot\n\tf.prompt = prompt\n\tf.model = model\n\tf.configRoot = configRoot\n\tf.configDir = configDir\n\tf.logPath = logPath\n\treturn nil\n}\n\ntype fakeOpenCodeRunner struct {\n\tenv map[string]string\n}\n\ntype fakeOpenCodeProcess struct{}\n\nfunc (fakeOpenCodeProcess) Wait() error { return nil }\n\nfunc (fakeOpenCodeProcess) Kill() error { return nil }\n\nfunc (f *fakeOpenCodeRunner) Start(args []string, env map[string]string, stdoutPath string) (opencode.Process, error) {\n\tf.env = env\n\treturn fakeOpenCodeProcess{}, nil\n}\n\ntype fakeGitRunner struct {\n\tcalls  []string\n\toutput string\n\terr    error\n}\n\nfunc (f *fakeGitRunner) Run(name string, args ...string) (string, error) {\n\tf.calls = append(f.calls, name+\" \"+strings.Join(args, \" \"))\n\treturn f.output, f.err\n}\n\ntype fakeExit struct {\n\tcode int\n}\n\nfunc (f *fakeExit) Exit(code int) {\n\tf.code = code\n}\n\ntype fakeRunOnce struct {\n\tcalled bool\n\topts   runner.RunOnceOptions\n\tdeps   runner.RunOnceDeps\n\tresult string\n\terr    error\n}\n\nfunc (f *fakeRunOnce) Run(opts runner.RunOnceOptions, deps runner.RunOnceDeps) (string, error) {\n\n\tf.called = true\n\tf.opts = opts\n\tf.deps = deps\n\treturn f.result, f.err\n}\n\nfunc TestRunOnceMainReturnsErrorCodeOnFailure(t *testing.T) {\n\trunner := &fakeRunOnce{err: errors.New(\"boom\")}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\n\tcode := RunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\"}, runner.Run, exit.Exit, out, out, nil, nil)\n\n\tif code != 1 {\n\t\tt.Fatalf(\"expected exit code 1, got %d\", code)\n\t}\n\tif exit.code != 1 {\n\t\tt.Fatalf(\"expected exit to be called with 1, got %d\", exit.code)\n\t}\n\tif !strings.Contains(out.String(), \"boom\") {\n\t\tt.Fatalf(\"expected error output, got %q\", out.String())\n\t}\n}\n\nfunc TestRunOnceMainWiresDependencies(t *testing.T) {\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tRunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\", \"--model\", \"model\", \"--dry-run\"}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif !runner.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n\tif runner.opts.RepoRoot != \"/repo\" || runner.opts.RootID != \"root\" || runner.opts.Model != \"model\" || !runner.opts.DryRun {\n\t\tt.Fatalf(\"unexpected options: %#v\", runner.opts)\n\t}\n\tif runner.opts.Out == nil {\n\t\tt.Fatalf(\"expected output writer\")\n\t}\n\tif runner.deps.Beads == nil || runner.deps.Git == nil || runner.deps.Prompt == nil || runner.deps.OpenCode == nil || runner.deps.Logger == nil {\n\t\tt.Fatalf(\"expected deps to be wired\")\n\t}\n\tif exit.code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", exit.code)\n\t}\n}\n\nfunc TestRunOnceMainDefaultsConfigPaths(t *testing.T) {\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tt.Setenv(\"HOME\", \"/home/user\")\n\n\tRunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\"}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif !runner.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n\tif runner.opts.ConfigRoot == \"\" {\n\t\tt.Fatalf(\"expected config root to be set\")\n\t}\n\tif runner.opts.ConfigDir == \"\" {\n\t\tt.Fatalf(\"expected config dir to be set\")\n\t}\n\texpectedConfigRoot := filepath.Join(\"/home/user\", \".config\", \"opencode-runner\")\n\tif runner.opts.ConfigRoot != expectedConfigRoot {\n\t\tt.Fatalf(\"expected config root %q, got %q\", expectedConfigRoot, runner.opts.ConfigRoot)\n\t}\n\texpectedConfigDir := filepath.Join(expectedConfigRoot, \"opencode\")\n\tif runner.opts.ConfigDir != expectedConfigDir {\n\t\tt.Fatalf(\"expected config dir %q, got %q\", expectedConfigDir, runner.opts.ConfigDir)\n\t}\n\tif exit.code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", exit.code)\n\t}\n}\n\ntype fakeTUIProgram struct {\n\tstarted chan struct{}\n\tquit    chan struct{}\n\tevents  []runner.Event\n}\n\nfunc newFakeTUIProgram() *fakeTUIProgram {\n\treturn &fakeTUIProgram{\n\t\tstarted: make(chan struct{}),\n\t\tquit:    make(chan struct{}),\n\t}\n}\n\nfunc (f *fakeTUIProgram) Start() error {\n\tclose(f.started)\n\treturn nil\n}\n\nfunc (f *fakeTUIProgram) Send(event runner.Event) {\n\tf.events = append(f.events, event)\n}\n\nfunc (f *fakeTUIProgram) Quit() {\n\tclose(f.quit)\n}\n\nfunc waitForSignal(t *testing.T, signal chan struct{}, label string) {\n\tt.Helper()\n\tselect {\n\tcase <-signal:\n\t\treturn\n\tcase <-time.After(100 * time.Millisecond):\n\t\tt.Fatalf(\"expected %s\", label)\n\t}\n}\n\nfunc TestRunOnceMainUsesTUIOnTTYByDefault(t *testing.T) {\n\tfakeProgram := newFakeTUIProgram()\n\tprevIsTerminal := isTerminal\n\tprevNewTUIProgram := newTUIProgram\n\tisTerminal = func(io.Writer) bool { return true }\n\tnewTUIProgram = func(stdout io.Writer) tuiProgram { return fakeProgram }\n\tt.Cleanup(func() {\n\t\tisTerminal = prevIsTerminal\n\t\tnewTUIProgram = prevNewTUIProgram\n\t})\n\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\"}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", code)\n\t}\n\tif runner.deps.Events == nil {\n\t\tt.Fatalf(\"expected events emitter to be set\")\n\t}\n\trunner.deps.Events.Emit(runner.Event{Type: runner.EventSelectTask})\n\tif len(fakeProgram.events) != 1 {\n\t\tt.Fatalf(\"expected event to be forwarded to TUI\")\n\t}\n\twaitForSignal(t, fakeProgram.started, \"tui start\")\n\twaitForSignal(t, fakeProgram.quit, \"tui quit\")\n}\n\nfunc TestRunOnceMainHeadlessDisablesTUI(t *testing.T) {\n\tcalled := false\n\tprevIsTerminal := isTerminal\n\tprevNewTUIProgram := newTUIProgram\n\tisTerminal = func(io.Writer) bool { return true }\n\tnewTUIProgram = func(stdout io.Writer) tuiProgram {\n\t\tcalled = true\n\t\treturn newFakeTUIProgram()\n\t}\n\tt.Cleanup(func() {\n\t\tisTerminal = prevIsTerminal\n\t\tnewTUIProgram = prevNewTUIProgram\n\t})\n\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\tstderr := &bytes.Buffer{}\n\n\tRunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\", \"--headless\"}, runner.Run, exit.Exit, out, stderr, beadsRunner, gitRunner)\n\n\tif called {\n\t\tt.Fatalf(\"expected TUI program not to start\")\n\t}\n\tif runner.deps.Events != nil {\n\t\tt.Fatalf(\"expected no events emitter in headless mode\")\n\t}\n}\n\nfunc TestOpenCodeRunDefaultsCreateConfigAndEnv(t *testing.T) {\n\ttempDir := t.TempDir()\n\trepoRoot := filepath.Join(tempDir, \"repo\")\n\tif err := os.MkdirAll(repoRoot, 0o755); err != nil {\n\t\tt.Fatalf(\"mkdir repo: %v\", err)\n\t}\n\tt.Setenv(\"HOME\", tempDir)\n\n\topenCodeRunner := &fakeOpenCodeRunner{}\n\topenCodeAdapter := openCodeAdapter{runner: openCodeRunner}\n\n\tconfigRoot := filepath.Join(tempDir, \".config\", \"opencode-runner\")\n\tconfigDir := filepath.Join(configRoot, \"opencode\")\n\tlogPath := filepath.Join(tempDir, \"runner-logs\", \"opencode\", \"issue-1.jsonl\")\n\n\tif err := openCodeAdapter.Run(\"issue-1\", repoRoot, \"prompt\", \"\", configRoot, configDir, logPath); err != nil {\n\t\tt.Fatalf(\"open code run error: %v\", err)\n\t}\n\n\tconfigFile := filepath.Join(configDir, \"opencode.json\")\n\tif _, err := os.Stat(configFile); err != nil {\n\t\tt.Fatalf(\"expected opencode.json to exist: %v\", err)\n\t}\n\texpectedConfigFile := filepath.Join(configDir, \"opencode.json\")\n\tif openCodeRunner.env[\"XDG_CONFIG_HOME\"] != configRoot {\n\t\tt.Fatalf(\"expected XDG_CONFIG_HOME set\")\n\t}\n\tif openCodeRunner.env[\"OPENCODE_CONFIG_DIR\"] != configDir {\n\t\tt.Fatalf(\"expected OPENCODE_CONFIG_DIR set\")\n\t}\n\tif openCodeRunner.env[\"OPENCODE_CONFIG\"] != expectedConfigFile {\n\t\tt.Fatalf(\"expected OPENCODE_CONFIG set\")\n\t}\n\tif openCodeRunner.env[\"OPENCODE_CONFIG_CONTENT\"] != \"{}\" {\n\t\tt.Fatalf(\"expected OPENCODE_CONFIG_CONTENT set\")\n\t}\n}\n","additions":2,"deletions":0},"truncated":false},"time":{"start":1768840653335,"end":1768840653614}},"metadata":{"openai":{"itemId":"fc_0b460233a1ef2a2401696e5dcb268481919178f8534737b015"}}}}
{"type":"step_finish","timestamp":1768840653632,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd71e6b2f001UqEKKLQ8ApLsID","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd71e55eb001xe8PyFas8dnuWe","type":"step-finish","reason":"tool-calls","snapshot":"6835df942479dc235cda414223331cc50828ec07","cost":0,"tokens":{"input":1724,"output":240,"reasoning":64,"cache":{"read":42624,"write":0}}}}
{"type":"step_start","timestamp":1768840654145,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd71e6d41001o5PHfB4OMtCAsq","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd71e6b5d001dnnMcA6uaQluAJ","type":"step-start","snapshot":"36dd608c38fd87614460bbe1c38ce6c373609837"}}
{"type":"step_finish","timestamp":1768840658766,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd71e7f410014kMrMjL1Wyi2uW","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd71e6b5d001dnnMcA6uaQluAJ","type":"step-finish","reason":"tool-calls","snapshot":"4fca26237de30a1611bd78b78c10d7042dc4c18b","cost":0,"tokens":{"input":1129,"output":84,"reasoning":0,"cache":{"read":43648,"write":0}}}}
{"type":"step_start","timestamp":1768840659280,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd71e814f0017zdy0B9DSDTwEe","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd71e7f69001p67Mk20LpypCdx","type":"step-start","snapshot":"d8baa4307eebdc4b71ed9ebc6567f75e0a6005fc"}}
{"type":"tool_use","timestamp":1768840678646,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd71e8819001xCfdE85GKh1Iy6","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd71e7f69001p67Mk20LpypCdx","type":"tool","callID":"call_g0xZP4MhjXaDr4HmqoCAKIT9","tool":"edit","state":{"status":"completed","input":{"filePath":"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go","oldString":"\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\"}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", code)\n\t}\n\tif runner.deps.Events == nil {\n\t\tt.Fatalf(\"expected events emitter to be set\")\n\t}\n\trunner.deps.Events.Emit(runner.Event{Type: runner.EventSelectTask})\n\tif len(fakeProgram.events) != 1 {\n\t\tt.Fatalf(\"expected event to be forwarded to TUI\")\n\t}\n\twaitForSignal(t, fakeProgram.started, \"tui start\")\n\twaitForSignal(t, fakeProgram.quit, \"tui quit\")\n}\n\nfunc TestRunOnceMainHeadlessDisablesTUI(t *testing.T) {\n\tcalled := false\n\tprevIsTerminal := isTerminal\n\tprevNewTUIProgram := newTUIProgram\n\tisTerminal = func(io.Writer) bool { return true }\n\tnewTUIProgram = func(stdout io.Writer) tuiProgram {\n\t\tcalled = true\n\t\treturn newFakeTUIProgram()\n\t}\n\tt.Cleanup(func() {\n\t\tisTerminal = prevIsTerminal\n\t\tnewTUIProgram = prevNewTUIProgram\n\t})\n\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\tstderr := &bytes.Buffer{}\n\n\tRunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\", \"--headless\"}, runner.Run, exit.Exit, out, stderr, beadsRunner, gitRunner)\n\n\tif called {\n\t\tt.Fatalf(\"expected TUI program not to start\")\n\t}\n\tif runner.deps.Events != nil {\n\t\tt.Fatalf(\"expected no events emitter in headless mode\")\n\t}\n}\n","newString":"\trunOnce := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\"}, runOnce.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", code)\n\t}\n\tif runOnce.deps.Events == nil {\n\t\tt.Fatalf(\"expected events emitter to be set\")\n\t}\n\trunOnce.deps.Events.Emit(runner.Event{Type: runner.EventSelectTask})\n\tif len(fakeProgram.events) != 1 {\n\t\tt.Fatalf(\"expected event to be forwarded to TUI\")\n\t}\n\twaitForSignal(t, fakeProgram.started, \"tui start\")\n\twaitForSignal(t, fakeProgram.quit, \"tui quit\")\n}\n\nfunc TestRunOnceMainHeadlessDisablesTUI(t *testing.T) {\n\tcalled := false\n\tprevIsTerminal := isTerminal\n\tprevNewTUIProgram := newTUIProgram\n\tisTerminal = func(io.Writer) bool { return true }\n\tnewTUIProgram = func(stdout io.Writer) tuiProgram {\n\t\tcalled = true\n\t\treturn newFakeTUIProgram()\n\t}\n\tt.Cleanup(func() {\n\t\tisTerminal = prevIsTerminal\n\t\tnewTUIProgram = prevNewTUIProgram\n\t})\n\n\trunOnce := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\tstderr := &bytes.Buffer{}\n\n\tRunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\", \"--headless\"}, runOnce.Run, exit.Exit, out, stderr, beadsRunner, gitRunner)\n\n\tif called {\n\t\tt.Fatalf(\"expected TUI program not to start\")\n\t}\n\tif runOnce.deps.Events != nil {\n\t\tt.Fatalf(\"expected no events emitter in headless mode\")\n\t}\n}\n"},"output":"Edit applied successfully.\n\nLSP errors detected in this file, please fix:\n<diagnostics file=\"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go\">\nERROR [214:20] undefined: isTerminal\nERROR [215:23] undefined: newTUIProgram\nERROR [216:2] undefined: isTerminal\nERROR [217:2] undefined: newTUIProgram\nERROR [217:41] undefined: tuiProgram\nERROR [219:3] undefined: isTerminal\nERROR [220:3] undefined: newTUIProgram\nERROR [247:20] undefined: isTerminal\nERROR [248:23] undefined: newTUIProgram\nERROR [249:2] undefined: isTerminal\nERROR [250:2] undefined: newTUIProgram\nERROR [250:41] undefined: tuiProgram\nERROR [255:3] undefined: isTerminal\nERROR [256:3] undefined: newTUIProgram\n</diagnostics>","title":"cmd/yolo-runner/main_test.go","metadata":{"diagnostics":{"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main.go":[],"/Users/egv/dev/yolo-runner/go.mod":[{"range":{"start":{"line":6,"character":44},"end":{"line":6,"character":55}},"severity":2,"source":"go mod tidy","message":"github.com/charmbracelet/bubbletea should be direct"}],"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go":[{"range":{"start":{"line":213,"character":19},"end":{"line":213,"character":29}},"severity":1,"code":"UndeclaredName","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UndeclaredName"},"source":"compiler","message":"undefined: isTerminal"},{"range":{"start":{"line":214,"character":22},"end":{"line":214,"character":35}},"severity":1,"code":"UndeclaredName","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UndeclaredName"},"source":"compiler","message":"undefined: newTUIProgram"},{"range":{"start":{"line":215,"character":1},"end":{"line":215,"character":11}},"severity":1,"code":"UndeclaredName","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UndeclaredName"},"source":"compiler","message":"undefined: isTerminal"},{"range":{"start":{"line":216,"character":1},"end":{"line":216,"character":14}},"severity":1,"code":"UndeclaredName","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UndeclaredName"},"source":"compiler","message":"undefined: newTUIProgram"},{"range":{"start":{"line":216,"character":40},"end":{"line":216,"character":50}},"severity":1,"code":"UndeclaredName","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UndeclaredName"},"source":"compiler","message":"undefined: tuiProgram"},{"range":{"start":{"line":218,"character":2},"end":{"line":218,"character":12}},"severity":1,"code":"UndeclaredName","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UndeclaredName"},"source":"compiler","message":"undefined: isTerminal"},{"range":{"start":{"line":219,"character":2},"end":{"line":219,"character":15}},"severity":1,"code":"UndeclaredName","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UndeclaredName"},"source":"compiler","message":"undefined: newTUIProgram"},{"range":{"start":{"line":246,"character":19},"end":{"line":246,"character":29}},"severity":1,"code":"UndeclaredName","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UndeclaredName"},"source":"compiler","message":"undefined: isTerminal"},{"range":{"start":{"line":247,"character":22},"end":{"line":247,"character":35}},"severity":1,"code":"UndeclaredName","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UndeclaredName"},"source":"compiler","message":"undefined: newTUIProgram"},{"range":{"start":{"line":248,"character":1},"end":{"line":248,"character":11}},"severity":1,"code":"UndeclaredName","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UndeclaredName"},"source":"compiler","message":"undefined: isTerminal"},{"range":{"start":{"line":249,"character":1},"end":{"line":249,"character":14}},"severity":1,"code":"UndeclaredName","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UndeclaredName"},"source":"compiler","message":"undefined: newTUIProgram"},{"range":{"start":{"line":249,"character":40},"end":{"line":249,"character":50}},"severity":1,"code":"UndeclaredName","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UndeclaredName"},"source":"compiler","message":"undefined: tuiProgram"},{"range":{"start":{"line":254,"character":2},"end":{"line":254,"character":12}},"severity":1,"code":"UndeclaredName","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UndeclaredName"},"source":"compiler","message":"undefined: isTerminal"},{"range":{"start":{"line":255,"character":2},"end":{"line":255,"character":15}},"severity":1,"code":"UndeclaredName","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UndeclaredName"},"source":"compiler","message":"undefined: newTUIProgram"}],"/Users/egv/dev/yolo-runner/bubbletea_test.go":[],"/Users/egv/dev/yolo-runner/opencode_adapter_v1.go":[{"range":{"start":{"line":24,"character":1},"end":{"line":24,"character":18}},"severity":2,"code":"default","codeDescription":{"href":"https://staticcheck.dev/docs/checks/#S1031"},"source":"S1031","message":"unnecessary nil check around range"}],"/Users/egv/dev/yolo-runner/internal/ui/tui/model.go":[],"/Users/egv/dev/yolo-runner/internal/runner/runner.go":[],"/Users/egv/dev/yolo-runner/internal/ui/tui/model_test.go":[],"/Users/egv/dev/yolo-runner/internal/runner/events.go":[],"/Users/egv/dev/yolo-runner/internal/runner/loop_test.go":[],"/Users/egv/dev/yolo-runner/internal/runner/runner_test.go":[],"/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/tea.go":[],"/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/tty_unix.go":[],"/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/tty.go":[],"/Users/egv/dev/yolo-runner/internal/opencode/watchdog.go":[],"/Users/egv/dev/yolo-runner/internal/opencode/client.go":[{"range":{"start":{"line":28,"character":1},"end":{"line":28,"character":18}},"severity":2,"code":"default","codeDescription":{"href":"https://staticcheck.dev/docs/checks/#S1031"},"source":"S1031","message":"unnecessary nil check around range"}],"/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/options.go":[],"/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/tty_windows.go":[{"range":{"start":{"line":3,"character":8},"end":{"line":3,"character":11}},"severity":2,"source":"go list","message":"This file is within module \"../../go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0\", which is not included in your workspace.\nTo fix this problem, you can add a go.work file that uses this directory.\nSee the documentation for more information on setting up your workspace:\nhttps://github.com/golang/tools/blob/master/gopls/doc/workspace.md.","data":{"Actions":[{"title":"Add a go.work file using this module","kind":"quickfix","command":{"title":"Run `go work init && go work use`","command":"gopls.run_go_work_command","arguments":[{"ViewID":"1","InitFirst":true,"Args":["use","../../go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0"]}]}}]}}]},"diff":"Index: /Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go\n===================================================================\n--- /Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go\n+++ /Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go\n@@ -219,23 +219,23 @@\n \t\tisTerminal = prevIsTerminal\n \t\tnewTUIProgram = prevNewTUIProgram\n \t})\n \n-\trunner := &fakeRunOnce{result: \"no_tasks\"}\n+\trunOnce := &fakeRunOnce{result: \"no_tasks\"}\n \texit := &fakeExit{}\n \tout := &bytes.Buffer{}\n \tbeadsRunner := &fakeRunner{}\n \tgitRunner := &fakeGitRunner{}\n \n-\tcode := RunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\"}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n+\tcode := RunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\"}, runOnce.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n \n \tif code != 0 {\n \t\tt.Fatalf(\"expected exit code 0, got %d\", code)\n \t}\n-\tif runner.deps.Events == nil {\n+\tif runOnce.deps.Events == nil {\n \t\tt.Fatalf(\"expected events emitter to be set\")\n \t}\n-\trunner.deps.Events.Emit(runner.Event{Type: runner.EventSelectTask})\n+\trunOnce.deps.Events.Emit(runner.Event{Type: runner.EventSelectTask})\n \tif len(fakeProgram.events) != 1 {\n \t\tt.Fatalf(\"expected event to be forwarded to TUI\")\n \t}\n \twaitForSignal(t, fakeProgram.started, \"tui start\")\n@@ -255,21 +255,21 @@\n \t\tisTerminal = prevIsTerminal\n \t\tnewTUIProgram = prevNewTUIProgram\n \t})\n \n-\trunner := &fakeRunOnce{result: \"no_tasks\"}\n+\trunOnce := &fakeRunOnce{result: \"no_tasks\"}\n \texit := &fakeExit{}\n \tout := &bytes.Buffer{}\n \tbeadsRunner := &fakeRunner{}\n \tgitRunner := &fakeGitRunner{}\n \tstderr := &bytes.Buffer{}\n \n-\tRunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\", \"--headless\"}, runner.Run, exit.Exit, out, stderr, beadsRunner, gitRunner)\n+\tRunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\", \"--headless\"}, runOnce.Run, exit.Exit, out, stderr, beadsRunner, gitRunner)\n \n \tif called {\n \t\tt.Fatalf(\"expected TUI program not to start\")\n \t}\n-\tif runner.deps.Events != nil {\n+\tif runOnce.deps.Events != nil {\n \t\tt.Fatalf(\"expected no events emitter in headless mode\")\n \t}\n }\n \n","filediff":{"file":"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go","before":"package main\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"yolo-runner/internal/opencode\"\n\t\"yolo-runner/internal/runner\"\n)\n\ntype fakeRunner struct {\n\tcalls []string\n}\n\nfunc (f *fakeRunner) Run(args ...string) (string, error) {\n\tf.calls = append(f.calls, strings.Join(args, \" \"))\n\treturn \"\", nil\n}\n\ntype fakeOpenCodeRunLogger struct {\n\tcalled     bool\n\tissueID    string\n\trepoRoot   string\n\tprompt     string\n\tmodel      string\n\tconfigRoot string\n\tconfigDir  string\n\tlogPath    string\n}\n\nfunc (f *fakeOpenCodeRunLogger) Run(issueID string, repoRoot string, prompt string, model string, configRoot string, configDir string, logPath string) error {\n\tf.called = true\n\tf.issueID = issueID\n\tf.repoRoot = repoRoot\n\tf.prompt = prompt\n\tf.model = model\n\tf.configRoot = configRoot\n\tf.configDir = configDir\n\tf.logPath = logPath\n\treturn nil\n}\n\ntype fakeOpenCodeRunner struct {\n\tenv map[string]string\n}\n\ntype fakeOpenCodeProcess struct{}\n\nfunc (fakeOpenCodeProcess) Wait() error { return nil }\n\nfunc (fakeOpenCodeProcess) Kill() error { return nil }\n\nfunc (f *fakeOpenCodeRunner) Start(args []string, env map[string]string, stdoutPath string) (opencode.Process, error) {\n\tf.env = env\n\treturn fakeOpenCodeProcess{}, nil\n}\n\ntype fakeGitRunner struct {\n\tcalls  []string\n\toutput string\n\terr    error\n}\n\nfunc (f *fakeGitRunner) Run(name string, args ...string) (string, error) {\n\tf.calls = append(f.calls, name+\" \"+strings.Join(args, \" \"))\n\treturn f.output, f.err\n}\n\ntype fakeExit struct {\n\tcode int\n}\n\nfunc (f *fakeExit) Exit(code int) {\n\tf.code = code\n}\n\ntype fakeRunOnce struct {\n\tcalled bool\n\topts   runner.RunOnceOptions\n\tdeps   runner.RunOnceDeps\n\tresult string\n\terr    error\n}\n\nfunc (f *fakeRunOnce) Run(opts runner.RunOnceOptions, deps runner.RunOnceDeps) (string, error) {\n\n\tf.called = true\n\tf.opts = opts\n\tf.deps = deps\n\treturn f.result, f.err\n}\n\nfunc TestRunOnceMainReturnsErrorCodeOnFailure(t *testing.T) {\n\trunner := &fakeRunOnce{err: errors.New(\"boom\")}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\n\tcode := RunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\"}, runner.Run, exit.Exit, out, out, nil, nil)\n\n\tif code != 1 {\n\t\tt.Fatalf(\"expected exit code 1, got %d\", code)\n\t}\n\tif exit.code != 1 {\n\t\tt.Fatalf(\"expected exit to be called with 1, got %d\", exit.code)\n\t}\n\tif !strings.Contains(out.String(), \"boom\") {\n\t\tt.Fatalf(\"expected error output, got %q\", out.String())\n\t}\n}\n\nfunc TestRunOnceMainWiresDependencies(t *testing.T) {\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tRunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\", \"--model\", \"model\", \"--dry-run\"}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif !runner.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n\tif runner.opts.RepoRoot != \"/repo\" || runner.opts.RootID != \"root\" || runner.opts.Model != \"model\" || !runner.opts.DryRun {\n\t\tt.Fatalf(\"unexpected options: %#v\", runner.opts)\n\t}\n\tif runner.opts.Out == nil {\n\t\tt.Fatalf(\"expected output writer\")\n\t}\n\tif runner.deps.Beads == nil || runner.deps.Git == nil || runner.deps.Prompt == nil || runner.deps.OpenCode == nil || runner.deps.Logger == nil {\n\t\tt.Fatalf(\"expected deps to be wired\")\n\t}\n\tif exit.code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", exit.code)\n\t}\n}\n\nfunc TestRunOnceMainDefaultsConfigPaths(t *testing.T) {\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tt.Setenv(\"HOME\", \"/home/user\")\n\n\tRunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\"}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif !runner.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n\tif runner.opts.ConfigRoot == \"\" {\n\t\tt.Fatalf(\"expected config root to be set\")\n\t}\n\tif runner.opts.ConfigDir == \"\" {\n\t\tt.Fatalf(\"expected config dir to be set\")\n\t}\n\texpectedConfigRoot := filepath.Join(\"/home/user\", \".config\", \"opencode-runner\")\n\tif runner.opts.ConfigRoot != expectedConfigRoot {\n\t\tt.Fatalf(\"expected config root %q, got %q\", expectedConfigRoot, runner.opts.ConfigRoot)\n\t}\n\texpectedConfigDir := filepath.Join(expectedConfigRoot, \"opencode\")\n\tif runner.opts.ConfigDir != expectedConfigDir {\n\t\tt.Fatalf(\"expected config dir %q, got %q\", expectedConfigDir, runner.opts.ConfigDir)\n\t}\n\tif exit.code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", exit.code)\n\t}\n}\n\ntype fakeTUIProgram struct {\n\tstarted chan struct{}\n\tquit    chan struct{}\n\tevents  []runner.Event\n}\n\nfunc newFakeTUIProgram() *fakeTUIProgram {\n\treturn &fakeTUIProgram{\n\t\tstarted: make(chan struct{}),\n\t\tquit:    make(chan struct{}),\n\t}\n}\n\nfunc (f *fakeTUIProgram) Start() error {\n\tclose(f.started)\n\treturn nil\n}\n\nfunc (f *fakeTUIProgram) Send(event runner.Event) {\n\tf.events = append(f.events, event)\n}\n\nfunc (f *fakeTUIProgram) Quit() {\n\tclose(f.quit)\n}\n\nfunc waitForSignal(t *testing.T, signal chan struct{}, label string) {\n\tt.Helper()\n\tselect {\n\tcase <-signal:\n\t\treturn\n\tcase <-time.After(100 * time.Millisecond):\n\t\tt.Fatalf(\"expected %s\", label)\n\t}\n}\n\nfunc TestRunOnceMainUsesTUIOnTTYByDefault(t *testing.T) {\n\tfakeProgram := newFakeTUIProgram()\n\tprevIsTerminal := isTerminal\n\tprevNewTUIProgram := newTUIProgram\n\tisTerminal = func(io.Writer) bool { return true }\n\tnewTUIProgram = func(stdout io.Writer) tuiProgram { return fakeProgram }\n\tt.Cleanup(func() {\n\t\tisTerminal = prevIsTerminal\n\t\tnewTUIProgram = prevNewTUIProgram\n\t})\n\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\"}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", code)\n\t}\n\tif runner.deps.Events == nil {\n\t\tt.Fatalf(\"expected events emitter to be set\")\n\t}\n\trunner.deps.Events.Emit(runner.Event{Type: runner.EventSelectTask})\n\tif len(fakeProgram.events) != 1 {\n\t\tt.Fatalf(\"expected event to be forwarded to TUI\")\n\t}\n\twaitForSignal(t, fakeProgram.started, \"tui start\")\n\twaitForSignal(t, fakeProgram.quit, \"tui quit\")\n}\n\nfunc TestRunOnceMainHeadlessDisablesTUI(t *testing.T) {\n\tcalled := false\n\tprevIsTerminal := isTerminal\n\tprevNewTUIProgram := newTUIProgram\n\tisTerminal = func(io.Writer) bool { return true }\n\tnewTUIProgram = func(stdout io.Writer) tuiProgram {\n\t\tcalled = true\n\t\treturn newFakeTUIProgram()\n\t}\n\tt.Cleanup(func() {\n\t\tisTerminal = prevIsTerminal\n\t\tnewTUIProgram = prevNewTUIProgram\n\t})\n\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\tstderr := &bytes.Buffer{}\n\n\tRunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\", \"--headless\"}, runner.Run, exit.Exit, out, stderr, beadsRunner, gitRunner)\n\n\tif called {\n\t\tt.Fatalf(\"expected TUI program not to start\")\n\t}\n\tif runner.deps.Events != nil {\n\t\tt.Fatalf(\"expected no events emitter in headless mode\")\n\t}\n}\n\nfunc TestOpenCodeRunDefaultsCreateConfigAndEnv(t *testing.T) {\n\ttempDir := t.TempDir()\n\trepoRoot := filepath.Join(tempDir, \"repo\")\n\tif err := os.MkdirAll(repoRoot, 0o755); err != nil {\n\t\tt.Fatalf(\"mkdir repo: %v\", err)\n\t}\n\tt.Setenv(\"HOME\", tempDir)\n\n\topenCodeRunner := &fakeOpenCodeRunner{}\n\topenCodeAdapter := openCodeAdapter{runner: openCodeRunner}\n\n\tconfigRoot := filepath.Join(tempDir, \".config\", \"opencode-runner\")\n\tconfigDir := filepath.Join(configRoot, \"opencode\")\n\tlogPath := filepath.Join(tempDir, \"runner-logs\", \"opencode\", \"issue-1.jsonl\")\n\n\tif err := openCodeAdapter.Run(\"issue-1\", repoRoot, \"prompt\", \"\", configRoot, configDir, logPath); err != nil {\n\t\tt.Fatalf(\"open code run error: %v\", err)\n\t}\n\n\tconfigFile := filepath.Join(configDir, \"opencode.json\")\n\tif _, err := os.Stat(configFile); err != nil {\n\t\tt.Fatalf(\"expected opencode.json to exist: %v\", err)\n\t}\n\texpectedConfigFile := filepath.Join(configDir, \"opencode.json\")\n\tif openCodeRunner.env[\"XDG_CONFIG_HOME\"] != configRoot {\n\t\tt.Fatalf(\"expected XDG_CONFIG_HOME set\")\n\t}\n\tif openCodeRunner.env[\"OPENCODE_CONFIG_DIR\"] != configDir {\n\t\tt.Fatalf(\"expected OPENCODE_CONFIG_DIR set\")\n\t}\n\tif openCodeRunner.env[\"OPENCODE_CONFIG\"] != expectedConfigFile {\n\t\tt.Fatalf(\"expected OPENCODE_CONFIG set\")\n\t}\n\tif openCodeRunner.env[\"OPENCODE_CONFIG_CONTENT\"] != \"{}\" {\n\t\tt.Fatalf(\"expected OPENCODE_CONFIG_CONTENT set\")\n\t}\n}\n","after":"package main\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"yolo-runner/internal/opencode\"\n\t\"yolo-runner/internal/runner\"\n)\n\ntype fakeRunner struct {\n\tcalls []string\n}\n\nfunc (f *fakeRunner) Run(args ...string) (string, error) {\n\tf.calls = append(f.calls, strings.Join(args, \" \"))\n\treturn \"\", nil\n}\n\ntype fakeOpenCodeRunLogger struct {\n\tcalled     bool\n\tissueID    string\n\trepoRoot   string\n\tprompt     string\n\tmodel      string\n\tconfigRoot string\n\tconfigDir  string\n\tlogPath    string\n}\n\nfunc (f *fakeOpenCodeRunLogger) Run(issueID string, repoRoot string, prompt string, model string, configRoot string, configDir string, logPath string) error {\n\tf.called = true\n\tf.issueID = issueID\n\tf.repoRoot = repoRoot\n\tf.prompt = prompt\n\tf.model = model\n\tf.configRoot = configRoot\n\tf.configDir = configDir\n\tf.logPath = logPath\n\treturn nil\n}\n\ntype fakeOpenCodeRunner struct {\n\tenv map[string]string\n}\n\ntype fakeOpenCodeProcess struct{}\n\nfunc (fakeOpenCodeProcess) Wait() error { return nil }\n\nfunc (fakeOpenCodeProcess) Kill() error { return nil }\n\nfunc (f *fakeOpenCodeRunner) Start(args []string, env map[string]string, stdoutPath string) (opencode.Process, error) {\n\tf.env = env\n\treturn fakeOpenCodeProcess{}, nil\n}\n\ntype fakeGitRunner struct {\n\tcalls  []string\n\toutput string\n\terr    error\n}\n\nfunc (f *fakeGitRunner) Run(name string, args ...string) (string, error) {\n\tf.calls = append(f.calls, name+\" \"+strings.Join(args, \" \"))\n\treturn f.output, f.err\n}\n\ntype fakeExit struct {\n\tcode int\n}\n\nfunc (f *fakeExit) Exit(code int) {\n\tf.code = code\n}\n\ntype fakeRunOnce struct {\n\tcalled bool\n\topts   runner.RunOnceOptions\n\tdeps   runner.RunOnceDeps\n\tresult string\n\terr    error\n}\n\nfunc (f *fakeRunOnce) Run(opts runner.RunOnceOptions, deps runner.RunOnceDeps) (string, error) {\n\n\tf.called = true\n\tf.opts = opts\n\tf.deps = deps\n\treturn f.result, f.err\n}\n\nfunc TestRunOnceMainReturnsErrorCodeOnFailure(t *testing.T) {\n\trunner := &fakeRunOnce{err: errors.New(\"boom\")}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\n\tcode := RunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\"}, runner.Run, exit.Exit, out, out, nil, nil)\n\n\tif code != 1 {\n\t\tt.Fatalf(\"expected exit code 1, got %d\", code)\n\t}\n\tif exit.code != 1 {\n\t\tt.Fatalf(\"expected exit to be called with 1, got %d\", exit.code)\n\t}\n\tif !strings.Contains(out.String(), \"boom\") {\n\t\tt.Fatalf(\"expected error output, got %q\", out.String())\n\t}\n}\n\nfunc TestRunOnceMainWiresDependencies(t *testing.T) {\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tRunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\", \"--model\", \"model\", \"--dry-run\"}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif !runner.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n\tif runner.opts.RepoRoot != \"/repo\" || runner.opts.RootID != \"root\" || runner.opts.Model != \"model\" || !runner.opts.DryRun {\n\t\tt.Fatalf(\"unexpected options: %#v\", runner.opts)\n\t}\n\tif runner.opts.Out == nil {\n\t\tt.Fatalf(\"expected output writer\")\n\t}\n\tif runner.deps.Beads == nil || runner.deps.Git == nil || runner.deps.Prompt == nil || runner.deps.OpenCode == nil || runner.deps.Logger == nil {\n\t\tt.Fatalf(\"expected deps to be wired\")\n\t}\n\tif exit.code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", exit.code)\n\t}\n}\n\nfunc TestRunOnceMainDefaultsConfigPaths(t *testing.T) {\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tt.Setenv(\"HOME\", \"/home/user\")\n\n\tRunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\"}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif !runner.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n\tif runner.opts.ConfigRoot == \"\" {\n\t\tt.Fatalf(\"expected config root to be set\")\n\t}\n\tif runner.opts.ConfigDir == \"\" {\n\t\tt.Fatalf(\"expected config dir to be set\")\n\t}\n\texpectedConfigRoot := filepath.Join(\"/home/user\", \".config\", \"opencode-runner\")\n\tif runner.opts.ConfigRoot != expectedConfigRoot {\n\t\tt.Fatalf(\"expected config root %q, got %q\", expectedConfigRoot, runner.opts.ConfigRoot)\n\t}\n\texpectedConfigDir := filepath.Join(expectedConfigRoot, \"opencode\")\n\tif runner.opts.ConfigDir != expectedConfigDir {\n\t\tt.Fatalf(\"expected config dir %q, got %q\", expectedConfigDir, runner.opts.ConfigDir)\n\t}\n\tif exit.code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", exit.code)\n\t}\n}\n\ntype fakeTUIProgram struct {\n\tstarted chan struct{}\n\tquit    chan struct{}\n\tevents  []runner.Event\n}\n\nfunc newFakeTUIProgram() *fakeTUIProgram {\n\treturn &fakeTUIProgram{\n\t\tstarted: make(chan struct{}),\n\t\tquit:    make(chan struct{}),\n\t}\n}\n\nfunc (f *fakeTUIProgram) Start() error {\n\tclose(f.started)\n\treturn nil\n}\n\nfunc (f *fakeTUIProgram) Send(event runner.Event) {\n\tf.events = append(f.events, event)\n}\n\nfunc (f *fakeTUIProgram) Quit() {\n\tclose(f.quit)\n}\n\nfunc waitForSignal(t *testing.T, signal chan struct{}, label string) {\n\tt.Helper()\n\tselect {\n\tcase <-signal:\n\t\treturn\n\tcase <-time.After(100 * time.Millisecond):\n\t\tt.Fatalf(\"expected %s\", label)\n\t}\n}\n\nfunc TestRunOnceMainUsesTUIOnTTYByDefault(t *testing.T) {\n\tfakeProgram := newFakeTUIProgram()\n\tprevIsTerminal := isTerminal\n\tprevNewTUIProgram := newTUIProgram\n\tisTerminal = func(io.Writer) bool { return true }\n\tnewTUIProgram = func(stdout io.Writer) tuiProgram { return fakeProgram }\n\tt.Cleanup(func() {\n\t\tisTerminal = prevIsTerminal\n\t\tnewTUIProgram = prevNewTUIProgram\n\t})\n\n\trunOnce := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\"}, runOnce.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", code)\n\t}\n\tif runOnce.deps.Events == nil {\n\t\tt.Fatalf(\"expected events emitter to be set\")\n\t}\n\trunOnce.deps.Events.Emit(runner.Event{Type: runner.EventSelectTask})\n\tif len(fakeProgram.events) != 1 {\n\t\tt.Fatalf(\"expected event to be forwarded to TUI\")\n\t}\n\twaitForSignal(t, fakeProgram.started, \"tui start\")\n\twaitForSignal(t, fakeProgram.quit, \"tui quit\")\n}\n\nfunc TestRunOnceMainHeadlessDisablesTUI(t *testing.T) {\n\tcalled := false\n\tprevIsTerminal := isTerminal\n\tprevNewTUIProgram := newTUIProgram\n\tisTerminal = func(io.Writer) bool { return true }\n\tnewTUIProgram = func(stdout io.Writer) tuiProgram {\n\t\tcalled = true\n\t\treturn newFakeTUIProgram()\n\t}\n\tt.Cleanup(func() {\n\t\tisTerminal = prevIsTerminal\n\t\tnewTUIProgram = prevNewTUIProgram\n\t})\n\n\trunOnce := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\tstderr := &bytes.Buffer{}\n\n\tRunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\", \"--headless\"}, runOnce.Run, exit.Exit, out, stderr, beadsRunner, gitRunner)\n\n\tif called {\n\t\tt.Fatalf(\"expected TUI program not to start\")\n\t}\n\tif runOnce.deps.Events != nil {\n\t\tt.Fatalf(\"expected no events emitter in headless mode\")\n\t}\n}\n\nfunc TestOpenCodeRunDefaultsCreateConfigAndEnv(t *testing.T) {\n\ttempDir := t.TempDir()\n\trepoRoot := filepath.Join(tempDir, \"repo\")\n\tif err := os.MkdirAll(repoRoot, 0o755); err != nil {\n\t\tt.Fatalf(\"mkdir repo: %v\", err)\n\t}\n\tt.Setenv(\"HOME\", tempDir)\n\n\topenCodeRunner := &fakeOpenCodeRunner{}\n\topenCodeAdapter := openCodeAdapter{runner: openCodeRunner}\n\n\tconfigRoot := filepath.Join(tempDir, \".config\", \"opencode-runner\")\n\tconfigDir := filepath.Join(configRoot, \"opencode\")\n\tlogPath := filepath.Join(tempDir, \"runner-logs\", \"opencode\", \"issue-1.jsonl\")\n\n\tif err := openCodeAdapter.Run(\"issue-1\", repoRoot, \"prompt\", \"\", configRoot, configDir, logPath); err != nil {\n\t\tt.Fatalf(\"open code run error: %v\", err)\n\t}\n\n\tconfigFile := filepath.Join(configDir, \"opencode.json\")\n\tif _, err := os.Stat(configFile); err != nil {\n\t\tt.Fatalf(\"expected opencode.json to exist: %v\", err)\n\t}\n\texpectedConfigFile := filepath.Join(configDir, \"opencode.json\")\n\tif openCodeRunner.env[\"XDG_CONFIG_HOME\"] != configRoot {\n\t\tt.Fatalf(\"expected XDG_CONFIG_HOME set\")\n\t}\n\tif openCodeRunner.env[\"OPENCODE_CONFIG_DIR\"] != configDir {\n\t\tt.Fatalf(\"expected OPENCODE_CONFIG_DIR set\")\n\t}\n\tif openCodeRunner.env[\"OPENCODE_CONFIG\"] != expectedConfigFile {\n\t\tt.Fatalf(\"expected OPENCODE_CONFIG set\")\n\t}\n\tif openCodeRunner.env[\"OPENCODE_CONFIG_CONTENT\"] != \"{}\" {\n\t\tt.Fatalf(\"expected OPENCODE_CONFIG_CONTENT set\")\n\t}\n}\n","additions":7,"deletions":7},"truncated":false},"time":{"start":1768840678485,"end":1768840678645}},"metadata":{"openai":{"itemId":"fc_032d8115c1da245a01696e5dd504c881918d5f32cf4eccd51c"}}}}
{"type":"step_finish","timestamp":1768840678665,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd71eccf6001ZatJIPdAmbBtFS","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd71e7f69001p67Mk20LpypCdx","type":"step-finish","reason":"tool-calls","snapshot":"eea84b7457ab8c0b8d5ae2ac0d943879f945d660","cost":0,"tokens":{"input":206,"output":1111,"reasoning":0,"cache":{"read":44672,"write":0}}}}
{"type":"step_start","timestamp":1768840679077,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd71ecea5001WnSaCSRzXsNrU5","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd71ecd24001UimgbXD0o2AcpB","type":"step-start","snapshot":"dd32e0e1bc89ccbad45d3d0c09773b3c2a901238"}}
{"type":"tool_use","timestamp":1768840706814,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd71f37b4001vDph1ggXfeHt1n","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd71ecd24001UimgbXD0o2AcpB","type":"tool","callID":"call_IalPFuuuuyajDQtCXH7WPvUC","tool":"bash","state":{"status":"completed","input":{"command":"go test ./...","workdir":"/Users/egv/dev/yolo-runner","description":"Runs Go test suite"},"output":"# yolo-runner/cmd/yolo-runner [yolo-runner/cmd/yolo-runner.test]\ncmd/yolo-runner/main_test.go:214:20: undefined: isTerminal\ncmd/yolo-runner/main_test.go:215:23: undefined: newTUIProgram\ncmd/yolo-runner/main_test.go:216:2: undefined: isTerminal\ncmd/yolo-runner/main_test.go:217:2: undefined: newTUIProgram\ncmd/yolo-runner/main_test.go:217:41: undefined: tuiProgram\ncmd/yolo-runner/main_test.go:219:3: undefined: isTerminal\ncmd/yolo-runner/main_test.go:220:3: undefined: newTUIProgram\ncmd/yolo-runner/main_test.go:247:20: undefined: isTerminal\ncmd/yolo-runner/main_test.go:248:23: undefined: newTUIProgram\ncmd/yolo-runner/main_test.go:249:2: undefined: isTerminal\ncmd/yolo-runner/main_test.go:249:2: too many errors\nok  \tyolo-runner\t(cached)\nFAIL\tyolo-runner/cmd/yolo-runner [build failed]\nok  \tyolo-runner/internal/beads\t(cached)\nok  \tyolo-runner/internal/logging\t(cached)\nok  \tyolo-runner/internal/opencode\t(cached)\nok  \tyolo-runner/internal/prompt\t(cached)\nok  \tyolo-runner/internal/runner\t(cached)\nok  \tyolo-runner/internal/ui/tui\t(cached)\nok  \tyolo-runner/internal/vcs/git\t(cached)\nFAIL\n","title":"Runs Go test suite","metadata":{"output":"# yolo-runner/cmd/yolo-runner [yolo-runner/cmd/yolo-runner.test]\ncmd/yolo-runner/main_test.go:214:20: undefined: isTerminal\ncmd/yolo-runner/main_test.go:215:23: undefined: newTUIProgram\ncmd/yolo-runner/main_test.go:216:2: undefined: isTerminal\ncmd/yolo-runner/main_test.go:217:2: undefined: newTUIProgram\ncmd/yolo-runner/main_test.go:217:41: undefined: tuiProgram\ncmd/yolo-runner/main_test.go:219:3: undefined: isTerminal\ncmd/yolo-runner/main_test.go:220:3: undefined: newTUIProgram\ncmd/yolo-runner/main_test.go:247:20: undefined: isTerminal\ncmd/yolo-runner/main_test.go:248:23: undefined: newTUIProgram\ncmd/yolo-runner/main_test.go:249:2: undefined: isTerminal\ncmd/yolo-runner/main_test.go:249:2: too many errors\nok  \tyolo-runner\t(cached)\nFAIL\tyolo-runner/cmd/yolo-runner [build failed]\nok  \tyolo-runner/internal/beads\t(cached)\nok  \tyolo-runner/internal/logging\t(cached)\nok  \tyolo-runner/internal/opencode\t(cached)\nok  \tyolo-runner/internal/prompt\t(cached)\nok  \tyolo-runner/internal/runner\t(cached)\nok  \tyolo-runner/internal/ui/tui\t(cached)\nok  \tyolo-runner/internal/vcs/git\t(cached)\nFAIL\n","exit":1,"description":"Runs Go test suite","truncated":false},"time":{"start":1768840706682,"end":1768840706813}},"metadata":{"openai":{"itemId":"fc_0ec40bebe99018e001696e5e01f0a0819199cf0cd00d9f0742"}}}}
{"type":"step_finish","timestamp":1768840706829,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd71f3afe001NjcGktbqyp5RRK","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd71ecd24001UimgbXD0o2AcpB","type":"step-finish","reason":"tool-calls","snapshot":"234c8c442701d7947ebd432de07d04950625ee69","cost":0,"tokens":{"input":1531,"output":1324,"reasoning":1280,"cache":{"read":44672,"write":0}}}}
{"type":"step_start","timestamp":1768840707340,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd71f3d0a001ucRO6VjSoZl7hJ","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd71f3b29001sC0wxxiDTrrLSx","type":"step-start","snapshot":"2b982eb556bfa8cd0aeb318f5bad884318bca457"}}
{"type":"tool_use","timestamp":1768840712304,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd71f3e47001fopGUroyZv0BAB","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd71f3b29001sC0wxxiDTrrLSx","type":"tool","callID":"call_55BNmKRKkBn5qDKZi5iblNu2","tool":"edit","state":{"status":"completed","input":{"filePath":"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main.go","oldString":"\trootID := fs.String(\"root\", \"algi-8bt\", \"Root bead/epic ID\")\n\tmodel := fs.String(\"model\", \"\", \"OpenCode model\")\n\tdryRun := fs.Bool(\"dry-run\", false, \"Print task and prompt without executing\")\n\tconfigRoot := fs.String(\"config-root\", \"\", \"OpenCode config root\")\n\tconfigDir := fs.String(\"config-dir\", \"\", \"OpenCode config dir\")\n","newString":"\trootID := fs.String(\"root\", \"algi-8bt\", \"Root bead/epic ID\")\n\tmodel := fs.String(\"model\", \"\", \"OpenCode model\")\n\tdryRun := fs.Bool(\"dry-run\", false, \"Print task and prompt without executing\")\n\theadless := fs.Bool(\"headless\", false, \"Force plain output without TUI\")\n\tconfigRoot := fs.String(\"config-root\", \"\", \"OpenCode config root\")\n\tconfigDir := fs.String(\"config-dir\", \"\", \"OpenCode config dir\")\n"},"output":"Edit applied successfully.\n\nLSP errors detected in this file, please fix:\n<diagnostics file=\"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main.go\">\nERROR [62:2] declared and not used: headless\n</diagnostics>","title":"cmd/yolo-runner/main.go","metadata":{"diagnostics":{"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main.go":[{"range":{"start":{"line":61,"character":1},"end":{"line":61,"character":9}},"severity":1,"code":"UnusedVar","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UnusedVar"},"source":"compiler","message":"declared and not used: headless","tags":[1]}],"/Users/egv/dev/yolo-runner/go.mod":[{"range":{"start":{"line":6,"character":44},"end":{"line":6,"character":55}},"severity":2,"source":"go mod tidy","message":"github.com/charmbracelet/bubbletea should be direct"}],"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go":[{"range":{"start":{"line":213,"character":19},"end":{"line":213,"character":29}},"severity":1,"code":"UndeclaredName","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UndeclaredName"},"source":"compiler","message":"undefined: isTerminal"},{"range":{"start":{"line":214,"character":22},"end":{"line":214,"character":35}},"severity":1,"code":"UndeclaredName","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UndeclaredName"},"source":"compiler","message":"undefined: newTUIProgram"},{"range":{"start":{"line":215,"character":1},"end":{"line":215,"character":11}},"severity":1,"code":"UndeclaredName","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UndeclaredName"},"source":"compiler","message":"undefined: isTerminal"},{"range":{"start":{"line":216,"character":1},"end":{"line":216,"character":14}},"severity":1,"code":"UndeclaredName","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UndeclaredName"},"source":"compiler","message":"undefined: newTUIProgram"},{"range":{"start":{"line":216,"character":40},"end":{"line":216,"character":50}},"severity":1,"code":"UndeclaredName","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UndeclaredName"},"source":"compiler","message":"undefined: tuiProgram"},{"range":{"start":{"line":218,"character":2},"end":{"line":218,"character":12}},"severity":1,"code":"UndeclaredName","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UndeclaredName"},"source":"compiler","message":"undefined: isTerminal"},{"range":{"start":{"line":219,"character":2},"end":{"line":219,"character":15}},"severity":1,"code":"UndeclaredName","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UndeclaredName"},"source":"compiler","message":"undefined: newTUIProgram"},{"range":{"start":{"line":246,"character":19},"end":{"line":246,"character":29}},"severity":1,"code":"UndeclaredName","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UndeclaredName"},"source":"compiler","message":"undefined: isTerminal"},{"range":{"start":{"line":247,"character":22},"end":{"line":247,"character":35}},"severity":1,"code":"UndeclaredName","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UndeclaredName"},"source":"compiler","message":"undefined: newTUIProgram"},{"range":{"start":{"line":248,"character":1},"end":{"line":248,"character":11}},"severity":1,"code":"UndeclaredName","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UndeclaredName"},"source":"compiler","message":"undefined: isTerminal"},{"range":{"start":{"line":249,"character":1},"end":{"line":249,"character":14}},"severity":1,"code":"UndeclaredName","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UndeclaredName"},"source":"compiler","message":"undefined: newTUIProgram"},{"range":{"start":{"line":249,"character":40},"end":{"line":249,"character":50}},"severity":1,"code":"UndeclaredName","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UndeclaredName"},"source":"compiler","message":"undefined: tuiProgram"},{"range":{"start":{"line":254,"character":2},"end":{"line":254,"character":12}},"severity":1,"code":"UndeclaredName","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UndeclaredName"},"source":"compiler","message":"undefined: isTerminal"},{"range":{"start":{"line":255,"character":2},"end":{"line":255,"character":15}},"severity":1,"code":"UndeclaredName","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UndeclaredName"},"source":"compiler","message":"undefined: newTUIProgram"}],"/Users/egv/dev/yolo-runner/bubbletea_test.go":[],"/Users/egv/dev/yolo-runner/opencode_adapter_v1.go":[{"range":{"start":{"line":24,"character":1},"end":{"line":24,"character":18}},"severity":2,"code":"default","codeDescription":{"href":"https://staticcheck.dev/docs/checks/#S1031"},"source":"S1031","message":"unnecessary nil check around range"}],"/Users/egv/dev/yolo-runner/internal/ui/tui/model.go":[],"/Users/egv/dev/yolo-runner/internal/runner/runner.go":[],"/Users/egv/dev/yolo-runner/internal/ui/tui/model_test.go":[],"/Users/egv/dev/yolo-runner/internal/runner/events.go":[],"/Users/egv/dev/yolo-runner/internal/runner/loop_test.go":[],"/Users/egv/dev/yolo-runner/internal/runner/runner_test.go":[],"/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/tea.go":[],"/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/tty_unix.go":[],"/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/tty.go":[],"/Users/egv/dev/yolo-runner/internal/opencode/watchdog.go":[],"/Users/egv/dev/yolo-runner/internal/opencode/client.go":[{"range":{"start":{"line":28,"character":1},"end":{"line":28,"character":18}},"severity":2,"code":"default","codeDescription":{"href":"https://staticcheck.dev/docs/checks/#S1031"},"source":"S1031","message":"unnecessary nil check around range"}],"/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/options.go":[],"/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/tty_windows.go":[{"range":{"start":{"line":3,"character":8},"end":{"line":3,"character":11}},"severity":2,"source":"go list","message":"This file is within module \"../../go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0\", which is not included in your workspace.\nTo fix this problem, you can add a go.work file that uses this directory.\nSee the documentation for more information on setting up your workspace:\nhttps://github.com/golang/tools/blob/master/gopls/doc/workspace.md.","data":{"Actions":[{"title":"Add a go.work file using this module","kind":"quickfix","command":{"title":"Run `go work init && go work use`","command":"gopls.run_go_work_command","arguments":[{"ViewID":"1","InitFirst":true,"Args":["use","../../go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0"]}]}}]}}]},"diff":"Index: /Users/egv/dev/yolo-runner/cmd/yolo-runner/main.go\n===================================================================\n--- /Users/egv/dev/yolo-runner/cmd/yolo-runner/main.go\n+++ /Users/egv/dev/yolo-runner/cmd/yolo-runner/main.go\n@@ -58,8 +58,9 @@\n repoRoot := fs.String(\"repo\", \".\", \"Repository root path\")\n rootID := fs.String(\"root\", \"algi-8bt\", \"Root bead/epic ID\")\n model := fs.String(\"model\", \"\", \"OpenCode model\")\n dryRun := fs.Bool(\"dry-run\", false, \"Print task and prompt without executing\")\n+headless := fs.Bool(\"headless\", false, \"Force plain output without TUI\")\n configRoot := fs.String(\"config-root\", \"\", \"OpenCode config root\")\n configDir := fs.String(\"config-dir\", \"\", \"OpenCode config dir\")\n \n if err := fs.Parse(args); err != nil {\n","filediff":{"file":"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main.go","before":"package main\n\nimport (\n\t\"flag\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n\n\t\"yolo-runner/internal/beads\"\n\t\"yolo-runner/internal/logging\"\n\t\"yolo-runner/internal/opencode\"\n\t\"yolo-runner/internal/prompt\"\n\t\"yolo-runner/internal/runner\"\n\tgitadapter \"yolo-runner/internal/vcs/git\"\n)\n\ntype runOnceFunc func(opts runner.RunOnceOptions, deps runner.RunOnceDeps) (string, error)\n\ntype exitFunc func(code int)\n\ntype beadsRunner interface {\n\tRun(args ...string) (string, error)\n}\n\ntype gitRunner interface {\n\tRun(name string, args ...string) (string, error)\n}\n\ntype openCodeRunner interface {\n\tStart(args []string, env map[string]string, stdoutPath string) (opencode.Process, error)\n}\n\ntype adapterRunner struct{}\n\nfunc (adapterRunner) Run(args ...string) (string, error) {\n\treturn runCommand(args...)\n}\n\ntype adapterGitRunner struct{}\n\nfunc (adapterGitRunner) Run(name string, args ...string) (string, error) {\n\treturn runCommand(append([]string{name}, args...)...)\n}\n\ntype openCodeAdapter struct {\n\trunner openCodeRunner\n}\n\nfunc (o openCodeAdapter) Run(issueID string, repoRoot string, promptText string, model string, configRoot string, configDir string, logPath string) error {\n\treturn opencode.Run(issueID, repoRoot, promptText, model, configRoot, configDir, logPath, o.runner)\n}\n\nfunc RunOnceMain(args []string, runOnce runOnceFunc, exit exitFunc, stdout io.Writer, stderr io.Writer, beadsRunner beadsRunner, gitRunner gitRunner) int {\n\tfs := flag.NewFlagSet(\"yolo-runner\", flag.ContinueOnError)\n\tfs.SetOutput(stderr)\n\n\trepoRoot := fs.String(\"repo\", \".\", \"Repository root path\")\n\trootID := fs.String(\"root\", \"algi-8bt\", \"Root bead/epic ID\")\n\tmodel := fs.String(\"model\", \"\", \"OpenCode model\")\n\tdryRun := fs.Bool(\"dry-run\", false, \"Print task and prompt without executing\")\n\tconfigRoot := fs.String(\"config-root\", \"\", \"OpenCode config root\")\n\tconfigDir := fs.String(\"config-dir\", \"\", \"OpenCode config dir\")\n\n\tif err := fs.Parse(args); err != nil {\n\t\tfmt.Fprintln(stderr, err)\n\t\tif exit != nil {\n\t\t\texit(1)\n\t\t}\n\t\treturn 1\n\t}\n\n\tif runOnce == nil {\n\t\trunOnce = runner.RunOnce\n\t}\n\n\tif beadsRunner == nil {\n\t\tbeadsRunner = adapterRunner{}\n\t}\n\tif gitRunner == nil {\n\t\tgitRunner = adapterGitRunner{}\n\t}\n\n\tbeadsAdapter := beads.New(beadsRunner)\n\tgitAdapter := gitadapter.New(gitRunner)\n\topenCodeAdapter := openCodeAdapter{runner: defaultOpenCodeRunner{}}\n\n\tdeps := runner.RunOnceDeps{\n\t\tBeads:    beadsAdapter,\n\t\tPrompt:   promptBuilder{},\n\t\tOpenCode: openCodeAdapter,\n\t\tGit:      gitAdapter,\n\t\tLogger:   runnerLogger{},\n\t}\n\n\tresolvedConfigRoot := *configRoot\n\tresolvedConfigDir := *configDir\n\tif resolvedConfigRoot == \"\" {\n\t\thomeDir := os.Getenv(\"HOME\")\n\t\tif homeDir != \"\" {\n\t\t\tresolvedConfigRoot = filepath.Join(homeDir, \".config\", \"opencode-runner\")\n\t\t}\n\t}\n\tif resolvedConfigDir == \"\" && resolvedConfigRoot != \"\" {\n\t\tresolvedConfigDir = filepath.Join(resolvedConfigRoot, \"opencode\")\n\t}\n\n\toptions := runner.RunOnceOptions{\n\t\tRepoRoot:   *repoRoot,\n\t\tRootID:     *rootID,\n\t\tModel:      *model,\n\t\tConfigRoot: resolvedConfigRoot,\n\t\tConfigDir:  resolvedConfigDir,\n\t\tDryRun:     *dryRun,\n\t\tOut:        stdout,\n\t}\n\n\tif stdout == nil {\n\t\toptions.Out = io.Discard\n\t}\n\tif stderr == nil {\n\t\tstderr = io.Discard\n\t}\n\n\t_, err := runOnce(options, deps)\n\tif err != nil {\n\t\tfmt.Fprintln(stderr, err)\n\t\tif exit != nil {\n\t\t\texit(1)\n\t\t}\n\t\treturn 1\n\t}\n\n\tif exit != nil {\n\t\texit(0)\n\t}\n\treturn 0\n}\n\nfunc main() {\n\tRunOnceMain(os.Args[1:], runner.RunOnce, os.Exit, os.Stdout, os.Stderr, nil, nil)\n}\n\ntype promptBuilder struct{}\n\nfunc (promptBuilder) Build(issueID string, title string, description string, acceptance string) string {\n\treturn prompt.Build(issueID, title, description, acceptance)\n}\n\ntype runnerLogger struct{}\n\nfunc (runnerLogger) AppendRunnerSummary(repoRoot string, issueID string, title string, status string, commitSHA string) error {\n\treturn logging.AppendRunnerSummary(repoRoot, issueID, title, status, commitSHA)\n}\n\ntype defaultOpenCodeRunner struct{}\n\nfunc (defaultOpenCodeRunner) Start(args []string, env map[string]string, stdoutPath string) (opencode.Process, error) {\n\treturn startCommandWithEnv(args, env, stdoutPath)\n}\n","after":"package main\n\nimport (\n\t\"flag\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n\n\t\"yolo-runner/internal/beads\"\n\t\"yolo-runner/internal/logging\"\n\t\"yolo-runner/internal/opencode\"\n\t\"yolo-runner/internal/prompt\"\n\t\"yolo-runner/internal/runner\"\n\tgitadapter \"yolo-runner/internal/vcs/git\"\n)\n\ntype runOnceFunc func(opts runner.RunOnceOptions, deps runner.RunOnceDeps) (string, error)\n\ntype exitFunc func(code int)\n\ntype beadsRunner interface {\n\tRun(args ...string) (string, error)\n}\n\ntype gitRunner interface {\n\tRun(name string, args ...string) (string, error)\n}\n\ntype openCodeRunner interface {\n\tStart(args []string, env map[string]string, stdoutPath string) (opencode.Process, error)\n}\n\ntype adapterRunner struct{}\n\nfunc (adapterRunner) Run(args ...string) (string, error) {\n\treturn runCommand(args...)\n}\n\ntype adapterGitRunner struct{}\n\nfunc (adapterGitRunner) Run(name string, args ...string) (string, error) {\n\treturn runCommand(append([]string{name}, args...)...)\n}\n\ntype openCodeAdapter struct {\n\trunner openCodeRunner\n}\n\nfunc (o openCodeAdapter) Run(issueID string, repoRoot string, promptText string, model string, configRoot string, configDir string, logPath string) error {\n\treturn opencode.Run(issueID, repoRoot, promptText, model, configRoot, configDir, logPath, o.runner)\n}\n\nfunc RunOnceMain(args []string, runOnce runOnceFunc, exit exitFunc, stdout io.Writer, stderr io.Writer, beadsRunner beadsRunner, gitRunner gitRunner) int {\n\tfs := flag.NewFlagSet(\"yolo-runner\", flag.ContinueOnError)\n\tfs.SetOutput(stderr)\n\n\trepoRoot := fs.String(\"repo\", \".\", \"Repository root path\")\n\trootID := fs.String(\"root\", \"algi-8bt\", \"Root bead/epic ID\")\n\tmodel := fs.String(\"model\", \"\", \"OpenCode model\")\n\tdryRun := fs.Bool(\"dry-run\", false, \"Print task and prompt without executing\")\n\theadless := fs.Bool(\"headless\", false, \"Force plain output without TUI\")\n\tconfigRoot := fs.String(\"config-root\", \"\", \"OpenCode config root\")\n\tconfigDir := fs.String(\"config-dir\", \"\", \"OpenCode config dir\")\n\n\tif err := fs.Parse(args); err != nil {\n\t\tfmt.Fprintln(stderr, err)\n\t\tif exit != nil {\n\t\t\texit(1)\n\t\t}\n\t\treturn 1\n\t}\n\n\tif runOnce == nil {\n\t\trunOnce = runner.RunOnce\n\t}\n\n\tif beadsRunner == nil {\n\t\tbeadsRunner = adapterRunner{}\n\t}\n\tif gitRunner == nil {\n\t\tgitRunner = adapterGitRunner{}\n\t}\n\n\tbeadsAdapter := beads.New(beadsRunner)\n\tgitAdapter := gitadapter.New(gitRunner)\n\topenCodeAdapter := openCodeAdapter{runner: defaultOpenCodeRunner{}}\n\n\tdeps := runner.RunOnceDeps{\n\t\tBeads:    beadsAdapter,\n\t\tPrompt:   promptBuilder{},\n\t\tOpenCode: openCodeAdapter,\n\t\tGit:      gitAdapter,\n\t\tLogger:   runnerLogger{},\n\t}\n\n\tresolvedConfigRoot := *configRoot\n\tresolvedConfigDir := *configDir\n\tif resolvedConfigRoot == \"\" {\n\t\thomeDir := os.Getenv(\"HOME\")\n\t\tif homeDir != \"\" {\n\t\t\tresolvedConfigRoot = filepath.Join(homeDir, \".config\", \"opencode-runner\")\n\t\t}\n\t}\n\tif resolvedConfigDir == \"\" && resolvedConfigRoot != \"\" {\n\t\tresolvedConfigDir = filepath.Join(resolvedConfigRoot, \"opencode\")\n\t}\n\n\toptions := runner.RunOnceOptions{\n\t\tRepoRoot:   *repoRoot,\n\t\tRootID:     *rootID,\n\t\tModel:      *model,\n\t\tConfigRoot: resolvedConfigRoot,\n\t\tConfigDir:  resolvedConfigDir,\n\t\tDryRun:     *dryRun,\n\t\tOut:        stdout,\n\t}\n\n\tif stdout == nil {\n\t\toptions.Out = io.Discard\n\t}\n\tif stderr == nil {\n\t\tstderr = io.Discard\n\t}\n\n\t_, err := runOnce(options, deps)\n\tif err != nil {\n\t\tfmt.Fprintln(stderr, err)\n\t\tif exit != nil {\n\t\t\texit(1)\n\t\t}\n\t\treturn 1\n\t}\n\n\tif exit != nil {\n\t\texit(0)\n\t}\n\treturn 0\n}\n\nfunc main() {\n\tRunOnceMain(os.Args[1:], runner.RunOnce, os.Exit, os.Stdout, os.Stderr, nil, nil)\n}\n\ntype promptBuilder struct{}\n\nfunc (promptBuilder) Build(issueID string, title string, description string, acceptance string) string {\n\treturn prompt.Build(issueID, title, description, acceptance)\n}\n\ntype runnerLogger struct{}\n\nfunc (runnerLogger) AppendRunnerSummary(repoRoot string, issueID string, title string, status string, commitSHA string) error {\n\treturn logging.AppendRunnerSummary(repoRoot, issueID, title, status, commitSHA)\n}\n\ntype defaultOpenCodeRunner struct{}\n\nfunc (defaultOpenCodeRunner) Start(args []string, env map[string]string, stdoutPath string) (opencode.Process, error) {\n\treturn startCommandWithEnv(args, env, stdoutPath)\n}\n","additions":1,"deletions":0},"truncated":false},"time":{"start":1768840712140,"end":1768840712303}},"metadata":{"openai":{"itemId":"fc_0ff25a92ec6ffe8401696e5e03aa68819188981ebd6d30cfa6"}}}}
{"type":"step_finish","timestamp":1768840712322,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd71f5070001nEDw52Csmlc744","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd71f3b29001sC0wxxiDTrrLSx","type":"step-finish","reason":"tool-calls","snapshot":"574f5bed24851e60c84d2a001fca72864e3820dc","cost":0,"tokens":{"input":906,"output":279,"reasoning":0,"cache":{"read":45696,"write":0}}}}
{"type":"step_start","timestamp":1768840712820,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd71f5273001RypjbTjtf51Vjh","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd71f509f001ZGHxXd4CWdesZE","type":"step-start","snapshot":"42541b7ff7f2549fd7a5fbca051451e0a0fb2f2b"}}
{"type":"tool_use","timestamp":1768840718321,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd71f549a001Q2VSrlgdhEUZle","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd71f509f001ZGHxXd4CWdesZE","type":"tool","callID":"call_OwYtSxeWfzcqCOtLi29hgvBd","tool":"edit","state":{"status":"completed","input":{"filePath":"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main.go","oldString":"import (\n\t\"flag\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n\n\t\"yolo-runner/internal/beads\"\n\t\"yolo-runner/internal/logging\"\n\t\"yolo-runner/internal/opencode\"\n\t\"yolo-runner/internal/prompt\"\n\t\"yolo-runner/internal/runner\"\n\tgitadapter \"yolo-runner/internal/vcs/git\"\n)\n","newString":"import (\n\t\"context\"\n\t\"flag\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n\n\t\"yolo-runner/internal/beads\"\n\t\"yolo-runner/internal/logging\"\n\t\"yolo-runner/internal/opencode\"\n\t\"yolo-runner/internal/prompt\"\n\t\"yolo-runner/internal/runner\"\n\t\"yolo-runner/internal/ui/tui\"\n\tgitadapter \"yolo-runner/internal/vcs/git\"\n\n\ttea \"github.com/charmbracelet/bubbletea\"\n\t\"golang.org/x/term\"\n)\n"},"output":"Edit applied successfully.\n\nLSP errors detected in this file, please fix:\n<diagnostics file=\"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main.go\">\nERROR [4:2] \"context\" imported and not used\nERROR [16:2] \"yolo-runner/internal/ui/tui\" imported and not used\nERROR [19:2] \"github.com/charmbracelet/bubbletea\" imported as tea and not used\nERROR [20:2] \"golang.org/x/term\" imported and not used\nERROR [67:2] declared and not used: headless\n</diagnostics>","title":"cmd/yolo-runner/main.go","metadata":{"diagnostics":{"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main.go":[{"range":{"start":{"line":3,"character":1},"end":{"line":3,"character":10}},"severity":1,"code":"UnusedImport","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UnusedImport"},"source":"compiler","message":"\"context\" imported and not used","tags":[1]},{"range":{"start":{"line":15,"character":1},"end":{"line":15,"character":30}},"severity":1,"code":"UnusedImport","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UnusedImport"},"source":"compiler","message":"\"yolo-runner/internal/ui/tui\" imported and not used","tags":[1]},{"range":{"start":{"line":18,"character":1},"end":{"line":18,"character":4}},"severity":1,"code":"UnusedImport","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UnusedImport"},"source":"compiler","message":"\"github.com/charmbracelet/bubbletea\" imported as tea and not used","tags":[1]},{"range":{"start":{"line":19,"character":1},"end":{"line":19,"character":20}},"severity":1,"code":"UnusedImport","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UnusedImport"},"source":"compiler","message":"\"golang.org/x/term\" imported and not used","tags":[1]},{"range":{"start":{"line":66,"character":1},"end":{"line":66,"character":9}},"severity":1,"code":"UnusedVar","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UnusedVar"},"source":"compiler","message":"declared and not used: headless","tags":[1]}],"/Users/egv/dev/yolo-runner/go.mod":[{"range":{"start":{"line":6,"character":44},"end":{"line":6,"character":55}},"severity":2,"source":"go mod tidy","message":"github.com/charmbracelet/bubbletea should be direct"}],"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go":[{"range":{"start":{"line":213,"character":19},"end":{"line":213,"character":29}},"severity":1,"code":"UndeclaredName","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UndeclaredName"},"source":"compiler","message":"undefined: isTerminal"},{"range":{"start":{"line":214,"character":22},"end":{"line":214,"character":35}},"severity":1,"code":"UndeclaredName","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UndeclaredName"},"source":"compiler","message":"undefined: newTUIProgram"},{"range":{"start":{"line":215,"character":1},"end":{"line":215,"character":11}},"severity":1,"code":"UndeclaredName","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UndeclaredName"},"source":"compiler","message":"undefined: isTerminal"},{"range":{"start":{"line":216,"character":1},"end":{"line":216,"character":14}},"severity":1,"code":"UndeclaredName","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UndeclaredName"},"source":"compiler","message":"undefined: newTUIProgram"},{"range":{"start":{"line":216,"character":40},"end":{"line":216,"character":50}},"severity":1,"code":"UndeclaredName","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UndeclaredName"},"source":"compiler","message":"undefined: tuiProgram"},{"range":{"start":{"line":218,"character":2},"end":{"line":218,"character":12}},"severity":1,"code":"UndeclaredName","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UndeclaredName"},"source":"compiler","message":"undefined: isTerminal"},{"range":{"start":{"line":219,"character":2},"end":{"line":219,"character":15}},"severity":1,"code":"UndeclaredName","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UndeclaredName"},"source":"compiler","message":"undefined: newTUIProgram"},{"range":{"start":{"line":246,"character":19},"end":{"line":246,"character":29}},"severity":1,"code":"UndeclaredName","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UndeclaredName"},"source":"compiler","message":"undefined: isTerminal"},{"range":{"start":{"line":247,"character":22},"end":{"line":247,"character":35}},"severity":1,"code":"UndeclaredName","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UndeclaredName"},"source":"compiler","message":"undefined: newTUIProgram"},{"range":{"start":{"line":248,"character":1},"end":{"line":248,"character":11}},"severity":1,"code":"UndeclaredName","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UndeclaredName"},"source":"compiler","message":"undefined: isTerminal"},{"range":{"start":{"line":249,"character":1},"end":{"line":249,"character":14}},"severity":1,"code":"UndeclaredName","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UndeclaredName"},"source":"compiler","message":"undefined: newTUIProgram"},{"range":{"start":{"line":249,"character":40},"end":{"line":249,"character":50}},"severity":1,"code":"UndeclaredName","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UndeclaredName"},"source":"compiler","message":"undefined: tuiProgram"},{"range":{"start":{"line":254,"character":2},"end":{"line":254,"character":12}},"severity":1,"code":"UndeclaredName","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UndeclaredName"},"source":"compiler","message":"undefined: isTerminal"},{"range":{"start":{"line":255,"character":2},"end":{"line":255,"character":15}},"severity":1,"code":"UndeclaredName","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UndeclaredName"},"source":"compiler","message":"undefined: newTUIProgram"}],"/Users/egv/dev/yolo-runner/bubbletea_test.go":[],"/Users/egv/dev/yolo-runner/opencode_adapter_v1.go":[{"range":{"start":{"line":24,"character":1},"end":{"line":24,"character":18}},"severity":2,"code":"default","codeDescription":{"href":"https://staticcheck.dev/docs/checks/#S1031"},"source":"S1031","message":"unnecessary nil check around range"}],"/Users/egv/dev/yolo-runner/internal/ui/tui/model.go":[],"/Users/egv/dev/yolo-runner/internal/runner/runner.go":[],"/Users/egv/dev/yolo-runner/internal/ui/tui/model_test.go":[],"/Users/egv/dev/yolo-runner/internal/runner/events.go":[],"/Users/egv/dev/yolo-runner/internal/runner/loop_test.go":[],"/Users/egv/dev/yolo-runner/internal/runner/runner_test.go":[],"/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/tea.go":[],"/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/tty_unix.go":[],"/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/tty.go":[],"/Users/egv/dev/yolo-runner/internal/opencode/watchdog.go":[],"/Users/egv/dev/yolo-runner/internal/opencode/client.go":[{"range":{"start":{"line":28,"character":1},"end":{"line":28,"character":18}},"severity":2,"code":"default","codeDescription":{"href":"https://staticcheck.dev/docs/checks/#S1031"},"source":"S1031","message":"unnecessary nil check around range"}],"/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/options.go":[],"/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/tty_windows.go":[{"range":{"start":{"line":3,"character":8},"end":{"line":3,"character":11}},"severity":2,"source":"go list","message":"This file is within module \"../../go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0\", which is not included in your workspace.\nTo fix this problem, you can add a go.work file that uses this directory.\nSee the documentation for more information on setting up your workspace:\nhttps://github.com/golang/tools/blob/master/gopls/doc/workspace.md.","data":{"Actions":[{"title":"Add a go.work file using this module","kind":"quickfix","command":{"title":"Run `go work init && go work use`","command":"gopls.run_go_work_command","arguments":[{"ViewID":"1","InitFirst":true,"Args":["use","../../go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0"]}]}}]}}]},"diff":"Index: /Users/egv/dev/yolo-runner/cmd/yolo-runner/main.go\n===================================================================\n--- /Users/egv/dev/yolo-runner/cmd/yolo-runner/main.go\n+++ /Users/egv/dev/yolo-runner/cmd/yolo-runner/main.go\n@@ -1,7 +1,8 @@\n package main\n \n import (\n+\t\"context\"\n \t\"flag\"\n \t\"fmt\"\n \t\"io\"\n \t\"os\"\n@@ -11,9 +12,13 @@\n \t\"yolo-runner/internal/logging\"\n \t\"yolo-runner/internal/opencode\"\n \t\"yolo-runner/internal/prompt\"\n \t\"yolo-runner/internal/runner\"\n+\t\"yolo-runner/internal/ui/tui\"\n \tgitadapter \"yolo-runner/internal/vcs/git\"\n+\n+\ttea \"github.com/charmbracelet/bubbletea\"\n+\t\"golang.org/x/term\"\n )\n \n type runOnceFunc func(opts runner.RunOnceOptions, deps runner.RunOnceDeps) (string, error)\n \n","filediff":{"file":"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main.go","before":"package main\n\nimport (\n\t\"flag\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n\n\t\"yolo-runner/internal/beads\"\n\t\"yolo-runner/internal/logging\"\n\t\"yolo-runner/internal/opencode\"\n\t\"yolo-runner/internal/prompt\"\n\t\"yolo-runner/internal/runner\"\n\tgitadapter \"yolo-runner/internal/vcs/git\"\n)\n\ntype runOnceFunc func(opts runner.RunOnceOptions, deps runner.RunOnceDeps) (string, error)\n\ntype exitFunc func(code int)\n\ntype beadsRunner interface {\n\tRun(args ...string) (string, error)\n}\n\ntype gitRunner interface {\n\tRun(name string, args ...string) (string, error)\n}\n\ntype openCodeRunner interface {\n\tStart(args []string, env map[string]string, stdoutPath string) (opencode.Process, error)\n}\n\ntype adapterRunner struct{}\n\nfunc (adapterRunner) Run(args ...string) (string, error) {\n\treturn runCommand(args...)\n}\n\ntype adapterGitRunner struct{}\n\nfunc (adapterGitRunner) Run(name string, args ...string) (string, error) {\n\treturn runCommand(append([]string{name}, args...)...)\n}\n\ntype openCodeAdapter struct {\n\trunner openCodeRunner\n}\n\nfunc (o openCodeAdapter) Run(issueID string, repoRoot string, promptText string, model string, configRoot string, configDir string, logPath string) error {\n\treturn opencode.Run(issueID, repoRoot, promptText, model, configRoot, configDir, logPath, o.runner)\n}\n\nfunc RunOnceMain(args []string, runOnce runOnceFunc, exit exitFunc, stdout io.Writer, stderr io.Writer, beadsRunner beadsRunner, gitRunner gitRunner) int {\n\tfs := flag.NewFlagSet(\"yolo-runner\", flag.ContinueOnError)\n\tfs.SetOutput(stderr)\n\n\trepoRoot := fs.String(\"repo\", \".\", \"Repository root path\")\n\trootID := fs.String(\"root\", \"algi-8bt\", \"Root bead/epic ID\")\n\tmodel := fs.String(\"model\", \"\", \"OpenCode model\")\n\tdryRun := fs.Bool(\"dry-run\", false, \"Print task and prompt without executing\")\n\theadless := fs.Bool(\"headless\", false, \"Force plain output without TUI\")\n\tconfigRoot := fs.String(\"config-root\", \"\", \"OpenCode config root\")\n\tconfigDir := fs.String(\"config-dir\", \"\", \"OpenCode config dir\")\n\n\tif err := fs.Parse(args); err != nil {\n\t\tfmt.Fprintln(stderr, err)\n\t\tif exit != nil {\n\t\t\texit(1)\n\t\t}\n\t\treturn 1\n\t}\n\n\tif runOnce == nil {\n\t\trunOnce = runner.RunOnce\n\t}\n\n\tif beadsRunner == nil {\n\t\tbeadsRunner = adapterRunner{}\n\t}\n\tif gitRunner == nil {\n\t\tgitRunner = adapterGitRunner{}\n\t}\n\n\tbeadsAdapter := beads.New(beadsRunner)\n\tgitAdapter := gitadapter.New(gitRunner)\n\topenCodeAdapter := openCodeAdapter{runner: defaultOpenCodeRunner{}}\n\n\tdeps := runner.RunOnceDeps{\n\t\tBeads:    beadsAdapter,\n\t\tPrompt:   promptBuilder{},\n\t\tOpenCode: openCodeAdapter,\n\t\tGit:      gitAdapter,\n\t\tLogger:   runnerLogger{},\n\t}\n\n\tresolvedConfigRoot := *configRoot\n\tresolvedConfigDir := *configDir\n\tif resolvedConfigRoot == \"\" {\n\t\thomeDir := os.Getenv(\"HOME\")\n\t\tif homeDir != \"\" {\n\t\t\tresolvedConfigRoot = filepath.Join(homeDir, \".config\", \"opencode-runner\")\n\t\t}\n\t}\n\tif resolvedConfigDir == \"\" && resolvedConfigRoot != \"\" {\n\t\tresolvedConfigDir = filepath.Join(resolvedConfigRoot, \"opencode\")\n\t}\n\n\toptions := runner.RunOnceOptions{\n\t\tRepoRoot:   *repoRoot,\n\t\tRootID:     *rootID,\n\t\tModel:      *model,\n\t\tConfigRoot: resolvedConfigRoot,\n\t\tConfigDir:  resolvedConfigDir,\n\t\tDryRun:     *dryRun,\n\t\tOut:        stdout,\n\t}\n\n\tif stdout == nil {\n\t\toptions.Out = io.Discard\n\t}\n\tif stderr == nil {\n\t\tstderr = io.Discard\n\t}\n\n\t_, err := runOnce(options, deps)\n\tif err != nil {\n\t\tfmt.Fprintln(stderr, err)\n\t\tif exit != nil {\n\t\t\texit(1)\n\t\t}\n\t\treturn 1\n\t}\n\n\tif exit != nil {\n\t\texit(0)\n\t}\n\treturn 0\n}\n\nfunc main() {\n\tRunOnceMain(os.Args[1:], runner.RunOnce, os.Exit, os.Stdout, os.Stderr, nil, nil)\n}\n\ntype promptBuilder struct{}\n\nfunc (promptBuilder) Build(issueID string, title string, description string, acceptance string) string {\n\treturn prompt.Build(issueID, title, description, acceptance)\n}\n\ntype runnerLogger struct{}\n\nfunc (runnerLogger) AppendRunnerSummary(repoRoot string, issueID string, title string, status string, commitSHA string) error {\n\treturn logging.AppendRunnerSummary(repoRoot, issueID, title, status, commitSHA)\n}\n\ntype defaultOpenCodeRunner struct{}\n\nfunc (defaultOpenCodeRunner) Start(args []string, env map[string]string, stdoutPath string) (opencode.Process, error) {\n\treturn startCommandWithEnv(args, env, stdoutPath)\n}\n","after":"package main\n\nimport (\n\t\"context\"\n\t\"flag\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n\n\t\"yolo-runner/internal/beads\"\n\t\"yolo-runner/internal/logging\"\n\t\"yolo-runner/internal/opencode\"\n\t\"yolo-runner/internal/prompt\"\n\t\"yolo-runner/internal/runner\"\n\t\"yolo-runner/internal/ui/tui\"\n\tgitadapter \"yolo-runner/internal/vcs/git\"\n\n\ttea \"github.com/charmbracelet/bubbletea\"\n\t\"golang.org/x/term\"\n)\n\ntype runOnceFunc func(opts runner.RunOnceOptions, deps runner.RunOnceDeps) (string, error)\n\ntype exitFunc func(code int)\n\ntype beadsRunner interface {\n\tRun(args ...string) (string, error)\n}\n\ntype gitRunner interface {\n\tRun(name string, args ...string) (string, error)\n}\n\ntype openCodeRunner interface {\n\tStart(args []string, env map[string]string, stdoutPath string) (opencode.Process, error)\n}\n\ntype adapterRunner struct{}\n\nfunc (adapterRunner) Run(args ...string) (string, error) {\n\treturn runCommand(args...)\n}\n\ntype adapterGitRunner struct{}\n\nfunc (adapterGitRunner) Run(name string, args ...string) (string, error) {\n\treturn runCommand(append([]string{name}, args...)...)\n}\n\ntype openCodeAdapter struct {\n\trunner openCodeRunner\n}\n\nfunc (o openCodeAdapter) Run(issueID string, repoRoot string, promptText string, model string, configRoot string, configDir string, logPath string) error {\n\treturn opencode.Run(issueID, repoRoot, promptText, model, configRoot, configDir, logPath, o.runner)\n}\n\nfunc RunOnceMain(args []string, runOnce runOnceFunc, exit exitFunc, stdout io.Writer, stderr io.Writer, beadsRunner beadsRunner, gitRunner gitRunner) int {\n\tfs := flag.NewFlagSet(\"yolo-runner\", flag.ContinueOnError)\n\tfs.SetOutput(stderr)\n\n\trepoRoot := fs.String(\"repo\", \".\", \"Repository root path\")\n\trootID := fs.String(\"root\", \"algi-8bt\", \"Root bead/epic ID\")\n\tmodel := fs.String(\"model\", \"\", \"OpenCode model\")\n\tdryRun := fs.Bool(\"dry-run\", false, \"Print task and prompt without executing\")\n\theadless := fs.Bool(\"headless\", false, \"Force plain output without TUI\")\n\tconfigRoot := fs.String(\"config-root\", \"\", \"OpenCode config root\")\n\tconfigDir := fs.String(\"config-dir\", \"\", \"OpenCode config dir\")\n\n\tif err := fs.Parse(args); err != nil {\n\t\tfmt.Fprintln(stderr, err)\n\t\tif exit != nil {\n\t\t\texit(1)\n\t\t}\n\t\treturn 1\n\t}\n\n\tif runOnce == nil {\n\t\trunOnce = runner.RunOnce\n\t}\n\n\tif beadsRunner == nil {\n\t\tbeadsRunner = adapterRunner{}\n\t}\n\tif gitRunner == nil {\n\t\tgitRunner = adapterGitRunner{}\n\t}\n\n\tbeadsAdapter := beads.New(beadsRunner)\n\tgitAdapter := gitadapter.New(gitRunner)\n\topenCodeAdapter := openCodeAdapter{runner: defaultOpenCodeRunner{}}\n\n\tdeps := runner.RunOnceDeps{\n\t\tBeads:    beadsAdapter,\n\t\tPrompt:   promptBuilder{},\n\t\tOpenCode: openCodeAdapter,\n\t\tGit:      gitAdapter,\n\t\tLogger:   runnerLogger{},\n\t}\n\n\tresolvedConfigRoot := *configRoot\n\tresolvedConfigDir := *configDir\n\tif resolvedConfigRoot == \"\" {\n\t\thomeDir := os.Getenv(\"HOME\")\n\t\tif homeDir != \"\" {\n\t\t\tresolvedConfigRoot = filepath.Join(homeDir, \".config\", \"opencode-runner\")\n\t\t}\n\t}\n\tif resolvedConfigDir == \"\" && resolvedConfigRoot != \"\" {\n\t\tresolvedConfigDir = filepath.Join(resolvedConfigRoot, \"opencode\")\n\t}\n\n\toptions := runner.RunOnceOptions{\n\t\tRepoRoot:   *repoRoot,\n\t\tRootID:     *rootID,\n\t\tModel:      *model,\n\t\tConfigRoot: resolvedConfigRoot,\n\t\tConfigDir:  resolvedConfigDir,\n\t\tDryRun:     *dryRun,\n\t\tOut:        stdout,\n\t}\n\n\tif stdout == nil {\n\t\toptions.Out = io.Discard\n\t}\n\tif stderr == nil {\n\t\tstderr = io.Discard\n\t}\n\n\t_, err := runOnce(options, deps)\n\tif err != nil {\n\t\tfmt.Fprintln(stderr, err)\n\t\tif exit != nil {\n\t\t\texit(1)\n\t\t}\n\t\treturn 1\n\t}\n\n\tif exit != nil {\n\t\texit(0)\n\t}\n\treturn 0\n}\n\nfunc main() {\n\tRunOnceMain(os.Args[1:], runner.RunOnce, os.Exit, os.Stdout, os.Stderr, nil, nil)\n}\n\ntype promptBuilder struct{}\n\nfunc (promptBuilder) Build(issueID string, title string, description string, acceptance string) string {\n\treturn prompt.Build(issueID, title, description, acceptance)\n}\n\ntype runnerLogger struct{}\n\nfunc (runnerLogger) AppendRunnerSummary(repoRoot string, issueID string, title string, status string, commitSHA string) error {\n\treturn logging.AppendRunnerSummary(repoRoot, issueID, title, status, commitSHA)\n}\n\ntype defaultOpenCodeRunner struct{}\n\nfunc (defaultOpenCodeRunner) Start(args []string, env map[string]string, stdoutPath string) (opencode.Process, error) {\n\treturn startCommandWithEnv(args, env, stdoutPath)\n}\n","additions":5,"deletions":0},"truncated":false},"time":{"start":1768840718024,"end":1768840718320}},"metadata":{"openai":{"itemId":"fc_027dfe7ba47436a601696e5e0960e48191bbf942a2cb0881c3"}}}}
{"type":"step_finish","timestamp":1768840718340,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd71f67f1001MHqGOuS7jglXsM","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd71f509f001ZGHxXd4CWdesZE","type":"step-finish","reason":"tool-calls","snapshot":"ef761616021a69d3c39c093f25df8adb31101e07","cost":0,"tokens":{"input":1248,"output":289,"reasoning":0,"cache":{"read":45696,"write":0}}}}
{"type":"step_start","timestamp":1768840718768,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd71f69af001Gge4V3pO60IPPI","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd71f6820001xewbxYcr26gfjY","type":"step-start","snapshot":"1de1b60778798b3210437e2c32954c46137a05ce"}}
{"type":"tool_use","timestamp":1768840722344,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd71f6b7c0012AjwxW0TU8CTjX","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd71f6820001xewbxYcr26gfjY","type":"tool","callID":"call_9QQnJPzRirtHpn6Uti3Z4mli","tool":"edit","state":{"status":"completed","input":{"filePath":"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main.go","oldString":"type openCodeRunner interface {\n\tStart(args []string, env map[string]string, stdoutPath string) (opencode.Process, error)\n}\n","newString":"type openCodeRunner interface {\n\tStart(args []string, env map[string]string, stdoutPath string) (opencode.Process, error)\n}\n\ntype tuiProgram interface {\n\tStart() error\n\tSend(event runner.Event)\n\tQuit()\n}\n\ntype tuiEmitter struct {\n\tprogram tuiProgram\n}\n\nfunc (t tuiEmitter) Emit(event runner.Event) {\n\tif t.program == nil {\n\t\treturn\n\t}\n\tt.program.Send(event)\n}\n"},"output":"Edit applied successfully.\n\nLSP errors detected in this file, please fix:\n<diagnostics file=\"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main.go\">\nERROR [4:2] \"context\" imported and not used\nERROR [16:2] \"yolo-runner/internal/ui/tui\" imported and not used\nERROR [19:2] \"github.com/charmbracelet/bubbletea\" imported as tea and not used\nERROR [20:2] \"golang.org/x/term\" imported and not used\nERROR [84:2] declared and not used: headless\n</diagnostics>","title":"cmd/yolo-runner/main.go","metadata":{"diagnostics":{"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main.go":[{"range":{"start":{"line":3,"character":1},"end":{"line":3,"character":10}},"severity":1,"code":"UnusedImport","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UnusedImport"},"source":"compiler","message":"\"context\" imported and not used","tags":[1]},{"range":{"start":{"line":15,"character":1},"end":{"line":15,"character":30}},"severity":1,"code":"UnusedImport","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UnusedImport"},"source":"compiler","message":"\"yolo-runner/internal/ui/tui\" imported and not used","tags":[1]},{"range":{"start":{"line":18,"character":1},"end":{"line":18,"character":4}},"severity":1,"code":"UnusedImport","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UnusedImport"},"source":"compiler","message":"\"github.com/charmbracelet/bubbletea\" imported as tea and not used","tags":[1]},{"range":{"start":{"line":19,"character":1},"end":{"line":19,"character":20}},"severity":1,"code":"UnusedImport","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UnusedImport"},"source":"compiler","message":"\"golang.org/x/term\" imported and not used","tags":[1]},{"range":{"start":{"line":83,"character":1},"end":{"line":83,"character":9}},"severity":1,"code":"UnusedVar","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UnusedVar"},"source":"compiler","message":"declared and not used: headless","tags":[1]}],"/Users/egv/dev/yolo-runner/go.mod":[{"range":{"start":{"line":6,"character":44},"end":{"line":6,"character":55}},"severity":2,"source":"go mod tidy","message":"github.com/charmbracelet/bubbletea should be direct"},{"range":{"start":{"line":19,"character":26},"end":{"line":19,"character":37}},"severity":2,"source":"go mod tidy","message":"golang.org/x/term should be direct"}],"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go":[{"range":{"start":{"line":213,"character":19},"end":{"line":213,"character":29}},"severity":1,"code":"UndeclaredName","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UndeclaredName"},"source":"compiler","message":"undefined: isTerminal"},{"range":{"start":{"line":214,"character":22},"end":{"line":214,"character":35}},"severity":1,"code":"UndeclaredName","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UndeclaredName"},"source":"compiler","message":"undefined: newTUIProgram"},{"range":{"start":{"line":215,"character":1},"end":{"line":215,"character":11}},"severity":1,"code":"UndeclaredName","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UndeclaredName"},"source":"compiler","message":"undefined: isTerminal"},{"range":{"start":{"line":216,"character":1},"end":{"line":216,"character":14}},"severity":1,"code":"UndeclaredName","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UndeclaredName"},"source":"compiler","message":"undefined: newTUIProgram"},{"range":{"start":{"line":216,"character":40},"end":{"line":216,"character":50}},"severity":1,"code":"UndeclaredName","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UndeclaredName"},"source":"compiler","message":"undefined: tuiProgram"},{"range":{"start":{"line":218,"character":2},"end":{"line":218,"character":12}},"severity":1,"code":"UndeclaredName","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UndeclaredName"},"source":"compiler","message":"undefined: isTerminal"},{"range":{"start":{"line":219,"character":2},"end":{"line":219,"character":15}},"severity":1,"code":"UndeclaredName","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UndeclaredName"},"source":"compiler","message":"undefined: newTUIProgram"},{"range":{"start":{"line":246,"character":19},"end":{"line":246,"character":29}},"severity":1,"code":"UndeclaredName","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UndeclaredName"},"source":"compiler","message":"undefined: isTerminal"},{"range":{"start":{"line":247,"character":22},"end":{"line":247,"character":35}},"severity":1,"code":"UndeclaredName","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UndeclaredName"},"source":"compiler","message":"undefined: newTUIProgram"},{"range":{"start":{"line":248,"character":1},"end":{"line":248,"character":11}},"severity":1,"code":"UndeclaredName","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UndeclaredName"},"source":"compiler","message":"undefined: isTerminal"},{"range":{"start":{"line":249,"character":1},"end":{"line":249,"character":14}},"severity":1,"code":"UndeclaredName","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UndeclaredName"},"source":"compiler","message":"undefined: newTUIProgram"},{"range":{"start":{"line":249,"character":40},"end":{"line":249,"character":50}},"severity":1,"code":"UndeclaredName","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UndeclaredName"},"source":"compiler","message":"undefined: tuiProgram"},{"range":{"start":{"line":254,"character":2},"end":{"line":254,"character":12}},"severity":1,"code":"UndeclaredName","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UndeclaredName"},"source":"compiler","message":"undefined: isTerminal"},{"range":{"start":{"line":255,"character":2},"end":{"line":255,"character":15}},"severity":1,"code":"UndeclaredName","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UndeclaredName"},"source":"compiler","message":"undefined: newTUIProgram"}],"/Users/egv/dev/yolo-runner/bubbletea_test.go":[],"/Users/egv/dev/yolo-runner/opencode_adapter_v1.go":[{"range":{"start":{"line":24,"character":1},"end":{"line":24,"character":18}},"severity":2,"code":"default","codeDescription":{"href":"https://staticcheck.dev/docs/checks/#S1031"},"source":"S1031","message":"unnecessary nil check around range"}],"/Users/egv/dev/yolo-runner/internal/ui/tui/model.go":[],"/Users/egv/dev/yolo-runner/internal/runner/runner.go":[],"/Users/egv/dev/yolo-runner/internal/ui/tui/model_test.go":[],"/Users/egv/dev/yolo-runner/internal/runner/events.go":[],"/Users/egv/dev/yolo-runner/internal/runner/loop_test.go":[],"/Users/egv/dev/yolo-runner/internal/runner/runner_test.go":[],"/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/tea.go":[],"/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/tty_unix.go":[],"/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/tty.go":[],"/Users/egv/dev/yolo-runner/internal/opencode/watchdog.go":[],"/Users/egv/dev/yolo-runner/internal/opencode/client.go":[{"range":{"start":{"line":28,"character":1},"end":{"line":28,"character":18}},"severity":2,"code":"default","codeDescription":{"href":"https://staticcheck.dev/docs/checks/#S1031"},"source":"S1031","message":"unnecessary nil check around range"}],"/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/options.go":[],"/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/tty_windows.go":[{"range":{"start":{"line":3,"character":8},"end":{"line":3,"character":11}},"severity":2,"source":"go list","message":"This file is within module \"../../go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0\", which is not included in your workspace.\nTo fix this problem, you can add a go.work file that uses this directory.\nSee the documentation for more information on setting up your workspace:\nhttps://github.com/golang/tools/blob/master/gopls/doc/workspace.md.","data":{"Actions":[{"title":"Add a go.work file using this module","kind":"quickfix","command":{"title":"Run `go work init && go work use`","command":"gopls.run_go_work_command","arguments":[{"ViewID":"1","InitFirst":true,"Args":["use","../../go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0"]}]}}]}}]},"diff":"Index: /Users/egv/dev/yolo-runner/cmd/yolo-runner/main.go\n===================================================================\n--- /Users/egv/dev/yolo-runner/cmd/yolo-runner/main.go\n+++ /Users/egv/dev/yolo-runner/cmd/yolo-runner/main.go\n@@ -35,8 +35,25 @@\n type openCodeRunner interface {\n \tStart(args []string, env map[string]string, stdoutPath string) (opencode.Process, error)\n }\n \n+type tuiProgram interface {\n+\tStart() error\n+\tSend(event runner.Event)\n+\tQuit()\n+}\n+\n+type tuiEmitter struct {\n+\tprogram tuiProgram\n+}\n+\n+func (t tuiEmitter) Emit(event runner.Event) {\n+\tif t.program == nil {\n+\t\treturn\n+\t}\n+\tt.program.Send(event)\n+}\n+\n type adapterRunner struct{}\n \n func (adapterRunner) Run(args ...string) (string, error) {\n \treturn runCommand(args...)\n","filediff":{"file":"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main.go","before":"package main\n\nimport (\n\t\"context\"\n\t\"flag\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n\n\t\"yolo-runner/internal/beads\"\n\t\"yolo-runner/internal/logging\"\n\t\"yolo-runner/internal/opencode\"\n\t\"yolo-runner/internal/prompt\"\n\t\"yolo-runner/internal/runner\"\n\t\"yolo-runner/internal/ui/tui\"\n\tgitadapter \"yolo-runner/internal/vcs/git\"\n\n\ttea \"github.com/charmbracelet/bubbletea\"\n\t\"golang.org/x/term\"\n)\n\ntype runOnceFunc func(opts runner.RunOnceOptions, deps runner.RunOnceDeps) (string, error)\n\ntype exitFunc func(code int)\n\ntype beadsRunner interface {\n\tRun(args ...string) (string, error)\n}\n\ntype gitRunner interface {\n\tRun(name string, args ...string) (string, error)\n}\n\ntype openCodeRunner interface {\n\tStart(args []string, env map[string]string, stdoutPath string) (opencode.Process, error)\n}\n\ntype adapterRunner struct{}\n\nfunc (adapterRunner) Run(args ...string) (string, error) {\n\treturn runCommand(args...)\n}\n\ntype adapterGitRunner struct{}\n\nfunc (adapterGitRunner) Run(name string, args ...string) (string, error) {\n\treturn runCommand(append([]string{name}, args...)...)\n}\n\ntype openCodeAdapter struct {\n\trunner openCodeRunner\n}\n\nfunc (o openCodeAdapter) Run(issueID string, repoRoot string, promptText string, model string, configRoot string, configDir string, logPath string) error {\n\treturn opencode.Run(issueID, repoRoot, promptText, model, configRoot, configDir, logPath, o.runner)\n}\n\nfunc RunOnceMain(args []string, runOnce runOnceFunc, exit exitFunc, stdout io.Writer, stderr io.Writer, beadsRunner beadsRunner, gitRunner gitRunner) int {\n\tfs := flag.NewFlagSet(\"yolo-runner\", flag.ContinueOnError)\n\tfs.SetOutput(stderr)\n\n\trepoRoot := fs.String(\"repo\", \".\", \"Repository root path\")\n\trootID := fs.String(\"root\", \"algi-8bt\", \"Root bead/epic ID\")\n\tmodel := fs.String(\"model\", \"\", \"OpenCode model\")\n\tdryRun := fs.Bool(\"dry-run\", false, \"Print task and prompt without executing\")\n\theadless := fs.Bool(\"headless\", false, \"Force plain output without TUI\")\n\tconfigRoot := fs.String(\"config-root\", \"\", \"OpenCode config root\")\n\tconfigDir := fs.String(\"config-dir\", \"\", \"OpenCode config dir\")\n\n\tif err := fs.Parse(args); err != nil {\n\t\tfmt.Fprintln(stderr, err)\n\t\tif exit != nil {\n\t\t\texit(1)\n\t\t}\n\t\treturn 1\n\t}\n\n\tif runOnce == nil {\n\t\trunOnce = runner.RunOnce\n\t}\n\n\tif beadsRunner == nil {\n\t\tbeadsRunner = adapterRunner{}\n\t}\n\tif gitRunner == nil {\n\t\tgitRunner = adapterGitRunner{}\n\t}\n\n\tbeadsAdapter := beads.New(beadsRunner)\n\tgitAdapter := gitadapter.New(gitRunner)\n\topenCodeAdapter := openCodeAdapter{runner: defaultOpenCodeRunner{}}\n\n\tdeps := runner.RunOnceDeps{\n\t\tBeads:    beadsAdapter,\n\t\tPrompt:   promptBuilder{},\n\t\tOpenCode: openCodeAdapter,\n\t\tGit:      gitAdapter,\n\t\tLogger:   runnerLogger{},\n\t}\n\n\tresolvedConfigRoot := *configRoot\n\tresolvedConfigDir := *configDir\n\tif resolvedConfigRoot == \"\" {\n\t\thomeDir := os.Getenv(\"HOME\")\n\t\tif homeDir != \"\" {\n\t\t\tresolvedConfigRoot = filepath.Join(homeDir, \".config\", \"opencode-runner\")\n\t\t}\n\t}\n\tif resolvedConfigDir == \"\" && resolvedConfigRoot != \"\" {\n\t\tresolvedConfigDir = filepath.Join(resolvedConfigRoot, \"opencode\")\n\t}\n\n\toptions := runner.RunOnceOptions{\n\t\tRepoRoot:   *repoRoot,\n\t\tRootID:     *rootID,\n\t\tModel:      *model,\n\t\tConfigRoot: resolvedConfigRoot,\n\t\tConfigDir:  resolvedConfigDir,\n\t\tDryRun:     *dryRun,\n\t\tOut:        stdout,\n\t}\n\n\tif stdout == nil {\n\t\toptions.Out = io.Discard\n\t}\n\tif stderr == nil {\n\t\tstderr = io.Discard\n\t}\n\n\t_, err := runOnce(options, deps)\n\tif err != nil {\n\t\tfmt.Fprintln(stderr, err)\n\t\tif exit != nil {\n\t\t\texit(1)\n\t\t}\n\t\treturn 1\n\t}\n\n\tif exit != nil {\n\t\texit(0)\n\t}\n\treturn 0\n}\n\nfunc main() {\n\tRunOnceMain(os.Args[1:], runner.RunOnce, os.Exit, os.Stdout, os.Stderr, nil, nil)\n}\n\ntype promptBuilder struct{}\n\nfunc (promptBuilder) Build(issueID string, title string, description string, acceptance string) string {\n\treturn prompt.Build(issueID, title, description, acceptance)\n}\n\ntype runnerLogger struct{}\n\nfunc (runnerLogger) AppendRunnerSummary(repoRoot string, issueID string, title string, status string, commitSHA string) error {\n\treturn logging.AppendRunnerSummary(repoRoot, issueID, title, status, commitSHA)\n}\n\ntype defaultOpenCodeRunner struct{}\n\nfunc (defaultOpenCodeRunner) Start(args []string, env map[string]string, stdoutPath string) (opencode.Process, error) {\n\treturn startCommandWithEnv(args, env, stdoutPath)\n}\n","after":"package main\n\nimport (\n\t\"context\"\n\t\"flag\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n\n\t\"yolo-runner/internal/beads\"\n\t\"yolo-runner/internal/logging\"\n\t\"yolo-runner/internal/opencode\"\n\t\"yolo-runner/internal/prompt\"\n\t\"yolo-runner/internal/runner\"\n\t\"yolo-runner/internal/ui/tui\"\n\tgitadapter \"yolo-runner/internal/vcs/git\"\n\n\ttea \"github.com/charmbracelet/bubbletea\"\n\t\"golang.org/x/term\"\n)\n\ntype runOnceFunc func(opts runner.RunOnceOptions, deps runner.RunOnceDeps) (string, error)\n\ntype exitFunc func(code int)\n\ntype beadsRunner interface {\n\tRun(args ...string) (string, error)\n}\n\ntype gitRunner interface {\n\tRun(name string, args ...string) (string, error)\n}\n\ntype openCodeRunner interface {\n\tStart(args []string, env map[string]string, stdoutPath string) (opencode.Process, error)\n}\n\ntype tuiProgram interface {\n\tStart() error\n\tSend(event runner.Event)\n\tQuit()\n}\n\ntype tuiEmitter struct {\n\tprogram tuiProgram\n}\n\nfunc (t tuiEmitter) Emit(event runner.Event) {\n\tif t.program == nil {\n\t\treturn\n\t}\n\tt.program.Send(event)\n}\n\ntype adapterRunner struct{}\n\nfunc (adapterRunner) Run(args ...string) (string, error) {\n\treturn runCommand(args...)\n}\n\ntype adapterGitRunner struct{}\n\nfunc (adapterGitRunner) Run(name string, args ...string) (string, error) {\n\treturn runCommand(append([]string{name}, args...)...)\n}\n\ntype openCodeAdapter struct {\n\trunner openCodeRunner\n}\n\nfunc (o openCodeAdapter) Run(issueID string, repoRoot string, promptText string, model string, configRoot string, configDir string, logPath string) error {\n\treturn opencode.Run(issueID, repoRoot, promptText, model, configRoot, configDir, logPath, o.runner)\n}\n\nfunc RunOnceMain(args []string, runOnce runOnceFunc, exit exitFunc, stdout io.Writer, stderr io.Writer, beadsRunner beadsRunner, gitRunner gitRunner) int {\n\tfs := flag.NewFlagSet(\"yolo-runner\", flag.ContinueOnError)\n\tfs.SetOutput(stderr)\n\n\trepoRoot := fs.String(\"repo\", \".\", \"Repository root path\")\n\trootID := fs.String(\"root\", \"algi-8bt\", \"Root bead/epic ID\")\n\tmodel := fs.String(\"model\", \"\", \"OpenCode model\")\n\tdryRun := fs.Bool(\"dry-run\", false, \"Print task and prompt without executing\")\n\theadless := fs.Bool(\"headless\", false, \"Force plain output without TUI\")\n\tconfigRoot := fs.String(\"config-root\", \"\", \"OpenCode config root\")\n\tconfigDir := fs.String(\"config-dir\", \"\", \"OpenCode config dir\")\n\n\tif err := fs.Parse(args); err != nil {\n\t\tfmt.Fprintln(stderr, err)\n\t\tif exit != nil {\n\t\t\texit(1)\n\t\t}\n\t\treturn 1\n\t}\n\n\tif runOnce == nil {\n\t\trunOnce = runner.RunOnce\n\t}\n\n\tif beadsRunner == nil {\n\t\tbeadsRunner = adapterRunner{}\n\t}\n\tif gitRunner == nil {\n\t\tgitRunner = adapterGitRunner{}\n\t}\n\n\tbeadsAdapter := beads.New(beadsRunner)\n\tgitAdapter := gitadapter.New(gitRunner)\n\topenCodeAdapter := openCodeAdapter{runner: defaultOpenCodeRunner{}}\n\n\tdeps := runner.RunOnceDeps{\n\t\tBeads:    beadsAdapter,\n\t\tPrompt:   promptBuilder{},\n\t\tOpenCode: openCodeAdapter,\n\t\tGit:      gitAdapter,\n\t\tLogger:   runnerLogger{},\n\t}\n\n\tresolvedConfigRoot := *configRoot\n\tresolvedConfigDir := *configDir\n\tif resolvedConfigRoot == \"\" {\n\t\thomeDir := os.Getenv(\"HOME\")\n\t\tif homeDir != \"\" {\n\t\t\tresolvedConfigRoot = filepath.Join(homeDir, \".config\", \"opencode-runner\")\n\t\t}\n\t}\n\tif resolvedConfigDir == \"\" && resolvedConfigRoot != \"\" {\n\t\tresolvedConfigDir = filepath.Join(resolvedConfigRoot, \"opencode\")\n\t}\n\n\toptions := runner.RunOnceOptions{\n\t\tRepoRoot:   *repoRoot,\n\t\tRootID:     *rootID,\n\t\tModel:      *model,\n\t\tConfigRoot: resolvedConfigRoot,\n\t\tConfigDir:  resolvedConfigDir,\n\t\tDryRun:     *dryRun,\n\t\tOut:        stdout,\n\t}\n\n\tif stdout == nil {\n\t\toptions.Out = io.Discard\n\t}\n\tif stderr == nil {\n\t\tstderr = io.Discard\n\t}\n\n\t_, err := runOnce(options, deps)\n\tif err != nil {\n\t\tfmt.Fprintln(stderr, err)\n\t\tif exit != nil {\n\t\t\texit(1)\n\t\t}\n\t\treturn 1\n\t}\n\n\tif exit != nil {\n\t\texit(0)\n\t}\n\treturn 0\n}\n\nfunc main() {\n\tRunOnceMain(os.Args[1:], runner.RunOnce, os.Exit, os.Stdout, os.Stderr, nil, nil)\n}\n\ntype promptBuilder struct{}\n\nfunc (promptBuilder) Build(issueID string, title string, description string, acceptance string) string {\n\treturn prompt.Build(issueID, title, description, acceptance)\n}\n\ntype runnerLogger struct{}\n\nfunc (runnerLogger) AppendRunnerSummary(repoRoot string, issueID string, title string, status string, commitSHA string) error {\n\treturn logging.AppendRunnerSummary(repoRoot, issueID, title, status, commitSHA)\n}\n\ntype defaultOpenCodeRunner struct{}\n\nfunc (defaultOpenCodeRunner) Start(args []string, env map[string]string, stdoutPath string) (opencode.Process, error) {\n\treturn startCommandWithEnv(args, env, stdoutPath)\n}\n","additions":17,"deletions":0},"truncated":false},"time":{"start":1768840722185,"end":1768840722343}},"metadata":{"openai":{"itemId":"fc_0fbc9475b4e2f43e01696e5e0f35948191b5204531289db145"}}}}
{"type":"step_finish","timestamp":1768840722377,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd71f77b8001AlOc8yqa6ntnFj","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd71f6820001xewbxYcr26gfjY","type":"step-finish","reason":"tool-calls","snapshot":"f8139ec8c4da3559c9d8ca82e6823643f726ecb6","cost":0,"tokens":{"input":654,"output":186,"reasoning":0,"cache":{"read":46720,"write":0}}}}
{"type":"step_start","timestamp":1768840722948,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd71f7a03001FLOpGcc6x8dsck","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd71f77ec001NJEQMVt7FTFwfX","type":"step-start","snapshot":"968eb076e41c0c41bc76fe8ae383dfd3c45cbcdc"}}
{"type":"tool_use","timestamp":1768840750003,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd71f7be90014nzQqPtQZTwTpH","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd71f77ec001NJEQMVt7FTFwfX","type":"tool","callID":"call_7CCWA80M056U30MrfyIWyQwM","tool":"edit","state":{"status":"completed","input":{"filePath":"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main.go","oldString":"func RunOnceMain(args []string, runOnce runOnceFunc, exit exitFunc, stdout io.Writer, stderr io.Writer, beadsRunner beadsRunner, gitRunner gitRunner) int {\n\tfs := flag.NewFlagSet(\"yolo-runner\", flag.ContinueOnError)\n\tfs.SetOutput(stderr)\n\n\trepoRoot := fs.String(\"repo\", \".\", \"Repository root path\")\n\trootID := fs.String(\"root\", \"algi-8bt\", \"Root bead/epic ID\")\n\tmodel := fs.String(\"model\", \"\", \"OpenCode model\")\n\tdryRun := fs.Bool(\"dry-run\", false, \"Print task and prompt without executing\")\n\theadless := fs.Bool(\"headless\", false, \"Force plain output without TUI\")\n\tconfigRoot := fs.String(\"config-root\", \"\", \"OpenCode config root\")\n\tconfigDir := fs.String(\"config-dir\", \"\", \"OpenCode config dir\")\n\n\tif err := fs.Parse(args); err != nil {\n\t\tfmt.Fprintln(stderr, err)\n\t\tif exit != nil {\n\t\t\texit(1)\n\t\t}\n\t\treturn 1\n\t}\n\n\tif runOnce == nil {\n\t\trunOnce = runner.RunOnce\n\t}\n\n\tif beadsRunner == nil {\n\t\tbeadsRunner = adapterRunner{}\n\t}\n\tif gitRunner == nil {\n\t\tgitRunner = adapterGitRunner{}\n\t}\n\n\tbeadsAdapter := beads.New(beadsRunner)\n\tgitAdapter := gitadapter.New(gitRunner)\n\topenCodeAdapter := openCodeAdapter{runner: defaultOpenCodeRunner{}}\n\n\tdeps := runner.RunOnceDeps{\n\t\tBeads:    beadsAdapter,\n\t\tPrompt:   promptBuilder{},\n\t\tOpenCode: openCodeAdapter,\n\t\tGit:      gitAdapter,\n\t\tLogger:   runnerLogger{},\n\t}\n\n\tresolvedConfigRoot := *configRoot\n\tresolvedConfigDir := *configDir\n\tif resolvedConfigRoot == \"\" {\n\t\thomeDir := os.Getenv(\"HOME\")\n\t\tif homeDir != \"\" {\n\t\t\tresolvedConfigRoot = filepath.Join(homeDir, \".config\", \"opencode-runner\")\n\t\t}\n\t}\n\tif resolvedConfigDir == \"\" && resolvedConfigRoot != \"\" {\n\t\tresolvedConfigDir = filepath.Join(resolvedConfigRoot, \"opencode\")\n\t}\n\n\toptions := runner.RunOnceOptions{\n\t\tRepoRoot:   *repoRoot,\n\t\tRootID:     *rootID,\n\t\tModel:      *model,\n\t\tConfigRoot: resolvedConfigRoot,\n\t\tConfigDir:  resolvedConfigDir,\n\t\tDryRun:     *dryRun,\n\t\tOut:        stdout,\n\t}\n\n\tif stdout == nil {\n\t\toptions.Out = io.Discard\n\t}\n\tif stderr == nil {\n\t\tstderr = io.Discard\n\t}\n\n\t_, err := runOnce(options, deps)\n\tif err != nil {\n\t\tfmt.Fprintln(stderr, err)\n\t\tif exit != nil {\n\t\t\texit(1)\n\t\t}\n\t\treturn 1\n\t}\n\n\tif exit != nil {\n\t\texit(0)\n\t}\n\treturn 0\n}\n","newString":"func RunOnceMain(args []string, runOnce runOnceFunc, exit exitFunc, stdout io.Writer, stderr io.Writer, beadsRunner beadsRunner, gitRunner gitRunner) int {\n\tfs := flag.NewFlagSet(\"yolo-runner\", flag.ContinueOnError)\n\tfs.SetOutput(stderr)\n\n\trepoRoot := fs.String(\"repo\", \".\", \"Repository root path\")\n\trootID := fs.String(\"root\", \"algi-8bt\", \"Root bead/epic ID\")\n\tmodel := fs.String(\"model\", \"\", \"OpenCode model\")\n\tdryRun := fs.Bool(\"dry-run\", false, \"Print task and prompt without executing\")\n\theadless := fs.Bool(\"headless\", false, \"Force plain output without TUI\")\n\tconfigRoot := fs.String(\"config-root\", \"\", \"OpenCode config root\")\n\tconfigDir := fs.String(\"config-dir\", \"\", \"OpenCode config dir\")\n\n\tif err := fs.Parse(args); err != nil {\n\t\tfmt.Fprintln(stderr, err)\n\t\tif exit != nil {\n\t\t\texit(1)\n\t\t}\n\t\treturn 1\n\t}\n\n\tif runOnce == nil {\n\t\trunOnce = runner.RunOnce\n\t}\n\n\tif beadsRunner == nil {\n\t\tbeadsRunner = adapterRunner{}\n\t}\n\tif gitRunner == nil {\n\t\tgitRunner = adapterGitRunner{}\n\t}\n\n\tbeadsAdapter := beads.New(beadsRunner)\n\tgitAdapter := gitadapter.New(gitRunner)\n\topenCodeAdapter := openCodeAdapter{runner: defaultOpenCodeRunner{}}\n\n\tdeps := runner.RunOnceDeps{\n\t\tBeads:    beadsAdapter,\n\t\tPrompt:   promptBuilder{},\n\t\tOpenCode: openCodeAdapter,\n\t\tGit:      gitAdapter,\n\t\tLogger:   runnerLogger{},\n\t}\n\n\tresolvedConfigRoot := *configRoot\n\tresolvedConfigDir := *configDir\n\tif resolvedConfigRoot == \"\" {\n\t\thomeDir := os.Getenv(\"HOME\")\n\t\tif homeDir != \"\" {\n\t\t\tresolvedConfigRoot = filepath.Join(homeDir, \".config\", \"opencode-runner\")\n\t\t}\n\t}\n\tif resolvedConfigDir == \"\" && resolvedConfigRoot != \"\" {\n\t\tresolvedConfigDir = filepath.Join(resolvedConfigRoot, \"opencode\")\n\t}\n\n\toptions := runner.RunOnceOptions{\n\t\tRepoRoot:   *repoRoot,\n\t\tRootID:     *rootID,\n\t\tModel:      *model,\n\t\tConfigRoot: resolvedConfigRoot,\n\t\tConfigDir:  resolvedConfigDir,\n\t\tDryRun:     *dryRun,\n\t\tOut:        stdout,\n\t}\n\n\tif stdout == nil {\n\t\toptions.Out = io.Discard\n\t}\n\tif stderr == nil {\n\t\tstderr = io.Discard\n\t}\n\n\tvar program tuiProgram\n\tif !*headless && isTerminal(stdout) {\n\t\tprogram = newTUIProgram(stdout)\n\t\tdeps.Events = tuiEmitter{program: program}\n\t}\n\n\t_, err := runOnce(options, deps)\n\tif program != nil {\n\t\tprogram.Quit()\n\t}\n\tif err != nil {\n\t\tfmt.Fprintln(stderr, err)\n\t\tif exit != nil {\n\t\t\texit(1)\n\t\t}\n\t\treturn 1\n\t}\n\n\tif exit != nil {\n\t\texit(0)\n\t}\n\treturn 0\n}\n"},"output":"Edit applied successfully.\n\nLSP errors detected in this file, please fix:\n<diagnostics file=\"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main.go\">\nERROR [4:2] \"context\" imported and not used\nERROR [16:2] \"yolo-runner/internal/ui/tui\" imported and not used\nERROR [19:2] \"github.com/charmbracelet/bubbletea\" imported as tea and not used\nERROR [20:2] \"golang.org/x/term\" imported and not used\nERROR [149:19] undefined: isTerminal\nERROR [150:13] undefined: newTUIProgram\n</diagnostics>","title":"cmd/yolo-runner/main.go","metadata":{"diagnostics":{"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main.go":[{"range":{"start":{"line":3,"character":1},"end":{"line":3,"character":10}},"severity":1,"code":"UnusedImport","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UnusedImport"},"source":"compiler","message":"\"context\" imported and not used","tags":[1]},{"range":{"start":{"line":15,"character":1},"end":{"line":15,"character":30}},"severity":1,"code":"UnusedImport","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UnusedImport"},"source":"compiler","message":"\"yolo-runner/internal/ui/tui\" imported and not used","tags":[1]},{"range":{"start":{"line":18,"character":1},"end":{"line":18,"character":4}},"severity":1,"code":"UnusedImport","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UnusedImport"},"source":"compiler","message":"\"github.com/charmbracelet/bubbletea\" imported as tea and not used","tags":[1]},{"range":{"start":{"line":19,"character":1},"end":{"line":19,"character":20}},"severity":1,"code":"UnusedImport","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UnusedImport"},"source":"compiler","message":"\"golang.org/x/term\" imported and not used","tags":[1]},{"range":{"start":{"line":148,"character":18},"end":{"line":148,"character":28}},"severity":1,"code":"UndeclaredName","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UndeclaredName"},"source":"compiler","message":"undefined: isTerminal"},{"range":{"start":{"line":149,"character":12},"end":{"line":149,"character":25}},"severity":1,"code":"UndeclaredName","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UndeclaredName"},"source":"compiler","message":"undefined: newTUIProgram"}],"/Users/egv/dev/yolo-runner/go.mod":[{"range":{"start":{"line":6,"character":44},"end":{"line":6,"character":55}},"severity":2,"source":"go mod tidy","message":"github.com/charmbracelet/bubbletea should be direct"},{"range":{"start":{"line":19,"character":26},"end":{"line":19,"character":37}},"severity":2,"source":"go mod tidy","message":"golang.org/x/term should be direct"}],"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go":[{"range":{"start":{"line":213,"character":19},"end":{"line":213,"character":29}},"severity":1,"code":"UndeclaredName","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UndeclaredName"},"source":"compiler","message":"undefined: isTerminal"},{"range":{"start":{"line":214,"character":22},"end":{"line":214,"character":35}},"severity":1,"code":"UndeclaredName","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UndeclaredName"},"source":"compiler","message":"undefined: newTUIProgram"},{"range":{"start":{"line":215,"character":1},"end":{"line":215,"character":11}},"severity":1,"code":"UndeclaredName","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UndeclaredName"},"source":"compiler","message":"undefined: isTerminal"},{"range":{"start":{"line":216,"character":1},"end":{"line":216,"character":14}},"severity":1,"code":"UndeclaredName","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UndeclaredName"},"source":"compiler","message":"undefined: newTUIProgram"},{"range":{"start":{"line":218,"character":2},"end":{"line":218,"character":12}},"severity":1,"code":"UndeclaredName","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UndeclaredName"},"source":"compiler","message":"undefined: isTerminal"},{"range":{"start":{"line":219,"character":2},"end":{"line":219,"character":15}},"severity":1,"code":"UndeclaredName","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UndeclaredName"},"source":"compiler","message":"undefined: newTUIProgram"},{"range":{"start":{"line":246,"character":19},"end":{"line":246,"character":29}},"severity":1,"code":"UndeclaredName","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UndeclaredName"},"source":"compiler","message":"undefined: isTerminal"},{"range":{"start":{"line":247,"character":22},"end":{"line":247,"character":35}},"severity":1,"code":"UndeclaredName","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UndeclaredName"},"source":"compiler","message":"undefined: newTUIProgram"},{"range":{"start":{"line":248,"character":1},"end":{"line":248,"character":11}},"severity":1,"code":"UndeclaredName","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UndeclaredName"},"source":"compiler","message":"undefined: isTerminal"},{"range":{"start":{"line":249,"character":1},"end":{"line":249,"character":14}},"severity":1,"code":"UndeclaredName","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UndeclaredName"},"source":"compiler","message":"undefined: newTUIProgram"},{"range":{"start":{"line":254,"character":2},"end":{"line":254,"character":12}},"severity":1,"code":"UndeclaredName","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UndeclaredName"},"source":"compiler","message":"undefined: isTerminal"},{"range":{"start":{"line":255,"character":2},"end":{"line":255,"character":15}},"severity":1,"code":"UndeclaredName","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UndeclaredName"},"source":"compiler","message":"undefined: newTUIProgram"}],"/Users/egv/dev/yolo-runner/bubbletea_test.go":[],"/Users/egv/dev/yolo-runner/opencode_adapter_v1.go":[{"range":{"start":{"line":24,"character":1},"end":{"line":24,"character":18}},"severity":2,"code":"default","codeDescription":{"href":"https://staticcheck.dev/docs/checks/#S1031"},"source":"S1031","message":"unnecessary nil check around range"}],"/Users/egv/dev/yolo-runner/internal/ui/tui/model.go":[],"/Users/egv/dev/yolo-runner/internal/runner/runner.go":[],"/Users/egv/dev/yolo-runner/internal/ui/tui/model_test.go":[],"/Users/egv/dev/yolo-runner/internal/runner/events.go":[],"/Users/egv/dev/yolo-runner/internal/runner/loop_test.go":[],"/Users/egv/dev/yolo-runner/internal/runner/runner_test.go":[],"/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/tea.go":[],"/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/tty_unix.go":[],"/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/tty.go":[],"/Users/egv/dev/yolo-runner/internal/opencode/watchdog.go":[],"/Users/egv/dev/yolo-runner/internal/opencode/client.go":[{"range":{"start":{"line":28,"character":1},"end":{"line":28,"character":18}},"severity":2,"code":"default","codeDescription":{"href":"https://staticcheck.dev/docs/checks/#S1031"},"source":"S1031","message":"unnecessary nil check around range"}],"/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/options.go":[],"/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/tty_windows.go":[{"range":{"start":{"line":3,"character":8},"end":{"line":3,"character":11}},"severity":2,"source":"go list","message":"This file is within module \"../../go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0\", which is not included in your workspace.\nTo fix this problem, you can add a go.work file that uses this directory.\nSee the documentation for more information on setting up your workspace:\nhttps://github.com/golang/tools/blob/master/gopls/doc/workspace.md.","data":{"Actions":[{"title":"Add a go.work file using this module","kind":"quickfix","command":{"title":"Run `go work init && go work use`","command":"gopls.run_go_work_command","arguments":[{"ViewID":"1","InitFirst":true,"Args":["use","../../go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0"]}]}}]}}]},"diff":"Index: /Users/egv/dev/yolo-runner/cmd/yolo-runner/main.go\n===================================================================\n--- /Users/egv/dev/yolo-runner/cmd/yolo-runner/main.go\n+++ /Users/egv/dev/yolo-runner/cmd/yolo-runner/main.go\n@@ -144,9 +144,18 @@\n if stderr == nil {\n \tstderr = io.Discard\n }\n \n+var program tuiProgram\n+if !*headless && isTerminal(stdout) {\n+\tprogram = newTUIProgram(stdout)\n+\tdeps.Events = tuiEmitter{program: program}\n+}\n+\n _, err := runOnce(options, deps)\n+if program != nil {\n+\tprogram.Quit()\n+}\n if err != nil {\n \tfmt.Fprintln(stderr, err)\n \tif exit != nil {\n \t\texit(1)\n","filediff":{"file":"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main.go","before":"package main\n\nimport (\n\t\"context\"\n\t\"flag\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n\n\t\"yolo-runner/internal/beads\"\n\t\"yolo-runner/internal/logging\"\n\t\"yolo-runner/internal/opencode\"\n\t\"yolo-runner/internal/prompt\"\n\t\"yolo-runner/internal/runner\"\n\t\"yolo-runner/internal/ui/tui\"\n\tgitadapter \"yolo-runner/internal/vcs/git\"\n\n\ttea \"github.com/charmbracelet/bubbletea\"\n\t\"golang.org/x/term\"\n)\n\ntype runOnceFunc func(opts runner.RunOnceOptions, deps runner.RunOnceDeps) (string, error)\n\ntype exitFunc func(code int)\n\ntype beadsRunner interface {\n\tRun(args ...string) (string, error)\n}\n\ntype gitRunner interface {\n\tRun(name string, args ...string) (string, error)\n}\n\ntype openCodeRunner interface {\n\tStart(args []string, env map[string]string, stdoutPath string) (opencode.Process, error)\n}\n\ntype tuiProgram interface {\n\tStart() error\n\tSend(event runner.Event)\n\tQuit()\n}\n\ntype tuiEmitter struct {\n\tprogram tuiProgram\n}\n\nfunc (t tuiEmitter) Emit(event runner.Event) {\n\tif t.program == nil {\n\t\treturn\n\t}\n\tt.program.Send(event)\n}\n\ntype adapterRunner struct{}\n\nfunc (adapterRunner) Run(args ...string) (string, error) {\n\treturn runCommand(args...)\n}\n\ntype adapterGitRunner struct{}\n\nfunc (adapterGitRunner) Run(name string, args ...string) (string, error) {\n\treturn runCommand(append([]string{name}, args...)...)\n}\n\ntype openCodeAdapter struct {\n\trunner openCodeRunner\n}\n\nfunc (o openCodeAdapter) Run(issueID string, repoRoot string, promptText string, model string, configRoot string, configDir string, logPath string) error {\n\treturn opencode.Run(issueID, repoRoot, promptText, model, configRoot, configDir, logPath, o.runner)\n}\n\nfunc RunOnceMain(args []string, runOnce runOnceFunc, exit exitFunc, stdout io.Writer, stderr io.Writer, beadsRunner beadsRunner, gitRunner gitRunner) int {\n\tfs := flag.NewFlagSet(\"yolo-runner\", flag.ContinueOnError)\n\tfs.SetOutput(stderr)\n\n\trepoRoot := fs.String(\"repo\", \".\", \"Repository root path\")\n\trootID := fs.String(\"root\", \"algi-8bt\", \"Root bead/epic ID\")\n\tmodel := fs.String(\"model\", \"\", \"OpenCode model\")\n\tdryRun := fs.Bool(\"dry-run\", false, \"Print task and prompt without executing\")\n\theadless := fs.Bool(\"headless\", false, \"Force plain output without TUI\")\n\tconfigRoot := fs.String(\"config-root\", \"\", \"OpenCode config root\")\n\tconfigDir := fs.String(\"config-dir\", \"\", \"OpenCode config dir\")\n\n\tif err := fs.Parse(args); err != nil {\n\t\tfmt.Fprintln(stderr, err)\n\t\tif exit != nil {\n\t\t\texit(1)\n\t\t}\n\t\treturn 1\n\t}\n\n\tif runOnce == nil {\n\t\trunOnce = runner.RunOnce\n\t}\n\n\tif beadsRunner == nil {\n\t\tbeadsRunner = adapterRunner{}\n\t}\n\tif gitRunner == nil {\n\t\tgitRunner = adapterGitRunner{}\n\t}\n\n\tbeadsAdapter := beads.New(beadsRunner)\n\tgitAdapter := gitadapter.New(gitRunner)\n\topenCodeAdapter := openCodeAdapter{runner: defaultOpenCodeRunner{}}\n\n\tdeps := runner.RunOnceDeps{\n\t\tBeads:    beadsAdapter,\n\t\tPrompt:   promptBuilder{},\n\t\tOpenCode: openCodeAdapter,\n\t\tGit:      gitAdapter,\n\t\tLogger:   runnerLogger{},\n\t}\n\n\tresolvedConfigRoot := *configRoot\n\tresolvedConfigDir := *configDir\n\tif resolvedConfigRoot == \"\" {\n\t\thomeDir := os.Getenv(\"HOME\")\n\t\tif homeDir != \"\" {\n\t\t\tresolvedConfigRoot = filepath.Join(homeDir, \".config\", \"opencode-runner\")\n\t\t}\n\t}\n\tif resolvedConfigDir == \"\" && resolvedConfigRoot != \"\" {\n\t\tresolvedConfigDir = filepath.Join(resolvedConfigRoot, \"opencode\")\n\t}\n\n\toptions := runner.RunOnceOptions{\n\t\tRepoRoot:   *repoRoot,\n\t\tRootID:     *rootID,\n\t\tModel:      *model,\n\t\tConfigRoot: resolvedConfigRoot,\n\t\tConfigDir:  resolvedConfigDir,\n\t\tDryRun:     *dryRun,\n\t\tOut:        stdout,\n\t}\n\n\tif stdout == nil {\n\t\toptions.Out = io.Discard\n\t}\n\tif stderr == nil {\n\t\tstderr = io.Discard\n\t}\n\n\t_, err := runOnce(options, deps)\n\tif err != nil {\n\t\tfmt.Fprintln(stderr, err)\n\t\tif exit != nil {\n\t\t\texit(1)\n\t\t}\n\t\treturn 1\n\t}\n\n\tif exit != nil {\n\t\texit(0)\n\t}\n\treturn 0\n}\n\nfunc main() {\n\tRunOnceMain(os.Args[1:], runner.RunOnce, os.Exit, os.Stdout, os.Stderr, nil, nil)\n}\n\ntype promptBuilder struct{}\n\nfunc (promptBuilder) Build(issueID string, title string, description string, acceptance string) string {\n\treturn prompt.Build(issueID, title, description, acceptance)\n}\n\ntype runnerLogger struct{}\n\nfunc (runnerLogger) AppendRunnerSummary(repoRoot string, issueID string, title string, status string, commitSHA string) error {\n\treturn logging.AppendRunnerSummary(repoRoot, issueID, title, status, commitSHA)\n}\n\ntype defaultOpenCodeRunner struct{}\n\nfunc (defaultOpenCodeRunner) Start(args []string, env map[string]string, stdoutPath string) (opencode.Process, error) {\n\treturn startCommandWithEnv(args, env, stdoutPath)\n}\n","after":"package main\n\nimport (\n\t\"context\"\n\t\"flag\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n\n\t\"yolo-runner/internal/beads\"\n\t\"yolo-runner/internal/logging\"\n\t\"yolo-runner/internal/opencode\"\n\t\"yolo-runner/internal/prompt\"\n\t\"yolo-runner/internal/runner\"\n\t\"yolo-runner/internal/ui/tui\"\n\tgitadapter \"yolo-runner/internal/vcs/git\"\n\n\ttea \"github.com/charmbracelet/bubbletea\"\n\t\"golang.org/x/term\"\n)\n\ntype runOnceFunc func(opts runner.RunOnceOptions, deps runner.RunOnceDeps) (string, error)\n\ntype exitFunc func(code int)\n\ntype beadsRunner interface {\n\tRun(args ...string) (string, error)\n}\n\ntype gitRunner interface {\n\tRun(name string, args ...string) (string, error)\n}\n\ntype openCodeRunner interface {\n\tStart(args []string, env map[string]string, stdoutPath string) (opencode.Process, error)\n}\n\ntype tuiProgram interface {\n\tStart() error\n\tSend(event runner.Event)\n\tQuit()\n}\n\ntype tuiEmitter struct {\n\tprogram tuiProgram\n}\n\nfunc (t tuiEmitter) Emit(event runner.Event) {\n\tif t.program == nil {\n\t\treturn\n\t}\n\tt.program.Send(event)\n}\n\ntype adapterRunner struct{}\n\nfunc (adapterRunner) Run(args ...string) (string, error) {\n\treturn runCommand(args...)\n}\n\ntype adapterGitRunner struct{}\n\nfunc (adapterGitRunner) Run(name string, args ...string) (string, error) {\n\treturn runCommand(append([]string{name}, args...)...)\n}\n\ntype openCodeAdapter struct {\n\trunner openCodeRunner\n}\n\nfunc (o openCodeAdapter) Run(issueID string, repoRoot string, promptText string, model string, configRoot string, configDir string, logPath string) error {\n\treturn opencode.Run(issueID, repoRoot, promptText, model, configRoot, configDir, logPath, o.runner)\n}\n\nfunc RunOnceMain(args []string, runOnce runOnceFunc, exit exitFunc, stdout io.Writer, stderr io.Writer, beadsRunner beadsRunner, gitRunner gitRunner) int {\n\tfs := flag.NewFlagSet(\"yolo-runner\", flag.ContinueOnError)\n\tfs.SetOutput(stderr)\n\n\trepoRoot := fs.String(\"repo\", \".\", \"Repository root path\")\n\trootID := fs.String(\"root\", \"algi-8bt\", \"Root bead/epic ID\")\n\tmodel := fs.String(\"model\", \"\", \"OpenCode model\")\n\tdryRun := fs.Bool(\"dry-run\", false, \"Print task and prompt without executing\")\n\theadless := fs.Bool(\"headless\", false, \"Force plain output without TUI\")\n\tconfigRoot := fs.String(\"config-root\", \"\", \"OpenCode config root\")\n\tconfigDir := fs.String(\"config-dir\", \"\", \"OpenCode config dir\")\n\n\tif err := fs.Parse(args); err != nil {\n\t\tfmt.Fprintln(stderr, err)\n\t\tif exit != nil {\n\t\t\texit(1)\n\t\t}\n\t\treturn 1\n\t}\n\n\tif runOnce == nil {\n\t\trunOnce = runner.RunOnce\n\t}\n\n\tif beadsRunner == nil {\n\t\tbeadsRunner = adapterRunner{}\n\t}\n\tif gitRunner == nil {\n\t\tgitRunner = adapterGitRunner{}\n\t}\n\n\tbeadsAdapter := beads.New(beadsRunner)\n\tgitAdapter := gitadapter.New(gitRunner)\n\topenCodeAdapter := openCodeAdapter{runner: defaultOpenCodeRunner{}}\n\n\tdeps := runner.RunOnceDeps{\n\t\tBeads:    beadsAdapter,\n\t\tPrompt:   promptBuilder{},\n\t\tOpenCode: openCodeAdapter,\n\t\tGit:      gitAdapter,\n\t\tLogger:   runnerLogger{},\n\t}\n\n\tresolvedConfigRoot := *configRoot\n\tresolvedConfigDir := *configDir\n\tif resolvedConfigRoot == \"\" {\n\t\thomeDir := os.Getenv(\"HOME\")\n\t\tif homeDir != \"\" {\n\t\t\tresolvedConfigRoot = filepath.Join(homeDir, \".config\", \"opencode-runner\")\n\t\t}\n\t}\n\tif resolvedConfigDir == \"\" && resolvedConfigRoot != \"\" {\n\t\tresolvedConfigDir = filepath.Join(resolvedConfigRoot, \"opencode\")\n\t}\n\n\toptions := runner.RunOnceOptions{\n\t\tRepoRoot:   *repoRoot,\n\t\tRootID:     *rootID,\n\t\tModel:      *model,\n\t\tConfigRoot: resolvedConfigRoot,\n\t\tConfigDir:  resolvedConfigDir,\n\t\tDryRun:     *dryRun,\n\t\tOut:        stdout,\n\t}\n\n\tif stdout == nil {\n\t\toptions.Out = io.Discard\n\t}\n\tif stderr == nil {\n\t\tstderr = io.Discard\n\t}\n\n\tvar program tuiProgram\n\tif !*headless && isTerminal(stdout) {\n\t\tprogram = newTUIProgram(stdout)\n\t\tdeps.Events = tuiEmitter{program: program}\n\t}\n\n\t_, err := runOnce(options, deps)\n\tif program != nil {\n\t\tprogram.Quit()\n\t}\n\tif err != nil {\n\t\tfmt.Fprintln(stderr, err)\n\t\tif exit != nil {\n\t\t\texit(1)\n\t\t}\n\t\treturn 1\n\t}\n\n\tif exit != nil {\n\t\texit(0)\n\t}\n\treturn 0\n}\n\nfunc main() {\n\tRunOnceMain(os.Args[1:], runner.RunOnce, os.Exit, os.Stdout, os.Stderr, nil, nil)\n}\n\ntype promptBuilder struct{}\n\nfunc (promptBuilder) Build(issueID string, title string, description string, acceptance string) string {\n\treturn prompt.Build(issueID, title, description, acceptance)\n}\n\ntype runnerLogger struct{}\n\nfunc (runnerLogger) AppendRunnerSummary(repoRoot string, issueID string, title string, status string, commitSHA string) error {\n\treturn logging.AppendRunnerSummary(repoRoot, issueID, title, status, commitSHA)\n}\n\ntype defaultOpenCodeRunner struct{}\n\nfunc (defaultOpenCodeRunner) Start(args []string, env map[string]string, stdoutPath string) (opencode.Process, error) {\n\treturn startCommandWithEnv(args, env, stdoutPath)\n}\n","additions":9,"deletions":0},"truncated":false},"time":{"start":1768840749842,"end":1768840750002}},"metadata":{"openai":{"itemId":"fc_08a95b41bf4f778201696e5e136ff88191b8aed7808463e667"}}}}
{"type":"step_finish","timestamp":1768840750022,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd71fe3b3001CWGpWW0AhSRXZg","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd71f77ec001NJEQMVt7FTFwfX","type":"step-finish","reason":"tool-calls","snapshot":"65ad452b0f5f3bc423005b1ac550a9b601d9666a","cost":0,"tokens":{"input":981,"output":1643,"reasoning":0,"cache":{"read":46720,"write":0}}}}
{"type":"step_start","timestamp":1768840750422,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd71fe555001ddHsr0ZR3iawnc","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd71fe3e9001FQPrVqwl9KVyPP","type":"step-start","snapshot":"88429cdf48acfe3ecb6bb42147bcdab3f35e4fb2"}}
{"type":"step_finish","timestamp":1768840756676,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd71ffdb4001idAwk1085iFT4Z","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd71fe3e9001FQPrVqwl9KVyPP","type":"step-finish","reason":"tool-calls","snapshot":"ade752a014cb0cbbbf1123fea210496ef6c6b6af","cost":0,"tokens":{"input":2775,"output":331,"reasoning":0,"cache":{"read":46720,"write":0}}}}
{"type":"step_start","timestamp":1768840757144,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd71fff970016ikJMszSgUoGEa","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd71ffde8001Zs4GgNRcrWFE9i","type":"step-start","snapshot":"8bf7e66b3f57f022488aaa8782da2847a6b145e0"}}
{"type":"tool_use","timestamp":1768840763199,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd720019b001rMT1mbugJwjMZf","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd71ffde8001Zs4GgNRcrWFE9i","type":"tool","callID":"call_RYgKEcs9jXd62aG0q9J1pDLg","tool":"edit","state":{"status":"completed","input":{"filePath":"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main.go","oldString":"import (\n\t\"context\"\n\t\"flag\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n\n\t\"yolo-runner/internal/beads\"\n\t\"yolo-runner/internal/logging\"\n\t\"yolo-runner/internal/opencode\"\n\t\"yolo-runner/internal/prompt\"\n\t\"yolo-runner/internal/runner\"\n\t\"yolo-runner/internal/ui/tui\"\n\tgitadapter \"yolo-runner/internal/vcs/git\"\n\n\ttea \"github.com/charmbracelet/bubbletea\"\n\t\"golang.org/x/term\"\n)\n","newString":"import (\n\t\"flag\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n\n\t\"yolo-runner/internal/beads\"\n\t\"yolo-runner/internal/logging\"\n\t\"yolo-runner/internal/opencode\"\n\t\"yolo-runner/internal/prompt\"\n\t\"yolo-runner/internal/runner\"\n\t\"yolo-runner/internal/ui/tui\"\n\tgitadapter \"yolo-runner/internal/vcs/git\"\n\n\ttea \"github.com/charmbracelet/bubbletea\"\n\t\"golang.org/x/term\"\n)\n"},"output":"Edit applied successfully.\n\nLSP errors detected in this file, please fix:\n<diagnostics file=\"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main.go\">\nERROR [15:2] \"yolo-runner/internal/ui/tui\" imported and not used\nERROR [18:2] \"github.com/charmbracelet/bubbletea\" imported as tea and not used\nERROR [19:2] \"golang.org/x/term\" imported and not used\nERROR [148:19] undefined: isTerminal\nERROR [149:13] undefined: newTUIProgram\n</diagnostics>","title":"cmd/yolo-runner/main.go","metadata":{"diagnostics":{"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main.go":[{"range":{"start":{"line":14,"character":1},"end":{"line":14,"character":30}},"severity":1,"code":"UnusedImport","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UnusedImport"},"source":"compiler","message":"\"yolo-runner/internal/ui/tui\" imported and not used","tags":[1]},{"range":{"start":{"line":17,"character":1},"end":{"line":17,"character":4}},"severity":1,"code":"UnusedImport","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UnusedImport"},"source":"compiler","message":"\"github.com/charmbracelet/bubbletea\" imported as tea and not used","tags":[1]},{"range":{"start":{"line":18,"character":1},"end":{"line":18,"character":20}},"severity":1,"code":"UnusedImport","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UnusedImport"},"source":"compiler","message":"\"golang.org/x/term\" imported and not used","tags":[1]},{"range":{"start":{"line":147,"character":18},"end":{"line":147,"character":28}},"severity":1,"code":"UndeclaredName","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UndeclaredName"},"source":"compiler","message":"undefined: isTerminal"},{"range":{"start":{"line":148,"character":12},"end":{"line":148,"character":25}},"severity":1,"code":"UndeclaredName","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UndeclaredName"},"source":"compiler","message":"undefined: newTUIProgram"}],"/Users/egv/dev/yolo-runner/go.mod":[{"range":{"start":{"line":6,"character":44},"end":{"line":6,"character":55}},"severity":2,"source":"go mod tidy","message":"github.com/charmbracelet/bubbletea should be direct"},{"range":{"start":{"line":19,"character":26},"end":{"line":19,"character":37}},"severity":2,"source":"go mod tidy","message":"golang.org/x/term should be direct"}],"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go":[{"range":{"start":{"line":213,"character":19},"end":{"line":213,"character":29}},"severity":1,"code":"UndeclaredName","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UndeclaredName"},"source":"compiler","message":"undefined: isTerminal"},{"range":{"start":{"line":214,"character":22},"end":{"line":214,"character":35}},"severity":1,"code":"UndeclaredName","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UndeclaredName"},"source":"compiler","message":"undefined: newTUIProgram"},{"range":{"start":{"line":215,"character":1},"end":{"line":215,"character":11}},"severity":1,"code":"UndeclaredName","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UndeclaredName"},"source":"compiler","message":"undefined: isTerminal"},{"range":{"start":{"line":216,"character":1},"end":{"line":216,"character":14}},"severity":1,"code":"UndeclaredName","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UndeclaredName"},"source":"compiler","message":"undefined: newTUIProgram"},{"range":{"start":{"line":218,"character":2},"end":{"line":218,"character":12}},"severity":1,"code":"UndeclaredName","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UndeclaredName"},"source":"compiler","message":"undefined: isTerminal"},{"range":{"start":{"line":219,"character":2},"end":{"line":219,"character":15}},"severity":1,"code":"UndeclaredName","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UndeclaredName"},"source":"compiler","message":"undefined: newTUIProgram"},{"range":{"start":{"line":246,"character":19},"end":{"line":246,"character":29}},"severity":1,"code":"UndeclaredName","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UndeclaredName"},"source":"compiler","message":"undefined: isTerminal"},{"range":{"start":{"line":247,"character":22},"end":{"line":247,"character":35}},"severity":1,"code":"UndeclaredName","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UndeclaredName"},"source":"compiler","message":"undefined: newTUIProgram"},{"range":{"start":{"line":248,"character":1},"end":{"line":248,"character":11}},"severity":1,"code":"UndeclaredName","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UndeclaredName"},"source":"compiler","message":"undefined: isTerminal"},{"range":{"start":{"line":249,"character":1},"end":{"line":249,"character":14}},"severity":1,"code":"UndeclaredName","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UndeclaredName"},"source":"compiler","message":"undefined: newTUIProgram"},{"range":{"start":{"line":254,"character":2},"end":{"line":254,"character":12}},"severity":1,"code":"UndeclaredName","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UndeclaredName"},"source":"compiler","message":"undefined: isTerminal"},{"range":{"start":{"line":255,"character":2},"end":{"line":255,"character":15}},"severity":1,"code":"UndeclaredName","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UndeclaredName"},"source":"compiler","message":"undefined: newTUIProgram"}],"/Users/egv/dev/yolo-runner/bubbletea_test.go":[],"/Users/egv/dev/yolo-runner/opencode_adapter_v1.go":[{"range":{"start":{"line":24,"character":1},"end":{"line":24,"character":18}},"severity":2,"code":"default","codeDescription":{"href":"https://staticcheck.dev/docs/checks/#S1031"},"source":"S1031","message":"unnecessary nil check around range"}],"/Users/egv/dev/yolo-runner/internal/ui/tui/model.go":[],"/Users/egv/dev/yolo-runner/internal/runner/runner.go":[],"/Users/egv/dev/yolo-runner/internal/ui/tui/model_test.go":[],"/Users/egv/dev/yolo-runner/internal/runner/events.go":[],"/Users/egv/dev/yolo-runner/internal/runner/loop_test.go":[],"/Users/egv/dev/yolo-runner/internal/runner/runner_test.go":[],"/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/tea.go":[],"/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/tty_unix.go":[],"/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/tty.go":[],"/Users/egv/dev/yolo-runner/internal/opencode/watchdog.go":[],"/Users/egv/dev/yolo-runner/internal/opencode/client.go":[{"range":{"start":{"line":28,"character":1},"end":{"line":28,"character":18}},"severity":2,"code":"default","codeDescription":{"href":"https://staticcheck.dev/docs/checks/#S1031"},"source":"S1031","message":"unnecessary nil check around range"}],"/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/options.go":[],"/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/tty_windows.go":[{"range":{"start":{"line":3,"character":8},"end":{"line":3,"character":11}},"severity":2,"source":"go list","message":"This file is within module \"../../go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0\", which is not included in your workspace.\nTo fix this problem, you can add a go.work file that uses this directory.\nSee the documentation for more information on setting up your workspace:\nhttps://github.com/golang/tools/blob/master/gopls/doc/workspace.md.","data":{"Actions":[{"title":"Add a go.work file using this module","kind":"quickfix","command":{"title":"Run `go work init && go work use`","command":"gopls.run_go_work_command","arguments":[{"ViewID":"1","InitFirst":true,"Args":["use","../../go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0"]}]}}]}}]},"diff":"Index: /Users/egv/dev/yolo-runner/cmd/yolo-runner/main.go\n===================================================================\n--- /Users/egv/dev/yolo-runner/cmd/yolo-runner/main.go\n+++ /Users/egv/dev/yolo-runner/cmd/yolo-runner/main.go\n@@ -1,8 +1,7 @@\n package main\n \n import (\n-\t\"context\"\n \t\"flag\"\n \t\"fmt\"\n \t\"io\"\n \t\"os\"\n","filediff":{"file":"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main.go","before":"package main\n\nimport (\n\t\"context\"\n\t\"flag\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n\n\t\"yolo-runner/internal/beads\"\n\t\"yolo-runner/internal/logging\"\n\t\"yolo-runner/internal/opencode\"\n\t\"yolo-runner/internal/prompt\"\n\t\"yolo-runner/internal/runner\"\n\t\"yolo-runner/internal/ui/tui\"\n\tgitadapter \"yolo-runner/internal/vcs/git\"\n\n\ttea \"github.com/charmbracelet/bubbletea\"\n\t\"golang.org/x/term\"\n)\n\ntype runOnceFunc func(opts runner.RunOnceOptions, deps runner.RunOnceDeps) (string, error)\n\ntype exitFunc func(code int)\n\ntype beadsRunner interface {\n\tRun(args ...string) (string, error)\n}\n\ntype gitRunner interface {\n\tRun(name string, args ...string) (string, error)\n}\n\ntype openCodeRunner interface {\n\tStart(args []string, env map[string]string, stdoutPath string) (opencode.Process, error)\n}\n\ntype tuiProgram interface {\n\tStart() error\n\tSend(event runner.Event)\n\tQuit()\n}\n\ntype tuiEmitter struct {\n\tprogram tuiProgram\n}\n\nfunc (t tuiEmitter) Emit(event runner.Event) {\n\tif t.program == nil {\n\t\treturn\n\t}\n\tt.program.Send(event)\n}\n\ntype adapterRunner struct{}\n\nfunc (adapterRunner) Run(args ...string) (string, error) {\n\treturn runCommand(args...)\n}\n\ntype adapterGitRunner struct{}\n\nfunc (adapterGitRunner) Run(name string, args ...string) (string, error) {\n\treturn runCommand(append([]string{name}, args...)...)\n}\n\ntype openCodeAdapter struct {\n\trunner openCodeRunner\n}\n\nfunc (o openCodeAdapter) Run(issueID string, repoRoot string, promptText string, model string, configRoot string, configDir string, logPath string) error {\n\treturn opencode.Run(issueID, repoRoot, promptText, model, configRoot, configDir, logPath, o.runner)\n}\n\nfunc RunOnceMain(args []string, runOnce runOnceFunc, exit exitFunc, stdout io.Writer, stderr io.Writer, beadsRunner beadsRunner, gitRunner gitRunner) int {\n\tfs := flag.NewFlagSet(\"yolo-runner\", flag.ContinueOnError)\n\tfs.SetOutput(stderr)\n\n\trepoRoot := fs.String(\"repo\", \".\", \"Repository root path\")\n\trootID := fs.String(\"root\", \"algi-8bt\", \"Root bead/epic ID\")\n\tmodel := fs.String(\"model\", \"\", \"OpenCode model\")\n\tdryRun := fs.Bool(\"dry-run\", false, \"Print task and prompt without executing\")\n\theadless := fs.Bool(\"headless\", false, \"Force plain output without TUI\")\n\tconfigRoot := fs.String(\"config-root\", \"\", \"OpenCode config root\")\n\tconfigDir := fs.String(\"config-dir\", \"\", \"OpenCode config dir\")\n\n\tif err := fs.Parse(args); err != nil {\n\t\tfmt.Fprintln(stderr, err)\n\t\tif exit != nil {\n\t\t\texit(1)\n\t\t}\n\t\treturn 1\n\t}\n\n\tif runOnce == nil {\n\t\trunOnce = runner.RunOnce\n\t}\n\n\tif beadsRunner == nil {\n\t\tbeadsRunner = adapterRunner{}\n\t}\n\tif gitRunner == nil {\n\t\tgitRunner = adapterGitRunner{}\n\t}\n\n\tbeadsAdapter := beads.New(beadsRunner)\n\tgitAdapter := gitadapter.New(gitRunner)\n\topenCodeAdapter := openCodeAdapter{runner: defaultOpenCodeRunner{}}\n\n\tdeps := runner.RunOnceDeps{\n\t\tBeads:    beadsAdapter,\n\t\tPrompt:   promptBuilder{},\n\t\tOpenCode: openCodeAdapter,\n\t\tGit:      gitAdapter,\n\t\tLogger:   runnerLogger{},\n\t}\n\n\tresolvedConfigRoot := *configRoot\n\tresolvedConfigDir := *configDir\n\tif resolvedConfigRoot == \"\" {\n\t\thomeDir := os.Getenv(\"HOME\")\n\t\tif homeDir != \"\" {\n\t\t\tresolvedConfigRoot = filepath.Join(homeDir, \".config\", \"opencode-runner\")\n\t\t}\n\t}\n\tif resolvedConfigDir == \"\" && resolvedConfigRoot != \"\" {\n\t\tresolvedConfigDir = filepath.Join(resolvedConfigRoot, \"opencode\")\n\t}\n\n\toptions := runner.RunOnceOptions{\n\t\tRepoRoot:   *repoRoot,\n\t\tRootID:     *rootID,\n\t\tModel:      *model,\n\t\tConfigRoot: resolvedConfigRoot,\n\t\tConfigDir:  resolvedConfigDir,\n\t\tDryRun:     *dryRun,\n\t\tOut:        stdout,\n\t}\n\n\tif stdout == nil {\n\t\toptions.Out = io.Discard\n\t}\n\tif stderr == nil {\n\t\tstderr = io.Discard\n\t}\n\n\tvar program tuiProgram\n\tif !*headless && isTerminal(stdout) {\n\t\tprogram = newTUIProgram(stdout)\n\t\tdeps.Events = tuiEmitter{program: program}\n\t}\n\n\t_, err := runOnce(options, deps)\n\tif program != nil {\n\t\tprogram.Quit()\n\t}\n\tif err != nil {\n\t\tfmt.Fprintln(stderr, err)\n\t\tif exit != nil {\n\t\t\texit(1)\n\t\t}\n\t\treturn 1\n\t}\n\n\tif exit != nil {\n\t\texit(0)\n\t}\n\treturn 0\n}\n\nfunc main() {\n\tRunOnceMain(os.Args[1:], runner.RunOnce, os.Exit, os.Stdout, os.Stderr, nil, nil)\n}\n\ntype promptBuilder struct{}\n\nfunc (promptBuilder) Build(issueID string, title string, description string, acceptance string) string {\n\treturn prompt.Build(issueID, title, description, acceptance)\n}\n\ntype runnerLogger struct{}\n\nfunc (runnerLogger) AppendRunnerSummary(repoRoot string, issueID string, title string, status string, commitSHA string) error {\n\treturn logging.AppendRunnerSummary(repoRoot, issueID, title, status, commitSHA)\n}\n\ntype defaultOpenCodeRunner struct{}\n\nfunc (defaultOpenCodeRunner) Start(args []string, env map[string]string, stdoutPath string) (opencode.Process, error) {\n\treturn startCommandWithEnv(args, env, stdoutPath)\n}\n","after":"package main\n\nimport (\n\t\"flag\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n\n\t\"yolo-runner/internal/beads\"\n\t\"yolo-runner/internal/logging\"\n\t\"yolo-runner/internal/opencode\"\n\t\"yolo-runner/internal/prompt\"\n\t\"yolo-runner/internal/runner\"\n\t\"yolo-runner/internal/ui/tui\"\n\tgitadapter \"yolo-runner/internal/vcs/git\"\n\n\ttea \"github.com/charmbracelet/bubbletea\"\n\t\"golang.org/x/term\"\n)\n\ntype runOnceFunc func(opts runner.RunOnceOptions, deps runner.RunOnceDeps) (string, error)\n\ntype exitFunc func(code int)\n\ntype beadsRunner interface {\n\tRun(args ...string) (string, error)\n}\n\ntype gitRunner interface {\n\tRun(name string, args ...string) (string, error)\n}\n\ntype openCodeRunner interface {\n\tStart(args []string, env map[string]string, stdoutPath string) (opencode.Process, error)\n}\n\ntype tuiProgram interface {\n\tStart() error\n\tSend(event runner.Event)\n\tQuit()\n}\n\ntype tuiEmitter struct {\n\tprogram tuiProgram\n}\n\nfunc (t tuiEmitter) Emit(event runner.Event) {\n\tif t.program == nil {\n\t\treturn\n\t}\n\tt.program.Send(event)\n}\n\ntype adapterRunner struct{}\n\nfunc (adapterRunner) Run(args ...string) (string, error) {\n\treturn runCommand(args...)\n}\n\ntype adapterGitRunner struct{}\n\nfunc (adapterGitRunner) Run(name string, args ...string) (string, error) {\n\treturn runCommand(append([]string{name}, args...)...)\n}\n\ntype openCodeAdapter struct {\n\trunner openCodeRunner\n}\n\nfunc (o openCodeAdapter) Run(issueID string, repoRoot string, promptText string, model string, configRoot string, configDir string, logPath string) error {\n\treturn opencode.Run(issueID, repoRoot, promptText, model, configRoot, configDir, logPath, o.runner)\n}\n\nfunc RunOnceMain(args []string, runOnce runOnceFunc, exit exitFunc, stdout io.Writer, stderr io.Writer, beadsRunner beadsRunner, gitRunner gitRunner) int {\n\tfs := flag.NewFlagSet(\"yolo-runner\", flag.ContinueOnError)\n\tfs.SetOutput(stderr)\n\n\trepoRoot := fs.String(\"repo\", \".\", \"Repository root path\")\n\trootID := fs.String(\"root\", \"algi-8bt\", \"Root bead/epic ID\")\n\tmodel := fs.String(\"model\", \"\", \"OpenCode model\")\n\tdryRun := fs.Bool(\"dry-run\", false, \"Print task and prompt without executing\")\n\theadless := fs.Bool(\"headless\", false, \"Force plain output without TUI\")\n\tconfigRoot := fs.String(\"config-root\", \"\", \"OpenCode config root\")\n\tconfigDir := fs.String(\"config-dir\", \"\", \"OpenCode config dir\")\n\n\tif err := fs.Parse(args); err != nil {\n\t\tfmt.Fprintln(stderr, err)\n\t\tif exit != nil {\n\t\t\texit(1)\n\t\t}\n\t\treturn 1\n\t}\n\n\tif runOnce == nil {\n\t\trunOnce = runner.RunOnce\n\t}\n\n\tif beadsRunner == nil {\n\t\tbeadsRunner = adapterRunner{}\n\t}\n\tif gitRunner == nil {\n\t\tgitRunner = adapterGitRunner{}\n\t}\n\n\tbeadsAdapter := beads.New(beadsRunner)\n\tgitAdapter := gitadapter.New(gitRunner)\n\topenCodeAdapter := openCodeAdapter{runner: defaultOpenCodeRunner{}}\n\n\tdeps := runner.RunOnceDeps{\n\t\tBeads:    beadsAdapter,\n\t\tPrompt:   promptBuilder{},\n\t\tOpenCode: openCodeAdapter,\n\t\tGit:      gitAdapter,\n\t\tLogger:   runnerLogger{},\n\t}\n\n\tresolvedConfigRoot := *configRoot\n\tresolvedConfigDir := *configDir\n\tif resolvedConfigRoot == \"\" {\n\t\thomeDir := os.Getenv(\"HOME\")\n\t\tif homeDir != \"\" {\n\t\t\tresolvedConfigRoot = filepath.Join(homeDir, \".config\", \"opencode-runner\")\n\t\t}\n\t}\n\tif resolvedConfigDir == \"\" && resolvedConfigRoot != \"\" {\n\t\tresolvedConfigDir = filepath.Join(resolvedConfigRoot, \"opencode\")\n\t}\n\n\toptions := runner.RunOnceOptions{\n\t\tRepoRoot:   *repoRoot,\n\t\tRootID:     *rootID,\n\t\tModel:      *model,\n\t\tConfigRoot: resolvedConfigRoot,\n\t\tConfigDir:  resolvedConfigDir,\n\t\tDryRun:     *dryRun,\n\t\tOut:        stdout,\n\t}\n\n\tif stdout == nil {\n\t\toptions.Out = io.Discard\n\t}\n\tif stderr == nil {\n\t\tstderr = io.Discard\n\t}\n\n\tvar program tuiProgram\n\tif !*headless && isTerminal(stdout) {\n\t\tprogram = newTUIProgram(stdout)\n\t\tdeps.Events = tuiEmitter{program: program}\n\t}\n\n\t_, err := runOnce(options, deps)\n\tif program != nil {\n\t\tprogram.Quit()\n\t}\n\tif err != nil {\n\t\tfmt.Fprintln(stderr, err)\n\t\tif exit != nil {\n\t\t\texit(1)\n\t\t}\n\t\treturn 1\n\t}\n\n\tif exit != nil {\n\t\texit(0)\n\t}\n\treturn 0\n}\n\nfunc main() {\n\tRunOnceMain(os.Args[1:], runner.RunOnce, os.Exit, os.Stdout, os.Stderr, nil, nil)\n}\n\ntype promptBuilder struct{}\n\nfunc (promptBuilder) Build(issueID string, title string, description string, acceptance string) string {\n\treturn prompt.Build(issueID, title, description, acceptance)\n}\n\ntype runnerLogger struct{}\n\nfunc (runnerLogger) AppendRunnerSummary(repoRoot string, issueID string, title string, status string, commitSHA string) error {\n\treturn logging.AppendRunnerSummary(repoRoot, issueID, title, status, commitSHA)\n}\n\ntype defaultOpenCodeRunner struct{}\n\nfunc (defaultOpenCodeRunner) Start(args []string, env map[string]string, stdoutPath string) (opencode.Process, error) {\n\treturn startCommandWithEnv(args, env, stdoutPath)\n}\n","additions":0,"deletions":1},"truncated":false},"time":{"start":1768840762901,"end":1768840763198}},"metadata":{"openai":{"itemId":"fc_0d92f22863c7783701696e5e359f648191ba527936512cc297"}}}}
{"type":"step_finish","timestamp":1768840763216,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd720173f001gayJrao0a9LAAy","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd71ffde8001Zs4GgNRcrWFE9i","type":"step-finish","reason":"tool-calls","snapshot":"18832c8f5aa7e8deff70aad10093a18ec55aa928","cost":0,"tokens":{"input":1075,"output":326,"reasoning":0,"cache":{"read":48768,"write":0}}}}
{"type":"step_start","timestamp":1768840763622,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd72018e5001V2e46CfnQB04qy","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd7201770001uQhm5JZquKfmSw","type":"step-start","snapshot":"01e49ce16ad30937760b1be9827103679f683028"}}
{"type":"tool_use","timestamp":1768840770435,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd7201a8d001ajJI0gPkgJhhia","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd7201770001uQhm5JZquKfmSw","type":"tool","callID":"call_g7LKTQnELmXXFCCNvJ4IetPZ","tool":"edit","state":{"status":"completed","input":{"filePath":"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main.go","oldString":"type tuiEmitter struct {\n\tprogram tuiProgram\n}\n\nfunc (t tuiEmitter) Emit(event runner.Event) {\n\tif t.program == nil {\n\t\treturn\n\t}\n\tt.program.Send(event)\n}\n","newString":"type tuiEmitter struct {\n\tprogram tuiProgram\n}\n\nfunc (t tuiEmitter) Emit(event runner.Event) {\n\tif t.program == nil {\n\t\treturn\n\t}\n\tt.program.Send(event)\n}\n\ntype bubbleTUIProgram struct {\n\tprogram *tea.Program\n}\n\nfunc (b bubbleTUIProgram) Start() error {\n\tif b.program == nil {\n\t\treturn nil\n\t}\n\treturn b.program.Start()\n}\n\nfunc (b bubbleTUIProgram) Send(event runner.Event) {\n\tif b.program == nil {\n\t\treturn\n\t}\n\tb.program.Send(event)\n}\n\nfunc (b bubbleTUIProgram) Quit() {\n\tif b.program == nil {\n\t\treturn\n\t}\n\tb.program.Quit()\n}\n\nvar isTerminal = func(writer io.Writer) bool {\n\tif file, ok := writer.(*os.File); ok {\n\t\treturn term.IsTerminal(int(file.Fd()))\n\t}\n\treturn false\n}\n\nvar newTUIProgram = func(stdout io.Writer) tuiProgram {\n\tprogram := tea.NewProgram(tui.NewModel(nil), tea.WithInput(nil), tea.WithOutput(stdout))\n\treturn bubbleTUIProgram{program: program}\n}\n"},"output":"Edit applied successfully.","title":"cmd/yolo-runner/main.go","metadata":{"diagnostics":{"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main.go":[],"/Users/egv/dev/yolo-runner/go.mod":[{"range":{"start":{"line":6,"character":44},"end":{"line":6,"character":55}},"severity":2,"source":"go mod tidy","message":"github.com/charmbracelet/bubbletea should be direct"},{"range":{"start":{"line":19,"character":26},"end":{"line":19,"character":37}},"severity":2,"source":"go mod tidy","message":"golang.org/x/term should be direct"}],"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go":[{"range":{"start":{"line":213,"character":19},"end":{"line":213,"character":29}},"severity":1,"code":"UndeclaredName","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UndeclaredName"},"source":"compiler","message":"undefined: isTerminal"},{"range":{"start":{"line":214,"character":22},"end":{"line":214,"character":35}},"severity":1,"code":"UndeclaredName","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UndeclaredName"},"source":"compiler","message":"undefined: newTUIProgram"},{"range":{"start":{"line":215,"character":1},"end":{"line":215,"character":11}},"severity":1,"code":"UndeclaredName","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UndeclaredName"},"source":"compiler","message":"undefined: isTerminal"},{"range":{"start":{"line":216,"character":1},"end":{"line":216,"character":14}},"severity":1,"code":"UndeclaredName","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UndeclaredName"},"source":"compiler","message":"undefined: newTUIProgram"},{"range":{"start":{"line":218,"character":2},"end":{"line":218,"character":12}},"severity":1,"code":"UndeclaredName","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UndeclaredName"},"source":"compiler","message":"undefined: isTerminal"},{"range":{"start":{"line":219,"character":2},"end":{"line":219,"character":15}},"severity":1,"code":"UndeclaredName","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UndeclaredName"},"source":"compiler","message":"undefined: newTUIProgram"},{"range":{"start":{"line":246,"character":19},"end":{"line":246,"character":29}},"severity":1,"code":"UndeclaredName","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UndeclaredName"},"source":"compiler","message":"undefined: isTerminal"},{"range":{"start":{"line":247,"character":22},"end":{"line":247,"character":35}},"severity":1,"code":"UndeclaredName","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UndeclaredName"},"source":"compiler","message":"undefined: newTUIProgram"},{"range":{"start":{"line":248,"character":1},"end":{"line":248,"character":11}},"severity":1,"code":"UndeclaredName","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UndeclaredName"},"source":"compiler","message":"undefined: isTerminal"},{"range":{"start":{"line":249,"character":1},"end":{"line":249,"character":14}},"severity":1,"code":"UndeclaredName","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UndeclaredName"},"source":"compiler","message":"undefined: newTUIProgram"},{"range":{"start":{"line":254,"character":2},"end":{"line":254,"character":12}},"severity":1,"code":"UndeclaredName","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UndeclaredName"},"source":"compiler","message":"undefined: isTerminal"},{"range":{"start":{"line":255,"character":2},"end":{"line":255,"character":15}},"severity":1,"code":"UndeclaredName","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UndeclaredName"},"source":"compiler","message":"undefined: newTUIProgram"}],"/Users/egv/dev/yolo-runner/bubbletea_test.go":[],"/Users/egv/dev/yolo-runner/opencode_adapter_v1.go":[{"range":{"start":{"line":24,"character":1},"end":{"line":24,"character":18}},"severity":2,"code":"default","codeDescription":{"href":"https://staticcheck.dev/docs/checks/#S1031"},"source":"S1031","message":"unnecessary nil check around range"}],"/Users/egv/dev/yolo-runner/internal/ui/tui/model.go":[],"/Users/egv/dev/yolo-runner/internal/runner/runner.go":[],"/Users/egv/dev/yolo-runner/internal/ui/tui/model_test.go":[],"/Users/egv/dev/yolo-runner/internal/runner/events.go":[],"/Users/egv/dev/yolo-runner/internal/runner/loop_test.go":[],"/Users/egv/dev/yolo-runner/internal/runner/runner_test.go":[],"/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/tea.go":[],"/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/tty_unix.go":[],"/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/tty.go":[],"/Users/egv/dev/yolo-runner/internal/opencode/watchdog.go":[],"/Users/egv/dev/yolo-runner/internal/opencode/client.go":[{"range":{"start":{"line":28,"character":1},"end":{"line":28,"character":18}},"severity":2,"code":"default","codeDescription":{"href":"https://staticcheck.dev/docs/checks/#S1031"},"source":"S1031","message":"unnecessary nil check around range"}],"/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/options.go":[],"/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/tty_windows.go":[{"range":{"start":{"line":3,"character":8},"end":{"line":3,"character":11}},"severity":2,"source":"go list","message":"This file is within module \"../../go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0\", which is not included in your workspace.\nTo fix this problem, you can add a go.work file that uses this directory.\nSee the documentation for more information on setting up your workspace:\nhttps://github.com/golang/tools/blob/master/gopls/doc/workspace.md.","data":{"Actions":[{"title":"Add a go.work file using this module","kind":"quickfix","command":{"title":"Run `go work init && go work use`","command":"gopls.run_go_work_command","arguments":[{"ViewID":"1","InitFirst":true,"Args":["use","../../go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0"]}]}}]}}]},"diff":"Index: /Users/egv/dev/yolo-runner/cmd/yolo-runner/main.go\n===================================================================\n--- /Users/egv/dev/yolo-runner/cmd/yolo-runner/main.go\n+++ /Users/egv/dev/yolo-runner/cmd/yolo-runner/main.go\n@@ -51,8 +51,45 @@\n \t}\n \tt.program.Send(event)\n }\n \n+type bubbleTUIProgram struct {\n+\tprogram *tea.Program\n+}\n+\n+func (b bubbleTUIProgram) Start() error {\n+\tif b.program == nil {\n+\t\treturn nil\n+\t}\n+\treturn b.program.Start()\n+}\n+\n+func (b bubbleTUIProgram) Send(event runner.Event) {\n+\tif b.program == nil {\n+\t\treturn\n+\t}\n+\tb.program.Send(event)\n+}\n+\n+func (b bubbleTUIProgram) Quit() {\n+\tif b.program == nil {\n+\t\treturn\n+\t}\n+\tb.program.Quit()\n+}\n+\n+var isTerminal = func(writer io.Writer) bool {\n+\tif file, ok := writer.(*os.File); ok {\n+\t\treturn term.IsTerminal(int(file.Fd()))\n+\t}\n+\treturn false\n+}\n+\n+var newTUIProgram = func(stdout io.Writer) tuiProgram {\n+\tprogram := tea.NewProgram(tui.NewModel(nil), tea.WithInput(nil), tea.WithOutput(stdout))\n+\treturn bubbleTUIProgram{program: program}\n+}\n+\n type adapterRunner struct{}\n \n func (adapterRunner) Run(args ...string) (string, error) {\n \treturn runCommand(args...)\n","filediff":{"file":"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main.go","before":"package main\n\nimport (\n\t\"flag\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n\n\t\"yolo-runner/internal/beads\"\n\t\"yolo-runner/internal/logging\"\n\t\"yolo-runner/internal/opencode\"\n\t\"yolo-runner/internal/prompt\"\n\t\"yolo-runner/internal/runner\"\n\t\"yolo-runner/internal/ui/tui\"\n\tgitadapter \"yolo-runner/internal/vcs/git\"\n\n\ttea \"github.com/charmbracelet/bubbletea\"\n\t\"golang.org/x/term\"\n)\n\ntype runOnceFunc func(opts runner.RunOnceOptions, deps runner.RunOnceDeps) (string, error)\n\ntype exitFunc func(code int)\n\ntype beadsRunner interface {\n\tRun(args ...string) (string, error)\n}\n\ntype gitRunner interface {\n\tRun(name string, args ...string) (string, error)\n}\n\ntype openCodeRunner interface {\n\tStart(args []string, env map[string]string, stdoutPath string) (opencode.Process, error)\n}\n\ntype tuiProgram interface {\n\tStart() error\n\tSend(event runner.Event)\n\tQuit()\n}\n\ntype tuiEmitter struct {\n\tprogram tuiProgram\n}\n\nfunc (t tuiEmitter) Emit(event runner.Event) {\n\tif t.program == nil {\n\t\treturn\n\t}\n\tt.program.Send(event)\n}\n\ntype adapterRunner struct{}\n\nfunc (adapterRunner) Run(args ...string) (string, error) {\n\treturn runCommand(args...)\n}\n\ntype adapterGitRunner struct{}\n\nfunc (adapterGitRunner) Run(name string, args ...string) (string, error) {\n\treturn runCommand(append([]string{name}, args...)...)\n}\n\ntype openCodeAdapter struct {\n\trunner openCodeRunner\n}\n\nfunc (o openCodeAdapter) Run(issueID string, repoRoot string, promptText string, model string, configRoot string, configDir string, logPath string) error {\n\treturn opencode.Run(issueID, repoRoot, promptText, model, configRoot, configDir, logPath, o.runner)\n}\n\nfunc RunOnceMain(args []string, runOnce runOnceFunc, exit exitFunc, stdout io.Writer, stderr io.Writer, beadsRunner beadsRunner, gitRunner gitRunner) int {\n\tfs := flag.NewFlagSet(\"yolo-runner\", flag.ContinueOnError)\n\tfs.SetOutput(stderr)\n\n\trepoRoot := fs.String(\"repo\", \".\", \"Repository root path\")\n\trootID := fs.String(\"root\", \"algi-8bt\", \"Root bead/epic ID\")\n\tmodel := fs.String(\"model\", \"\", \"OpenCode model\")\n\tdryRun := fs.Bool(\"dry-run\", false, \"Print task and prompt without executing\")\n\theadless := fs.Bool(\"headless\", false, \"Force plain output without TUI\")\n\tconfigRoot := fs.String(\"config-root\", \"\", \"OpenCode config root\")\n\tconfigDir := fs.String(\"config-dir\", \"\", \"OpenCode config dir\")\n\n\tif err := fs.Parse(args); err != nil {\n\t\tfmt.Fprintln(stderr, err)\n\t\tif exit != nil {\n\t\t\texit(1)\n\t\t}\n\t\treturn 1\n\t}\n\n\tif runOnce == nil {\n\t\trunOnce = runner.RunOnce\n\t}\n\n\tif beadsRunner == nil {\n\t\tbeadsRunner = adapterRunner{}\n\t}\n\tif gitRunner == nil {\n\t\tgitRunner = adapterGitRunner{}\n\t}\n\n\tbeadsAdapter := beads.New(beadsRunner)\n\tgitAdapter := gitadapter.New(gitRunner)\n\topenCodeAdapter := openCodeAdapter{runner: defaultOpenCodeRunner{}}\n\n\tdeps := runner.RunOnceDeps{\n\t\tBeads:    beadsAdapter,\n\t\tPrompt:   promptBuilder{},\n\t\tOpenCode: openCodeAdapter,\n\t\tGit:      gitAdapter,\n\t\tLogger:   runnerLogger{},\n\t}\n\n\tresolvedConfigRoot := *configRoot\n\tresolvedConfigDir := *configDir\n\tif resolvedConfigRoot == \"\" {\n\t\thomeDir := os.Getenv(\"HOME\")\n\t\tif homeDir != \"\" {\n\t\t\tresolvedConfigRoot = filepath.Join(homeDir, \".config\", \"opencode-runner\")\n\t\t}\n\t}\n\tif resolvedConfigDir == \"\" && resolvedConfigRoot != \"\" {\n\t\tresolvedConfigDir = filepath.Join(resolvedConfigRoot, \"opencode\")\n\t}\n\n\toptions := runner.RunOnceOptions{\n\t\tRepoRoot:   *repoRoot,\n\t\tRootID:     *rootID,\n\t\tModel:      *model,\n\t\tConfigRoot: resolvedConfigRoot,\n\t\tConfigDir:  resolvedConfigDir,\n\t\tDryRun:     *dryRun,\n\t\tOut:        stdout,\n\t}\n\n\tif stdout == nil {\n\t\toptions.Out = io.Discard\n\t}\n\tif stderr == nil {\n\t\tstderr = io.Discard\n\t}\n\n\tvar program tuiProgram\n\tif !*headless && isTerminal(stdout) {\n\t\tprogram = newTUIProgram(stdout)\n\t\tdeps.Events = tuiEmitter{program: program}\n\t}\n\n\t_, err := runOnce(options, deps)\n\tif program != nil {\n\t\tprogram.Quit()\n\t}\n\tif err != nil {\n\t\tfmt.Fprintln(stderr, err)\n\t\tif exit != nil {\n\t\t\texit(1)\n\t\t}\n\t\treturn 1\n\t}\n\n\tif exit != nil {\n\t\texit(0)\n\t}\n\treturn 0\n}\n\nfunc main() {\n\tRunOnceMain(os.Args[1:], runner.RunOnce, os.Exit, os.Stdout, os.Stderr, nil, nil)\n}\n\ntype promptBuilder struct{}\n\nfunc (promptBuilder) Build(issueID string, title string, description string, acceptance string) string {\n\treturn prompt.Build(issueID, title, description, acceptance)\n}\n\ntype runnerLogger struct{}\n\nfunc (runnerLogger) AppendRunnerSummary(repoRoot string, issueID string, title string, status string, commitSHA string) error {\n\treturn logging.AppendRunnerSummary(repoRoot, issueID, title, status, commitSHA)\n}\n\ntype defaultOpenCodeRunner struct{}\n\nfunc (defaultOpenCodeRunner) Start(args []string, env map[string]string, stdoutPath string) (opencode.Process, error) {\n\treturn startCommandWithEnv(args, env, stdoutPath)\n}\n","after":"package main\n\nimport (\n\t\"flag\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n\n\t\"yolo-runner/internal/beads\"\n\t\"yolo-runner/internal/logging\"\n\t\"yolo-runner/internal/opencode\"\n\t\"yolo-runner/internal/prompt\"\n\t\"yolo-runner/internal/runner\"\n\t\"yolo-runner/internal/ui/tui\"\n\tgitadapter \"yolo-runner/internal/vcs/git\"\n\n\ttea \"github.com/charmbracelet/bubbletea\"\n\t\"golang.org/x/term\"\n)\n\ntype runOnceFunc func(opts runner.RunOnceOptions, deps runner.RunOnceDeps) (string, error)\n\ntype exitFunc func(code int)\n\ntype beadsRunner interface {\n\tRun(args ...string) (string, error)\n}\n\ntype gitRunner interface {\n\tRun(name string, args ...string) (string, error)\n}\n\ntype openCodeRunner interface {\n\tStart(args []string, env map[string]string, stdoutPath string) (opencode.Process, error)\n}\n\ntype tuiProgram interface {\n\tStart() error\n\tSend(event runner.Event)\n\tQuit()\n}\n\ntype tuiEmitter struct {\n\tprogram tuiProgram\n}\n\nfunc (t tuiEmitter) Emit(event runner.Event) {\n\tif t.program == nil {\n\t\treturn\n\t}\n\tt.program.Send(event)\n}\n\ntype bubbleTUIProgram struct {\n\tprogram *tea.Program\n}\n\nfunc (b bubbleTUIProgram) Start() error {\n\tif b.program == nil {\n\t\treturn nil\n\t}\n\treturn b.program.Start()\n}\n\nfunc (b bubbleTUIProgram) Send(event runner.Event) {\n\tif b.program == nil {\n\t\treturn\n\t}\n\tb.program.Send(event)\n}\n\nfunc (b bubbleTUIProgram) Quit() {\n\tif b.program == nil {\n\t\treturn\n\t}\n\tb.program.Quit()\n}\n\nvar isTerminal = func(writer io.Writer) bool {\n\tif file, ok := writer.(*os.File); ok {\n\t\treturn term.IsTerminal(int(file.Fd()))\n\t}\n\treturn false\n}\n\nvar newTUIProgram = func(stdout io.Writer) tuiProgram {\n\tprogram := tea.NewProgram(tui.NewModel(nil), tea.WithInput(nil), tea.WithOutput(stdout))\n\treturn bubbleTUIProgram{program: program}\n}\n\ntype adapterRunner struct{}\n\nfunc (adapterRunner) Run(args ...string) (string, error) {\n\treturn runCommand(args...)\n}\n\ntype adapterGitRunner struct{}\n\nfunc (adapterGitRunner) Run(name string, args ...string) (string, error) {\n\treturn runCommand(append([]string{name}, args...)...)\n}\n\ntype openCodeAdapter struct {\n\trunner openCodeRunner\n}\n\nfunc (o openCodeAdapter) Run(issueID string, repoRoot string, promptText string, model string, configRoot string, configDir string, logPath string) error {\n\treturn opencode.Run(issueID, repoRoot, promptText, model, configRoot, configDir, logPath, o.runner)\n}\n\nfunc RunOnceMain(args []string, runOnce runOnceFunc, exit exitFunc, stdout io.Writer, stderr io.Writer, beadsRunner beadsRunner, gitRunner gitRunner) int {\n\tfs := flag.NewFlagSet(\"yolo-runner\", flag.ContinueOnError)\n\tfs.SetOutput(stderr)\n\n\trepoRoot := fs.String(\"repo\", \".\", \"Repository root path\")\n\trootID := fs.String(\"root\", \"algi-8bt\", \"Root bead/epic ID\")\n\tmodel := fs.String(\"model\", \"\", \"OpenCode model\")\n\tdryRun := fs.Bool(\"dry-run\", false, \"Print task and prompt without executing\")\n\theadless := fs.Bool(\"headless\", false, \"Force plain output without TUI\")\n\tconfigRoot := fs.String(\"config-root\", \"\", \"OpenCode config root\")\n\tconfigDir := fs.String(\"config-dir\", \"\", \"OpenCode config dir\")\n\n\tif err := fs.Parse(args); err != nil {\n\t\tfmt.Fprintln(stderr, err)\n\t\tif exit != nil {\n\t\t\texit(1)\n\t\t}\n\t\treturn 1\n\t}\n\n\tif runOnce == nil {\n\t\trunOnce = runner.RunOnce\n\t}\n\n\tif beadsRunner == nil {\n\t\tbeadsRunner = adapterRunner{}\n\t}\n\tif gitRunner == nil {\n\t\tgitRunner = adapterGitRunner{}\n\t}\n\n\tbeadsAdapter := beads.New(beadsRunner)\n\tgitAdapter := gitadapter.New(gitRunner)\n\topenCodeAdapter := openCodeAdapter{runner: defaultOpenCodeRunner{}}\n\n\tdeps := runner.RunOnceDeps{\n\t\tBeads:    beadsAdapter,\n\t\tPrompt:   promptBuilder{},\n\t\tOpenCode: openCodeAdapter,\n\t\tGit:      gitAdapter,\n\t\tLogger:   runnerLogger{},\n\t}\n\n\tresolvedConfigRoot := *configRoot\n\tresolvedConfigDir := *configDir\n\tif resolvedConfigRoot == \"\" {\n\t\thomeDir := os.Getenv(\"HOME\")\n\t\tif homeDir != \"\" {\n\t\t\tresolvedConfigRoot = filepath.Join(homeDir, \".config\", \"opencode-runner\")\n\t\t}\n\t}\n\tif resolvedConfigDir == \"\" && resolvedConfigRoot != \"\" {\n\t\tresolvedConfigDir = filepath.Join(resolvedConfigRoot, \"opencode\")\n\t}\n\n\toptions := runner.RunOnceOptions{\n\t\tRepoRoot:   *repoRoot,\n\t\tRootID:     *rootID,\n\t\tModel:      *model,\n\t\tConfigRoot: resolvedConfigRoot,\n\t\tConfigDir:  resolvedConfigDir,\n\t\tDryRun:     *dryRun,\n\t\tOut:        stdout,\n\t}\n\n\tif stdout == nil {\n\t\toptions.Out = io.Discard\n\t}\n\tif stderr == nil {\n\t\tstderr = io.Discard\n\t}\n\n\tvar program tuiProgram\n\tif !*headless && isTerminal(stdout) {\n\t\tprogram = newTUIProgram(stdout)\n\t\tdeps.Events = tuiEmitter{program: program}\n\t}\n\n\t_, err := runOnce(options, deps)\n\tif program != nil {\n\t\tprogram.Quit()\n\t}\n\tif err != nil {\n\t\tfmt.Fprintln(stderr, err)\n\t\tif exit != nil {\n\t\t\texit(1)\n\t\t}\n\t\treturn 1\n\t}\n\n\tif exit != nil {\n\t\texit(0)\n\t}\n\treturn 0\n}\n\nfunc main() {\n\tRunOnceMain(os.Args[1:], runner.RunOnce, os.Exit, os.Stdout, os.Stderr, nil, nil)\n}\n\ntype promptBuilder struct{}\n\nfunc (promptBuilder) Build(issueID string, title string, description string, acceptance string) string {\n\treturn prompt.Build(issueID, title, description, acceptance)\n}\n\ntype runnerLogger struct{}\n\nfunc (runnerLogger) AppendRunnerSummary(repoRoot string, issueID string, title string, status string, commitSHA string) error {\n\treturn logging.AppendRunnerSummary(repoRoot, issueID, title, status, commitSHA)\n}\n\ntype defaultOpenCodeRunner struct{}\n\nfunc (defaultOpenCodeRunner) Start(args []string, env map[string]string, stdoutPath string) (opencode.Process, error) {\n\treturn startCommandWithEnv(args, env, stdoutPath)\n}\n","additions":37,"deletions":0},"truncated":false},"time":{"start":1768840770272,"end":1768840770434}},"metadata":{"openai":{"itemId":"fc_03cb9ac86e1f507c01696e5e3c0e808191b4647127b9063313"}}}}
{"type":"step_finish","timestamp":1768840770453,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd7203383001MU124VGNmL4nQo","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd7201770001uQhm5JZquKfmSw","type":"step-finish","reason":"tool-calls","snapshot":"ed1735916f9e5c3fb61c887f5e6edecfce636de2","cost":0,"tokens":{"input":1538,"output":382,"reasoning":0,"cache":{"read":48768,"write":0}}}}
{"type":"step_start","timestamp":1768840770839,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd7203516001FpDSo1r1ynNIGf","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd72033b3001oRfU18LusdFIyc","type":"step-start","snapshot":"4d2077930ca3b017caa8f319bea2fc2cac79f554"}}
{"type":"tool_use","timestamp":1768840775823,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd7203767001vzUZ4OJnhHb4J7","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd72033b3001oRfU18LusdFIyc","type":"tool","callID":"call_bC2dn2aPxMIXd60gH7NXqZyK","tool":"edit","state":{"status":"completed","input":{"filePath":"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main.go","oldString":"\tvar program tuiProgram\n\tif !*headless && isTerminal(stdout) {\n\t\tprogram = newTUIProgram(stdout)\n\t\tdeps.Events = tuiEmitter{program: program}\n\t}\n\n\t_, err := runOnce(options, deps)\n\tif program != nil {\n\t\tprogram.Quit()\n\t}\n","newString":"\tvar program tuiProgram\n\tif !*headless && isTerminal(stdout) {\n\t\tprogram = newTUIProgram(stdout)\n\t\tdeps.Events = tuiEmitter{program: program}\n\t\tif err := program.Start(); err != nil {\n\t\t\tfmt.Fprintln(stderr, err)\n\t\t\tif exit != nil {\n\t\t\t\texit(1)\n\t\t\t}\n\t\t\treturn 1\n\t\t}\n\t}\n\n\t_, err := runOnce(options, deps)\n\tif program != nil {\n\t\tprogram.Quit()\n\t}\n"},"output":"Edit applied successfully.","title":"cmd/yolo-runner/main.go","metadata":{"diagnostics":{"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main.go":[],"/Users/egv/dev/yolo-runner/go.mod":[{"range":{"start":{"line":6,"character":44},"end":{"line":6,"character":55}},"severity":2,"source":"go mod tidy","message":"github.com/charmbracelet/bubbletea should be direct"},{"range":{"start":{"line":19,"character":26},"end":{"line":19,"character":37}},"severity":2,"source":"go mod tidy","message":"golang.org/x/term should be direct"}],"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go":[],"/Users/egv/dev/yolo-runner/bubbletea_test.go":[],"/Users/egv/dev/yolo-runner/opencode_adapter_v1.go":[{"range":{"start":{"line":24,"character":1},"end":{"line":24,"character":18}},"severity":2,"code":"default","codeDescription":{"href":"https://staticcheck.dev/docs/checks/#S1031"},"source":"S1031","message":"unnecessary nil check around range"}],"/Users/egv/dev/yolo-runner/internal/ui/tui/model.go":[],"/Users/egv/dev/yolo-runner/internal/runner/runner.go":[],"/Users/egv/dev/yolo-runner/internal/ui/tui/model_test.go":[],"/Users/egv/dev/yolo-runner/internal/runner/events.go":[],"/Users/egv/dev/yolo-runner/internal/runner/loop_test.go":[],"/Users/egv/dev/yolo-runner/internal/runner/runner_test.go":[],"/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/tea.go":[],"/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/tty_unix.go":[],"/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/tty.go":[],"/Users/egv/dev/yolo-runner/internal/opencode/watchdog.go":[],"/Users/egv/dev/yolo-runner/internal/opencode/client.go":[{"range":{"start":{"line":28,"character":1},"end":{"line":28,"character":18}},"severity":2,"code":"default","codeDescription":{"href":"https://staticcheck.dev/docs/checks/#S1031"},"source":"S1031","message":"unnecessary nil check around range"}],"/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/options.go":[],"/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/tty_windows.go":[{"range":{"start":{"line":3,"character":8},"end":{"line":3,"character":11}},"severity":2,"source":"go list","message":"This file is within module \"../../go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0\", which is not included in your workspace.\nTo fix this problem, you can add a go.work file that uses this directory.\nSee the documentation for more information on setting up your workspace:\nhttps://github.com/golang/tools/blob/master/gopls/doc/workspace.md.","data":{"Actions":[{"title":"Add a go.work file using this module","kind":"quickfix","command":{"title":"Run `go work init && go work use`","command":"gopls.run_go_work_command","arguments":[{"ViewID":"1","InitFirst":true,"Args":["use","../../go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0"]}]}}]}}]},"diff":"Index: /Users/egv/dev/yolo-runner/cmd/yolo-runner/main.go\n===================================================================\n--- /Users/egv/dev/yolo-runner/cmd/yolo-runner/main.go\n+++ /Users/egv/dev/yolo-runner/cmd/yolo-runner/main.go\n@@ -184,8 +184,15 @@\n var program tuiProgram\n if !*headless && isTerminal(stdout) {\n \tprogram = newTUIProgram(stdout)\n \tdeps.Events = tuiEmitter{program: program}\n+\tif err := program.Start(); err != nil {\n+\t\tfmt.Fprintln(stderr, err)\n+\t\tif exit != nil {\n+\t\t\texit(1)\n+\t\t}\n+\t\treturn 1\n+\t}\n }\n \n _, err := runOnce(options, deps)\n if program != nil {\n","filediff":{"file":"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main.go","before":"package main\n\nimport (\n\t\"flag\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n\n\t\"yolo-runner/internal/beads\"\n\t\"yolo-runner/internal/logging\"\n\t\"yolo-runner/internal/opencode\"\n\t\"yolo-runner/internal/prompt\"\n\t\"yolo-runner/internal/runner\"\n\t\"yolo-runner/internal/ui/tui\"\n\tgitadapter \"yolo-runner/internal/vcs/git\"\n\n\ttea \"github.com/charmbracelet/bubbletea\"\n\t\"golang.org/x/term\"\n)\n\ntype runOnceFunc func(opts runner.RunOnceOptions, deps runner.RunOnceDeps) (string, error)\n\ntype exitFunc func(code int)\n\ntype beadsRunner interface {\n\tRun(args ...string) (string, error)\n}\n\ntype gitRunner interface {\n\tRun(name string, args ...string) (string, error)\n}\n\ntype openCodeRunner interface {\n\tStart(args []string, env map[string]string, stdoutPath string) (opencode.Process, error)\n}\n\ntype tuiProgram interface {\n\tStart() error\n\tSend(event runner.Event)\n\tQuit()\n}\n\ntype tuiEmitter struct {\n\tprogram tuiProgram\n}\n\nfunc (t tuiEmitter) Emit(event runner.Event) {\n\tif t.program == nil {\n\t\treturn\n\t}\n\tt.program.Send(event)\n}\n\ntype bubbleTUIProgram struct {\n\tprogram *tea.Program\n}\n\nfunc (b bubbleTUIProgram) Start() error {\n\tif b.program == nil {\n\t\treturn nil\n\t}\n\treturn b.program.Start()\n}\n\nfunc (b bubbleTUIProgram) Send(event runner.Event) {\n\tif b.program == nil {\n\t\treturn\n\t}\n\tb.program.Send(event)\n}\n\nfunc (b bubbleTUIProgram) Quit() {\n\tif b.program == nil {\n\t\treturn\n\t}\n\tb.program.Quit()\n}\n\nvar isTerminal = func(writer io.Writer) bool {\n\tif file, ok := writer.(*os.File); ok {\n\t\treturn term.IsTerminal(int(file.Fd()))\n\t}\n\treturn false\n}\n\nvar newTUIProgram = func(stdout io.Writer) tuiProgram {\n\tprogram := tea.NewProgram(tui.NewModel(nil), tea.WithInput(nil), tea.WithOutput(stdout))\n\treturn bubbleTUIProgram{program: program}\n}\n\ntype adapterRunner struct{}\n\nfunc (adapterRunner) Run(args ...string) (string, error) {\n\treturn runCommand(args...)\n}\n\ntype adapterGitRunner struct{}\n\nfunc (adapterGitRunner) Run(name string, args ...string) (string, error) {\n\treturn runCommand(append([]string{name}, args...)...)\n}\n\ntype openCodeAdapter struct {\n\trunner openCodeRunner\n}\n\nfunc (o openCodeAdapter) Run(issueID string, repoRoot string, promptText string, model string, configRoot string, configDir string, logPath string) error {\n\treturn opencode.Run(issueID, repoRoot, promptText, model, configRoot, configDir, logPath, o.runner)\n}\n\nfunc RunOnceMain(args []string, runOnce runOnceFunc, exit exitFunc, stdout io.Writer, stderr io.Writer, beadsRunner beadsRunner, gitRunner gitRunner) int {\n\tfs := flag.NewFlagSet(\"yolo-runner\", flag.ContinueOnError)\n\tfs.SetOutput(stderr)\n\n\trepoRoot := fs.String(\"repo\", \".\", \"Repository root path\")\n\trootID := fs.String(\"root\", \"algi-8bt\", \"Root bead/epic ID\")\n\tmodel := fs.String(\"model\", \"\", \"OpenCode model\")\n\tdryRun := fs.Bool(\"dry-run\", false, \"Print task and prompt without executing\")\n\theadless := fs.Bool(\"headless\", false, \"Force plain output without TUI\")\n\tconfigRoot := fs.String(\"config-root\", \"\", \"OpenCode config root\")\n\tconfigDir := fs.String(\"config-dir\", \"\", \"OpenCode config dir\")\n\n\tif err := fs.Parse(args); err != nil {\n\t\tfmt.Fprintln(stderr, err)\n\t\tif exit != nil {\n\t\t\texit(1)\n\t\t}\n\t\treturn 1\n\t}\n\n\tif runOnce == nil {\n\t\trunOnce = runner.RunOnce\n\t}\n\n\tif beadsRunner == nil {\n\t\tbeadsRunner = adapterRunner{}\n\t}\n\tif gitRunner == nil {\n\t\tgitRunner = adapterGitRunner{}\n\t}\n\n\tbeadsAdapter := beads.New(beadsRunner)\n\tgitAdapter := gitadapter.New(gitRunner)\n\topenCodeAdapter := openCodeAdapter{runner: defaultOpenCodeRunner{}}\n\n\tdeps := runner.RunOnceDeps{\n\t\tBeads:    beadsAdapter,\n\t\tPrompt:   promptBuilder{},\n\t\tOpenCode: openCodeAdapter,\n\t\tGit:      gitAdapter,\n\t\tLogger:   runnerLogger{},\n\t}\n\n\tresolvedConfigRoot := *configRoot\n\tresolvedConfigDir := *configDir\n\tif resolvedConfigRoot == \"\" {\n\t\thomeDir := os.Getenv(\"HOME\")\n\t\tif homeDir != \"\" {\n\t\t\tresolvedConfigRoot = filepath.Join(homeDir, \".config\", \"opencode-runner\")\n\t\t}\n\t}\n\tif resolvedConfigDir == \"\" && resolvedConfigRoot != \"\" {\n\t\tresolvedConfigDir = filepath.Join(resolvedConfigRoot, \"opencode\")\n\t}\n\n\toptions := runner.RunOnceOptions{\n\t\tRepoRoot:   *repoRoot,\n\t\tRootID:     *rootID,\n\t\tModel:      *model,\n\t\tConfigRoot: resolvedConfigRoot,\n\t\tConfigDir:  resolvedConfigDir,\n\t\tDryRun:     *dryRun,\n\t\tOut:        stdout,\n\t}\n\n\tif stdout == nil {\n\t\toptions.Out = io.Discard\n\t}\n\tif stderr == nil {\n\t\tstderr = io.Discard\n\t}\n\n\tvar program tuiProgram\n\tif !*headless && isTerminal(stdout) {\n\t\tprogram = newTUIProgram(stdout)\n\t\tdeps.Events = tuiEmitter{program: program}\n\t}\n\n\t_, err := runOnce(options, deps)\n\tif program != nil {\n\t\tprogram.Quit()\n\t}\n\tif err != nil {\n\t\tfmt.Fprintln(stderr, err)\n\t\tif exit != nil {\n\t\t\texit(1)\n\t\t}\n\t\treturn 1\n\t}\n\n\tif exit != nil {\n\t\texit(0)\n\t}\n\treturn 0\n}\n\nfunc main() {\n\tRunOnceMain(os.Args[1:], runner.RunOnce, os.Exit, os.Stdout, os.Stderr, nil, nil)\n}\n\ntype promptBuilder struct{}\n\nfunc (promptBuilder) Build(issueID string, title string, description string, acceptance string) string {\n\treturn prompt.Build(issueID, title, description, acceptance)\n}\n\ntype runnerLogger struct{}\n\nfunc (runnerLogger) AppendRunnerSummary(repoRoot string, issueID string, title string, status string, commitSHA string) error {\n\treturn logging.AppendRunnerSummary(repoRoot, issueID, title, status, commitSHA)\n}\n\ntype defaultOpenCodeRunner struct{}\n\nfunc (defaultOpenCodeRunner) Start(args []string, env map[string]string, stdoutPath string) (opencode.Process, error) {\n\treturn startCommandWithEnv(args, env, stdoutPath)\n}\n","after":"package main\n\nimport (\n\t\"flag\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n\n\t\"yolo-runner/internal/beads\"\n\t\"yolo-runner/internal/logging\"\n\t\"yolo-runner/internal/opencode\"\n\t\"yolo-runner/internal/prompt\"\n\t\"yolo-runner/internal/runner\"\n\t\"yolo-runner/internal/ui/tui\"\n\tgitadapter \"yolo-runner/internal/vcs/git\"\n\n\ttea \"github.com/charmbracelet/bubbletea\"\n\t\"golang.org/x/term\"\n)\n\ntype runOnceFunc func(opts runner.RunOnceOptions, deps runner.RunOnceDeps) (string, error)\n\ntype exitFunc func(code int)\n\ntype beadsRunner interface {\n\tRun(args ...string) (string, error)\n}\n\ntype gitRunner interface {\n\tRun(name string, args ...string) (string, error)\n}\n\ntype openCodeRunner interface {\n\tStart(args []string, env map[string]string, stdoutPath string) (opencode.Process, error)\n}\n\ntype tuiProgram interface {\n\tStart() error\n\tSend(event runner.Event)\n\tQuit()\n}\n\ntype tuiEmitter struct {\n\tprogram tuiProgram\n}\n\nfunc (t tuiEmitter) Emit(event runner.Event) {\n\tif t.program == nil {\n\t\treturn\n\t}\n\tt.program.Send(event)\n}\n\ntype bubbleTUIProgram struct {\n\tprogram *tea.Program\n}\n\nfunc (b bubbleTUIProgram) Start() error {\n\tif b.program == nil {\n\t\treturn nil\n\t}\n\treturn b.program.Start()\n}\n\nfunc (b bubbleTUIProgram) Send(event runner.Event) {\n\tif b.program == nil {\n\t\treturn\n\t}\n\tb.program.Send(event)\n}\n\nfunc (b bubbleTUIProgram) Quit() {\n\tif b.program == nil {\n\t\treturn\n\t}\n\tb.program.Quit()\n}\n\nvar isTerminal = func(writer io.Writer) bool {\n\tif file, ok := writer.(*os.File); ok {\n\t\treturn term.IsTerminal(int(file.Fd()))\n\t}\n\treturn false\n}\n\nvar newTUIProgram = func(stdout io.Writer) tuiProgram {\n\tprogram := tea.NewProgram(tui.NewModel(nil), tea.WithInput(nil), tea.WithOutput(stdout))\n\treturn bubbleTUIProgram{program: program}\n}\n\ntype adapterRunner struct{}\n\nfunc (adapterRunner) Run(args ...string) (string, error) {\n\treturn runCommand(args...)\n}\n\ntype adapterGitRunner struct{}\n\nfunc (adapterGitRunner) Run(name string, args ...string) (string, error) {\n\treturn runCommand(append([]string{name}, args...)...)\n}\n\ntype openCodeAdapter struct {\n\trunner openCodeRunner\n}\n\nfunc (o openCodeAdapter) Run(issueID string, repoRoot string, promptText string, model string, configRoot string, configDir string, logPath string) error {\n\treturn opencode.Run(issueID, repoRoot, promptText, model, configRoot, configDir, logPath, o.runner)\n}\n\nfunc RunOnceMain(args []string, runOnce runOnceFunc, exit exitFunc, stdout io.Writer, stderr io.Writer, beadsRunner beadsRunner, gitRunner gitRunner) int {\n\tfs := flag.NewFlagSet(\"yolo-runner\", flag.ContinueOnError)\n\tfs.SetOutput(stderr)\n\n\trepoRoot := fs.String(\"repo\", \".\", \"Repository root path\")\n\trootID := fs.String(\"root\", \"algi-8bt\", \"Root bead/epic ID\")\n\tmodel := fs.String(\"model\", \"\", \"OpenCode model\")\n\tdryRun := fs.Bool(\"dry-run\", false, \"Print task and prompt without executing\")\n\theadless := fs.Bool(\"headless\", false, \"Force plain output without TUI\")\n\tconfigRoot := fs.String(\"config-root\", \"\", \"OpenCode config root\")\n\tconfigDir := fs.String(\"config-dir\", \"\", \"OpenCode config dir\")\n\n\tif err := fs.Parse(args); err != nil {\n\t\tfmt.Fprintln(stderr, err)\n\t\tif exit != nil {\n\t\t\texit(1)\n\t\t}\n\t\treturn 1\n\t}\n\n\tif runOnce == nil {\n\t\trunOnce = runner.RunOnce\n\t}\n\n\tif beadsRunner == nil {\n\t\tbeadsRunner = adapterRunner{}\n\t}\n\tif gitRunner == nil {\n\t\tgitRunner = adapterGitRunner{}\n\t}\n\n\tbeadsAdapter := beads.New(beadsRunner)\n\tgitAdapter := gitadapter.New(gitRunner)\n\topenCodeAdapter := openCodeAdapter{runner: defaultOpenCodeRunner{}}\n\n\tdeps := runner.RunOnceDeps{\n\t\tBeads:    beadsAdapter,\n\t\tPrompt:   promptBuilder{},\n\t\tOpenCode: openCodeAdapter,\n\t\tGit:      gitAdapter,\n\t\tLogger:   runnerLogger{},\n\t}\n\n\tresolvedConfigRoot := *configRoot\n\tresolvedConfigDir := *configDir\n\tif resolvedConfigRoot == \"\" {\n\t\thomeDir := os.Getenv(\"HOME\")\n\t\tif homeDir != \"\" {\n\t\t\tresolvedConfigRoot = filepath.Join(homeDir, \".config\", \"opencode-runner\")\n\t\t}\n\t}\n\tif resolvedConfigDir == \"\" && resolvedConfigRoot != \"\" {\n\t\tresolvedConfigDir = filepath.Join(resolvedConfigRoot, \"opencode\")\n\t}\n\n\toptions := runner.RunOnceOptions{\n\t\tRepoRoot:   *repoRoot,\n\t\tRootID:     *rootID,\n\t\tModel:      *model,\n\t\tConfigRoot: resolvedConfigRoot,\n\t\tConfigDir:  resolvedConfigDir,\n\t\tDryRun:     *dryRun,\n\t\tOut:        stdout,\n\t}\n\n\tif stdout == nil {\n\t\toptions.Out = io.Discard\n\t}\n\tif stderr == nil {\n\t\tstderr = io.Discard\n\t}\n\n\tvar program tuiProgram\n\tif !*headless && isTerminal(stdout) {\n\t\tprogram = newTUIProgram(stdout)\n\t\tdeps.Events = tuiEmitter{program: program}\n\t\tif err := program.Start(); err != nil {\n\t\t\tfmt.Fprintln(stderr, err)\n\t\t\tif exit != nil {\n\t\t\t\texit(1)\n\t\t\t}\n\t\t\treturn 1\n\t\t}\n\t}\n\n\t_, err := runOnce(options, deps)\n\tif program != nil {\n\t\tprogram.Quit()\n\t}\n\tif err != nil {\n\t\tfmt.Fprintln(stderr, err)\n\t\tif exit != nil {\n\t\t\texit(1)\n\t\t}\n\t\treturn 1\n\t}\n\n\tif exit != nil {\n\t\texit(0)\n\t}\n\treturn 0\n}\n\nfunc main() {\n\tRunOnceMain(os.Args[1:], runner.RunOnce, os.Exit, os.Stdout, os.Stderr, nil, nil)\n}\n\ntype promptBuilder struct{}\n\nfunc (promptBuilder) Build(issueID string, title string, description string, acceptance string) string {\n\treturn prompt.Build(issueID, title, description, acceptance)\n}\n\ntype runnerLogger struct{}\n\nfunc (runnerLogger) AppendRunnerSummary(repoRoot string, issueID string, title string, status string, commitSHA string) error {\n\treturn logging.AppendRunnerSummary(repoRoot, issueID, title, status, commitSHA)\n}\n\ntype defaultOpenCodeRunner struct{}\n\nfunc (defaultOpenCodeRunner) Start(args []string, env map[string]string, stdoutPath string) (opencode.Process, error) {\n\treturn startCommandWithEnv(args, env, stdoutPath)\n}\n","additions":7,"deletions":0},"truncated":false},"time":{"start":1768840775665,"end":1768840775822}},"metadata":{"openai":{"itemId":"fc_0de640a854e072db01696e5e436fc08191a4f37541972e8446"}}}}
{"type":"step_finish","timestamp":1768840775840,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd720488f0013O54eBrNvM9KBL","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd72033b3001oRfU18LusdFIyc","type":"step-finish","reason":"tool-calls","snapshot":"e574591af8419e1057481d7ace4c2b5e068cf6f3","cost":0,"tokens":{"input":907,"output":254,"reasoning":0,"cache":{"read":49792,"write":0}}}}
{"type":"step_start","timestamp":1768840776204,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd7204a0c001ofzzV6lHogafc0","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd72048c0001oOCv43trVaH4lx","type":"step-start","snapshot":"412b2786e6c97ccbb3c46eee27088fb3873c3a92"}}
{"type":"tool_use","timestamp":1768840778331,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd7204c73001534HJuCcNnMADC","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd72048c0001oOCv43trVaH4lx","type":"tool","callID":"call_49QQEyEsm5vROuDdudKRkLXb","tool":"bash","state":{"status":"completed","input":{"command":"go test ./...","workdir":"/Users/egv/dev/yolo-runner","description":"Runs Go test suite"},"output":"ok  \tyolo-runner\t(cached)\nok  \tyolo-runner/cmd/yolo-runner\t0.517s\nok  \tyolo-runner/internal/beads\t(cached)\nok  \tyolo-runner/internal/logging\t(cached)\nok  \tyolo-runner/internal/opencode\t(cached)\nok  \tyolo-runner/internal/prompt\t(cached)\nok  \tyolo-runner/internal/runner\t(cached)\nok  \tyolo-runner/internal/ui/tui\t(cached)\nok  \tyolo-runner/internal/vcs/git\t(cached)\n","title":"Runs Go test suite","metadata":{"output":"ok  \tyolo-runner\t(cached)\nok  \tyolo-runner/cmd/yolo-runner\t0.517s\nok  \tyolo-runner/internal/beads\t(cached)\nok  \tyolo-runner/internal/logging\t(cached)\nok  \tyolo-runner/internal/opencode\t(cached)\nok  \tyolo-runner/internal/prompt\t(cached)\nok  \tyolo-runner/internal/runner\t(cached)\nok  \tyolo-runner/internal/ui/tui\t(cached)\nok  \tyolo-runner/internal/vcs/git\t(cached)\n","exit":0,"description":"Runs Go test suite","truncated":false},"time":{"start":1768840777586,"end":1768840778331}},"metadata":{"openai":{"itemId":"fc_060b2742c6ef175301696e5e48d064819186eee7ce10f2f20a"}}}}
{"type":"step_finish","timestamp":1768840778350,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd720525b001JCRJ5OmEmx8BMW","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd72048c0001oOCv43trVaH4lx","type":"step-finish","reason":"tool-calls","snapshot":"1c3c51638992aae1a5d05dfde587ccd8a4b3ba3f","cost":0,"tokens":{"input":1172,"output":42,"reasoning":0,"cache":{"read":49792,"write":0}}}}
{"type":"step_start","timestamp":1768840778720,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd72053e00016xBymOaaulHwYq","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd720528e0017pGLfvzOMeyDiw","type":"step-start","snapshot":"c6da96be80347afb60b62b81fc1194e8eb0c2190"}}
{"type":"tool_use","timestamp":1768840780108,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd72056ee001Zx2HdHEDI3butP","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd720528e0017pGLfvzOMeyDiw","type":"tool","callID":"call_f2D8KELxUEMztAKHw76Xmr8B","tool":"bash","state":{"status":"completed","input":{"command":"git status --short","workdir":"/Users/egv/dev/yolo-runner","description":"Shows git status"},"output":" M .beads/issues.jsonl\n M cmd/yolo-runner/main.go\n M cmd/yolo-runner/main_test.go\n M runner-logs/beads_yolo_runner.jsonl\n?? runner-logs/opencode/yolo-runner-127.4.4.jsonl\n","title":"Shows git status","metadata":{"output":" M .beads/issues.jsonl\n M cmd/yolo-runner/main.go\n M cmd/yolo-runner/main_test.go\n M runner-logs/beads_yolo_runner.jsonl\n?? runner-logs/opencode/yolo-runner-127.4.4.jsonl\n","exit":0,"description":"Shows git status","truncated":false},"time":{"start":1768840780097,"end":1768840780108}},"metadata":{"openai":{"itemId":"fc_05631b7c6cac713f01696e5e4b828881919d19ad07378aad88"}}}}
{"type":"tool_use","timestamp":1768840781043,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd7205941001Zqe3PrGqtKRivg","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd720528e0017pGLfvzOMeyDiw","type":"tool","callID":"call_mNOCFSKmgh91mGIcxp0bwrQY","tool":"bash","state":{"status":"completed","input":{"command":"git diff","workdir":"/Users/egv/dev/yolo-runner","description":"Shows git diff"},"output":"diff --git a/.beads/issues.jsonl b/.beads/issues.jsonl\nindex 8672415..d99de46 100644\n--- a/.beads/issues.jsonl\n+++ b/.beads/issues.jsonl\n@@ -17,7 +17,7 @@\n {\"id\":\"yolo-runner-127.4.1\",\"title\":\"v1.2: Add Bubble Tea dependency\",\"description\":\"Add Bubble Tea dependencies and minimal wiring.\\n\\nFiles:\\n- Modify: go.mod\\n- Modify: go.sum\\n\\nAcceptance:\\n- go test ./... passes\\n- Bubble Tea module is added and buildable\",\"acceptance_criteria\":\"- go test ./... passes\\n- Bubble Tea module is added and buildable\",\"status\":\"closed\",\"priority\":1,\"issue_type\":\"task\",\"owner\":\"g.evstratov@gmail.com\",\"created_at\":\"2026-01-19T15:55:27.195836+03:00\",\"created_by\":\"Gennady Evstratov\",\"updated_at\":\"2026-01-19T18:59:10.354843+03:00\",\"closed_at\":\"2026-01-19T18:59:10.354843+03:00\",\"close_reason\":\"Closed\",\"dependencies\":[{\"issue_id\":\"yolo-runner-127.4.1\",\"depends_on_id\":\"yolo-runner-127.4\",\"type\":\"parent-child\",\"created_at\":\"2026-01-19T15:55:27.196499+03:00\",\"created_by\":\"Gennady Evstratov\"}]}\n {\"id\":\"yolo-runner-127.4.2\",\"title\":\"v1.2: TUI model for runner status\",\"description\":\"Implement a Bubble Tea model that renders:\\n- current task (id + title)\\n- current phase/state string\\n- spinner that advances when new output is detected\\n- last-output age seconds\\n\\nFiles:\\n- Create: internal/ui/tui/model.go\\n- Create: internal/ui/tui/model_test.go\\n\\nAcceptance:\\n- Given status updates, view output contains task id/title and phase string\\n- Spinner advances when notified of new output\\n- Tests run without requiring a real TTY\\n- go test ./... passes\",\"acceptance_criteria\":\"- Renders task and phase\\n- Spinner advances on output events\\n- Tests are deterministic and non-TTY\\n- go test ./... passes\",\"status\":\"closed\",\"priority\":1,\"issue_type\":\"task\",\"owner\":\"g.evstratov@gmail.com\",\"created_at\":\"2026-01-19T15:55:27.275855+03:00\",\"created_by\":\"Gennady Evstratov\",\"updated_at\":\"2026-01-19T19:02:37.853373+03:00\",\"closed_at\":\"2026-01-19T19:02:37.853373+03:00\",\"close_reason\":\"Closed\",\"dependencies\":[{\"issue_id\":\"yolo-runner-127.4.2\",\"depends_on_id\":\"yolo-runner-127.4\",\"type\":\"parent-child\",\"created_at\":\"2026-01-19T15:55:27.276643+03:00\",\"created_by\":\"Gennady Evstratov\"}]}\n {\"id\":\"yolo-runner-127.4.3\",\"title\":\"v1.2: Wire runner phases into TUI\",\"description\":\"Plumb runner phase/state updates into the TUI.\\n\\nFiles:\\n- Modify: internal/runner/runner.go\\n- Create: internal/runner/events.go\\n\\nAcceptance:\\n- Runner emits structured events for: selecting task, bd update, opencode start/end, git add/status/commit, bd close/verify, bd sync\\n- TUI displays current phase based on latest event\\n- go test ./... passes\",\"acceptance_criteria\":\"- Runner emits phase events\\n- TUI updates from events\\n- go test ./... passes\",\"status\":\"closed\",\"priority\":1,\"issue_type\":\"task\",\"owner\":\"g.evstratov@gmail.com\",\"created_at\":\"2026-01-19T15:55:27.357111+03:00\",\"created_by\":\"Gennady Evstratov\",\"updated_at\":\"2026-01-19T19:24:34.458796+03:00\",\"closed_at\":\"2026-01-19T19:24:34.458796+03:00\",\"close_reason\":\"Closed\",\"dependencies\":[{\"issue_id\":\"yolo-runner-127.4.3\",\"depends_on_id\":\"yolo-runner-127.4\",\"type\":\"parent-child\",\"created_at\":\"2026-01-19T15:55:27.357695+03:00\",\"created_by\":\"Gennady Evstratov\"}]}\n-{\"id\":\"yolo-runner-127.4.4\",\"title\":\"v1.2: Headless mode flag\",\"description\":\"Add CLI flag --headless to force plain output (no Bubble Tea), even when stdout is a TTY.\\n\\nFiles:\\n- Modify: cmd/yolo-runner/main.go\\n- Modify: cmd/yolo-runner/main_test.go\\n\\nAcceptance:\\n- Given stdout is a TTY, default is TUI\\n- Given --headless, runner does not start Bubble Tea\\n- go test ./... passes\",\"acceptance_criteria\":\"- Default TUI on TTY\\n- --headless disables TUI\\n- go test ./... passes\",\"status\":\"open\",\"priority\":1,\"issue_type\":\"task\",\"owner\":\"g.evstratov@gmail.com\",\"created_at\":\"2026-01-19T15:55:27.438163+03:00\",\"created_by\":\"Gennady Evstratov\",\"updated_at\":\"2026-01-19T15:55:27.438163+03:00\",\"dependencies\":[{\"issue_id\":\"yolo-runner-127.4.4\",\"depends_on_id\":\"yolo-runner-127.4\",\"type\":\"parent-child\",\"created_at\":\"2026-01-19T15:55:27.438678+03:00\",\"created_by\":\"Gennady Evstratov\"}]}\n+{\"id\":\"yolo-runner-127.4.4\",\"title\":\"v1.2: Headless mode flag\",\"description\":\"Add CLI flag --headless to force plain output (no Bubble Tea), even when stdout is a TTY.\\n\\nFiles:\\n- Modify: cmd/yolo-runner/main.go\\n- Modify: cmd/yolo-runner/main_test.go\\n\\nAcceptance:\\n- Given stdout is a TTY, default is TUI\\n- Given --headless, runner does not start Bubble Tea\\n- go test ./... passes\",\"acceptance_criteria\":\"- Default TUI on TTY\\n- --headless disables TUI\\n- go test ./... passes\",\"status\":\"in_progress\",\"priority\":1,\"issue_type\":\"task\",\"owner\":\"g.evstratov@gmail.com\",\"created_at\":\"2026-01-19T15:55:27.438163+03:00\",\"created_by\":\"Gennady Evstratov\",\"updated_at\":\"2026-01-19T19:24:39.834437+03:00\",\"dependencies\":[{\"issue_id\":\"yolo-runner-127.4.4\",\"depends_on_id\":\"yolo-runner-127.4\",\"type\":\"parent-child\",\"created_at\":\"2026-01-19T15:55:27.438678+03:00\",\"created_by\":\"Gennady Evstratov\"}]}\n {\"id\":\"yolo-runner-127.4.5\",\"title\":\"v1.2: Detect OpenCode log growth for heartbeat\",\"description\":\"Implement a watcher that polls the per-task OpenCode JSONL log file size and sends an event when it grows.\\n\\nFiles:\\n- Create: internal/ui/tui/logwatch.go\\n- Create: internal/ui/tui/logwatch_test.go\\n\\nAcceptance:\\n- Given a file grows, watcher emits an \\\"output\\\" event\\n- Given no growth, watcher emits nothing\\n- Tests use temp files and a fake clock/ticker\\n- go test ./... passes\",\"acceptance_criteria\":\"- Emits event on file growth\\n- No event when no growth\\n- Deterministic tests\\n- go test ./... passes\",\"status\":\"open\",\"priority\":2,\"issue_type\":\"task\",\"owner\":\"g.evstratov@gmail.com\",\"created_at\":\"2026-01-19T15:55:27.519065+03:00\",\"created_by\":\"Gennady Evstratov\",\"updated_at\":\"2026-01-19T15:55:27.519065+03:00\",\"dependencies\":[{\"issue_id\":\"yolo-runner-127.4.5\",\"depends_on_id\":\"yolo-runner-127.4\",\"type\":\"parent-child\",\"created_at\":\"2026-01-19T15:55:27.519738+03:00\",\"created_by\":\"Gennady Evstratov\"}]}\n {\"id\":\"yolo-runner-127.4.6\",\"title\":\"v1.2: Update README for TUI/headless\",\"description\":\"Document the TUI behavior and the --headless flag.\\n\\nFiles:\\n- Modify: README.md\\n\\nAcceptance:\\n- README explains default TUI on TTY\\n- README documents --headless\\n- go test ./... passes\",\"acceptance_criteria\":\"- README documents TUI and --headless\",\"status\":\"open\",\"priority\":3,\"issue_type\":\"task\",\"owner\":\"g.evstratov@gmail.com\",\"created_at\":\"2026-01-19T15:55:27.595872+03:00\",\"created_by\":\"Gennady Evstratov\",\"updated_at\":\"2026-01-19T15:55:27.595872+03:00\",\"dependencies\":[{\"issue_id\":\"yolo-runner-127.4.6\",\"depends_on_id\":\"yolo-runner-127.4\",\"type\":\"parent-child\",\"created_at\":\"2026-01-19T15:55:27.596552+03:00\",\"created_by\":\"Gennady Evstratov\"}]}\n {\"id\":\"yolo-runner-127.4.7\",\"title\":\"v1.2: Detect default root (avoid hardcoded algi-8bt)\",\"description\":\"Fix the Go runner default --root behavior so it does not default to an unrelated project id (algi-8bt).\\n\\nGoal:\\n- If --root is omitted, infer a sensible default for this repo OR fail fast with a clear error.\\n\\nRecommended approach:\\n- If exactly one roadmap root exists (e.g., top-level epic titled \\\"Roadmap\\\"), default to that id.\\n- Otherwise, require --root and print instructions.\\n\\nFiles:\\n- Modify: cmd/yolo-runner/main.go\\n- Modify: cmd/yolo-runner/main_test.go\\n- Modify (if needed): internal/beads/client.go\\n\\nAcceptance:\\n- Given --root is not provided and a unique \\\"Roadmap\\\" epic exists, runner uses that id\\n- Given --root is not provided and no unique default can be inferred, runner exits non-zero with a clear message\\n- Given --root is provided, runner behavior unchanged\\n- go test ./... passes\",\"acceptance_criteria\":\"- Default root is inferred when unique Roadmap epic exists\\n- Otherwise runner fails fast with clear message\\n- Explicit --root still works\\n- go test ./... passes\",\"status\":\"open\",\"priority\":1,\"issue_type\":\"task\",\"owner\":\"g.evstratov@gmail.com\",\"created_at\":\"2026-01-19T16:12:48.996251+03:00\",\"created_by\":\"Gennady Evstratov\",\"updated_at\":\"2026-01-19T16:12:48.996251+03:00\",\"dependencies\":[{\"issue_id\":\"yolo-runner-127.4.7\",\"depends_on_id\":\"yolo-runner-127.4\",\"type\":\"parent-child\",\"created_at\":\"2026-01-19T16:12:48.996902+03:00\",\"created_by\":\"Gennady Evstratov\"}]}\ndiff --git a/cmd/yolo-runner/main.go b/cmd/yolo-runner/main.go\nindex ea7b1da..8a20cb3 100644\n--- a/cmd/yolo-runner/main.go\n+++ b/cmd/yolo-runner/main.go\n@@ -12,7 +12,11 @@ import (\n \t\"yolo-runner/internal/opencode\"\n \t\"yolo-runner/internal/prompt\"\n \t\"yolo-runner/internal/runner\"\n+\t\"yolo-runner/internal/ui/tui\"\n \tgitadapter \"yolo-runner/internal/vcs/git\"\n+\n+\ttea \"github.com/charmbracelet/bubbletea\"\n+\t\"golang.org/x/term\"\n )\n \n type runOnceFunc func(opts runner.RunOnceOptions, deps runner.RunOnceDeps) (string, error)\n@@ -31,6 +35,60 @@ type openCodeRunner interface {\n \tStart(args []string, env map[string]string, stdoutPath string) (opencode.Process, error)\n }\n \n+type tuiProgram interface {\n+\tStart() error\n+\tSend(event runner.Event)\n+\tQuit()\n+}\n+\n+type tuiEmitter struct {\n+\tprogram tuiProgram\n+}\n+\n+func (t tuiEmitter) Emit(event runner.Event) {\n+\tif t.program == nil {\n+\t\treturn\n+\t}\n+\tt.program.Send(event)\n+}\n+\n+type bubbleTUIProgram struct {\n+\tprogram *tea.Program\n+}\n+\n+func (b bubbleTUIProgram) Start() error {\n+\tif b.program == nil {\n+\t\treturn nil\n+\t}\n+\treturn b.program.Start()\n+}\n+\n+func (b bubbleTUIProgram) Send(event runner.Event) {\n+\tif b.program == nil {\n+\t\treturn\n+\t}\n+\tb.program.Send(event)\n+}\n+\n+func (b bubbleTUIProgram) Quit() {\n+\tif b.program == nil {\n+\t\treturn\n+\t}\n+\tb.program.Quit()\n+}\n+\n+var isTerminal = func(writer io.Writer) bool {\n+\tif file, ok := writer.(*os.File); ok {\n+\t\treturn term.IsTerminal(int(file.Fd()))\n+\t}\n+\treturn false\n+}\n+\n+var newTUIProgram = func(stdout io.Writer) tuiProgram {\n+\tprogram := tea.NewProgram(tui.NewModel(nil), tea.WithInput(nil), tea.WithOutput(stdout))\n+\treturn bubbleTUIProgram{program: program}\n+}\n+\n type adapterRunner struct{}\n \n func (adapterRunner) Run(args ...string) (string, error) {\n@@ -59,6 +117,7 @@ func RunOnceMain(args []string, runOnce runOnceFunc, exit exitFunc, stdout io.Wr\n \trootID := fs.String(\"root\", \"algi-8bt\", \"Root bead/epic ID\")\n \tmodel := fs.String(\"model\", \"\", \"OpenCode model\")\n \tdryRun := fs.Bool(\"dry-run\", false, \"Print task and prompt without executing\")\n+\theadless := fs.Bool(\"headless\", false, \"Force plain output without TUI\")\n \tconfigRoot := fs.String(\"config-root\", \"\", \"OpenCode config root\")\n \tconfigDir := fs.String(\"config-dir\", \"\", \"OpenCode config dir\")\n \n@@ -122,7 +181,23 @@ func RunOnceMain(args []string, runOnce runOnceFunc, exit exitFunc, stdout io.Wr\n \t\tstderr = io.Discard\n \t}\n \n+\tvar program tuiProgram\n+\tif !*headless && isTerminal(stdout) {\n+\t\tprogram = newTUIProgram(stdout)\n+\t\tdeps.Events = tuiEmitter{program: program}\n+\t\tif err := program.Start(); err != nil {\n+\t\t\tfmt.Fprintln(stderr, err)\n+\t\t\tif exit != nil {\n+\t\t\t\texit(1)\n+\t\t\t}\n+\t\t\treturn 1\n+\t\t}\n+\t}\n+\n \t_, err := runOnce(options, deps)\n+\tif program != nil {\n+\t\tprogram.Quit()\n+\t}\n \tif err != nil {\n \t\tfmt.Fprintln(stderr, err)\n \t\tif exit != nil {\ndiff --git a/cmd/yolo-runner/main_test.go b/cmd/yolo-runner/main_test.go\nindex db5ad71..fa11b4d 100644\n--- a/cmd/yolo-runner/main_test.go\n+++ b/cmd/yolo-runner/main_test.go\n@@ -3,10 +3,12 @@ package main\n import (\n \t\"bytes\"\n \t\"errors\"\n+\t\"io\"\n \t\"os\"\n \t\"path/filepath\"\n \t\"strings\"\n \t\"testing\"\n+\t\"time\"\n \n \t\"yolo-runner/internal/opencode\"\n \t\"yolo-runner/internal/runner\"\n@@ -171,6 +173,106 @@ func TestRunOnceMainDefaultsConfigPaths(t *testing.T) {\n \t}\n }\n \n+type fakeTUIProgram struct {\n+\tstarted chan struct{}\n+\tquit    chan struct{}\n+\tevents  []runner.Event\n+}\n+\n+func newFakeTUIProgram() *fakeTUIProgram {\n+\treturn &fakeTUIProgram{\n+\t\tstarted: make(chan struct{}),\n+\t\tquit:    make(chan struct{}),\n+\t}\n+}\n+\n+func (f *fakeTUIProgram) Start() error {\n+\tclose(f.started)\n+\treturn nil\n+}\n+\n+func (f *fakeTUIProgram) Send(event runner.Event) {\n+\tf.events = append(f.events, event)\n+}\n+\n+func (f *fakeTUIProgram) Quit() {\n+\tclose(f.quit)\n+}\n+\n+func waitForSignal(t *testing.T, signal chan struct{}, label string) {\n+\tt.Helper()\n+\tselect {\n+\tcase <-signal:\n+\t\treturn\n+\tcase <-time.After(100 * time.Millisecond):\n+\t\tt.Fatalf(\"expected %s\", label)\n+\t}\n+}\n+\n+func TestRunOnceMainUsesTUIOnTTYByDefault(t *testing.T) {\n+\tfakeProgram := newFakeTUIProgram()\n+\tprevIsTerminal := isTerminal\n+\tprevNewTUIProgram := newTUIProgram\n+\tisTerminal = func(io.Writer) bool { return true }\n+\tnewTUIProgram = func(stdout io.Writer) tuiProgram { return fakeProgram }\n+\tt.Cleanup(func() {\n+\t\tisTerminal = prevIsTerminal\n+\t\tnewTUIProgram = prevNewTUIProgram\n+\t})\n+\n+\trunOnce := &fakeRunOnce{result: \"no_tasks\"}\n+\texit := &fakeExit{}\n+\tout := &bytes.Buffer{}\n+\tbeadsRunner := &fakeRunner{}\n+\tgitRunner := &fakeGitRunner{}\n+\n+\tcode := RunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\"}, runOnce.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n+\n+\tif code != 0 {\n+\t\tt.Fatalf(\"expected exit code 0, got %d\", code)\n+\t}\n+\tif runOnce.deps.Events == nil {\n+\t\tt.Fatalf(\"expected events emitter to be set\")\n+\t}\n+\trunOnce.deps.Events.Emit(runner.Event{Type: runner.EventSelectTask})\n+\tif len(fakeProgram.events) != 1 {\n+\t\tt.Fatalf(\"expected event to be forwarded to TUI\")\n+\t}\n+\twaitForSignal(t, fakeProgram.started, \"tui start\")\n+\twaitForSignal(t, fakeProgram.quit, \"tui quit\")\n+}\n+\n+func TestRunOnceMainHeadlessDisablesTUI(t *testing.T) {\n+\tcalled := false\n+\tprevIsTerminal := isTerminal\n+\tprevNewTUIProgram := newTUIProgram\n+\tisTerminal = func(io.Writer) bool { return true }\n+\tnewTUIProgram = func(stdout io.Writer) tuiProgram {\n+\t\tcalled = true\n+\t\treturn newFakeTUIProgram()\n+\t}\n+\tt.Cleanup(func() {\n+\t\tisTerminal = prevIsTerminal\n+\t\tnewTUIProgram = prevNewTUIProgram\n+\t})\n+\n+\trunOnce := &fakeRunOnce{result: \"no_tasks\"}\n+\texit := &fakeExit{}\n+\tout := &bytes.Buffer{}\n+\tbeadsRunner := &fakeRunner{}\n+\tgitRunner := &fakeGitRunner{}\n+\tstderr := &bytes.Buffer{}\n+\n+\tRunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\", \"--headless\"}, runOnce.Run, exit.Exit, out, stderr, beadsRunner, gitRunner)\n+\n+\tif called {\n+\t\tt.Fatalf(\"expected TUI program not to start\")\n+\t}\n+\tif runOnce.deps.Events != nil {\n+\t\tt.Fatalf(\"expected no events emitter in headless mode\")\n+\t}\n+}\n+\n func TestOpenCodeRunDefaultsCreateConfigAndEnv(t *testing.T) {\n \ttempDir := t.TempDir()\n \trepoRoot := filepath.Join(tempDir, \"repo\")\ndiff --git a/runner-logs/beads_yolo_runner.jsonl b/runner-logs/beads_yolo_runner.jsonl\nindex f725320..49e3f3f 100644\n--- a/runner-logs/beads_yolo_runner.jsonl\n+++ b/runner-logs/beads_yolo_runner.jsonl\n@@ -11,3 +11,4 @@\n {\"timestamp\": \"2026-01-19T18:55:57Z\", \"issue_id\": \"yolo-runner-127.4.9.3\", \"title\": \"Align: Document OpenCode config isolation\", \"status\": \"completed\", \"commit_sha\": \"a8a41f8235365dbe9d6175da642b6474f0c85026\"}\n {\"timestamp\": \"2026-01-19T18:59:10Z\", \"issue_id\": \"yolo-runner-127.4.1\", \"title\": \"v1.2: Add Bubble Tea dependency\", \"status\": \"completed\", \"commit_sha\": \"cc8582a8a8b0e27afcbac3d06fdce45ad5f0a170\"}\n {\"timestamp\": \"2026-01-19T19:02:37Z\", \"issue_id\": \"yolo-runner-127.4.2\", \"title\": \"v1.2: TUI model for runner status\", \"status\": \"completed\", \"commit_sha\": \"8e8cc26b9970413399f384dd498a5ce08a2d3d37\"}\n+{\"timestamp\": \"2026-01-19T19:24:34Z\", \"issue_id\": \"yolo-runner-127.4.3\", \"title\": \"v1.2: Wire runner phases into TUI\", \"status\": \"completed\", \"commit_sha\": \"0585becefcbb776410c255013e4bac8bb0056e22\"}\n","title":"Shows git diff","metadata":{"output":"diff --git a/.beads/issues.jsonl b/.beads/issues.jsonl\nindex 8672415..d99de46 100644\n--- a/.beads/issues.jsonl\n+++ b/.beads/issues.jsonl\n@@ -17,7 +17,7 @@\n {\"id\":\"yolo-runner-127.4.1\",\"title\":\"v1.2: Add Bubble Tea dependency\",\"description\":\"Add Bubble Tea dependencies and minimal wiring.\\n\\nFiles:\\n- Modify: go.mod\\n- Modify: go.sum\\n\\nAcceptance:\\n- go test ./... passes\\n- Bubble Tea module is added and buildable\",\"acceptance_criteria\":\"- go test ./... passes\\n- Bubble Tea module is added and buildable\",\"status\":\"closed\",\"priority\":1,\"issue_type\":\"task\",\"owner\":\"g.evstratov@gmail.com\",\"created_at\":\"2026-01-19T15:55:27.195836+03:00\",\"created_by\":\"Gennady Evstratov\",\"updated_at\":\"2026-01-19T18:59:10.354843+03:00\",\"closed_at\":\"2026-01-19T18:59:10.354843+03:00\",\"close_reason\":\"Closed\",\"dependencies\":[{\"issue_id\":\"yolo-runner-127.4.1\",\"depends_on_id\":\"yolo-runner-127.4\",\"type\":\"parent-child\",\"created_at\":\"2026-01-19T15:55:27.196499+03:00\",\"created_by\":\"Gennady Evstratov\"}]}\n {\"id\":\"yolo-runner-127.4.2\",\"title\":\"v1.2: TUI model for runner status\",\"description\":\"Implement a Bubble Tea model that renders:\\n- current task (id + title)\\n- current phase/state string\\n- spinner that advances when new output is detected\\n- last-output age seconds\\n\\nFiles:\\n- Create: internal/ui/tui/model.go\\n- Create: internal/ui/tui/model_test.go\\n\\nAcceptance:\\n- Given status updates, view output contains task id/title and phase string\\n- Spinner advances when notified of new output\\n- Tests run without requiring a real TTY\\n- go test ./... passes\",\"acceptance_criteria\":\"- Renders task and phase\\n- Spinner advances on output events\\n- Tests are deterministic and non-TTY\\n- go test ./... passes\",\"status\":\"closed\",\"priority\":1,\"issue_type\":\"task\",\"owner\":\"g.evstratov@gmail.com\",\"created_at\":\"2026-01-19T15:55:27.275855+03:00\",\"created_by\":\"Gennady Evstratov\",\"updated_at\":\"2026-01-19T19:02:37.853373+03:00\",\"closed_at\":\"2026-01-19T19:02:37.853373+03:00\",\"close_reason\":\"Closed\",\"dependencies\":[{\"issue_id\":\"yolo-runner-127.4.2\",\"depends_on_id\":\"yolo-runner-127.4\",\"type\":\"parent-child\",\"created_at\":\"2026-01-19T15:55:27.276643+03:00\",\"created_by\":\"Gennady Evstratov\"}]}\n {\"id\":\"yolo-runner-127.4.3\",\"title\":\"v1.2: Wire runner phases into TUI\",\"description\":\"Plumb runner phase/state updates into the TUI.\\n\\nFiles:\\n- Modify: internal/runner/runner.go\\n- Create: internal/runner/events.go\\n\\nAcceptance:\\n- Runner emits structured events for: selecting task, bd update, opencode start/end, git add/status/commit, bd close/verify, bd sync\\n- TUI displays current phase based on latest event\\n- go test ./... passes\",\"acceptance_criteria\":\"- Runner emits phase events\\n- TUI updates from events\\n- go test ./... passes\",\"status\":\"closed\",\"priority\":1,\"issue_type\":\"task\",\"owner\":\"g.evstratov@gmail.com\",\"created_at\":\"2026-01-19T15:55:27.357111+03:00\",\"created_by\":\"Gennady Evstratov\",\"updated_at\":\"2026-01-19T19:24:34.458796+03:00\",\"closed_at\":\"2026-01-19T19:24:34.458796+03:00\",\"close_reason\":\"Closed\",\"dependencies\":[{\"issue_id\":\"yolo-runner-127.4.3\",\"depends_on_id\":\"yolo-runner-127.4\",\"type\":\"parent-child\",\"created_at\":\"2026-01-19T15:55:27.357695+03:00\",\"created_by\":\"Gennady Evstratov\"}]}\n-{\"id\":\"yolo-runner-127.4.4\",\"title\":\"v1.2: Headless mode flag\",\"description\":\"Add CLI flag --headless to force plain output (no Bubble Tea), even when stdout is a TTY.\\n\\nFiles:\\n- Modify: cmd/yolo-runner/main.go\\n- Modify: cmd/yolo-runner/main_test.go\\n\\nAcceptance:\\n- Given stdout is a TTY, default is TUI\\n- Given --headless, runner does not start Bubble Tea\\n- go test ./... passes\",\"acceptance_criteria\":\"- Default TUI on TTY\\n- --headless disables TUI\\n- go test ./... passes\",\"status\":\"open\",\"priority\":1,\"issue_type\":\"task\",\"owner\":\"g.evstratov@gmail.com\",\"created_at\":\"2026-01-19T15:55:27.438163+03:00\",\"created_by\":\"Gennady Evstratov\",\"updated_at\":\"2026-01-19T15:55:27.438163+03:00\",\"dependencies\":[{\"issue_id\":\"yolo-runner-127.4.4\",\"depends_on_id\":\"yolo-runner-127.4\",\"type\":\"parent-child\",\"created_at\":\"2026-01-19T15:55:27.438678+03:00\",\"created_by\":\"Gennady Evstratov\"}]}\n+{\"id\":\"yolo-runner-127.4.4\",\"title\":\"v1.2: Headless mode flag\",\"description\":\"Add CLI flag --headless to force plain output (no Bubble Tea), even when stdout is a TTY.\\n\\nFiles:\\n- Modify: cmd/yolo-runner/main.go\\n- Modify: cmd/yolo-runner/main_test.go\\n\\nAcceptance:\\n- Given stdout is a TTY, default is TUI\\n- Given --headless, runner does not start Bubble Tea\\n- go test ./... passes\",\"acceptance_criteria\":\"- Default TUI on TTY\\n- --headless disables TUI\\n- go test ./... passes\",\"status\":\"in_progress\",\"priority\":1,\"issue_type\":\"task\",\"owner\":\"g.evstratov@gmail.com\",\"created_at\":\"2026-01-19T15:55:27.438163+03:00\",\"created_by\":\"Gennady Evstratov\",\"updated_at\":\"2026-01-19T19:24:39.834437+03:00\",\"dependencies\":[{\"issue_id\":\"yolo-runner-127.4.4\",\"depends_on_id\":\"yolo-runner-127.4\",\"type\":\"parent-child\",\"created_at\":\"2026-01-19T15:55:27.438678+03:00\",\"created_by\":\"Gennady Evstratov\"}]}\n {\"id\":\"yolo-runner-127.4.5\",\"title\":\"v1.2: Detect OpenCode log growth for heartbeat\",\"description\":\"Implement a watcher that polls the per-task OpenCode JSONL log file size and sends an event when it grows.\\n\\nFiles:\\n- Create: internal/ui/tui/logwatch.go\\n- Create: internal/ui/tui/logwatch_test.go\\n\\nAcceptance:\\n- Given a file grows, watcher emits an \\\"output\\\" event\\n- Given no growth, watcher emits nothing\\n- Tests use temp files and a fake clock/ticker\\n- go test ./... passes\",\"acceptance_criteria\":\"- Emits event on file growth\\n- No event when no growth\\n- Deterministic tests\\n- go test ./... passes\",\"status\":\"open\",\"priority\":2,\"issue_type\":\"task\",\"owner\":\"g.evstratov@gmail.com\",\"created_at\":\"2026-01-19T15:55:27.519065+03:00\",\"created_by\":\"Gennady Evstratov\",\"updated_at\":\"2026-01-19T15:55:27.519065+03:00\",\"dependencies\":[{\"issue_id\":\"yolo-runner-127.4.5\",\"depends_on_id\":\"yolo-runner-127.4\",\"type\":\"parent-child\",\"created_at\":\"2026-01-19T15:55:27.519738+03:00\",\"created_by\":\"Gennady Evstratov\"}]}\n {\"id\":\"yolo-runner-127.4.6\",\"title\":\"v1.2: Update README for TUI/headless\",\"description\":\"Document the TUI behavior and the --headless flag.\\n\\nFiles:\\n- Modify: README.md\\n\\nAcceptance:\\n- README explains default TUI on TTY\\n- README documents --headless\\n- go test ./... passes\",\"acceptance_criteria\":\"- README documents TUI and --headless\",\"status\":\"open\",\"priority\":3,\"issue_type\":\"task\",\"owner\":\"g.evstratov@gmail.com\",\"created_at\":\"2026-01-19T15:55:27.595872+03:00\",\"created_by\":\"Gennady Evstratov\",\"updated_at\":\"2026-01-19T15:55:27.595872+03:00\",\"dependencies\":[{\"issue_id\":\"yolo-runner-127.4.6\",\"depends_on_id\":\"yolo-runner-127.4\",\"type\":\"parent-child\",\"created_at\":\"2026-01-19T15:55:27.596552+03:00\",\"created_by\":\"Gennady Evstratov\"}]}\n {\"id\":\"yolo-runner-127.4.7\",\"title\":\"v1.2: Detect default root (avoid hardcoded algi-8bt)\",\"description\":\"Fix the Go runner default --root behavior so it does not default to an unrelated project id (algi-8bt).\\n\\nGoal:\\n- If --root is omitted, infer a sensible default for this repo OR fail fast with a clear error.\\n\\nRecommended approach:\\n- If exactly one roadmap root exists (e.g., top-level epic titled \\\"Roadmap\\\"), default to that id.\\n- Otherwise, require --root and print instructions.\\n\\nFiles:\\n- Modify: cmd/yolo-runner/main.go\\n- Modify: cmd/yolo-runner/main_test.go\\n- Modify (if needed): internal/beads/client.go\\n\\nAcceptance:\\n- Given --root is not provided and a unique \\\"Roadmap\\\" epic exists, runner uses that id\\n- Given --root is not provided and no unique default can be inferred, runner exits non-zero with a clear message\\n- Given --root is provided, runner behavior unchanged\\n- go test ./... passes\",\"acceptance_criteria\":\"- Default root is inferred when unique Roadmap epic exists\\n- Otherwise runner fails fast with clear message\\n- Explicit --root still works\\n- go test ./... passes\",\"status\":\"open\",\"priority\":1,\"issue_type\":\"task\",\"owner\":\"g.evstratov@gmail.com\",\"created_at\":\"2026-01-19T16:12:48.996251+03:00\",\"created_by\":\"Gennady Evstratov\",\"updated_at\":\"2026-01-19T16:12:48.996251+03:00\",\"dependencies\":[{\"issue_id\":\"yolo-runner-127.4.7\",\"depends_on_id\":\"yolo-runner-127.4\",\"type\":\"parent-child\",\"created_at\":\"2026-01-19T16:12:48.996902+03:00\",\"created_by\":\"Gennady Evstratov\"}]}\ndiff --git a/cmd/yolo-runner/main.go b/cmd/yolo-runner/main.go\nindex ea7b1da..8a20cb3 100644\n--- a/cmd/yolo-runner/main.go\n+++ b/cmd/yolo-runner/main.go\n@@ -12,7 +12,11 @@ import (\n \t\"yolo-runner/internal/opencode\"\n \t\"yolo-runner/internal/prompt\"\n \t\"yolo-runner/internal/runner\"\n+\t\"yolo-runner/internal/ui/tui\"\n \tgitadapter \"yolo-runner/internal/vcs/git\"\n+\n+\ttea \"github.com/charmbracelet/bubbletea\"\n+\t\"golang.org/x/term\"\n )\n \n type runOnceFunc func(opts runner.RunOnceOptions, deps runner.RunOnceDeps) (string, error)\n@@ -31,6 +35,60 @@ type openCodeRunner interface {\n \tStart(args []string, env map[string]string, stdoutPath string) (opencode.Process, error)\n }\n \n+type tuiProgram interface {\n+\tStart() error\n+\tSend(event runner.Event)\n+\tQuit()\n+}\n+\n+type tuiEmitter struct {\n+\tprogram tuiProgram\n+}\n+\n+func (t tuiEmitter) Emit(event runner.Event) {\n+\tif t.program == nil {\n+\t\treturn\n+\t}\n+\tt.program.Send(event)\n+}\n+\n+type bubbleTUIProgram struct {\n+\tprogram *tea.Program\n+}\n+\n+func (b bubbleTUIProgram) Start() error {\n+\tif b.program == nil {\n+\t\treturn nil\n+\t}\n+\treturn b.program.Start()\n+}\n+\n+func (b bubbleTUIProgram) Send(event runner.Event) {\n+\tif b.program == nil {\n+\t\treturn\n+\t}\n+\tb.program.Send(event)\n+}\n+\n+func (b bubbleTUIProgram) Quit() {\n+\tif b.program == nil {\n+\t\treturn\n+\t}\n+\tb.program.Quit()\n+}\n+\n+var isTerminal = func(writer io.Writer) bool {\n+\tif file, ok := writer.(*os.File); ok {\n+\t\treturn term.IsTerminal(int(file.Fd()))\n+\t}\n+\treturn false\n+}\n+\n+var newTUIProgram = func(stdout io.Writer) tuiProgram {\n+\tprogram := tea.NewProgram(tui.NewModel(nil), tea.WithInput(nil), tea.WithOutput(stdout))\n+\treturn bubbleTUIProgram{program: program}\n+}\n+\n type adapterRunner struct{}\n \n func (adapterRunner) Run(args ...string) (string, error) {\n@@ -59,6 +117,7 @@ func RunOnceMain(args []string, runOnce runOnceFunc, exit exitFunc, stdout io.Wr\n \trootID := fs.String(\"root\", \"algi-8bt\", \"Root bead/epic ID\")\n \tmodel := fs.String(\"model\", \"\", \"OpenCode model\")\n \tdryRun := fs.Bool(\"dry-run\", false, \"Print task and prompt without executing\")\n+\theadless := fs.Bool(\"headless\", false, \"Force plain output without TUI\")\n \tconfigRoot := fs.String(\"config-root\", \"\", \"OpenCode config root\")\n \tconfigDir := fs.String(\"config-dir\", \"\", \"OpenCode config dir\")\n \n@@ -122,7 +181,23 @@ func RunOnceMain(args []string, runOnce runOnceFunc, exit exitFunc, stdout io.Wr\n \t\tstderr = io.Discard\n \t}\n \n+\tvar program tuiProgram\n+\tif !*headless && isTerminal(stdout) {\n+\t\tprogram = newTUIProgram(stdout)\n+\t\tdeps.Events = tuiEmitter{program: program}\n+\t\tif err := program.Start(); err != nil {\n+\t\t\tfmt.Fprintln(stderr, err)\n+\t\t\tif exit != nil {\n+\t\t\t\texit(1)\n+\t\t\t}\n+\t\t\treturn 1\n+\t\t}\n+\t}\n+\n \t_, err := runOnce(options, deps)\n+\tif program != nil {\n+\t\tprogram.Quit()\n+\t}\n \tif err != nil {\n \t\tfmt.Fprintln(stderr, err)\n \t\tif exit != nil {\ndiff --git a/cmd/yolo-runner/main_test.go b/cmd/yolo-runner/main_test.go\nindex db5ad71..fa11b4d 100644\n--- a/cmd/yolo-runner/main_test.go\n+++ b/cmd/yolo-runner/main_test.go\n@@ -3,10 +3,12 @@ package main\n import (\n \t\"bytes\"\n \t\"errors\"\n+\t\"io\"\n \t\"os\"\n \t\"path/filepath\"\n \t\"strings\"\n \t\"testing\"\n+\t\"time\"\n \n \t\"yolo-runner/internal/opencode\"\n \t\"yolo-runner/internal/runner\"\n@@ -171,6 +173,106 @@ func TestRunOnceMainDefaultsConfigPaths(t *testing.T) {\n \t}\n }\n \n+type fakeTUIProgram struct {\n+\tstarted chan struct{}\n+\tquit    chan struct{}\n+\tevents  []runner.Event\n+}\n+\n+func newFakeTUIProgram() *fakeTUIProgram {\n+\treturn &fakeTUIProgram{\n+\t\tstarted: make(chan struct{}),\n+\t\tquit:    make(chan struct{}),\n+\t}\n+}\n+\n+func (f *fakeTUIProgram) Start() error {\n+\tclose(f.started)\n+\treturn nil\n+}\n+\n+func (f *fakeTUIProgram) Send(event runner.Event) {\n+\tf.events = append(f.events, event)\n+}\n+\n+func (f *fakeTUIProgram) Quit() {\n+\tclose(f.quit)\n+}\n+\n+func waitForSignal(t *testing.T, signal chan struct{}, label string) {\n+\tt.Helper()\n+\tselect {\n+\tcase <-signal:\n+\t\treturn\n+\tcase <-time.After(100 * time.Millisecond):\n+\t\tt.Fatalf(\"expected %s\", label)\n+\t}\n+}\n+\n+func TestRunOnceMainUsesTUIOnTTYByDefault(t *testing.T) {\n+\tfakeProgram := newFakeTUIProgram()\n+\tprevIsTerminal := isTerminal\n+\tprevNewTUIProgram := newTUIProgram\n+\tisTerminal = func(io.Writer) bool { return true }\n+\tnewTUIProgram = func(stdout io.Writer) tuiProgram { return fakeProgram }\n+\tt.Cleanup(func() {\n+\t\tisTerminal = prevIsTerminal\n+\t\tnewTUIProgram = prevNewTUIProgram\n+\t})\n+\n+\trunOnce := &fakeRunOnce{result: \"no_tasks\"}\n+\texit := &fakeExit{}\n+\tout := &bytes.Buffer{}\n+\tbeadsRunner := &fakeRunner{}\n+\tgitRunner := &fakeGitRunner{}\n+\n+\tcode := RunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\"}, runOnce.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n+\n+\tif code != 0 {\n+\t\tt.Fatalf(\"expected exit code 0, got %d\", code)\n+\t}\n+\tif runOnce.deps.Events == nil {\n+\t\tt.Fatalf(\"expected events emitter to be set\")\n+\t}\n+\trunOnce.deps.Events.Emit(runner.Event{Type: runner.EventSelectTask})\n+\tif len(fakeProgram.events) != 1 {\n+\t\tt.Fatalf(\"expected event to be forwarded to TUI\")\n+\t}\n+\twaitForSignal(t, fakeProgram.started, \"tui start\")\n+\twaitForSignal(t, fakeProgram.quit, \"tui quit\")\n+}\n+\n+func TestRunOnceMainHeadlessDisablesTUI(t *testing.T) {\n+\tcalled := false\n+\tprevIsTerminal := isTerminal\n+\tprevNewTUIProgram := newTUIProgram\n+\tisTerminal = func(io.Writer) bool { return true }\n+\tnewTUIProgram = func(stdout io.Writer) tuiProgram {\n+\t\tcalled = true\n+\t\treturn newFakeTUIProgram()\n+\t}\n+\tt.Cleanup(func() {\n+\t\tisTerminal = prevIsTerminal\n+\t\tnewTUIProgram = prevNewTUIProgram\n+\t})\n+\n+\trunOnce := &fakeRunOnce{result: \"no_tasks\"}\n+\texit := &fakeExit{}\n+\tout := &bytes.Buffer{}\n+\tbeadsRunner := &fakeRunner{}\n+\tgitRunner := &fakeGitRunner{}\n+\tstderr := &bytes.Buffer{}\n+\n+\tRunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\", \"--headless\"}, runOnce.Run, exit.Exit, out, stderr, beadsRunner, gitRunner)\n+\n+\tif called {\n+\t\tt.Fatalf(\"expected TUI program not to start\")\n+\t}\n+\tif runOnce.deps.Events != nil {\n+\t\tt.Fatalf(\"expected no events emitter in headless mode\")\n+\t}\n+}\n+\n func TestOpenCodeRunDefaultsCreateConfigAndEnv(t *testing.T) {\n \ttempDir := t.TempDir()\n \trepoRoot := filepath.Join(tempDir, \"repo\")\ndiff --git a/runner-logs/beads_yolo_runner.jsonl b/runner-logs/beads_yolo_runner.jsonl\nindex f725320..49e3f3f 100644\n--- a/runner-logs/beads_yolo_runner.jsonl\n+++ b/runner-logs/beads_yolo_runner.jsonl\n@@ -11,3 +11,4 @@\n {\"timestamp\": \"2026-01-19T18:55:57Z\", \"issue_id\": \"yolo-runner-127.4.9.3\", \"title\": \"Align: Document OpenCode config isolation\", \"status\": \"completed\", \"commit_sha\": \"a8a41f8235365dbe9d6175da642b6474f0c85026\"}\n {\"timestamp\": \"2026-01-19T18:59:10Z\", \"issue_id\": \"yolo-runner-127.4.1\", \"title\": \"v1.2: Add Bubble Tea dependency\", \"status\": \"completed\", \"commit_sha\": \"cc8582a8a8b0e27afcbac3d06fdce45ad5f0a170\"}\n {\"timestamp\": \"2026-01-19T19:02:37Z\", \"issue_id\": \"yolo-runner-127.4.2\", \"title\": \"v1.2: TUI model for runner status\", \"status\": \"completed\", \"commit_sha\": \"8e8cc26b9970413399f384dd498a5ce08a2d3d37\"}\n+{\"timestamp\": \"2026-01-19T19:24:34Z\", \"issue_id\": \"yolo-runner-127.4.3\", \"title\": \"v1.2: Wire runner phases into TUI\", \"status\": \"completed\", \"commit_sha\": \"0585becefcbb776410c255013e4bac8bb0056e22\"}\n","exit":0,"description":"Shows git diff","truncated":false},"time":{"start":1768840781031,"end":1768840781042}},"metadata":{"openai":{"itemId":"fc_05631b7c6cac713f01696e5e4c1b208191bbf7509627cb1c10"}}}}
{"type":"step_finish","timestamp":1768840781059,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd7205cf2001kBMxPo4ST4OOAS","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd720528e0017pGLfvzOMeyDiw","type":"step-finish","reason":"tool-calls","snapshot":"38aaaab5db7452a97df61330a0f8168e8ddd6dca","cost":0,"tokens":{"input":223,"output":92,"reasoning":0,"cache":{"read":25344,"write":0}}}}
{"type":"step_start","timestamp":1768840781429,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd7205e74001HJhi2sIlKUBgqN","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd7205d24001f8u1Pi1bO135A0","type":"step-start","snapshot":"b8b11568ace664777a2f20e8b0f619a0c6be262b"}}
{"type":"tool_use","timestamp":1768840827628,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd7210cf7001AhhiqeiLf87DCX","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd7205d24001f8u1Pi1bO135A0","type":"tool","callID":"call_RsMZno5wjOrXPxHFRBGYnrkH","tool":"edit","state":{"status":"completed","input":{"filePath":"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main.go","oldString":"type tuiEmitter struct {\n\tprogram tuiProgram\n}\n\nfunc (t tuiEmitter) Emit(event runner.Event) {\n\tif t.program == nil {\n\t\treturn\n\t}\n\tt.program.Send(event)\n}\n","newString":"type tuiEmitter struct {\n\tprogram tuiProgram\n}\n\nfunc (t tuiEmitter) Emit(event runner.Event) {\n\tif t.program == nil {\n\t\treturn\n\t}\n\tgo t.program.Send(event)\n}\n"},"output":"Edit applied successfully.","title":"cmd/yolo-runner/main.go","metadata":{"diagnostics":{"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main.go":[],"/Users/egv/dev/yolo-runner/go.mod":[{"range":{"start":{"line":6,"character":44},"end":{"line":6,"character":55}},"severity":2,"source":"go mod tidy","message":"github.com/charmbracelet/bubbletea should be direct"},{"range":{"start":{"line":19,"character":26},"end":{"line":19,"character":37}},"severity":2,"source":"go mod tidy","message":"golang.org/x/term should be direct"}],"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go":[],"/Users/egv/dev/yolo-runner/bubbletea_test.go":[],"/Users/egv/dev/yolo-runner/opencode_adapter_v1.go":[{"range":{"start":{"line":24,"character":1},"end":{"line":24,"character":18}},"severity":2,"code":"default","codeDescription":{"href":"https://staticcheck.dev/docs/checks/#S1031"},"source":"S1031","message":"unnecessary nil check around range"}],"/Users/egv/dev/yolo-runner/internal/ui/tui/model.go":[],"/Users/egv/dev/yolo-runner/internal/runner/runner.go":[],"/Users/egv/dev/yolo-runner/internal/ui/tui/model_test.go":[],"/Users/egv/dev/yolo-runner/internal/runner/events.go":[],"/Users/egv/dev/yolo-runner/internal/runner/loop_test.go":[],"/Users/egv/dev/yolo-runner/internal/runner/runner_test.go":[],"/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/tea.go":[],"/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/tty_unix.go":[],"/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/tty.go":[],"/Users/egv/dev/yolo-runner/internal/opencode/watchdog.go":[],"/Users/egv/dev/yolo-runner/internal/opencode/client.go":[{"range":{"start":{"line":28,"character":1},"end":{"line":28,"character":18}},"severity":2,"code":"default","codeDescription":{"href":"https://staticcheck.dev/docs/checks/#S1031"},"source":"S1031","message":"unnecessary nil check around range"}],"/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/options.go":[],"/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/tty_windows.go":[{"range":{"start":{"line":3,"character":8},"end":{"line":3,"character":11}},"severity":2,"source":"go list","message":"This file is within module \"../../go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0\", which is not included in your workspace.\nTo fix this problem, you can add a go.work file that uses this directory.\nSee the documentation for more information on setting up your workspace:\nhttps://github.com/golang/tools/blob/master/gopls/doc/workspace.md.","data":{"Actions":[{"title":"Add a go.work file using this module","kind":"quickfix","command":{"title":"Run `go work init && go work use`","command":"gopls.run_go_work_command","arguments":[{"ViewID":"1","InitFirst":true,"Args":["use","../../go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0"]}]}}]}}]},"diff":"Index: /Users/egv/dev/yolo-runner/cmd/yolo-runner/main.go\n===================================================================\n--- /Users/egv/dev/yolo-runner/cmd/yolo-runner/main.go\n+++ /Users/egv/dev/yolo-runner/cmd/yolo-runner/main.go\n@@ -48,9 +48,9 @@\n func (t tuiEmitter) Emit(event runner.Event) {\n \tif t.program == nil {\n \t\treturn\n \t}\n-\tt.program.Send(event)\n+\tgo t.program.Send(event)\n }\n \n type bubbleTUIProgram struct {\n \tprogram *tea.Program\n","filediff":{"file":"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main.go","before":"package main\n\nimport (\n\t\"flag\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n\n\t\"yolo-runner/internal/beads\"\n\t\"yolo-runner/internal/logging\"\n\t\"yolo-runner/internal/opencode\"\n\t\"yolo-runner/internal/prompt\"\n\t\"yolo-runner/internal/runner\"\n\t\"yolo-runner/internal/ui/tui\"\n\tgitadapter \"yolo-runner/internal/vcs/git\"\n\n\ttea \"github.com/charmbracelet/bubbletea\"\n\t\"golang.org/x/term\"\n)\n\ntype runOnceFunc func(opts runner.RunOnceOptions, deps runner.RunOnceDeps) (string, error)\n\ntype exitFunc func(code int)\n\ntype beadsRunner interface {\n\tRun(args ...string) (string, error)\n}\n\ntype gitRunner interface {\n\tRun(name string, args ...string) (string, error)\n}\n\ntype openCodeRunner interface {\n\tStart(args []string, env map[string]string, stdoutPath string) (opencode.Process, error)\n}\n\ntype tuiProgram interface {\n\tStart() error\n\tSend(event runner.Event)\n\tQuit()\n}\n\ntype tuiEmitter struct {\n\tprogram tuiProgram\n}\n\nfunc (t tuiEmitter) Emit(event runner.Event) {\n\tif t.program == nil {\n\t\treturn\n\t}\n\tt.program.Send(event)\n}\n\ntype bubbleTUIProgram struct {\n\tprogram *tea.Program\n}\n\nfunc (b bubbleTUIProgram) Start() error {\n\tif b.program == nil {\n\t\treturn nil\n\t}\n\treturn b.program.Start()\n}\n\nfunc (b bubbleTUIProgram) Send(event runner.Event) {\n\tif b.program == nil {\n\t\treturn\n\t}\n\tb.program.Send(event)\n}\n\nfunc (b bubbleTUIProgram) Quit() {\n\tif b.program == nil {\n\t\treturn\n\t}\n\tb.program.Quit()\n}\n\nvar isTerminal = func(writer io.Writer) bool {\n\tif file, ok := writer.(*os.File); ok {\n\t\treturn term.IsTerminal(int(file.Fd()))\n\t}\n\treturn false\n}\n\nvar newTUIProgram = func(stdout io.Writer) tuiProgram {\n\tprogram := tea.NewProgram(tui.NewModel(nil), tea.WithInput(nil), tea.WithOutput(stdout))\n\treturn bubbleTUIProgram{program: program}\n}\n\ntype adapterRunner struct{}\n\nfunc (adapterRunner) Run(args ...string) (string, error) {\n\treturn runCommand(args...)\n}\n\ntype adapterGitRunner struct{}\n\nfunc (adapterGitRunner) Run(name string, args ...string) (string, error) {\n\treturn runCommand(append([]string{name}, args...)...)\n}\n\ntype openCodeAdapter struct {\n\trunner openCodeRunner\n}\n\nfunc (o openCodeAdapter) Run(issueID string, repoRoot string, promptText string, model string, configRoot string, configDir string, logPath string) error {\n\treturn opencode.Run(issueID, repoRoot, promptText, model, configRoot, configDir, logPath, o.runner)\n}\n\nfunc RunOnceMain(args []string, runOnce runOnceFunc, exit exitFunc, stdout io.Writer, stderr io.Writer, beadsRunner beadsRunner, gitRunner gitRunner) int {\n\tfs := flag.NewFlagSet(\"yolo-runner\", flag.ContinueOnError)\n\tfs.SetOutput(stderr)\n\n\trepoRoot := fs.String(\"repo\", \".\", \"Repository root path\")\n\trootID := fs.String(\"root\", \"algi-8bt\", \"Root bead/epic ID\")\n\tmodel := fs.String(\"model\", \"\", \"OpenCode model\")\n\tdryRun := fs.Bool(\"dry-run\", false, \"Print task and prompt without executing\")\n\theadless := fs.Bool(\"headless\", false, \"Force plain output without TUI\")\n\tconfigRoot := fs.String(\"config-root\", \"\", \"OpenCode config root\")\n\tconfigDir := fs.String(\"config-dir\", \"\", \"OpenCode config dir\")\n\n\tif err := fs.Parse(args); err != nil {\n\t\tfmt.Fprintln(stderr, err)\n\t\tif exit != nil {\n\t\t\texit(1)\n\t\t}\n\t\treturn 1\n\t}\n\n\tif runOnce == nil {\n\t\trunOnce = runner.RunOnce\n\t}\n\n\tif beadsRunner == nil {\n\t\tbeadsRunner = adapterRunner{}\n\t}\n\tif gitRunner == nil {\n\t\tgitRunner = adapterGitRunner{}\n\t}\n\n\tbeadsAdapter := beads.New(beadsRunner)\n\tgitAdapter := gitadapter.New(gitRunner)\n\topenCodeAdapter := openCodeAdapter{runner: defaultOpenCodeRunner{}}\n\n\tdeps := runner.RunOnceDeps{\n\t\tBeads:    beadsAdapter,\n\t\tPrompt:   promptBuilder{},\n\t\tOpenCode: openCodeAdapter,\n\t\tGit:      gitAdapter,\n\t\tLogger:   runnerLogger{},\n\t}\n\n\tresolvedConfigRoot := *configRoot\n\tresolvedConfigDir := *configDir\n\tif resolvedConfigRoot == \"\" {\n\t\thomeDir := os.Getenv(\"HOME\")\n\t\tif homeDir != \"\" {\n\t\t\tresolvedConfigRoot = filepath.Join(homeDir, \".config\", \"opencode-runner\")\n\t\t}\n\t}\n\tif resolvedConfigDir == \"\" && resolvedConfigRoot != \"\" {\n\t\tresolvedConfigDir = filepath.Join(resolvedConfigRoot, \"opencode\")\n\t}\n\n\toptions := runner.RunOnceOptions{\n\t\tRepoRoot:   *repoRoot,\n\t\tRootID:     *rootID,\n\t\tModel:      *model,\n\t\tConfigRoot: resolvedConfigRoot,\n\t\tConfigDir:  resolvedConfigDir,\n\t\tDryRun:     *dryRun,\n\t\tOut:        stdout,\n\t}\n\n\tif stdout == nil {\n\t\toptions.Out = io.Discard\n\t}\n\tif stderr == nil {\n\t\tstderr = io.Discard\n\t}\n\n\tvar program tuiProgram\n\tif !*headless && isTerminal(stdout) {\n\t\tprogram = newTUIProgram(stdout)\n\t\tdeps.Events = tuiEmitter{program: program}\n\t\tif err := program.Start(); err != nil {\n\t\t\tfmt.Fprintln(stderr, err)\n\t\t\tif exit != nil {\n\t\t\t\texit(1)\n\t\t\t}\n\t\t\treturn 1\n\t\t}\n\t}\n\n\t_, err := runOnce(options, deps)\n\tif program != nil {\n\t\tprogram.Quit()\n\t}\n\tif err != nil {\n\t\tfmt.Fprintln(stderr, err)\n\t\tif exit != nil {\n\t\t\texit(1)\n\t\t}\n\t\treturn 1\n\t}\n\n\tif exit != nil {\n\t\texit(0)\n\t}\n\treturn 0\n}\n\nfunc main() {\n\tRunOnceMain(os.Args[1:], runner.RunOnce, os.Exit, os.Stdout, os.Stderr, nil, nil)\n}\n\ntype promptBuilder struct{}\n\nfunc (promptBuilder) Build(issueID string, title string, description string, acceptance string) string {\n\treturn prompt.Build(issueID, title, description, acceptance)\n}\n\ntype runnerLogger struct{}\n\nfunc (runnerLogger) AppendRunnerSummary(repoRoot string, issueID string, title string, status string, commitSHA string) error {\n\treturn logging.AppendRunnerSummary(repoRoot, issueID, title, status, commitSHA)\n}\n\ntype defaultOpenCodeRunner struct{}\n\nfunc (defaultOpenCodeRunner) Start(args []string, env map[string]string, stdoutPath string) (opencode.Process, error) {\n\treturn startCommandWithEnv(args, env, stdoutPath)\n}\n","after":"package main\n\nimport (\n\t\"flag\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n\n\t\"yolo-runner/internal/beads\"\n\t\"yolo-runner/internal/logging\"\n\t\"yolo-runner/internal/opencode\"\n\t\"yolo-runner/internal/prompt\"\n\t\"yolo-runner/internal/runner\"\n\t\"yolo-runner/internal/ui/tui\"\n\tgitadapter \"yolo-runner/internal/vcs/git\"\n\n\ttea \"github.com/charmbracelet/bubbletea\"\n\t\"golang.org/x/term\"\n)\n\ntype runOnceFunc func(opts runner.RunOnceOptions, deps runner.RunOnceDeps) (string, error)\n\ntype exitFunc func(code int)\n\ntype beadsRunner interface {\n\tRun(args ...string) (string, error)\n}\n\ntype gitRunner interface {\n\tRun(name string, args ...string) (string, error)\n}\n\ntype openCodeRunner interface {\n\tStart(args []string, env map[string]string, stdoutPath string) (opencode.Process, error)\n}\n\ntype tuiProgram interface {\n\tStart() error\n\tSend(event runner.Event)\n\tQuit()\n}\n\ntype tuiEmitter struct {\n\tprogram tuiProgram\n}\n\nfunc (t tuiEmitter) Emit(event runner.Event) {\n\tif t.program == nil {\n\t\treturn\n\t}\n\tgo t.program.Send(event)\n}\n\ntype bubbleTUIProgram struct {\n\tprogram *tea.Program\n}\n\nfunc (b bubbleTUIProgram) Start() error {\n\tif b.program == nil {\n\t\treturn nil\n\t}\n\treturn b.program.Start()\n}\n\nfunc (b bubbleTUIProgram) Send(event runner.Event) {\n\tif b.program == nil {\n\t\treturn\n\t}\n\tb.program.Send(event)\n}\n\nfunc (b bubbleTUIProgram) Quit() {\n\tif b.program == nil {\n\t\treturn\n\t}\n\tb.program.Quit()\n}\n\nvar isTerminal = func(writer io.Writer) bool {\n\tif file, ok := writer.(*os.File); ok {\n\t\treturn term.IsTerminal(int(file.Fd()))\n\t}\n\treturn false\n}\n\nvar newTUIProgram = func(stdout io.Writer) tuiProgram {\n\tprogram := tea.NewProgram(tui.NewModel(nil), tea.WithInput(nil), tea.WithOutput(stdout))\n\treturn bubbleTUIProgram{program: program}\n}\n\ntype adapterRunner struct{}\n\nfunc (adapterRunner) Run(args ...string) (string, error) {\n\treturn runCommand(args...)\n}\n\ntype adapterGitRunner struct{}\n\nfunc (adapterGitRunner) Run(name string, args ...string) (string, error) {\n\treturn runCommand(append([]string{name}, args...)...)\n}\n\ntype openCodeAdapter struct {\n\trunner openCodeRunner\n}\n\nfunc (o openCodeAdapter) Run(issueID string, repoRoot string, promptText string, model string, configRoot string, configDir string, logPath string) error {\n\treturn opencode.Run(issueID, repoRoot, promptText, model, configRoot, configDir, logPath, o.runner)\n}\n\nfunc RunOnceMain(args []string, runOnce runOnceFunc, exit exitFunc, stdout io.Writer, stderr io.Writer, beadsRunner beadsRunner, gitRunner gitRunner) int {\n\tfs := flag.NewFlagSet(\"yolo-runner\", flag.ContinueOnError)\n\tfs.SetOutput(stderr)\n\n\trepoRoot := fs.String(\"repo\", \".\", \"Repository root path\")\n\trootID := fs.String(\"root\", \"algi-8bt\", \"Root bead/epic ID\")\n\tmodel := fs.String(\"model\", \"\", \"OpenCode model\")\n\tdryRun := fs.Bool(\"dry-run\", false, \"Print task and prompt without executing\")\n\theadless := fs.Bool(\"headless\", false, \"Force plain output without TUI\")\n\tconfigRoot := fs.String(\"config-root\", \"\", \"OpenCode config root\")\n\tconfigDir := fs.String(\"config-dir\", \"\", \"OpenCode config dir\")\n\n\tif err := fs.Parse(args); err != nil {\n\t\tfmt.Fprintln(stderr, err)\n\t\tif exit != nil {\n\t\t\texit(1)\n\t\t}\n\t\treturn 1\n\t}\n\n\tif runOnce == nil {\n\t\trunOnce = runner.RunOnce\n\t}\n\n\tif beadsRunner == nil {\n\t\tbeadsRunner = adapterRunner{}\n\t}\n\tif gitRunner == nil {\n\t\tgitRunner = adapterGitRunner{}\n\t}\n\n\tbeadsAdapter := beads.New(beadsRunner)\n\tgitAdapter := gitadapter.New(gitRunner)\n\topenCodeAdapter := openCodeAdapter{runner: defaultOpenCodeRunner{}}\n\n\tdeps := runner.RunOnceDeps{\n\t\tBeads:    beadsAdapter,\n\t\tPrompt:   promptBuilder{},\n\t\tOpenCode: openCodeAdapter,\n\t\tGit:      gitAdapter,\n\t\tLogger:   runnerLogger{},\n\t}\n\n\tresolvedConfigRoot := *configRoot\n\tresolvedConfigDir := *configDir\n\tif resolvedConfigRoot == \"\" {\n\t\thomeDir := os.Getenv(\"HOME\")\n\t\tif homeDir != \"\" {\n\t\t\tresolvedConfigRoot = filepath.Join(homeDir, \".config\", \"opencode-runner\")\n\t\t}\n\t}\n\tif resolvedConfigDir == \"\" && resolvedConfigRoot != \"\" {\n\t\tresolvedConfigDir = filepath.Join(resolvedConfigRoot, \"opencode\")\n\t}\n\n\toptions := runner.RunOnceOptions{\n\t\tRepoRoot:   *repoRoot,\n\t\tRootID:     *rootID,\n\t\tModel:      *model,\n\t\tConfigRoot: resolvedConfigRoot,\n\t\tConfigDir:  resolvedConfigDir,\n\t\tDryRun:     *dryRun,\n\t\tOut:        stdout,\n\t}\n\n\tif stdout == nil {\n\t\toptions.Out = io.Discard\n\t}\n\tif stderr == nil {\n\t\tstderr = io.Discard\n\t}\n\n\tvar program tuiProgram\n\tif !*headless && isTerminal(stdout) {\n\t\tprogram = newTUIProgram(stdout)\n\t\tdeps.Events = tuiEmitter{program: program}\n\t\tif err := program.Start(); err != nil {\n\t\t\tfmt.Fprintln(stderr, err)\n\t\t\tif exit != nil {\n\t\t\t\texit(1)\n\t\t\t}\n\t\t\treturn 1\n\t\t}\n\t}\n\n\t_, err := runOnce(options, deps)\n\tif program != nil {\n\t\tprogram.Quit()\n\t}\n\tif err != nil {\n\t\tfmt.Fprintln(stderr, err)\n\t\tif exit != nil {\n\t\t\texit(1)\n\t\t}\n\t\treturn 1\n\t}\n\n\tif exit != nil {\n\t\texit(0)\n\t}\n\treturn 0\n}\n\nfunc main() {\n\tRunOnceMain(os.Args[1:], runner.RunOnce, os.Exit, os.Stdout, os.Stderr, nil, nil)\n}\n\ntype promptBuilder struct{}\n\nfunc (promptBuilder) Build(issueID string, title string, description string, acceptance string) string {\n\treturn prompt.Build(issueID, title, description, acceptance)\n}\n\ntype runnerLogger struct{}\n\nfunc (runnerLogger) AppendRunnerSummary(repoRoot string, issueID string, title string, status string, commitSHA string) error {\n\treturn logging.AppendRunnerSummary(repoRoot, issueID, title, status, commitSHA)\n}\n\ntype defaultOpenCodeRunner struct{}\n\nfunc (defaultOpenCodeRunner) Start(args []string, env map[string]string, stdoutPath string) (opencode.Process, error) {\n\treturn startCommandWithEnv(args, env, stdoutPath)\n}\n","additions":1,"deletions":1},"truncated":false},"time":{"start":1768840827468,"end":1768840827627}},"metadata":{"openai":{"itemId":"fc_02260babbb9856f201696e5e7a14048191a34ed9355a848450"}}}}
{"type":"step_finish","timestamp":1768840827648,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd72112ec001ukTEOjw5N4203L","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd7205d24001f8u1Pi1bO135A0","type":"step-finish","reason":"tool-calls","snapshot":"ce68e32a95ebea86a75f53bb7b5b211f1f94abe6","cost":0,"tokens":{"input":5143,"output":2068,"reasoning":1920,"cache":{"read":51072,"write":0}}}}
{"type":"step_start","timestamp":1768840828487,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd72116460014ug40o8Jw14rFo","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd7211325001dfqxs5Q11BpztF","type":"step-start","snapshot":"366d3d9b7d08b404ba1c4a884abf4220a9176ca2"}}
{"type":"tool_use","timestamp":1768840834530,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd721194d0011ORdRbtoyok3Wc","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd7211325001dfqxs5Q11BpztF","type":"tool","callID":"call_AZIKFO7ZiUwVQVhO8lxe8owd","tool":"edit","state":{"status":"completed","input":{"filePath":"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main.go","oldString":"\tvar program tuiProgram\n\tif !*headless && isTerminal(stdout) {\n\t\tprogram = newTUIProgram(stdout)\n\t\tdeps.Events = tuiEmitter{program: program}\n\t\tif err := program.Start(); err != nil {\n\t\t\tfmt.Fprintln(stderr, err)\n\t\t\tif exit != nil {\n\t\t\t\texit(1)\n\t\t\t}\n\t\t\treturn 1\n\t\t}\n\t}\n\n\t_, err := runOnce(options, deps)\n\tif program != nil {\n\t\tprogram.Quit()\n\t}\n","newString":"\tvar program tuiProgram\n\tif !*headless && isTerminal(stdout) {\n\t\tprogram = newTUIProgram(stdout)\n\t\tdeps.Events = tuiEmitter{program: program}\n\t\tgo func() {\n\t\t\tif err := program.Start(); err != nil {\n\t\t\t\tfmt.Fprintln(stderr, err)\n\t\t\t\tif exit != nil {\n\t\t\t\t\texit(1)\n\t\t\t\t}\n\t\t\t}\n\t\t}()\n\t}\n\n\t_, err := runOnce(options, deps)\n\tif program != nil {\n\t\tprogram.Quit()\n\t}\n"},"output":"Edit applied successfully.","title":"cmd/yolo-runner/main.go","metadata":{"diagnostics":{"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main.go":[],"/Users/egv/dev/yolo-runner/go.mod":[{"range":{"start":{"line":6,"character":44},"end":{"line":6,"character":55}},"severity":2,"source":"go mod tidy","message":"github.com/charmbracelet/bubbletea should be direct"},{"range":{"start":{"line":19,"character":26},"end":{"line":19,"character":37}},"severity":2,"source":"go mod tidy","message":"golang.org/x/term should be direct"}],"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go":[],"/Users/egv/dev/yolo-runner/bubbletea_test.go":[],"/Users/egv/dev/yolo-runner/opencode_adapter_v1.go":[{"range":{"start":{"line":24,"character":1},"end":{"line":24,"character":18}},"severity":2,"code":"default","codeDescription":{"href":"https://staticcheck.dev/docs/checks/#S1031"},"source":"S1031","message":"unnecessary nil check around range"}],"/Users/egv/dev/yolo-runner/internal/ui/tui/model.go":[],"/Users/egv/dev/yolo-runner/internal/runner/runner.go":[],"/Users/egv/dev/yolo-runner/internal/ui/tui/model_test.go":[],"/Users/egv/dev/yolo-runner/internal/runner/events.go":[],"/Users/egv/dev/yolo-runner/internal/runner/loop_test.go":[],"/Users/egv/dev/yolo-runner/internal/runner/runner_test.go":[],"/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/tea.go":[],"/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/tty_unix.go":[],"/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/tty.go":[],"/Users/egv/dev/yolo-runner/internal/opencode/watchdog.go":[],"/Users/egv/dev/yolo-runner/internal/opencode/client.go":[{"range":{"start":{"line":28,"character":1},"end":{"line":28,"character":18}},"severity":2,"code":"default","codeDescription":{"href":"https://staticcheck.dev/docs/checks/#S1031"},"source":"S1031","message":"unnecessary nil check around range"}],"/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/options.go":[],"/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/tty_windows.go":[{"range":{"start":{"line":3,"character":8},"end":{"line":3,"character":11}},"severity":2,"source":"go list","message":"This file is within module \"../../go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0\", which is not included in your workspace.\nTo fix this problem, you can add a go.work file that uses this directory.\nSee the documentation for more information on setting up your workspace:\nhttps://github.com/golang/tools/blob/master/gopls/doc/workspace.md.","data":{"Actions":[{"title":"Add a go.work file using this module","kind":"quickfix","command":{"title":"Run `go work init && go work use`","command":"gopls.run_go_work_command","arguments":[{"ViewID":"1","InitFirst":true,"Args":["use","../../go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0"]}]}}]}}]},"diff":"Index: /Users/egv/dev/yolo-runner/cmd/yolo-runner/main.go\n===================================================================\n--- /Users/egv/dev/yolo-runner/cmd/yolo-runner/main.go\n+++ /Users/egv/dev/yolo-runner/cmd/yolo-runner/main.go\n@@ -184,15 +184,16 @@\n var program tuiProgram\n if !*headless && isTerminal(stdout) {\n \tprogram = newTUIProgram(stdout)\n \tdeps.Events = tuiEmitter{program: program}\n-\tif err := program.Start(); err != nil {\n-\t\tfmt.Fprintln(stderr, err)\n-\t\tif exit != nil {\n-\t\t\texit(1)\n+\tgo func() {\n+\t\tif err := program.Start(); err != nil {\n+\t\t\tfmt.Fprintln(stderr, err)\n+\t\t\tif exit != nil {\n+\t\t\t\texit(1)\n+\t\t\t}\n \t\t}\n-\t\treturn 1\n-\t}\n+\t}()\n }\n \n _, err := runOnce(options, deps)\n if program != nil {\n","filediff":{"file":"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main.go","before":"package main\n\nimport (\n\t\"flag\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n\n\t\"yolo-runner/internal/beads\"\n\t\"yolo-runner/internal/logging\"\n\t\"yolo-runner/internal/opencode\"\n\t\"yolo-runner/internal/prompt\"\n\t\"yolo-runner/internal/runner\"\n\t\"yolo-runner/internal/ui/tui\"\n\tgitadapter \"yolo-runner/internal/vcs/git\"\n\n\ttea \"github.com/charmbracelet/bubbletea\"\n\t\"golang.org/x/term\"\n)\n\ntype runOnceFunc func(opts runner.RunOnceOptions, deps runner.RunOnceDeps) (string, error)\n\ntype exitFunc func(code int)\n\ntype beadsRunner interface {\n\tRun(args ...string) (string, error)\n}\n\ntype gitRunner interface {\n\tRun(name string, args ...string) (string, error)\n}\n\ntype openCodeRunner interface {\n\tStart(args []string, env map[string]string, stdoutPath string) (opencode.Process, error)\n}\n\ntype tuiProgram interface {\n\tStart() error\n\tSend(event runner.Event)\n\tQuit()\n}\n\ntype tuiEmitter struct {\n\tprogram tuiProgram\n}\n\nfunc (t tuiEmitter) Emit(event runner.Event) {\n\tif t.program == nil {\n\t\treturn\n\t}\n\tgo t.program.Send(event)\n}\n\ntype bubbleTUIProgram struct {\n\tprogram *tea.Program\n}\n\nfunc (b bubbleTUIProgram) Start() error {\n\tif b.program == nil {\n\t\treturn nil\n\t}\n\treturn b.program.Start()\n}\n\nfunc (b bubbleTUIProgram) Send(event runner.Event) {\n\tif b.program == nil {\n\t\treturn\n\t}\n\tb.program.Send(event)\n}\n\nfunc (b bubbleTUIProgram) Quit() {\n\tif b.program == nil {\n\t\treturn\n\t}\n\tb.program.Quit()\n}\n\nvar isTerminal = func(writer io.Writer) bool {\n\tif file, ok := writer.(*os.File); ok {\n\t\treturn term.IsTerminal(int(file.Fd()))\n\t}\n\treturn false\n}\n\nvar newTUIProgram = func(stdout io.Writer) tuiProgram {\n\tprogram := tea.NewProgram(tui.NewModel(nil), tea.WithInput(nil), tea.WithOutput(stdout))\n\treturn bubbleTUIProgram{program: program}\n}\n\ntype adapterRunner struct{}\n\nfunc (adapterRunner) Run(args ...string) (string, error) {\n\treturn runCommand(args...)\n}\n\ntype adapterGitRunner struct{}\n\nfunc (adapterGitRunner) Run(name string, args ...string) (string, error) {\n\treturn runCommand(append([]string{name}, args...)...)\n}\n\ntype openCodeAdapter struct {\n\trunner openCodeRunner\n}\n\nfunc (o openCodeAdapter) Run(issueID string, repoRoot string, promptText string, model string, configRoot string, configDir string, logPath string) error {\n\treturn opencode.Run(issueID, repoRoot, promptText, model, configRoot, configDir, logPath, o.runner)\n}\n\nfunc RunOnceMain(args []string, runOnce runOnceFunc, exit exitFunc, stdout io.Writer, stderr io.Writer, beadsRunner beadsRunner, gitRunner gitRunner) int {\n\tfs := flag.NewFlagSet(\"yolo-runner\", flag.ContinueOnError)\n\tfs.SetOutput(stderr)\n\n\trepoRoot := fs.String(\"repo\", \".\", \"Repository root path\")\n\trootID := fs.String(\"root\", \"algi-8bt\", \"Root bead/epic ID\")\n\tmodel := fs.String(\"model\", \"\", \"OpenCode model\")\n\tdryRun := fs.Bool(\"dry-run\", false, \"Print task and prompt without executing\")\n\theadless := fs.Bool(\"headless\", false, \"Force plain output without TUI\")\n\tconfigRoot := fs.String(\"config-root\", \"\", \"OpenCode config root\")\n\tconfigDir := fs.String(\"config-dir\", \"\", \"OpenCode config dir\")\n\n\tif err := fs.Parse(args); err != nil {\n\t\tfmt.Fprintln(stderr, err)\n\t\tif exit != nil {\n\t\t\texit(1)\n\t\t}\n\t\treturn 1\n\t}\n\n\tif runOnce == nil {\n\t\trunOnce = runner.RunOnce\n\t}\n\n\tif beadsRunner == nil {\n\t\tbeadsRunner = adapterRunner{}\n\t}\n\tif gitRunner == nil {\n\t\tgitRunner = adapterGitRunner{}\n\t}\n\n\tbeadsAdapter := beads.New(beadsRunner)\n\tgitAdapter := gitadapter.New(gitRunner)\n\topenCodeAdapter := openCodeAdapter{runner: defaultOpenCodeRunner{}}\n\n\tdeps := runner.RunOnceDeps{\n\t\tBeads:    beadsAdapter,\n\t\tPrompt:   promptBuilder{},\n\t\tOpenCode: openCodeAdapter,\n\t\tGit:      gitAdapter,\n\t\tLogger:   runnerLogger{},\n\t}\n\n\tresolvedConfigRoot := *configRoot\n\tresolvedConfigDir := *configDir\n\tif resolvedConfigRoot == \"\" {\n\t\thomeDir := os.Getenv(\"HOME\")\n\t\tif homeDir != \"\" {\n\t\t\tresolvedConfigRoot = filepath.Join(homeDir, \".config\", \"opencode-runner\")\n\t\t}\n\t}\n\tif resolvedConfigDir == \"\" && resolvedConfigRoot != \"\" {\n\t\tresolvedConfigDir = filepath.Join(resolvedConfigRoot, \"opencode\")\n\t}\n\n\toptions := runner.RunOnceOptions{\n\t\tRepoRoot:   *repoRoot,\n\t\tRootID:     *rootID,\n\t\tModel:      *model,\n\t\tConfigRoot: resolvedConfigRoot,\n\t\tConfigDir:  resolvedConfigDir,\n\t\tDryRun:     *dryRun,\n\t\tOut:        stdout,\n\t}\n\n\tif stdout == nil {\n\t\toptions.Out = io.Discard\n\t}\n\tif stderr == nil {\n\t\tstderr = io.Discard\n\t}\n\n\tvar program tuiProgram\n\tif !*headless && isTerminal(stdout) {\n\t\tprogram = newTUIProgram(stdout)\n\t\tdeps.Events = tuiEmitter{program: program}\n\t\tif err := program.Start(); err != nil {\n\t\t\tfmt.Fprintln(stderr, err)\n\t\t\tif exit != nil {\n\t\t\t\texit(1)\n\t\t\t}\n\t\t\treturn 1\n\t\t}\n\t}\n\n\t_, err := runOnce(options, deps)\n\tif program != nil {\n\t\tprogram.Quit()\n\t}\n\tif err != nil {\n\t\tfmt.Fprintln(stderr, err)\n\t\tif exit != nil {\n\t\t\texit(1)\n\t\t}\n\t\treturn 1\n\t}\n\n\tif exit != nil {\n\t\texit(0)\n\t}\n\treturn 0\n}\n\nfunc main() {\n\tRunOnceMain(os.Args[1:], runner.RunOnce, os.Exit, os.Stdout, os.Stderr, nil, nil)\n}\n\ntype promptBuilder struct{}\n\nfunc (promptBuilder) Build(issueID string, title string, description string, acceptance string) string {\n\treturn prompt.Build(issueID, title, description, acceptance)\n}\n\ntype runnerLogger struct{}\n\nfunc (runnerLogger) AppendRunnerSummary(repoRoot string, issueID string, title string, status string, commitSHA string) error {\n\treturn logging.AppendRunnerSummary(repoRoot, issueID, title, status, commitSHA)\n}\n\ntype defaultOpenCodeRunner struct{}\n\nfunc (defaultOpenCodeRunner) Start(args []string, env map[string]string, stdoutPath string) (opencode.Process, error) {\n\treturn startCommandWithEnv(args, env, stdoutPath)\n}\n","after":"package main\n\nimport (\n\t\"flag\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n\n\t\"yolo-runner/internal/beads\"\n\t\"yolo-runner/internal/logging\"\n\t\"yolo-runner/internal/opencode\"\n\t\"yolo-runner/internal/prompt\"\n\t\"yolo-runner/internal/runner\"\n\t\"yolo-runner/internal/ui/tui\"\n\tgitadapter \"yolo-runner/internal/vcs/git\"\n\n\ttea \"github.com/charmbracelet/bubbletea\"\n\t\"golang.org/x/term\"\n)\n\ntype runOnceFunc func(opts runner.RunOnceOptions, deps runner.RunOnceDeps) (string, error)\n\ntype exitFunc func(code int)\n\ntype beadsRunner interface {\n\tRun(args ...string) (string, error)\n}\n\ntype gitRunner interface {\n\tRun(name string, args ...string) (string, error)\n}\n\ntype openCodeRunner interface {\n\tStart(args []string, env map[string]string, stdoutPath string) (opencode.Process, error)\n}\n\ntype tuiProgram interface {\n\tStart() error\n\tSend(event runner.Event)\n\tQuit()\n}\n\ntype tuiEmitter struct {\n\tprogram tuiProgram\n}\n\nfunc (t tuiEmitter) Emit(event runner.Event) {\n\tif t.program == nil {\n\t\treturn\n\t}\n\tgo t.program.Send(event)\n}\n\ntype bubbleTUIProgram struct {\n\tprogram *tea.Program\n}\n\nfunc (b bubbleTUIProgram) Start() error {\n\tif b.program == nil {\n\t\treturn nil\n\t}\n\treturn b.program.Start()\n}\n\nfunc (b bubbleTUIProgram) Send(event runner.Event) {\n\tif b.program == nil {\n\t\treturn\n\t}\n\tb.program.Send(event)\n}\n\nfunc (b bubbleTUIProgram) Quit() {\n\tif b.program == nil {\n\t\treturn\n\t}\n\tb.program.Quit()\n}\n\nvar isTerminal = func(writer io.Writer) bool {\n\tif file, ok := writer.(*os.File); ok {\n\t\treturn term.IsTerminal(int(file.Fd()))\n\t}\n\treturn false\n}\n\nvar newTUIProgram = func(stdout io.Writer) tuiProgram {\n\tprogram := tea.NewProgram(tui.NewModel(nil), tea.WithInput(nil), tea.WithOutput(stdout))\n\treturn bubbleTUIProgram{program: program}\n}\n\ntype adapterRunner struct{}\n\nfunc (adapterRunner) Run(args ...string) (string, error) {\n\treturn runCommand(args...)\n}\n\ntype adapterGitRunner struct{}\n\nfunc (adapterGitRunner) Run(name string, args ...string) (string, error) {\n\treturn runCommand(append([]string{name}, args...)...)\n}\n\ntype openCodeAdapter struct {\n\trunner openCodeRunner\n}\n\nfunc (o openCodeAdapter) Run(issueID string, repoRoot string, promptText string, model string, configRoot string, configDir string, logPath string) error {\n\treturn opencode.Run(issueID, repoRoot, promptText, model, configRoot, configDir, logPath, o.runner)\n}\n\nfunc RunOnceMain(args []string, runOnce runOnceFunc, exit exitFunc, stdout io.Writer, stderr io.Writer, beadsRunner beadsRunner, gitRunner gitRunner) int {\n\tfs := flag.NewFlagSet(\"yolo-runner\", flag.ContinueOnError)\n\tfs.SetOutput(stderr)\n\n\trepoRoot := fs.String(\"repo\", \".\", \"Repository root path\")\n\trootID := fs.String(\"root\", \"algi-8bt\", \"Root bead/epic ID\")\n\tmodel := fs.String(\"model\", \"\", \"OpenCode model\")\n\tdryRun := fs.Bool(\"dry-run\", false, \"Print task and prompt without executing\")\n\theadless := fs.Bool(\"headless\", false, \"Force plain output without TUI\")\n\tconfigRoot := fs.String(\"config-root\", \"\", \"OpenCode config root\")\n\tconfigDir := fs.String(\"config-dir\", \"\", \"OpenCode config dir\")\n\n\tif err := fs.Parse(args); err != nil {\n\t\tfmt.Fprintln(stderr, err)\n\t\tif exit != nil {\n\t\t\texit(1)\n\t\t}\n\t\treturn 1\n\t}\n\n\tif runOnce == nil {\n\t\trunOnce = runner.RunOnce\n\t}\n\n\tif beadsRunner == nil {\n\t\tbeadsRunner = adapterRunner{}\n\t}\n\tif gitRunner == nil {\n\t\tgitRunner = adapterGitRunner{}\n\t}\n\n\tbeadsAdapter := beads.New(beadsRunner)\n\tgitAdapter := gitadapter.New(gitRunner)\n\topenCodeAdapter := openCodeAdapter{runner: defaultOpenCodeRunner{}}\n\n\tdeps := runner.RunOnceDeps{\n\t\tBeads:    beadsAdapter,\n\t\tPrompt:   promptBuilder{},\n\t\tOpenCode: openCodeAdapter,\n\t\tGit:      gitAdapter,\n\t\tLogger:   runnerLogger{},\n\t}\n\n\tresolvedConfigRoot := *configRoot\n\tresolvedConfigDir := *configDir\n\tif resolvedConfigRoot == \"\" {\n\t\thomeDir := os.Getenv(\"HOME\")\n\t\tif homeDir != \"\" {\n\t\t\tresolvedConfigRoot = filepath.Join(homeDir, \".config\", \"opencode-runner\")\n\t\t}\n\t}\n\tif resolvedConfigDir == \"\" && resolvedConfigRoot != \"\" {\n\t\tresolvedConfigDir = filepath.Join(resolvedConfigRoot, \"opencode\")\n\t}\n\n\toptions := runner.RunOnceOptions{\n\t\tRepoRoot:   *repoRoot,\n\t\tRootID:     *rootID,\n\t\tModel:      *model,\n\t\tConfigRoot: resolvedConfigRoot,\n\t\tConfigDir:  resolvedConfigDir,\n\t\tDryRun:     *dryRun,\n\t\tOut:        stdout,\n\t}\n\n\tif stdout == nil {\n\t\toptions.Out = io.Discard\n\t}\n\tif stderr == nil {\n\t\tstderr = io.Discard\n\t}\n\n\tvar program tuiProgram\n\tif !*headless && isTerminal(stdout) {\n\t\tprogram = newTUIProgram(stdout)\n\t\tdeps.Events = tuiEmitter{program: program}\n\t\tgo func() {\n\t\t\tif err := program.Start(); err != nil {\n\t\t\t\tfmt.Fprintln(stderr, err)\n\t\t\t\tif exit != nil {\n\t\t\t\t\texit(1)\n\t\t\t\t}\n\t\t\t}\n\t\t}()\n\t}\n\n\t_, err := runOnce(options, deps)\n\tif program != nil {\n\t\tprogram.Quit()\n\t}\n\tif err != nil {\n\t\tfmt.Fprintln(stderr, err)\n\t\tif exit != nil {\n\t\t\texit(1)\n\t\t}\n\t\treturn 1\n\t}\n\n\tif exit != nil {\n\t\texit(0)\n\t}\n\treturn 0\n}\n\nfunc main() {\n\tRunOnceMain(os.Args[1:], runner.RunOnce, os.Exit, os.Stdout, os.Stderr, nil, nil)\n}\n\ntype promptBuilder struct{}\n\nfunc (promptBuilder) Build(issueID string, title string, description string, acceptance string) string {\n\treturn prompt.Build(issueID, title, description, acceptance)\n}\n\ntype runnerLogger struct{}\n\nfunc (runnerLogger) AppendRunnerSummary(repoRoot string, issueID string, title string, status string, commitSHA string) error {\n\treturn logging.AppendRunnerSummary(repoRoot, issueID, title, status, commitSHA)\n}\n\ntype defaultOpenCodeRunner struct{}\n\nfunc (defaultOpenCodeRunner) Start(args []string, env map[string]string, stdoutPath string) (opencode.Process, error) {\n\treturn startCommandWithEnv(args, env, stdoutPath)\n}\n","additions":7,"deletions":6},"truncated":false},"time":{"start":1768840834369,"end":1768840834529}},"metadata":{"openai":{"itemId":"fc_0dd2fe2eafd0d73e01696e5e7d290c8191a3f11fde676598a7"}}}}
{"type":"step_finish","timestamp":1768840834550,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd7212de20018aWEv4sadDA9jy","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd7211325001dfqxs5Q11BpztF","type":"step-finish","reason":"tool-calls","snapshot":"03005707206080b6b1781cbe722b7f1f2032b0d2","cost":0,"tokens":{"input":436,"output":324,"reasoning":0,"cache":{"read":55936,"write":0}}}}
{"type":"step_start","timestamp":1768840834989,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd7212fac0016hddp4BO3f3Ohn","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd7212e17001cLZnEcA6kzM4ed","type":"step-start","snapshot":"146c297305b1e0748d4ae06a5248f7db2318fef1"}}
{"type":"tool_use","timestamp":1768840837193,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd721324e001Z33T18iEL4Hpkk","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd7212e17001cLZnEcA6kzM4ed","type":"tool","callID":"call_NKZHm0cISYup0mHTyk368B0o","tool":"bash","state":{"status":"completed","input":{"command":"go test ./...","workdir":"/Users/egv/dev/yolo-runner","description":"Runs Go test suite"},"output":"ok  \tyolo-runner\t(cached)\n--- FAIL: TestRunOnceMainUsesTUIOnTTYByDefault (0.00s)\n    main_test.go:239: expected event to be forwarded to TUI\nFAIL\nFAIL\tyolo-runner/cmd/yolo-runner\t0.654s\nok  \tyolo-runner/internal/beads\t(cached)\nok  \tyolo-runner/internal/logging\t(cached)\nok  \tyolo-runner/internal/opencode\t(cached)\nok  \tyolo-runner/internal/prompt\t(cached)\nok  \tyolo-runner/internal/runner\t(cached)\nok  \tyolo-runner/internal/ui/tui\t(cached)\nok  \tyolo-runner/internal/vcs/git\t(cached)\nFAIL\n","title":"Runs Go test suite","metadata":{"output":"ok  \tyolo-runner\t(cached)\n--- FAIL: TestRunOnceMainUsesTUIOnTTYByDefault (0.00s)\n    main_test.go:239: expected event to be forwarded to TUI\nFAIL\nFAIL\tyolo-runner/cmd/yolo-runner\t0.654s\nok  \tyolo-runner/internal/beads\t(cached)\nok  \tyolo-runner/internal/logging\t(cached)\nok  \tyolo-runner/internal/opencode\t(cached)\nok  \tyolo-runner/internal/prompt\t(cached)\nok  \tyolo-runner/internal/runner\t(cached)\nok  \tyolo-runner/internal/ui/tui\t(cached)\nok  \tyolo-runner/internal/vcs/git\t(cached)\nFAIL\n","exit":1,"description":"Runs Go test suite","truncated":false},"time":{"start":1768840836327,"end":1768840837193}},"metadata":{"openai":{"itemId":"fc_07c5602850fd141201696e5e83a1b88191b039a2298aab44a7"}}}}
{"type":"step_finish","timestamp":1768840837210,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd7213849001kiw88Gp3BZfBBn","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd7212e17001cLZnEcA6kzM4ed","type":"step-finish","reason":"tool-calls","snapshot":"52884b13c5f762f87f84d9a950fa08cb1c7cc355","cost":0,"tokens":{"input":771,"output":42,"reasoning":0,"cache":{"read":55936,"write":0}}}}
{"type":"step_start","timestamp":1768840837670,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd7213a26001yoovGXFW2m8M2e","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd72138820012X3FPu7Uw57kSu","type":"step-start","snapshot":"3548fe4abe04017cc33fbfce1b1489db579fa8cf"}}
{"type":"tool_use","timestamp":1768840842349,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd7213c9e001CUsma7Hfr5kwrq","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd72138820012X3FPu7Uw57kSu","type":"tool","callID":"call_bKTgDkDqczsXJ7NzwZlZcF3V","tool":"edit","state":{"status":"completed","input":{"filePath":"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go","oldString":"\trunOnce.deps.Events.Emit(runner.Event{Type: runner.EventSelectTask})\n\tif len(fakeProgram.events) != 1 {\n\t\tt.Fatalf(\"expected event to be forwarded to TUI\")\n\t}\n\twaitForSignal(t, fakeProgram.started, \"tui start\")\n\twaitForSignal(t, fakeProgram.quit, \"tui quit\")\n","newString":"\trunOnce.deps.Events.Emit(runner.Event{Type: runner.EventSelectTask})\n\twaitForSignal(t, fakeProgram.started, \"tui start\")\n\twaitForSignal(t, fakeProgram.quit, \"tui quit\")\n\tif len(fakeProgram.events) != 1 {\n\t\tt.Fatalf(\"expected event to be forwarded to TUI\")\n\t}\n"},"output":"Edit applied successfully.","title":"cmd/yolo-runner/main_test.go","metadata":{"diagnostics":{"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main.go":[],"/Users/egv/dev/yolo-runner/go.mod":[{"range":{"start":{"line":6,"character":44},"end":{"line":6,"character":55}},"severity":2,"source":"go mod tidy","message":"github.com/charmbracelet/bubbletea should be direct"},{"range":{"start":{"line":19,"character":26},"end":{"line":19,"character":37}},"severity":2,"source":"go mod tidy","message":"golang.org/x/term should be direct"}],"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go":[],"/Users/egv/dev/yolo-runner/bubbletea_test.go":[],"/Users/egv/dev/yolo-runner/opencode_adapter_v1.go":[{"range":{"start":{"line":24,"character":1},"end":{"line":24,"character":18}},"severity":2,"code":"default","codeDescription":{"href":"https://staticcheck.dev/docs/checks/#S1031"},"source":"S1031","message":"unnecessary nil check around range"}],"/Users/egv/dev/yolo-runner/internal/ui/tui/model.go":[],"/Users/egv/dev/yolo-runner/internal/runner/runner.go":[],"/Users/egv/dev/yolo-runner/internal/ui/tui/model_test.go":[],"/Users/egv/dev/yolo-runner/internal/runner/events.go":[],"/Users/egv/dev/yolo-runner/internal/runner/loop_test.go":[],"/Users/egv/dev/yolo-runner/internal/runner/runner_test.go":[],"/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/tea.go":[],"/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/tty_unix.go":[],"/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/tty.go":[],"/Users/egv/dev/yolo-runner/internal/opencode/watchdog.go":[],"/Users/egv/dev/yolo-runner/internal/opencode/client.go":[{"range":{"start":{"line":28,"character":1},"end":{"line":28,"character":18}},"severity":2,"code":"default","codeDescription":{"href":"https://staticcheck.dev/docs/checks/#S1031"},"source":"S1031","message":"unnecessary nil check around range"}],"/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/options.go":[],"/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/tty_windows.go":[{"range":{"start":{"line":3,"character":8},"end":{"line":3,"character":11}},"severity":2,"source":"go list","message":"This file is within module \"../../go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0\", which is not included in your workspace.\nTo fix this problem, you can add a go.work file that uses this directory.\nSee the documentation for more information on setting up your workspace:\nhttps://github.com/golang/tools/blob/master/gopls/doc/workspace.md.","data":{"Actions":[{"title":"Add a go.work file using this module","kind":"quickfix","command":{"title":"Run `go work init && go work use`","command":"gopls.run_go_work_command","arguments":[{"ViewID":"1","InitFirst":true,"Args":["use","../../go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0"]}]}}]}}]},"diff":"Index: /Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go\n===================================================================\n--- /Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go\n+++ /Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go\n@@ -234,13 +234,13 @@\n \tif runOnce.deps.Events == nil {\n \t\tt.Fatalf(\"expected events emitter to be set\")\n \t}\n \trunOnce.deps.Events.Emit(runner.Event{Type: runner.EventSelectTask})\n+\twaitForSignal(t, fakeProgram.started, \"tui start\")\n+\twaitForSignal(t, fakeProgram.quit, \"tui quit\")\n \tif len(fakeProgram.events) != 1 {\n \t\tt.Fatalf(\"expected event to be forwarded to TUI\")\n \t}\n-\twaitForSignal(t, fakeProgram.started, \"tui start\")\n-\twaitForSignal(t, fakeProgram.quit, \"tui quit\")\n }\n \n func TestRunOnceMainHeadlessDisablesTUI(t *testing.T) {\n \tcalled := false\n","filediff":{"file":"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go","before":"package main\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"yolo-runner/internal/opencode\"\n\t\"yolo-runner/internal/runner\"\n)\n\ntype fakeRunner struct {\n\tcalls []string\n}\n\nfunc (f *fakeRunner) Run(args ...string) (string, error) {\n\tf.calls = append(f.calls, strings.Join(args, \" \"))\n\treturn \"\", nil\n}\n\ntype fakeOpenCodeRunLogger struct {\n\tcalled     bool\n\tissueID    string\n\trepoRoot   string\n\tprompt     string\n\tmodel      string\n\tconfigRoot string\n\tconfigDir  string\n\tlogPath    string\n}\n\nfunc (f *fakeOpenCodeRunLogger) Run(issueID string, repoRoot string, prompt string, model string, configRoot string, configDir string, logPath string) error {\n\tf.called = true\n\tf.issueID = issueID\n\tf.repoRoot = repoRoot\n\tf.prompt = prompt\n\tf.model = model\n\tf.configRoot = configRoot\n\tf.configDir = configDir\n\tf.logPath = logPath\n\treturn nil\n}\n\ntype fakeOpenCodeRunner struct {\n\tenv map[string]string\n}\n\ntype fakeOpenCodeProcess struct{}\n\nfunc (fakeOpenCodeProcess) Wait() error { return nil }\n\nfunc (fakeOpenCodeProcess) Kill() error { return nil }\n\nfunc (f *fakeOpenCodeRunner) Start(args []string, env map[string]string, stdoutPath string) (opencode.Process, error) {\n\tf.env = env\n\treturn fakeOpenCodeProcess{}, nil\n}\n\ntype fakeGitRunner struct {\n\tcalls  []string\n\toutput string\n\terr    error\n}\n\nfunc (f *fakeGitRunner) Run(name string, args ...string) (string, error) {\n\tf.calls = append(f.calls, name+\" \"+strings.Join(args, \" \"))\n\treturn f.output, f.err\n}\n\ntype fakeExit struct {\n\tcode int\n}\n\nfunc (f *fakeExit) Exit(code int) {\n\tf.code = code\n}\n\ntype fakeRunOnce struct {\n\tcalled bool\n\topts   runner.RunOnceOptions\n\tdeps   runner.RunOnceDeps\n\tresult string\n\terr    error\n}\n\nfunc (f *fakeRunOnce) Run(opts runner.RunOnceOptions, deps runner.RunOnceDeps) (string, error) {\n\n\tf.called = true\n\tf.opts = opts\n\tf.deps = deps\n\treturn f.result, f.err\n}\n\nfunc TestRunOnceMainReturnsErrorCodeOnFailure(t *testing.T) {\n\trunner := &fakeRunOnce{err: errors.New(\"boom\")}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\n\tcode := RunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\"}, runner.Run, exit.Exit, out, out, nil, nil)\n\n\tif code != 1 {\n\t\tt.Fatalf(\"expected exit code 1, got %d\", code)\n\t}\n\tif exit.code != 1 {\n\t\tt.Fatalf(\"expected exit to be called with 1, got %d\", exit.code)\n\t}\n\tif !strings.Contains(out.String(), \"boom\") {\n\t\tt.Fatalf(\"expected error output, got %q\", out.String())\n\t}\n}\n\nfunc TestRunOnceMainWiresDependencies(t *testing.T) {\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tRunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\", \"--model\", \"model\", \"--dry-run\"}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif !runner.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n\tif runner.opts.RepoRoot != \"/repo\" || runner.opts.RootID != \"root\" || runner.opts.Model != \"model\" || !runner.opts.DryRun {\n\t\tt.Fatalf(\"unexpected options: %#v\", runner.opts)\n\t}\n\tif runner.opts.Out == nil {\n\t\tt.Fatalf(\"expected output writer\")\n\t}\n\tif runner.deps.Beads == nil || runner.deps.Git == nil || runner.deps.Prompt == nil || runner.deps.OpenCode == nil || runner.deps.Logger == nil {\n\t\tt.Fatalf(\"expected deps to be wired\")\n\t}\n\tif exit.code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", exit.code)\n\t}\n}\n\nfunc TestRunOnceMainDefaultsConfigPaths(t *testing.T) {\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tt.Setenv(\"HOME\", \"/home/user\")\n\n\tRunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\"}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif !runner.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n\tif runner.opts.ConfigRoot == \"\" {\n\t\tt.Fatalf(\"expected config root to be set\")\n\t}\n\tif runner.opts.ConfigDir == \"\" {\n\t\tt.Fatalf(\"expected config dir to be set\")\n\t}\n\texpectedConfigRoot := filepath.Join(\"/home/user\", \".config\", \"opencode-runner\")\n\tif runner.opts.ConfigRoot != expectedConfigRoot {\n\t\tt.Fatalf(\"expected config root %q, got %q\", expectedConfigRoot, runner.opts.ConfigRoot)\n\t}\n\texpectedConfigDir := filepath.Join(expectedConfigRoot, \"opencode\")\n\tif runner.opts.ConfigDir != expectedConfigDir {\n\t\tt.Fatalf(\"expected config dir %q, got %q\", expectedConfigDir, runner.opts.ConfigDir)\n\t}\n\tif exit.code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", exit.code)\n\t}\n}\n\ntype fakeTUIProgram struct {\n\tstarted chan struct{}\n\tquit    chan struct{}\n\tevents  []runner.Event\n}\n\nfunc newFakeTUIProgram() *fakeTUIProgram {\n\treturn &fakeTUIProgram{\n\t\tstarted: make(chan struct{}),\n\t\tquit:    make(chan struct{}),\n\t}\n}\n\nfunc (f *fakeTUIProgram) Start() error {\n\tclose(f.started)\n\treturn nil\n}\n\nfunc (f *fakeTUIProgram) Send(event runner.Event) {\n\tf.events = append(f.events, event)\n}\n\nfunc (f *fakeTUIProgram) Quit() {\n\tclose(f.quit)\n}\n\nfunc waitForSignal(t *testing.T, signal chan struct{}, label string) {\n\tt.Helper()\n\tselect {\n\tcase <-signal:\n\t\treturn\n\tcase <-time.After(100 * time.Millisecond):\n\t\tt.Fatalf(\"expected %s\", label)\n\t}\n}\n\nfunc TestRunOnceMainUsesTUIOnTTYByDefault(t *testing.T) {\n\tfakeProgram := newFakeTUIProgram()\n\tprevIsTerminal := isTerminal\n\tprevNewTUIProgram := newTUIProgram\n\tisTerminal = func(io.Writer) bool { return true }\n\tnewTUIProgram = func(stdout io.Writer) tuiProgram { return fakeProgram }\n\tt.Cleanup(func() {\n\t\tisTerminal = prevIsTerminal\n\t\tnewTUIProgram = prevNewTUIProgram\n\t})\n\n\trunOnce := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\"}, runOnce.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", code)\n\t}\n\tif runOnce.deps.Events == nil {\n\t\tt.Fatalf(\"expected events emitter to be set\")\n\t}\n\trunOnce.deps.Events.Emit(runner.Event{Type: runner.EventSelectTask})\n\tif len(fakeProgram.events) != 1 {\n\t\tt.Fatalf(\"expected event to be forwarded to TUI\")\n\t}\n\twaitForSignal(t, fakeProgram.started, \"tui start\")\n\twaitForSignal(t, fakeProgram.quit, \"tui quit\")\n}\n\nfunc TestRunOnceMainHeadlessDisablesTUI(t *testing.T) {\n\tcalled := false\n\tprevIsTerminal := isTerminal\n\tprevNewTUIProgram := newTUIProgram\n\tisTerminal = func(io.Writer) bool { return true }\n\tnewTUIProgram = func(stdout io.Writer) tuiProgram {\n\t\tcalled = true\n\t\treturn newFakeTUIProgram()\n\t}\n\tt.Cleanup(func() {\n\t\tisTerminal = prevIsTerminal\n\t\tnewTUIProgram = prevNewTUIProgram\n\t})\n\n\trunOnce := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\tstderr := &bytes.Buffer{}\n\n\tRunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\", \"--headless\"}, runOnce.Run, exit.Exit, out, stderr, beadsRunner, gitRunner)\n\n\tif called {\n\t\tt.Fatalf(\"expected TUI program not to start\")\n\t}\n\tif runOnce.deps.Events != nil {\n\t\tt.Fatalf(\"expected no events emitter in headless mode\")\n\t}\n}\n\nfunc TestOpenCodeRunDefaultsCreateConfigAndEnv(t *testing.T) {\n\ttempDir := t.TempDir()\n\trepoRoot := filepath.Join(tempDir, \"repo\")\n\tif err := os.MkdirAll(repoRoot, 0o755); err != nil {\n\t\tt.Fatalf(\"mkdir repo: %v\", err)\n\t}\n\tt.Setenv(\"HOME\", tempDir)\n\n\topenCodeRunner := &fakeOpenCodeRunner{}\n\topenCodeAdapter := openCodeAdapter{runner: openCodeRunner}\n\n\tconfigRoot := filepath.Join(tempDir, \".config\", \"opencode-runner\")\n\tconfigDir := filepath.Join(configRoot, \"opencode\")\n\tlogPath := filepath.Join(tempDir, \"runner-logs\", \"opencode\", \"issue-1.jsonl\")\n\n\tif err := openCodeAdapter.Run(\"issue-1\", repoRoot, \"prompt\", \"\", configRoot, configDir, logPath); err != nil {\n\t\tt.Fatalf(\"open code run error: %v\", err)\n\t}\n\n\tconfigFile := filepath.Join(configDir, \"opencode.json\")\n\tif _, err := os.Stat(configFile); err != nil {\n\t\tt.Fatalf(\"expected opencode.json to exist: %v\", err)\n\t}\n\texpectedConfigFile := filepath.Join(configDir, \"opencode.json\")\n\tif openCodeRunner.env[\"XDG_CONFIG_HOME\"] != configRoot {\n\t\tt.Fatalf(\"expected XDG_CONFIG_HOME set\")\n\t}\n\tif openCodeRunner.env[\"OPENCODE_CONFIG_DIR\"] != configDir {\n\t\tt.Fatalf(\"expected OPENCODE_CONFIG_DIR set\")\n\t}\n\tif openCodeRunner.env[\"OPENCODE_CONFIG\"] != expectedConfigFile {\n\t\tt.Fatalf(\"expected OPENCODE_CONFIG set\")\n\t}\n\tif openCodeRunner.env[\"OPENCODE_CONFIG_CONTENT\"] != \"{}\" {\n\t\tt.Fatalf(\"expected OPENCODE_CONFIG_CONTENT set\")\n\t}\n}\n","after":"package main\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"yolo-runner/internal/opencode\"\n\t\"yolo-runner/internal/runner\"\n)\n\ntype fakeRunner struct {\n\tcalls []string\n}\n\nfunc (f *fakeRunner) Run(args ...string) (string, error) {\n\tf.calls = append(f.calls, strings.Join(args, \" \"))\n\treturn \"\", nil\n}\n\ntype fakeOpenCodeRunLogger struct {\n\tcalled     bool\n\tissueID    string\n\trepoRoot   string\n\tprompt     string\n\tmodel      string\n\tconfigRoot string\n\tconfigDir  string\n\tlogPath    string\n}\n\nfunc (f *fakeOpenCodeRunLogger) Run(issueID string, repoRoot string, prompt string, model string, configRoot string, configDir string, logPath string) error {\n\tf.called = true\n\tf.issueID = issueID\n\tf.repoRoot = repoRoot\n\tf.prompt = prompt\n\tf.model = model\n\tf.configRoot = configRoot\n\tf.configDir = configDir\n\tf.logPath = logPath\n\treturn nil\n}\n\ntype fakeOpenCodeRunner struct {\n\tenv map[string]string\n}\n\ntype fakeOpenCodeProcess struct{}\n\nfunc (fakeOpenCodeProcess) Wait() error { return nil }\n\nfunc (fakeOpenCodeProcess) Kill() error { return nil }\n\nfunc (f *fakeOpenCodeRunner) Start(args []string, env map[string]string, stdoutPath string) (opencode.Process, error) {\n\tf.env = env\n\treturn fakeOpenCodeProcess{}, nil\n}\n\ntype fakeGitRunner struct {\n\tcalls  []string\n\toutput string\n\terr    error\n}\n\nfunc (f *fakeGitRunner) Run(name string, args ...string) (string, error) {\n\tf.calls = append(f.calls, name+\" \"+strings.Join(args, \" \"))\n\treturn f.output, f.err\n}\n\ntype fakeExit struct {\n\tcode int\n}\n\nfunc (f *fakeExit) Exit(code int) {\n\tf.code = code\n}\n\ntype fakeRunOnce struct {\n\tcalled bool\n\topts   runner.RunOnceOptions\n\tdeps   runner.RunOnceDeps\n\tresult string\n\terr    error\n}\n\nfunc (f *fakeRunOnce) Run(opts runner.RunOnceOptions, deps runner.RunOnceDeps) (string, error) {\n\n\tf.called = true\n\tf.opts = opts\n\tf.deps = deps\n\treturn f.result, f.err\n}\n\nfunc TestRunOnceMainReturnsErrorCodeOnFailure(t *testing.T) {\n\trunner := &fakeRunOnce{err: errors.New(\"boom\")}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\n\tcode := RunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\"}, runner.Run, exit.Exit, out, out, nil, nil)\n\n\tif code != 1 {\n\t\tt.Fatalf(\"expected exit code 1, got %d\", code)\n\t}\n\tif exit.code != 1 {\n\t\tt.Fatalf(\"expected exit to be called with 1, got %d\", exit.code)\n\t}\n\tif !strings.Contains(out.String(), \"boom\") {\n\t\tt.Fatalf(\"expected error output, got %q\", out.String())\n\t}\n}\n\nfunc TestRunOnceMainWiresDependencies(t *testing.T) {\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tRunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\", \"--model\", \"model\", \"--dry-run\"}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif !runner.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n\tif runner.opts.RepoRoot != \"/repo\" || runner.opts.RootID != \"root\" || runner.opts.Model != \"model\" || !runner.opts.DryRun {\n\t\tt.Fatalf(\"unexpected options: %#v\", runner.opts)\n\t}\n\tif runner.opts.Out == nil {\n\t\tt.Fatalf(\"expected output writer\")\n\t}\n\tif runner.deps.Beads == nil || runner.deps.Git == nil || runner.deps.Prompt == nil || runner.deps.OpenCode == nil || runner.deps.Logger == nil {\n\t\tt.Fatalf(\"expected deps to be wired\")\n\t}\n\tif exit.code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", exit.code)\n\t}\n}\n\nfunc TestRunOnceMainDefaultsConfigPaths(t *testing.T) {\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tt.Setenv(\"HOME\", \"/home/user\")\n\n\tRunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\"}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif !runner.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n\tif runner.opts.ConfigRoot == \"\" {\n\t\tt.Fatalf(\"expected config root to be set\")\n\t}\n\tif runner.opts.ConfigDir == \"\" {\n\t\tt.Fatalf(\"expected config dir to be set\")\n\t}\n\texpectedConfigRoot := filepath.Join(\"/home/user\", \".config\", \"opencode-runner\")\n\tif runner.opts.ConfigRoot != expectedConfigRoot {\n\t\tt.Fatalf(\"expected config root %q, got %q\", expectedConfigRoot, runner.opts.ConfigRoot)\n\t}\n\texpectedConfigDir := filepath.Join(expectedConfigRoot, \"opencode\")\n\tif runner.opts.ConfigDir != expectedConfigDir {\n\t\tt.Fatalf(\"expected config dir %q, got %q\", expectedConfigDir, runner.opts.ConfigDir)\n\t}\n\tif exit.code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", exit.code)\n\t}\n}\n\ntype fakeTUIProgram struct {\n\tstarted chan struct{}\n\tquit    chan struct{}\n\tevents  []runner.Event\n}\n\nfunc newFakeTUIProgram() *fakeTUIProgram {\n\treturn &fakeTUIProgram{\n\t\tstarted: make(chan struct{}),\n\t\tquit:    make(chan struct{}),\n\t}\n}\n\nfunc (f *fakeTUIProgram) Start() error {\n\tclose(f.started)\n\treturn nil\n}\n\nfunc (f *fakeTUIProgram) Send(event runner.Event) {\n\tf.events = append(f.events, event)\n}\n\nfunc (f *fakeTUIProgram) Quit() {\n\tclose(f.quit)\n}\n\nfunc waitForSignal(t *testing.T, signal chan struct{}, label string) {\n\tt.Helper()\n\tselect {\n\tcase <-signal:\n\t\treturn\n\tcase <-time.After(100 * time.Millisecond):\n\t\tt.Fatalf(\"expected %s\", label)\n\t}\n}\n\nfunc TestRunOnceMainUsesTUIOnTTYByDefault(t *testing.T) {\n\tfakeProgram := newFakeTUIProgram()\n\tprevIsTerminal := isTerminal\n\tprevNewTUIProgram := newTUIProgram\n\tisTerminal = func(io.Writer) bool { return true }\n\tnewTUIProgram = func(stdout io.Writer) tuiProgram { return fakeProgram }\n\tt.Cleanup(func() {\n\t\tisTerminal = prevIsTerminal\n\t\tnewTUIProgram = prevNewTUIProgram\n\t})\n\n\trunOnce := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\"}, runOnce.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", code)\n\t}\n\tif runOnce.deps.Events == nil {\n\t\tt.Fatalf(\"expected events emitter to be set\")\n\t}\n\trunOnce.deps.Events.Emit(runner.Event{Type: runner.EventSelectTask})\n\twaitForSignal(t, fakeProgram.started, \"tui start\")\n\twaitForSignal(t, fakeProgram.quit, \"tui quit\")\n\tif len(fakeProgram.events) != 1 {\n\t\tt.Fatalf(\"expected event to be forwarded to TUI\")\n\t}\n}\n\nfunc TestRunOnceMainHeadlessDisablesTUI(t *testing.T) {\n\tcalled := false\n\tprevIsTerminal := isTerminal\n\tprevNewTUIProgram := newTUIProgram\n\tisTerminal = func(io.Writer) bool { return true }\n\tnewTUIProgram = func(stdout io.Writer) tuiProgram {\n\t\tcalled = true\n\t\treturn newFakeTUIProgram()\n\t}\n\tt.Cleanup(func() {\n\t\tisTerminal = prevIsTerminal\n\t\tnewTUIProgram = prevNewTUIProgram\n\t})\n\n\trunOnce := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\tstderr := &bytes.Buffer{}\n\n\tRunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\", \"--headless\"}, runOnce.Run, exit.Exit, out, stderr, beadsRunner, gitRunner)\n\n\tif called {\n\t\tt.Fatalf(\"expected TUI program not to start\")\n\t}\n\tif runOnce.deps.Events != nil {\n\t\tt.Fatalf(\"expected no events emitter in headless mode\")\n\t}\n}\n\nfunc TestOpenCodeRunDefaultsCreateConfigAndEnv(t *testing.T) {\n\ttempDir := t.TempDir()\n\trepoRoot := filepath.Join(tempDir, \"repo\")\n\tif err := os.MkdirAll(repoRoot, 0o755); err != nil {\n\t\tt.Fatalf(\"mkdir repo: %v\", err)\n\t}\n\tt.Setenv(\"HOME\", tempDir)\n\n\topenCodeRunner := &fakeOpenCodeRunner{}\n\topenCodeAdapter := openCodeAdapter{runner: openCodeRunner}\n\n\tconfigRoot := filepath.Join(tempDir, \".config\", \"opencode-runner\")\n\tconfigDir := filepath.Join(configRoot, \"opencode\")\n\tlogPath := filepath.Join(tempDir, \"runner-logs\", \"opencode\", \"issue-1.jsonl\")\n\n\tif err := openCodeAdapter.Run(\"issue-1\", repoRoot, \"prompt\", \"\", configRoot, configDir, logPath); err != nil {\n\t\tt.Fatalf(\"open code run error: %v\", err)\n\t}\n\n\tconfigFile := filepath.Join(configDir, \"opencode.json\")\n\tif _, err := os.Stat(configFile); err != nil {\n\t\tt.Fatalf(\"expected opencode.json to exist: %v\", err)\n\t}\n\texpectedConfigFile := filepath.Join(configDir, \"opencode.json\")\n\tif openCodeRunner.env[\"XDG_CONFIG_HOME\"] != configRoot {\n\t\tt.Fatalf(\"expected XDG_CONFIG_HOME set\")\n\t}\n\tif openCodeRunner.env[\"OPENCODE_CONFIG_DIR\"] != configDir {\n\t\tt.Fatalf(\"expected OPENCODE_CONFIG_DIR set\")\n\t}\n\tif openCodeRunner.env[\"OPENCODE_CONFIG\"] != expectedConfigFile {\n\t\tt.Fatalf(\"expected OPENCODE_CONFIG set\")\n\t}\n\tif openCodeRunner.env[\"OPENCODE_CONFIG_CONTENT\"] != \"{}\" {\n\t\tt.Fatalf(\"expected OPENCODE_CONFIG_CONTENT set\")\n\t}\n}\n","additions":2,"deletions":2},"truncated":false},"time":{"start":1768840842188,"end":1768840842348}},"metadata":{"openai":{"itemId":"fc_0c3322bd16ecfaab01696e5e8647b88191823ce69cf8ed1a24"}}}}
{"type":"step_finish","timestamp":1768840842369,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd7214c6c00116p0QdVSQ3ftp0","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd72138820012X3FPu7Uw57kSu","type":"step-finish","reason":"tool-calls","snapshot":"881f8158ce5c4cf8bdb7aec135b465816b6e0bfd","cost":0,"tokens":{"input":341,"output":216,"reasoning":0,"cache":{"read":56576,"write":0}}}}
{"type":"step_start","timestamp":1768840842747,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd7214dfa0013j2HFjIijm0o90","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd7214c9f0017CsqaQfE5FbVjX","type":"step-start","snapshot":"64e25120a930f05ca892d0be3ac64be4d901b0b6"}}
{"type":"tool_use","timestamp":1768840846427,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd72150ba001XbEd3UilEqNaTw","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd7214c9f0017CsqaQfE5FbVjX","type":"tool","callID":"call_HfUKEP4aDV8mM02bDYDP6gnS","tool":"edit","state":{"status":"completed","input":{"filePath":"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go","oldString":"func waitForSignal(t *testing.T, signal chan struct{}, label string) {\n\tt.Helper()\n\tselect {\n\tcase <-signal:\n\t\treturn\n\tcase <-time.After(100 * time.Millisecond):\n\t\tt.Fatalf(\"expected %s\", label)\n\t}\n}\n","newString":"func waitForSignal(t *testing.T, signal chan struct{}, label string) {\n\tt.Helper()\n\tselect {\n\tcase <-signal:\n\t\treturn\n\tcase <-time.After(200 * time.Millisecond):\n\t\tt.Fatalf(\"expected %s\", label)\n\t}\n}\n"},"output":"Edit applied successfully.","title":"cmd/yolo-runner/main_test.go","metadata":{"diagnostics":{"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main.go":[],"/Users/egv/dev/yolo-runner/go.mod":[{"range":{"start":{"line":6,"character":44},"end":{"line":6,"character":55}},"severity":2,"source":"go mod tidy","message":"github.com/charmbracelet/bubbletea should be direct"},{"range":{"start":{"line":19,"character":26},"end":{"line":19,"character":37}},"severity":2,"source":"go mod tidy","message":"golang.org/x/term should be direct"}],"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go":[],"/Users/egv/dev/yolo-runner/bubbletea_test.go":[],"/Users/egv/dev/yolo-runner/opencode_adapter_v1.go":[{"range":{"start":{"line":24,"character":1},"end":{"line":24,"character":18}},"severity":2,"code":"default","codeDescription":{"href":"https://staticcheck.dev/docs/checks/#S1031"},"source":"S1031","message":"unnecessary nil check around range"}],"/Users/egv/dev/yolo-runner/internal/ui/tui/model.go":[],"/Users/egv/dev/yolo-runner/internal/runner/runner.go":[],"/Users/egv/dev/yolo-runner/internal/ui/tui/model_test.go":[],"/Users/egv/dev/yolo-runner/internal/runner/events.go":[],"/Users/egv/dev/yolo-runner/internal/runner/loop_test.go":[],"/Users/egv/dev/yolo-runner/internal/runner/runner_test.go":[],"/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/tea.go":[],"/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/tty_unix.go":[],"/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/tty.go":[],"/Users/egv/dev/yolo-runner/internal/opencode/watchdog.go":[],"/Users/egv/dev/yolo-runner/internal/opencode/client.go":[{"range":{"start":{"line":28,"character":1},"end":{"line":28,"character":18}},"severity":2,"code":"default","codeDescription":{"href":"https://staticcheck.dev/docs/checks/#S1031"},"source":"S1031","message":"unnecessary nil check around range"}],"/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/options.go":[],"/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/tty_windows.go":[{"range":{"start":{"line":3,"character":8},"end":{"line":3,"character":11}},"severity":2,"source":"go list","message":"This file is within module \"../../go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0\", which is not included in your workspace.\nTo fix this problem, you can add a go.work file that uses this directory.\nSee the documentation for more information on setting up your workspace:\nhttps://github.com/golang/tools/blob/master/gopls/doc/workspace.md.","data":{"Actions":[{"title":"Add a go.work file using this module","kind":"quickfix","command":{"title":"Run `go work init && go work use`","command":"gopls.run_go_work_command","arguments":[{"ViewID":"1","InitFirst":true,"Args":["use","../../go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0"]}]}}]}}]},"diff":"Index: /Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go\n===================================================================\n--- /Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go\n+++ /Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go\n@@ -203,9 +203,9 @@\n \tt.Helper()\n \tselect {\n \tcase <-signal:\n \t\treturn\n-\tcase <-time.After(100 * time.Millisecond):\n+\tcase <-time.After(200 * time.Millisecond):\n \t\tt.Fatalf(\"expected %s\", label)\n \t}\n }\n \n","filediff":{"file":"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go","before":"package main\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"yolo-runner/internal/opencode\"\n\t\"yolo-runner/internal/runner\"\n)\n\ntype fakeRunner struct {\n\tcalls []string\n}\n\nfunc (f *fakeRunner) Run(args ...string) (string, error) {\n\tf.calls = append(f.calls, strings.Join(args, \" \"))\n\treturn \"\", nil\n}\n\ntype fakeOpenCodeRunLogger struct {\n\tcalled     bool\n\tissueID    string\n\trepoRoot   string\n\tprompt     string\n\tmodel      string\n\tconfigRoot string\n\tconfigDir  string\n\tlogPath    string\n}\n\nfunc (f *fakeOpenCodeRunLogger) Run(issueID string, repoRoot string, prompt string, model string, configRoot string, configDir string, logPath string) error {\n\tf.called = true\n\tf.issueID = issueID\n\tf.repoRoot = repoRoot\n\tf.prompt = prompt\n\tf.model = model\n\tf.configRoot = configRoot\n\tf.configDir = configDir\n\tf.logPath = logPath\n\treturn nil\n}\n\ntype fakeOpenCodeRunner struct {\n\tenv map[string]string\n}\n\ntype fakeOpenCodeProcess struct{}\n\nfunc (fakeOpenCodeProcess) Wait() error { return nil }\n\nfunc (fakeOpenCodeProcess) Kill() error { return nil }\n\nfunc (f *fakeOpenCodeRunner) Start(args []string, env map[string]string, stdoutPath string) (opencode.Process, error) {\n\tf.env = env\n\treturn fakeOpenCodeProcess{}, nil\n}\n\ntype fakeGitRunner struct {\n\tcalls  []string\n\toutput string\n\terr    error\n}\n\nfunc (f *fakeGitRunner) Run(name string, args ...string) (string, error) {\n\tf.calls = append(f.calls, name+\" \"+strings.Join(args, \" \"))\n\treturn f.output, f.err\n}\n\ntype fakeExit struct {\n\tcode int\n}\n\nfunc (f *fakeExit) Exit(code int) {\n\tf.code = code\n}\n\ntype fakeRunOnce struct {\n\tcalled bool\n\topts   runner.RunOnceOptions\n\tdeps   runner.RunOnceDeps\n\tresult string\n\terr    error\n}\n\nfunc (f *fakeRunOnce) Run(opts runner.RunOnceOptions, deps runner.RunOnceDeps) (string, error) {\n\n\tf.called = true\n\tf.opts = opts\n\tf.deps = deps\n\treturn f.result, f.err\n}\n\nfunc TestRunOnceMainReturnsErrorCodeOnFailure(t *testing.T) {\n\trunner := &fakeRunOnce{err: errors.New(\"boom\")}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\n\tcode := RunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\"}, runner.Run, exit.Exit, out, out, nil, nil)\n\n\tif code != 1 {\n\t\tt.Fatalf(\"expected exit code 1, got %d\", code)\n\t}\n\tif exit.code != 1 {\n\t\tt.Fatalf(\"expected exit to be called with 1, got %d\", exit.code)\n\t}\n\tif !strings.Contains(out.String(), \"boom\") {\n\t\tt.Fatalf(\"expected error output, got %q\", out.String())\n\t}\n}\n\nfunc TestRunOnceMainWiresDependencies(t *testing.T) {\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tRunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\", \"--model\", \"model\", \"--dry-run\"}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif !runner.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n\tif runner.opts.RepoRoot != \"/repo\" || runner.opts.RootID != \"root\" || runner.opts.Model != \"model\" || !runner.opts.DryRun {\n\t\tt.Fatalf(\"unexpected options: %#v\", runner.opts)\n\t}\n\tif runner.opts.Out == nil {\n\t\tt.Fatalf(\"expected output writer\")\n\t}\n\tif runner.deps.Beads == nil || runner.deps.Git == nil || runner.deps.Prompt == nil || runner.deps.OpenCode == nil || runner.deps.Logger == nil {\n\t\tt.Fatalf(\"expected deps to be wired\")\n\t}\n\tif exit.code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", exit.code)\n\t}\n}\n\nfunc TestRunOnceMainDefaultsConfigPaths(t *testing.T) {\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tt.Setenv(\"HOME\", \"/home/user\")\n\n\tRunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\"}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif !runner.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n\tif runner.opts.ConfigRoot == \"\" {\n\t\tt.Fatalf(\"expected config root to be set\")\n\t}\n\tif runner.opts.ConfigDir == \"\" {\n\t\tt.Fatalf(\"expected config dir to be set\")\n\t}\n\texpectedConfigRoot := filepath.Join(\"/home/user\", \".config\", \"opencode-runner\")\n\tif runner.opts.ConfigRoot != expectedConfigRoot {\n\t\tt.Fatalf(\"expected config root %q, got %q\", expectedConfigRoot, runner.opts.ConfigRoot)\n\t}\n\texpectedConfigDir := filepath.Join(expectedConfigRoot, \"opencode\")\n\tif runner.opts.ConfigDir != expectedConfigDir {\n\t\tt.Fatalf(\"expected config dir %q, got %q\", expectedConfigDir, runner.opts.ConfigDir)\n\t}\n\tif exit.code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", exit.code)\n\t}\n}\n\ntype fakeTUIProgram struct {\n\tstarted chan struct{}\n\tquit    chan struct{}\n\tevents  []runner.Event\n}\n\nfunc newFakeTUIProgram() *fakeTUIProgram {\n\treturn &fakeTUIProgram{\n\t\tstarted: make(chan struct{}),\n\t\tquit:    make(chan struct{}),\n\t}\n}\n\nfunc (f *fakeTUIProgram) Start() error {\n\tclose(f.started)\n\treturn nil\n}\n\nfunc (f *fakeTUIProgram) Send(event runner.Event) {\n\tf.events = append(f.events, event)\n}\n\nfunc (f *fakeTUIProgram) Quit() {\n\tclose(f.quit)\n}\n\nfunc waitForSignal(t *testing.T, signal chan struct{}, label string) {\n\tt.Helper()\n\tselect {\n\tcase <-signal:\n\t\treturn\n\tcase <-time.After(100 * time.Millisecond):\n\t\tt.Fatalf(\"expected %s\", label)\n\t}\n}\n\nfunc TestRunOnceMainUsesTUIOnTTYByDefault(t *testing.T) {\n\tfakeProgram := newFakeTUIProgram()\n\tprevIsTerminal := isTerminal\n\tprevNewTUIProgram := newTUIProgram\n\tisTerminal = func(io.Writer) bool { return true }\n\tnewTUIProgram = func(stdout io.Writer) tuiProgram { return fakeProgram }\n\tt.Cleanup(func() {\n\t\tisTerminal = prevIsTerminal\n\t\tnewTUIProgram = prevNewTUIProgram\n\t})\n\n\trunOnce := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\"}, runOnce.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", code)\n\t}\n\tif runOnce.deps.Events == nil {\n\t\tt.Fatalf(\"expected events emitter to be set\")\n\t}\n\trunOnce.deps.Events.Emit(runner.Event{Type: runner.EventSelectTask})\n\twaitForSignal(t, fakeProgram.started, \"tui start\")\n\twaitForSignal(t, fakeProgram.quit, \"tui quit\")\n\tif len(fakeProgram.events) != 1 {\n\t\tt.Fatalf(\"expected event to be forwarded to TUI\")\n\t}\n}\n\nfunc TestRunOnceMainHeadlessDisablesTUI(t *testing.T) {\n\tcalled := false\n\tprevIsTerminal := isTerminal\n\tprevNewTUIProgram := newTUIProgram\n\tisTerminal = func(io.Writer) bool { return true }\n\tnewTUIProgram = func(stdout io.Writer) tuiProgram {\n\t\tcalled = true\n\t\treturn newFakeTUIProgram()\n\t}\n\tt.Cleanup(func() {\n\t\tisTerminal = prevIsTerminal\n\t\tnewTUIProgram = prevNewTUIProgram\n\t})\n\n\trunOnce := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\tstderr := &bytes.Buffer{}\n\n\tRunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\", \"--headless\"}, runOnce.Run, exit.Exit, out, stderr, beadsRunner, gitRunner)\n\n\tif called {\n\t\tt.Fatalf(\"expected TUI program not to start\")\n\t}\n\tif runOnce.deps.Events != nil {\n\t\tt.Fatalf(\"expected no events emitter in headless mode\")\n\t}\n}\n\nfunc TestOpenCodeRunDefaultsCreateConfigAndEnv(t *testing.T) {\n\ttempDir := t.TempDir()\n\trepoRoot := filepath.Join(tempDir, \"repo\")\n\tif err := os.MkdirAll(repoRoot, 0o755); err != nil {\n\t\tt.Fatalf(\"mkdir repo: %v\", err)\n\t}\n\tt.Setenv(\"HOME\", tempDir)\n\n\topenCodeRunner := &fakeOpenCodeRunner{}\n\topenCodeAdapter := openCodeAdapter{runner: openCodeRunner}\n\n\tconfigRoot := filepath.Join(tempDir, \".config\", \"opencode-runner\")\n\tconfigDir := filepath.Join(configRoot, \"opencode\")\n\tlogPath := filepath.Join(tempDir, \"runner-logs\", \"opencode\", \"issue-1.jsonl\")\n\n\tif err := openCodeAdapter.Run(\"issue-1\", repoRoot, \"prompt\", \"\", configRoot, configDir, logPath); err != nil {\n\t\tt.Fatalf(\"open code run error: %v\", err)\n\t}\n\n\tconfigFile := filepath.Join(configDir, \"opencode.json\")\n\tif _, err := os.Stat(configFile); err != nil {\n\t\tt.Fatalf(\"expected opencode.json to exist: %v\", err)\n\t}\n\texpectedConfigFile := filepath.Join(configDir, \"opencode.json\")\n\tif openCodeRunner.env[\"XDG_CONFIG_HOME\"] != configRoot {\n\t\tt.Fatalf(\"expected XDG_CONFIG_HOME set\")\n\t}\n\tif openCodeRunner.env[\"OPENCODE_CONFIG_DIR\"] != configDir {\n\t\tt.Fatalf(\"expected OPENCODE_CONFIG_DIR set\")\n\t}\n\tif openCodeRunner.env[\"OPENCODE_CONFIG\"] != expectedConfigFile {\n\t\tt.Fatalf(\"expected OPENCODE_CONFIG set\")\n\t}\n\tif openCodeRunner.env[\"OPENCODE_CONFIG_CONTENT\"] != \"{}\" {\n\t\tt.Fatalf(\"expected OPENCODE_CONFIG_CONTENT set\")\n\t}\n}\n","after":"package main\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"yolo-runner/internal/opencode\"\n\t\"yolo-runner/internal/runner\"\n)\n\ntype fakeRunner struct {\n\tcalls []string\n}\n\nfunc (f *fakeRunner) Run(args ...string) (string, error) {\n\tf.calls = append(f.calls, strings.Join(args, \" \"))\n\treturn \"\", nil\n}\n\ntype fakeOpenCodeRunLogger struct {\n\tcalled     bool\n\tissueID    string\n\trepoRoot   string\n\tprompt     string\n\tmodel      string\n\tconfigRoot string\n\tconfigDir  string\n\tlogPath    string\n}\n\nfunc (f *fakeOpenCodeRunLogger) Run(issueID string, repoRoot string, prompt string, model string, configRoot string, configDir string, logPath string) error {\n\tf.called = true\n\tf.issueID = issueID\n\tf.repoRoot = repoRoot\n\tf.prompt = prompt\n\tf.model = model\n\tf.configRoot = configRoot\n\tf.configDir = configDir\n\tf.logPath = logPath\n\treturn nil\n}\n\ntype fakeOpenCodeRunner struct {\n\tenv map[string]string\n}\n\ntype fakeOpenCodeProcess struct{}\n\nfunc (fakeOpenCodeProcess) Wait() error { return nil }\n\nfunc (fakeOpenCodeProcess) Kill() error { return nil }\n\nfunc (f *fakeOpenCodeRunner) Start(args []string, env map[string]string, stdoutPath string) (opencode.Process, error) {\n\tf.env = env\n\treturn fakeOpenCodeProcess{}, nil\n}\n\ntype fakeGitRunner struct {\n\tcalls  []string\n\toutput string\n\terr    error\n}\n\nfunc (f *fakeGitRunner) Run(name string, args ...string) (string, error) {\n\tf.calls = append(f.calls, name+\" \"+strings.Join(args, \" \"))\n\treturn f.output, f.err\n}\n\ntype fakeExit struct {\n\tcode int\n}\n\nfunc (f *fakeExit) Exit(code int) {\n\tf.code = code\n}\n\ntype fakeRunOnce struct {\n\tcalled bool\n\topts   runner.RunOnceOptions\n\tdeps   runner.RunOnceDeps\n\tresult string\n\terr    error\n}\n\nfunc (f *fakeRunOnce) Run(opts runner.RunOnceOptions, deps runner.RunOnceDeps) (string, error) {\n\n\tf.called = true\n\tf.opts = opts\n\tf.deps = deps\n\treturn f.result, f.err\n}\n\nfunc TestRunOnceMainReturnsErrorCodeOnFailure(t *testing.T) {\n\trunner := &fakeRunOnce{err: errors.New(\"boom\")}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\n\tcode := RunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\"}, runner.Run, exit.Exit, out, out, nil, nil)\n\n\tif code != 1 {\n\t\tt.Fatalf(\"expected exit code 1, got %d\", code)\n\t}\n\tif exit.code != 1 {\n\t\tt.Fatalf(\"expected exit to be called with 1, got %d\", exit.code)\n\t}\n\tif !strings.Contains(out.String(), \"boom\") {\n\t\tt.Fatalf(\"expected error output, got %q\", out.String())\n\t}\n}\n\nfunc TestRunOnceMainWiresDependencies(t *testing.T) {\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tRunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\", \"--model\", \"model\", \"--dry-run\"}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif !runner.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n\tif runner.opts.RepoRoot != \"/repo\" || runner.opts.RootID != \"root\" || runner.opts.Model != \"model\" || !runner.opts.DryRun {\n\t\tt.Fatalf(\"unexpected options: %#v\", runner.opts)\n\t}\n\tif runner.opts.Out == nil {\n\t\tt.Fatalf(\"expected output writer\")\n\t}\n\tif runner.deps.Beads == nil || runner.deps.Git == nil || runner.deps.Prompt == nil || runner.deps.OpenCode == nil || runner.deps.Logger == nil {\n\t\tt.Fatalf(\"expected deps to be wired\")\n\t}\n\tif exit.code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", exit.code)\n\t}\n}\n\nfunc TestRunOnceMainDefaultsConfigPaths(t *testing.T) {\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tt.Setenv(\"HOME\", \"/home/user\")\n\n\tRunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\"}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif !runner.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n\tif runner.opts.ConfigRoot == \"\" {\n\t\tt.Fatalf(\"expected config root to be set\")\n\t}\n\tif runner.opts.ConfigDir == \"\" {\n\t\tt.Fatalf(\"expected config dir to be set\")\n\t}\n\texpectedConfigRoot := filepath.Join(\"/home/user\", \".config\", \"opencode-runner\")\n\tif runner.opts.ConfigRoot != expectedConfigRoot {\n\t\tt.Fatalf(\"expected config root %q, got %q\", expectedConfigRoot, runner.opts.ConfigRoot)\n\t}\n\texpectedConfigDir := filepath.Join(expectedConfigRoot, \"opencode\")\n\tif runner.opts.ConfigDir != expectedConfigDir {\n\t\tt.Fatalf(\"expected config dir %q, got %q\", expectedConfigDir, runner.opts.ConfigDir)\n\t}\n\tif exit.code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", exit.code)\n\t}\n}\n\ntype fakeTUIProgram struct {\n\tstarted chan struct{}\n\tquit    chan struct{}\n\tevents  []runner.Event\n}\n\nfunc newFakeTUIProgram() *fakeTUIProgram {\n\treturn &fakeTUIProgram{\n\t\tstarted: make(chan struct{}),\n\t\tquit:    make(chan struct{}),\n\t}\n}\n\nfunc (f *fakeTUIProgram) Start() error {\n\tclose(f.started)\n\treturn nil\n}\n\nfunc (f *fakeTUIProgram) Send(event runner.Event) {\n\tf.events = append(f.events, event)\n}\n\nfunc (f *fakeTUIProgram) Quit() {\n\tclose(f.quit)\n}\n\nfunc waitForSignal(t *testing.T, signal chan struct{}, label string) {\n\tt.Helper()\n\tselect {\n\tcase <-signal:\n\t\treturn\n\tcase <-time.After(200 * time.Millisecond):\n\t\tt.Fatalf(\"expected %s\", label)\n\t}\n}\n\nfunc TestRunOnceMainUsesTUIOnTTYByDefault(t *testing.T) {\n\tfakeProgram := newFakeTUIProgram()\n\tprevIsTerminal := isTerminal\n\tprevNewTUIProgram := newTUIProgram\n\tisTerminal = func(io.Writer) bool { return true }\n\tnewTUIProgram = func(stdout io.Writer) tuiProgram { return fakeProgram }\n\tt.Cleanup(func() {\n\t\tisTerminal = prevIsTerminal\n\t\tnewTUIProgram = prevNewTUIProgram\n\t})\n\n\trunOnce := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\"}, runOnce.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", code)\n\t}\n\tif runOnce.deps.Events == nil {\n\t\tt.Fatalf(\"expected events emitter to be set\")\n\t}\n\trunOnce.deps.Events.Emit(runner.Event{Type: runner.EventSelectTask})\n\twaitForSignal(t, fakeProgram.started, \"tui start\")\n\twaitForSignal(t, fakeProgram.quit, \"tui quit\")\n\tif len(fakeProgram.events) != 1 {\n\t\tt.Fatalf(\"expected event to be forwarded to TUI\")\n\t}\n}\n\nfunc TestRunOnceMainHeadlessDisablesTUI(t *testing.T) {\n\tcalled := false\n\tprevIsTerminal := isTerminal\n\tprevNewTUIProgram := newTUIProgram\n\tisTerminal = func(io.Writer) bool { return true }\n\tnewTUIProgram = func(stdout io.Writer) tuiProgram {\n\t\tcalled = true\n\t\treturn newFakeTUIProgram()\n\t}\n\tt.Cleanup(func() {\n\t\tisTerminal = prevIsTerminal\n\t\tnewTUIProgram = prevNewTUIProgram\n\t})\n\n\trunOnce := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\tstderr := &bytes.Buffer{}\n\n\tRunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\", \"--headless\"}, runOnce.Run, exit.Exit, out, stderr, beadsRunner, gitRunner)\n\n\tif called {\n\t\tt.Fatalf(\"expected TUI program not to start\")\n\t}\n\tif runOnce.deps.Events != nil {\n\t\tt.Fatalf(\"expected no events emitter in headless mode\")\n\t}\n}\n\nfunc TestOpenCodeRunDefaultsCreateConfigAndEnv(t *testing.T) {\n\ttempDir := t.TempDir()\n\trepoRoot := filepath.Join(tempDir, \"repo\")\n\tif err := os.MkdirAll(repoRoot, 0o755); err != nil {\n\t\tt.Fatalf(\"mkdir repo: %v\", err)\n\t}\n\tt.Setenv(\"HOME\", tempDir)\n\n\topenCodeRunner := &fakeOpenCodeRunner{}\n\topenCodeAdapter := openCodeAdapter{runner: openCodeRunner}\n\n\tconfigRoot := filepath.Join(tempDir, \".config\", \"opencode-runner\")\n\tconfigDir := filepath.Join(configRoot, \"opencode\")\n\tlogPath := filepath.Join(tempDir, \"runner-logs\", \"opencode\", \"issue-1.jsonl\")\n\n\tif err := openCodeAdapter.Run(\"issue-1\", repoRoot, \"prompt\", \"\", configRoot, configDir, logPath); err != nil {\n\t\tt.Fatalf(\"open code run error: %v\", err)\n\t}\n\n\tconfigFile := filepath.Join(configDir, \"opencode.json\")\n\tif _, err := os.Stat(configFile); err != nil {\n\t\tt.Fatalf(\"expected opencode.json to exist: %v\", err)\n\t}\n\texpectedConfigFile := filepath.Join(configDir, \"opencode.json\")\n\tif openCodeRunner.env[\"XDG_CONFIG_HOME\"] != configRoot {\n\t\tt.Fatalf(\"expected XDG_CONFIG_HOME set\")\n\t}\n\tif openCodeRunner.env[\"OPENCODE_CONFIG_DIR\"] != configDir {\n\t\tt.Fatalf(\"expected OPENCODE_CONFIG_DIR set\")\n\t}\n\tif openCodeRunner.env[\"OPENCODE_CONFIG\"] != expectedConfigFile {\n\t\tt.Fatalf(\"expected OPENCODE_CONFIG set\")\n\t}\n\tif openCodeRunner.env[\"OPENCODE_CONFIG_CONTENT\"] != \"{}\" {\n\t\tt.Fatalf(\"expected OPENCODE_CONFIG_CONTENT set\")\n\t}\n}\n","additions":1,"deletions":1},"truncated":false},"time":{"start":1768840846267,"end":1768840846426}},"metadata":{"openai":{"itemId":"fc_003f748dd36867ec01696e5e8b6f788191bfc31f35be3d72dc"}}}}
{"type":"step_finish","timestamp":1768840846448,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd7215c5b001wh5p0Ami4I3usB","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd7214c9f0017CsqaQfE5FbVjX","type":"step-finish","reason":"tool-calls","snapshot":"3a942ac06852f99a3d6f75016070e2024edcc2f0","cost":0,"tokens":{"input":1208,"output":178,"reasoning":0,"cache":{"read":55936,"write":0}}}}
{"type":"step_start","timestamp":1768840846846,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd7215dfe001OKTXobdkBGqoI1","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd7215c950017xkp61LVXVE7c6","type":"step-start","snapshot":"eff5065b1cfeb29e80dc6ecca56315eb44c12908"}}
{"type":"tool_use","timestamp":1768840853770,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd721604b001j6eualGxAXhPHo","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd7215c950017xkp61LVXVE7c6","type":"tool","callID":"call_wSJcDE0DQEFK0LBIegzUXVL3","tool":"edit","state":{"status":"completed","input":{"filePath":"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go","oldString":"type fakeTUIProgram struct {\n\tstarted chan struct{}\n\tquit    chan struct{}\n\tevents  []runner.Event\n}\n\nfunc newFakeTUIProgram() *fakeTUIProgram {\n\treturn &fakeTUIProgram{\n\t\tstarted: make(chan struct{}),\n\t\tquit:    make(chan struct{}),\n\t}\n}\n\nfunc (f *fakeTUIProgram) Start() error {\n\tclose(f.started)\n\treturn nil\n}\n\nfunc (f *fakeTUIProgram) Send(event runner.Event) {\n\tf.events = append(f.events, event)\n}\n\nfunc (f *fakeTUIProgram) Quit() {\n\tclose(f.quit)\n}\n","newString":"type fakeTUIProgram struct {\n\tstarted chan struct{}\n\tquit    chan struct{}\n\tevents  chan runner.Event\n}\n\nfunc newFakeTUIProgram() *fakeTUIProgram {\n\treturn &fakeTUIProgram{\n\t\tstarted: make(chan struct{}),\n\t\tquit:    make(chan struct{}),\n\t\tevents:  make(chan runner.Event, 1),\n\t}\n}\n\nfunc (f *fakeTUIProgram) Start() error {\n\tclose(f.started)\n\treturn nil\n}\n\nfunc (f *fakeTUIProgram) Send(event runner.Event) {\n\tf.events <- event\n}\n\nfunc (f *fakeTUIProgram) Quit() {\n\tclose(f.quit)\n}\n"},"output":"Edit applied successfully.","title":"cmd/yolo-runner/main_test.go","metadata":{"diagnostics":{"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main.go":[],"/Users/egv/dev/yolo-runner/go.mod":[{"range":{"start":{"line":6,"character":44},"end":{"line":6,"character":55}},"severity":2,"source":"go mod tidy","message":"github.com/charmbracelet/bubbletea should be direct"},{"range":{"start":{"line":19,"character":26},"end":{"line":19,"character":37}},"severity":2,"source":"go mod tidy","message":"golang.org/x/term should be direct"}],"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go":[],"/Users/egv/dev/yolo-runner/bubbletea_test.go":[],"/Users/egv/dev/yolo-runner/opencode_adapter_v1.go":[{"range":{"start":{"line":24,"character":1},"end":{"line":24,"character":18}},"severity":2,"code":"default","codeDescription":{"href":"https://staticcheck.dev/docs/checks/#S1031"},"source":"S1031","message":"unnecessary nil check around range"}],"/Users/egv/dev/yolo-runner/internal/ui/tui/model.go":[],"/Users/egv/dev/yolo-runner/internal/runner/runner.go":[],"/Users/egv/dev/yolo-runner/internal/ui/tui/model_test.go":[],"/Users/egv/dev/yolo-runner/internal/runner/events.go":[],"/Users/egv/dev/yolo-runner/internal/runner/loop_test.go":[],"/Users/egv/dev/yolo-runner/internal/runner/runner_test.go":[],"/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/tea.go":[],"/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/tty_unix.go":[],"/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/tty.go":[],"/Users/egv/dev/yolo-runner/internal/opencode/watchdog.go":[],"/Users/egv/dev/yolo-runner/internal/opencode/client.go":[{"range":{"start":{"line":28,"character":1},"end":{"line":28,"character":18}},"severity":2,"code":"default","codeDescription":{"href":"https://staticcheck.dev/docs/checks/#S1031"},"source":"S1031","message":"unnecessary nil check around range"}],"/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/options.go":[],"/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/tty_windows.go":[{"range":{"start":{"line":3,"character":8},"end":{"line":3,"character":11}},"severity":2,"source":"go list","message":"This file is within module \"../../go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0\", which is not included in your workspace.\nTo fix this problem, you can add a go.work file that uses this directory.\nSee the documentation for more information on setting up your workspace:\nhttps://github.com/golang/tools/blob/master/gopls/doc/workspace.md.","data":{"Actions":[{"title":"Add a go.work file using this module","kind":"quickfix","command":{"title":"Run `go work init && go work use`","command":"gopls.run_go_work_command","arguments":[{"ViewID":"1","InitFirst":true,"Args":["use","../../go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0"]}]}}]}}]},"diff":"Index: /Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go\n===================================================================\n--- /Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go\n+++ /Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go\n@@ -175,15 +175,16 @@\n \n type fakeTUIProgram struct {\n \tstarted chan struct{}\n \tquit    chan struct{}\n-\tevents  []runner.Event\n+\tevents  chan runner.Event\n }\n \n func newFakeTUIProgram() *fakeTUIProgram {\n \treturn &fakeTUIProgram{\n \t\tstarted: make(chan struct{}),\n \t\tquit:    make(chan struct{}),\n+\t\tevents:  make(chan runner.Event, 1),\n \t}\n }\n \n func (f *fakeTUIProgram) Start() error {\n@@ -191,9 +192,9 @@\n \treturn nil\n }\n \n func (f *fakeTUIProgram) Send(event runner.Event) {\n-\tf.events = append(f.events, event)\n+\tf.events <- event\n }\n \n func (f *fakeTUIProgram) Quit() {\n \tclose(f.quit)\n","filediff":{"file":"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go","before":"package main\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"yolo-runner/internal/opencode\"\n\t\"yolo-runner/internal/runner\"\n)\n\ntype fakeRunner struct {\n\tcalls []string\n}\n\nfunc (f *fakeRunner) Run(args ...string) (string, error) {\n\tf.calls = append(f.calls, strings.Join(args, \" \"))\n\treturn \"\", nil\n}\n\ntype fakeOpenCodeRunLogger struct {\n\tcalled     bool\n\tissueID    string\n\trepoRoot   string\n\tprompt     string\n\tmodel      string\n\tconfigRoot string\n\tconfigDir  string\n\tlogPath    string\n}\n\nfunc (f *fakeOpenCodeRunLogger) Run(issueID string, repoRoot string, prompt string, model string, configRoot string, configDir string, logPath string) error {\n\tf.called = true\n\tf.issueID = issueID\n\tf.repoRoot = repoRoot\n\tf.prompt = prompt\n\tf.model = model\n\tf.configRoot = configRoot\n\tf.configDir = configDir\n\tf.logPath = logPath\n\treturn nil\n}\n\ntype fakeOpenCodeRunner struct {\n\tenv map[string]string\n}\n\ntype fakeOpenCodeProcess struct{}\n\nfunc (fakeOpenCodeProcess) Wait() error { return nil }\n\nfunc (fakeOpenCodeProcess) Kill() error { return nil }\n\nfunc (f *fakeOpenCodeRunner) Start(args []string, env map[string]string, stdoutPath string) (opencode.Process, error) {\n\tf.env = env\n\treturn fakeOpenCodeProcess{}, nil\n}\n\ntype fakeGitRunner struct {\n\tcalls  []string\n\toutput string\n\terr    error\n}\n\nfunc (f *fakeGitRunner) Run(name string, args ...string) (string, error) {\n\tf.calls = append(f.calls, name+\" \"+strings.Join(args, \" \"))\n\treturn f.output, f.err\n}\n\ntype fakeExit struct {\n\tcode int\n}\n\nfunc (f *fakeExit) Exit(code int) {\n\tf.code = code\n}\n\ntype fakeRunOnce struct {\n\tcalled bool\n\topts   runner.RunOnceOptions\n\tdeps   runner.RunOnceDeps\n\tresult string\n\terr    error\n}\n\nfunc (f *fakeRunOnce) Run(opts runner.RunOnceOptions, deps runner.RunOnceDeps) (string, error) {\n\n\tf.called = true\n\tf.opts = opts\n\tf.deps = deps\n\treturn f.result, f.err\n}\n\nfunc TestRunOnceMainReturnsErrorCodeOnFailure(t *testing.T) {\n\trunner := &fakeRunOnce{err: errors.New(\"boom\")}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\n\tcode := RunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\"}, runner.Run, exit.Exit, out, out, nil, nil)\n\n\tif code != 1 {\n\t\tt.Fatalf(\"expected exit code 1, got %d\", code)\n\t}\n\tif exit.code != 1 {\n\t\tt.Fatalf(\"expected exit to be called with 1, got %d\", exit.code)\n\t}\n\tif !strings.Contains(out.String(), \"boom\") {\n\t\tt.Fatalf(\"expected error output, got %q\", out.String())\n\t}\n}\n\nfunc TestRunOnceMainWiresDependencies(t *testing.T) {\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tRunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\", \"--model\", \"model\", \"--dry-run\"}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif !runner.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n\tif runner.opts.RepoRoot != \"/repo\" || runner.opts.RootID != \"root\" || runner.opts.Model != \"model\" || !runner.opts.DryRun {\n\t\tt.Fatalf(\"unexpected options: %#v\", runner.opts)\n\t}\n\tif runner.opts.Out == nil {\n\t\tt.Fatalf(\"expected output writer\")\n\t}\n\tif runner.deps.Beads == nil || runner.deps.Git == nil || runner.deps.Prompt == nil || runner.deps.OpenCode == nil || runner.deps.Logger == nil {\n\t\tt.Fatalf(\"expected deps to be wired\")\n\t}\n\tif exit.code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", exit.code)\n\t}\n}\n\nfunc TestRunOnceMainDefaultsConfigPaths(t *testing.T) {\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tt.Setenv(\"HOME\", \"/home/user\")\n\n\tRunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\"}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif !runner.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n\tif runner.opts.ConfigRoot == \"\" {\n\t\tt.Fatalf(\"expected config root to be set\")\n\t}\n\tif runner.opts.ConfigDir == \"\" {\n\t\tt.Fatalf(\"expected config dir to be set\")\n\t}\n\texpectedConfigRoot := filepath.Join(\"/home/user\", \".config\", \"opencode-runner\")\n\tif runner.opts.ConfigRoot != expectedConfigRoot {\n\t\tt.Fatalf(\"expected config root %q, got %q\", expectedConfigRoot, runner.opts.ConfigRoot)\n\t}\n\texpectedConfigDir := filepath.Join(expectedConfigRoot, \"opencode\")\n\tif runner.opts.ConfigDir != expectedConfigDir {\n\t\tt.Fatalf(\"expected config dir %q, got %q\", expectedConfigDir, runner.opts.ConfigDir)\n\t}\n\tif exit.code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", exit.code)\n\t}\n}\n\ntype fakeTUIProgram struct {\n\tstarted chan struct{}\n\tquit    chan struct{}\n\tevents  []runner.Event\n}\n\nfunc newFakeTUIProgram() *fakeTUIProgram {\n\treturn &fakeTUIProgram{\n\t\tstarted: make(chan struct{}),\n\t\tquit:    make(chan struct{}),\n\t}\n}\n\nfunc (f *fakeTUIProgram) Start() error {\n\tclose(f.started)\n\treturn nil\n}\n\nfunc (f *fakeTUIProgram) Send(event runner.Event) {\n\tf.events = append(f.events, event)\n}\n\nfunc (f *fakeTUIProgram) Quit() {\n\tclose(f.quit)\n}\n\nfunc waitForSignal(t *testing.T, signal chan struct{}, label string) {\n\tt.Helper()\n\tselect {\n\tcase <-signal:\n\t\treturn\n\tcase <-time.After(200 * time.Millisecond):\n\t\tt.Fatalf(\"expected %s\", label)\n\t}\n}\n\nfunc TestRunOnceMainUsesTUIOnTTYByDefault(t *testing.T) {\n\tfakeProgram := newFakeTUIProgram()\n\tprevIsTerminal := isTerminal\n\tprevNewTUIProgram := newTUIProgram\n\tisTerminal = func(io.Writer) bool { return true }\n\tnewTUIProgram = func(stdout io.Writer) tuiProgram { return fakeProgram }\n\tt.Cleanup(func() {\n\t\tisTerminal = prevIsTerminal\n\t\tnewTUIProgram = prevNewTUIProgram\n\t})\n\n\trunOnce := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\"}, runOnce.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", code)\n\t}\n\tif runOnce.deps.Events == nil {\n\t\tt.Fatalf(\"expected events emitter to be set\")\n\t}\n\trunOnce.deps.Events.Emit(runner.Event{Type: runner.EventSelectTask})\n\twaitForSignal(t, fakeProgram.started, \"tui start\")\n\twaitForSignal(t, fakeProgram.quit, \"tui quit\")\n\tif len(fakeProgram.events) != 1 {\n\t\tt.Fatalf(\"expected event to be forwarded to TUI\")\n\t}\n}\n\nfunc TestRunOnceMainHeadlessDisablesTUI(t *testing.T) {\n\tcalled := false\n\tprevIsTerminal := isTerminal\n\tprevNewTUIProgram := newTUIProgram\n\tisTerminal = func(io.Writer) bool { return true }\n\tnewTUIProgram = func(stdout io.Writer) tuiProgram {\n\t\tcalled = true\n\t\treturn newFakeTUIProgram()\n\t}\n\tt.Cleanup(func() {\n\t\tisTerminal = prevIsTerminal\n\t\tnewTUIProgram = prevNewTUIProgram\n\t})\n\n\trunOnce := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\tstderr := &bytes.Buffer{}\n\n\tRunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\", \"--headless\"}, runOnce.Run, exit.Exit, out, stderr, beadsRunner, gitRunner)\n\n\tif called {\n\t\tt.Fatalf(\"expected TUI program not to start\")\n\t}\n\tif runOnce.deps.Events != nil {\n\t\tt.Fatalf(\"expected no events emitter in headless mode\")\n\t}\n}\n\nfunc TestOpenCodeRunDefaultsCreateConfigAndEnv(t *testing.T) {\n\ttempDir := t.TempDir()\n\trepoRoot := filepath.Join(tempDir, \"repo\")\n\tif err := os.MkdirAll(repoRoot, 0o755); err != nil {\n\t\tt.Fatalf(\"mkdir repo: %v\", err)\n\t}\n\tt.Setenv(\"HOME\", tempDir)\n\n\topenCodeRunner := &fakeOpenCodeRunner{}\n\topenCodeAdapter := openCodeAdapter{runner: openCodeRunner}\n\n\tconfigRoot := filepath.Join(tempDir, \".config\", \"opencode-runner\")\n\tconfigDir := filepath.Join(configRoot, \"opencode\")\n\tlogPath := filepath.Join(tempDir, \"runner-logs\", \"opencode\", \"issue-1.jsonl\")\n\n\tif err := openCodeAdapter.Run(\"issue-1\", repoRoot, \"prompt\", \"\", configRoot, configDir, logPath); err != nil {\n\t\tt.Fatalf(\"open code run error: %v\", err)\n\t}\n\n\tconfigFile := filepath.Join(configDir, \"opencode.json\")\n\tif _, err := os.Stat(configFile); err != nil {\n\t\tt.Fatalf(\"expected opencode.json to exist: %v\", err)\n\t}\n\texpectedConfigFile := filepath.Join(configDir, \"opencode.json\")\n\tif openCodeRunner.env[\"XDG_CONFIG_HOME\"] != configRoot {\n\t\tt.Fatalf(\"expected XDG_CONFIG_HOME set\")\n\t}\n\tif openCodeRunner.env[\"OPENCODE_CONFIG_DIR\"] != configDir {\n\t\tt.Fatalf(\"expected OPENCODE_CONFIG_DIR set\")\n\t}\n\tif openCodeRunner.env[\"OPENCODE_CONFIG\"] != expectedConfigFile {\n\t\tt.Fatalf(\"expected OPENCODE_CONFIG set\")\n\t}\n\tif openCodeRunner.env[\"OPENCODE_CONFIG_CONTENT\"] != \"{}\" {\n\t\tt.Fatalf(\"expected OPENCODE_CONFIG_CONTENT set\")\n\t}\n}\n","after":"package main\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"yolo-runner/internal/opencode\"\n\t\"yolo-runner/internal/runner\"\n)\n\ntype fakeRunner struct {\n\tcalls []string\n}\n\nfunc (f *fakeRunner) Run(args ...string) (string, error) {\n\tf.calls = append(f.calls, strings.Join(args, \" \"))\n\treturn \"\", nil\n}\n\ntype fakeOpenCodeRunLogger struct {\n\tcalled     bool\n\tissueID    string\n\trepoRoot   string\n\tprompt     string\n\tmodel      string\n\tconfigRoot string\n\tconfigDir  string\n\tlogPath    string\n}\n\nfunc (f *fakeOpenCodeRunLogger) Run(issueID string, repoRoot string, prompt string, model string, configRoot string, configDir string, logPath string) error {\n\tf.called = true\n\tf.issueID = issueID\n\tf.repoRoot = repoRoot\n\tf.prompt = prompt\n\tf.model = model\n\tf.configRoot = configRoot\n\tf.configDir = configDir\n\tf.logPath = logPath\n\treturn nil\n}\n\ntype fakeOpenCodeRunner struct {\n\tenv map[string]string\n}\n\ntype fakeOpenCodeProcess struct{}\n\nfunc (fakeOpenCodeProcess) Wait() error { return nil }\n\nfunc (fakeOpenCodeProcess) Kill() error { return nil }\n\nfunc (f *fakeOpenCodeRunner) Start(args []string, env map[string]string, stdoutPath string) (opencode.Process, error) {\n\tf.env = env\n\treturn fakeOpenCodeProcess{}, nil\n}\n\ntype fakeGitRunner struct {\n\tcalls  []string\n\toutput string\n\terr    error\n}\n\nfunc (f *fakeGitRunner) Run(name string, args ...string) (string, error) {\n\tf.calls = append(f.calls, name+\" \"+strings.Join(args, \" \"))\n\treturn f.output, f.err\n}\n\ntype fakeExit struct {\n\tcode int\n}\n\nfunc (f *fakeExit) Exit(code int) {\n\tf.code = code\n}\n\ntype fakeRunOnce struct {\n\tcalled bool\n\topts   runner.RunOnceOptions\n\tdeps   runner.RunOnceDeps\n\tresult string\n\terr    error\n}\n\nfunc (f *fakeRunOnce) Run(opts runner.RunOnceOptions, deps runner.RunOnceDeps) (string, error) {\n\n\tf.called = true\n\tf.opts = opts\n\tf.deps = deps\n\treturn f.result, f.err\n}\n\nfunc TestRunOnceMainReturnsErrorCodeOnFailure(t *testing.T) {\n\trunner := &fakeRunOnce{err: errors.New(\"boom\")}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\n\tcode := RunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\"}, runner.Run, exit.Exit, out, out, nil, nil)\n\n\tif code != 1 {\n\t\tt.Fatalf(\"expected exit code 1, got %d\", code)\n\t}\n\tif exit.code != 1 {\n\t\tt.Fatalf(\"expected exit to be called with 1, got %d\", exit.code)\n\t}\n\tif !strings.Contains(out.String(), \"boom\") {\n\t\tt.Fatalf(\"expected error output, got %q\", out.String())\n\t}\n}\n\nfunc TestRunOnceMainWiresDependencies(t *testing.T) {\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tRunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\", \"--model\", \"model\", \"--dry-run\"}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif !runner.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n\tif runner.opts.RepoRoot != \"/repo\" || runner.opts.RootID != \"root\" || runner.opts.Model != \"model\" || !runner.opts.DryRun {\n\t\tt.Fatalf(\"unexpected options: %#v\", runner.opts)\n\t}\n\tif runner.opts.Out == nil {\n\t\tt.Fatalf(\"expected output writer\")\n\t}\n\tif runner.deps.Beads == nil || runner.deps.Git == nil || runner.deps.Prompt == nil || runner.deps.OpenCode == nil || runner.deps.Logger == nil {\n\t\tt.Fatalf(\"expected deps to be wired\")\n\t}\n\tif exit.code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", exit.code)\n\t}\n}\n\nfunc TestRunOnceMainDefaultsConfigPaths(t *testing.T) {\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tt.Setenv(\"HOME\", \"/home/user\")\n\n\tRunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\"}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif !runner.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n\tif runner.opts.ConfigRoot == \"\" {\n\t\tt.Fatalf(\"expected config root to be set\")\n\t}\n\tif runner.opts.ConfigDir == \"\" {\n\t\tt.Fatalf(\"expected config dir to be set\")\n\t}\n\texpectedConfigRoot := filepath.Join(\"/home/user\", \".config\", \"opencode-runner\")\n\tif runner.opts.ConfigRoot != expectedConfigRoot {\n\t\tt.Fatalf(\"expected config root %q, got %q\", expectedConfigRoot, runner.opts.ConfigRoot)\n\t}\n\texpectedConfigDir := filepath.Join(expectedConfigRoot, \"opencode\")\n\tif runner.opts.ConfigDir != expectedConfigDir {\n\t\tt.Fatalf(\"expected config dir %q, got %q\", expectedConfigDir, runner.opts.ConfigDir)\n\t}\n\tif exit.code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", exit.code)\n\t}\n}\n\ntype fakeTUIProgram struct {\n\tstarted chan struct{}\n\tquit    chan struct{}\n\tevents  chan runner.Event\n}\n\nfunc newFakeTUIProgram() *fakeTUIProgram {\n\treturn &fakeTUIProgram{\n\t\tstarted: make(chan struct{}),\n\t\tquit:    make(chan struct{}),\n\t\tevents:  make(chan runner.Event, 1),\n\t}\n}\n\nfunc (f *fakeTUIProgram) Start() error {\n\tclose(f.started)\n\treturn nil\n}\n\nfunc (f *fakeTUIProgram) Send(event runner.Event) {\n\tf.events <- event\n}\n\nfunc (f *fakeTUIProgram) Quit() {\n\tclose(f.quit)\n}\n\nfunc waitForSignal(t *testing.T, signal chan struct{}, label string) {\n\tt.Helper()\n\tselect {\n\tcase <-signal:\n\t\treturn\n\tcase <-time.After(200 * time.Millisecond):\n\t\tt.Fatalf(\"expected %s\", label)\n\t}\n}\n\nfunc TestRunOnceMainUsesTUIOnTTYByDefault(t *testing.T) {\n\tfakeProgram := newFakeTUIProgram()\n\tprevIsTerminal := isTerminal\n\tprevNewTUIProgram := newTUIProgram\n\tisTerminal = func(io.Writer) bool { return true }\n\tnewTUIProgram = func(stdout io.Writer) tuiProgram { return fakeProgram }\n\tt.Cleanup(func() {\n\t\tisTerminal = prevIsTerminal\n\t\tnewTUIProgram = prevNewTUIProgram\n\t})\n\n\trunOnce := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\"}, runOnce.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", code)\n\t}\n\tif runOnce.deps.Events == nil {\n\t\tt.Fatalf(\"expected events emitter to be set\")\n\t}\n\trunOnce.deps.Events.Emit(runner.Event{Type: runner.EventSelectTask})\n\twaitForSignal(t, fakeProgram.started, \"tui start\")\n\twaitForSignal(t, fakeProgram.quit, \"tui quit\")\n\tif len(fakeProgram.events) != 1 {\n\t\tt.Fatalf(\"expected event to be forwarded to TUI\")\n\t}\n}\n\nfunc TestRunOnceMainHeadlessDisablesTUI(t *testing.T) {\n\tcalled := false\n\tprevIsTerminal := isTerminal\n\tprevNewTUIProgram := newTUIProgram\n\tisTerminal = func(io.Writer) bool { return true }\n\tnewTUIProgram = func(stdout io.Writer) tuiProgram {\n\t\tcalled = true\n\t\treturn newFakeTUIProgram()\n\t}\n\tt.Cleanup(func() {\n\t\tisTerminal = prevIsTerminal\n\t\tnewTUIProgram = prevNewTUIProgram\n\t})\n\n\trunOnce := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\tstderr := &bytes.Buffer{}\n\n\tRunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\", \"--headless\"}, runOnce.Run, exit.Exit, out, stderr, beadsRunner, gitRunner)\n\n\tif called {\n\t\tt.Fatalf(\"expected TUI program not to start\")\n\t}\n\tif runOnce.deps.Events != nil {\n\t\tt.Fatalf(\"expected no events emitter in headless mode\")\n\t}\n}\n\nfunc TestOpenCodeRunDefaultsCreateConfigAndEnv(t *testing.T) {\n\ttempDir := t.TempDir()\n\trepoRoot := filepath.Join(tempDir, \"repo\")\n\tif err := os.MkdirAll(repoRoot, 0o755); err != nil {\n\t\tt.Fatalf(\"mkdir repo: %v\", err)\n\t}\n\tt.Setenv(\"HOME\", tempDir)\n\n\topenCodeRunner := &fakeOpenCodeRunner{}\n\topenCodeAdapter := openCodeAdapter{runner: openCodeRunner}\n\n\tconfigRoot := filepath.Join(tempDir, \".config\", \"opencode-runner\")\n\tconfigDir := filepath.Join(configRoot, \"opencode\")\n\tlogPath := filepath.Join(tempDir, \"runner-logs\", \"opencode\", \"issue-1.jsonl\")\n\n\tif err := openCodeAdapter.Run(\"issue-1\", repoRoot, \"prompt\", \"\", configRoot, configDir, logPath); err != nil {\n\t\tt.Fatalf(\"open code run error: %v\", err)\n\t}\n\n\tconfigFile := filepath.Join(configDir, \"opencode.json\")\n\tif _, err := os.Stat(configFile); err != nil {\n\t\tt.Fatalf(\"expected opencode.json to exist: %v\", err)\n\t}\n\texpectedConfigFile := filepath.Join(configDir, \"opencode.json\")\n\tif openCodeRunner.env[\"XDG_CONFIG_HOME\"] != configRoot {\n\t\tt.Fatalf(\"expected XDG_CONFIG_HOME set\")\n\t}\n\tif openCodeRunner.env[\"OPENCODE_CONFIG_DIR\"] != configDir {\n\t\tt.Fatalf(\"expected OPENCODE_CONFIG_DIR set\")\n\t}\n\tif openCodeRunner.env[\"OPENCODE_CONFIG\"] != expectedConfigFile {\n\t\tt.Fatalf(\"expected OPENCODE_CONFIG set\")\n\t}\n\tif openCodeRunner.env[\"OPENCODE_CONFIG_CONTENT\"] != \"{}\" {\n\t\tt.Fatalf(\"expected OPENCODE_CONFIG_CONTENT set\")\n\t}\n}\n","additions":3,"deletions":2},"truncated":false},"time":{"start":1768840853609,"end":1768840853769}},"metadata":{"openai":{"itemId":"fc_05bf7978c779299901696e5e8f70688191b5649f61c4ce9960"}}}}
{"type":"step_finish","timestamp":1768840853789,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd721790a001ZNJkC0SeIWn2X2","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd7215c950017xkp61LVXVE7c6","type":"step-finish","reason":"tool-calls","snapshot":"e84a674c5dbb1bb34ea6c653f98ac62e30c22144","cost":0,"tokens":{"input":373,"output":379,"reasoning":0,"cache":{"read":56960,"write":0}}}}
{"type":"step_start","timestamp":1768840854246,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd7217ae5001QQk7IUpbZdujrE","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd7217942001OH3eIsCOO9RFM4","type":"step-start","snapshot":"736767efe04eb9e950fc695e831596adb36db717"}}
{"type":"tool_use","timestamp":1768840856916,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd7217c9a0011GRLf7CyUfWFmb","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd7217942001OH3eIsCOO9RFM4","type":"tool","callID":"call_Utb3zqKhvZDSdqPSgLApsniu","tool":"edit","state":{"status":"completed","input":{"filePath":"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go","oldString":"\tif len(fakeProgram.events) != 1 {\n\t\tt.Fatalf(\"expected event to be forwarded to TUI\")\n\t}\n","newString":"\tselect {\n\tcase <-fakeProgram.events:\n\t\treturn\n\tcase <-time.After(200 * time.Millisecond):\n\t\tt.Fatalf(\"expected event to be forwarded to TUI\")\n\t}\n"},"output":"Edit applied successfully.","title":"cmd/yolo-runner/main_test.go","metadata":{"diagnostics":{"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main.go":[],"/Users/egv/dev/yolo-runner/go.mod":[{"range":{"start":{"line":6,"character":44},"end":{"line":6,"character":55}},"severity":2,"source":"go mod tidy","message":"github.com/charmbracelet/bubbletea should be direct"},{"range":{"start":{"line":19,"character":26},"end":{"line":19,"character":37}},"severity":2,"source":"go mod tidy","message":"golang.org/x/term should be direct"}],"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go":[],"/Users/egv/dev/yolo-runner/bubbletea_test.go":[],"/Users/egv/dev/yolo-runner/opencode_adapter_v1.go":[{"range":{"start":{"line":24,"character":1},"end":{"line":24,"character":18}},"severity":2,"code":"default","codeDescription":{"href":"https://staticcheck.dev/docs/checks/#S1031"},"source":"S1031","message":"unnecessary nil check around range"}],"/Users/egv/dev/yolo-runner/internal/ui/tui/model.go":[],"/Users/egv/dev/yolo-runner/internal/runner/runner.go":[],"/Users/egv/dev/yolo-runner/internal/ui/tui/model_test.go":[],"/Users/egv/dev/yolo-runner/internal/runner/events.go":[],"/Users/egv/dev/yolo-runner/internal/runner/loop_test.go":[],"/Users/egv/dev/yolo-runner/internal/runner/runner_test.go":[],"/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/tea.go":[],"/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/tty_unix.go":[],"/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/tty.go":[],"/Users/egv/dev/yolo-runner/internal/opencode/watchdog.go":[],"/Users/egv/dev/yolo-runner/internal/opencode/client.go":[{"range":{"start":{"line":28,"character":1},"end":{"line":28,"character":18}},"severity":2,"code":"default","codeDescription":{"href":"https://staticcheck.dev/docs/checks/#S1031"},"source":"S1031","message":"unnecessary nil check around range"}],"/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/options.go":[],"/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/tty_windows.go":[{"range":{"start":{"line":3,"character":8},"end":{"line":3,"character":11}},"severity":2,"source":"go list","message":"This file is within module \"../../go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0\", which is not included in your workspace.\nTo fix this problem, you can add a go.work file that uses this directory.\nSee the documentation for more information on setting up your workspace:\nhttps://github.com/golang/tools/blob/master/gopls/doc/workspace.md.","data":{"Actions":[{"title":"Add a go.work file using this module","kind":"quickfix","command":{"title":"Run `go work init && go work use`","command":"gopls.run_go_work_command","arguments":[{"ViewID":"1","InitFirst":true,"Args":["use","../../go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0"]}]}}]}}]},"diff":"Index: /Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go\n===================================================================\n--- /Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go\n+++ /Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go\n@@ -237,9 +237,12 @@\n \t}\n \trunOnce.deps.Events.Emit(runner.Event{Type: runner.EventSelectTask})\n \twaitForSignal(t, fakeProgram.started, \"tui start\")\n \twaitForSignal(t, fakeProgram.quit, \"tui quit\")\n-\tif len(fakeProgram.events) != 1 {\n+\tselect {\n+\tcase <-fakeProgram.events:\n+\t\treturn\n+\tcase <-time.After(200 * time.Millisecond):\n \t\tt.Fatalf(\"expected event to be forwarded to TUI\")\n \t}\n }\n \n","filediff":{"file":"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go","before":"package main\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"yolo-runner/internal/opencode\"\n\t\"yolo-runner/internal/runner\"\n)\n\ntype fakeRunner struct {\n\tcalls []string\n}\n\nfunc (f *fakeRunner) Run(args ...string) (string, error) {\n\tf.calls = append(f.calls, strings.Join(args, \" \"))\n\treturn \"\", nil\n}\n\ntype fakeOpenCodeRunLogger struct {\n\tcalled     bool\n\tissueID    string\n\trepoRoot   string\n\tprompt     string\n\tmodel      string\n\tconfigRoot string\n\tconfigDir  string\n\tlogPath    string\n}\n\nfunc (f *fakeOpenCodeRunLogger) Run(issueID string, repoRoot string, prompt string, model string, configRoot string, configDir string, logPath string) error {\n\tf.called = true\n\tf.issueID = issueID\n\tf.repoRoot = repoRoot\n\tf.prompt = prompt\n\tf.model = model\n\tf.configRoot = configRoot\n\tf.configDir = configDir\n\tf.logPath = logPath\n\treturn nil\n}\n\ntype fakeOpenCodeRunner struct {\n\tenv map[string]string\n}\n\ntype fakeOpenCodeProcess struct{}\n\nfunc (fakeOpenCodeProcess) Wait() error { return nil }\n\nfunc (fakeOpenCodeProcess) Kill() error { return nil }\n\nfunc (f *fakeOpenCodeRunner) Start(args []string, env map[string]string, stdoutPath string) (opencode.Process, error) {\n\tf.env = env\n\treturn fakeOpenCodeProcess{}, nil\n}\n\ntype fakeGitRunner struct {\n\tcalls  []string\n\toutput string\n\terr    error\n}\n\nfunc (f *fakeGitRunner) Run(name string, args ...string) (string, error) {\n\tf.calls = append(f.calls, name+\" \"+strings.Join(args, \" \"))\n\treturn f.output, f.err\n}\n\ntype fakeExit struct {\n\tcode int\n}\n\nfunc (f *fakeExit) Exit(code int) {\n\tf.code = code\n}\n\ntype fakeRunOnce struct {\n\tcalled bool\n\topts   runner.RunOnceOptions\n\tdeps   runner.RunOnceDeps\n\tresult string\n\terr    error\n}\n\nfunc (f *fakeRunOnce) Run(opts runner.RunOnceOptions, deps runner.RunOnceDeps) (string, error) {\n\n\tf.called = true\n\tf.opts = opts\n\tf.deps = deps\n\treturn f.result, f.err\n}\n\nfunc TestRunOnceMainReturnsErrorCodeOnFailure(t *testing.T) {\n\trunner := &fakeRunOnce{err: errors.New(\"boom\")}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\n\tcode := RunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\"}, runner.Run, exit.Exit, out, out, nil, nil)\n\n\tif code != 1 {\n\t\tt.Fatalf(\"expected exit code 1, got %d\", code)\n\t}\n\tif exit.code != 1 {\n\t\tt.Fatalf(\"expected exit to be called with 1, got %d\", exit.code)\n\t}\n\tif !strings.Contains(out.String(), \"boom\") {\n\t\tt.Fatalf(\"expected error output, got %q\", out.String())\n\t}\n}\n\nfunc TestRunOnceMainWiresDependencies(t *testing.T) {\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tRunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\", \"--model\", \"model\", \"--dry-run\"}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif !runner.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n\tif runner.opts.RepoRoot != \"/repo\" || runner.opts.RootID != \"root\" || runner.opts.Model != \"model\" || !runner.opts.DryRun {\n\t\tt.Fatalf(\"unexpected options: %#v\", runner.opts)\n\t}\n\tif runner.opts.Out == nil {\n\t\tt.Fatalf(\"expected output writer\")\n\t}\n\tif runner.deps.Beads == nil || runner.deps.Git == nil || runner.deps.Prompt == nil || runner.deps.OpenCode == nil || runner.deps.Logger == nil {\n\t\tt.Fatalf(\"expected deps to be wired\")\n\t}\n\tif exit.code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", exit.code)\n\t}\n}\n\nfunc TestRunOnceMainDefaultsConfigPaths(t *testing.T) {\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tt.Setenv(\"HOME\", \"/home/user\")\n\n\tRunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\"}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif !runner.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n\tif runner.opts.ConfigRoot == \"\" {\n\t\tt.Fatalf(\"expected config root to be set\")\n\t}\n\tif runner.opts.ConfigDir == \"\" {\n\t\tt.Fatalf(\"expected config dir to be set\")\n\t}\n\texpectedConfigRoot := filepath.Join(\"/home/user\", \".config\", \"opencode-runner\")\n\tif runner.opts.ConfigRoot != expectedConfigRoot {\n\t\tt.Fatalf(\"expected config root %q, got %q\", expectedConfigRoot, runner.opts.ConfigRoot)\n\t}\n\texpectedConfigDir := filepath.Join(expectedConfigRoot, \"opencode\")\n\tif runner.opts.ConfigDir != expectedConfigDir {\n\t\tt.Fatalf(\"expected config dir %q, got %q\", expectedConfigDir, runner.opts.ConfigDir)\n\t}\n\tif exit.code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", exit.code)\n\t}\n}\n\ntype fakeTUIProgram struct {\n\tstarted chan struct{}\n\tquit    chan struct{}\n\tevents  chan runner.Event\n}\n\nfunc newFakeTUIProgram() *fakeTUIProgram {\n\treturn &fakeTUIProgram{\n\t\tstarted: make(chan struct{}),\n\t\tquit:    make(chan struct{}),\n\t\tevents:  make(chan runner.Event, 1),\n\t}\n}\n\nfunc (f *fakeTUIProgram) Start() error {\n\tclose(f.started)\n\treturn nil\n}\n\nfunc (f *fakeTUIProgram) Send(event runner.Event) {\n\tf.events <- event\n}\n\nfunc (f *fakeTUIProgram) Quit() {\n\tclose(f.quit)\n}\n\nfunc waitForSignal(t *testing.T, signal chan struct{}, label string) {\n\tt.Helper()\n\tselect {\n\tcase <-signal:\n\t\treturn\n\tcase <-time.After(200 * time.Millisecond):\n\t\tt.Fatalf(\"expected %s\", label)\n\t}\n}\n\nfunc TestRunOnceMainUsesTUIOnTTYByDefault(t *testing.T) {\n\tfakeProgram := newFakeTUIProgram()\n\tprevIsTerminal := isTerminal\n\tprevNewTUIProgram := newTUIProgram\n\tisTerminal = func(io.Writer) bool { return true }\n\tnewTUIProgram = func(stdout io.Writer) tuiProgram { return fakeProgram }\n\tt.Cleanup(func() {\n\t\tisTerminal = prevIsTerminal\n\t\tnewTUIProgram = prevNewTUIProgram\n\t})\n\n\trunOnce := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\"}, runOnce.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", code)\n\t}\n\tif runOnce.deps.Events == nil {\n\t\tt.Fatalf(\"expected events emitter to be set\")\n\t}\n\trunOnce.deps.Events.Emit(runner.Event{Type: runner.EventSelectTask})\n\twaitForSignal(t, fakeProgram.started, \"tui start\")\n\twaitForSignal(t, fakeProgram.quit, \"tui quit\")\n\tif len(fakeProgram.events) != 1 {\n\t\tt.Fatalf(\"expected event to be forwarded to TUI\")\n\t}\n}\n\nfunc TestRunOnceMainHeadlessDisablesTUI(t *testing.T) {\n\tcalled := false\n\tprevIsTerminal := isTerminal\n\tprevNewTUIProgram := newTUIProgram\n\tisTerminal = func(io.Writer) bool { return true }\n\tnewTUIProgram = func(stdout io.Writer) tuiProgram {\n\t\tcalled = true\n\t\treturn newFakeTUIProgram()\n\t}\n\tt.Cleanup(func() {\n\t\tisTerminal = prevIsTerminal\n\t\tnewTUIProgram = prevNewTUIProgram\n\t})\n\n\trunOnce := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\tstderr := &bytes.Buffer{}\n\n\tRunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\", \"--headless\"}, runOnce.Run, exit.Exit, out, stderr, beadsRunner, gitRunner)\n\n\tif called {\n\t\tt.Fatalf(\"expected TUI program not to start\")\n\t}\n\tif runOnce.deps.Events != nil {\n\t\tt.Fatalf(\"expected no events emitter in headless mode\")\n\t}\n}\n\nfunc TestOpenCodeRunDefaultsCreateConfigAndEnv(t *testing.T) {\n\ttempDir := t.TempDir()\n\trepoRoot := filepath.Join(tempDir, \"repo\")\n\tif err := os.MkdirAll(repoRoot, 0o755); err != nil {\n\t\tt.Fatalf(\"mkdir repo: %v\", err)\n\t}\n\tt.Setenv(\"HOME\", tempDir)\n\n\topenCodeRunner := &fakeOpenCodeRunner{}\n\topenCodeAdapter := openCodeAdapter{runner: openCodeRunner}\n\n\tconfigRoot := filepath.Join(tempDir, \".config\", \"opencode-runner\")\n\tconfigDir := filepath.Join(configRoot, \"opencode\")\n\tlogPath := filepath.Join(tempDir, \"runner-logs\", \"opencode\", \"issue-1.jsonl\")\n\n\tif err := openCodeAdapter.Run(\"issue-1\", repoRoot, \"prompt\", \"\", configRoot, configDir, logPath); err != nil {\n\t\tt.Fatalf(\"open code run error: %v\", err)\n\t}\n\n\tconfigFile := filepath.Join(configDir, \"opencode.json\")\n\tif _, err := os.Stat(configFile); err != nil {\n\t\tt.Fatalf(\"expected opencode.json to exist: %v\", err)\n\t}\n\texpectedConfigFile := filepath.Join(configDir, \"opencode.json\")\n\tif openCodeRunner.env[\"XDG_CONFIG_HOME\"] != configRoot {\n\t\tt.Fatalf(\"expected XDG_CONFIG_HOME set\")\n\t}\n\tif openCodeRunner.env[\"OPENCODE_CONFIG_DIR\"] != configDir {\n\t\tt.Fatalf(\"expected OPENCODE_CONFIG_DIR set\")\n\t}\n\tif openCodeRunner.env[\"OPENCODE_CONFIG\"] != expectedConfigFile {\n\t\tt.Fatalf(\"expected OPENCODE_CONFIG set\")\n\t}\n\tif openCodeRunner.env[\"OPENCODE_CONFIG_CONTENT\"] != \"{}\" {\n\t\tt.Fatalf(\"expected OPENCODE_CONFIG_CONTENT set\")\n\t}\n}\n","after":"package main\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"yolo-runner/internal/opencode\"\n\t\"yolo-runner/internal/runner\"\n)\n\ntype fakeRunner struct {\n\tcalls []string\n}\n\nfunc (f *fakeRunner) Run(args ...string) (string, error) {\n\tf.calls = append(f.calls, strings.Join(args, \" \"))\n\treturn \"\", nil\n}\n\ntype fakeOpenCodeRunLogger struct {\n\tcalled     bool\n\tissueID    string\n\trepoRoot   string\n\tprompt     string\n\tmodel      string\n\tconfigRoot string\n\tconfigDir  string\n\tlogPath    string\n}\n\nfunc (f *fakeOpenCodeRunLogger) Run(issueID string, repoRoot string, prompt string, model string, configRoot string, configDir string, logPath string) error {\n\tf.called = true\n\tf.issueID = issueID\n\tf.repoRoot = repoRoot\n\tf.prompt = prompt\n\tf.model = model\n\tf.configRoot = configRoot\n\tf.configDir = configDir\n\tf.logPath = logPath\n\treturn nil\n}\n\ntype fakeOpenCodeRunner struct {\n\tenv map[string]string\n}\n\ntype fakeOpenCodeProcess struct{}\n\nfunc (fakeOpenCodeProcess) Wait() error { return nil }\n\nfunc (fakeOpenCodeProcess) Kill() error { return nil }\n\nfunc (f *fakeOpenCodeRunner) Start(args []string, env map[string]string, stdoutPath string) (opencode.Process, error) {\n\tf.env = env\n\treturn fakeOpenCodeProcess{}, nil\n}\n\ntype fakeGitRunner struct {\n\tcalls  []string\n\toutput string\n\terr    error\n}\n\nfunc (f *fakeGitRunner) Run(name string, args ...string) (string, error) {\n\tf.calls = append(f.calls, name+\" \"+strings.Join(args, \" \"))\n\treturn f.output, f.err\n}\n\ntype fakeExit struct {\n\tcode int\n}\n\nfunc (f *fakeExit) Exit(code int) {\n\tf.code = code\n}\n\ntype fakeRunOnce struct {\n\tcalled bool\n\topts   runner.RunOnceOptions\n\tdeps   runner.RunOnceDeps\n\tresult string\n\terr    error\n}\n\nfunc (f *fakeRunOnce) Run(opts runner.RunOnceOptions, deps runner.RunOnceDeps) (string, error) {\n\n\tf.called = true\n\tf.opts = opts\n\tf.deps = deps\n\treturn f.result, f.err\n}\n\nfunc TestRunOnceMainReturnsErrorCodeOnFailure(t *testing.T) {\n\trunner := &fakeRunOnce{err: errors.New(\"boom\")}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\n\tcode := RunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\"}, runner.Run, exit.Exit, out, out, nil, nil)\n\n\tif code != 1 {\n\t\tt.Fatalf(\"expected exit code 1, got %d\", code)\n\t}\n\tif exit.code != 1 {\n\t\tt.Fatalf(\"expected exit to be called with 1, got %d\", exit.code)\n\t}\n\tif !strings.Contains(out.String(), \"boom\") {\n\t\tt.Fatalf(\"expected error output, got %q\", out.String())\n\t}\n}\n\nfunc TestRunOnceMainWiresDependencies(t *testing.T) {\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tRunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\", \"--model\", \"model\", \"--dry-run\"}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif !runner.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n\tif runner.opts.RepoRoot != \"/repo\" || runner.opts.RootID != \"root\" || runner.opts.Model != \"model\" || !runner.opts.DryRun {\n\t\tt.Fatalf(\"unexpected options: %#v\", runner.opts)\n\t}\n\tif runner.opts.Out == nil {\n\t\tt.Fatalf(\"expected output writer\")\n\t}\n\tif runner.deps.Beads == nil || runner.deps.Git == nil || runner.deps.Prompt == nil || runner.deps.OpenCode == nil || runner.deps.Logger == nil {\n\t\tt.Fatalf(\"expected deps to be wired\")\n\t}\n\tif exit.code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", exit.code)\n\t}\n}\n\nfunc TestRunOnceMainDefaultsConfigPaths(t *testing.T) {\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tt.Setenv(\"HOME\", \"/home/user\")\n\n\tRunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\"}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif !runner.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n\tif runner.opts.ConfigRoot == \"\" {\n\t\tt.Fatalf(\"expected config root to be set\")\n\t}\n\tif runner.opts.ConfigDir == \"\" {\n\t\tt.Fatalf(\"expected config dir to be set\")\n\t}\n\texpectedConfigRoot := filepath.Join(\"/home/user\", \".config\", \"opencode-runner\")\n\tif runner.opts.ConfigRoot != expectedConfigRoot {\n\t\tt.Fatalf(\"expected config root %q, got %q\", expectedConfigRoot, runner.opts.ConfigRoot)\n\t}\n\texpectedConfigDir := filepath.Join(expectedConfigRoot, \"opencode\")\n\tif runner.opts.ConfigDir != expectedConfigDir {\n\t\tt.Fatalf(\"expected config dir %q, got %q\", expectedConfigDir, runner.opts.ConfigDir)\n\t}\n\tif exit.code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", exit.code)\n\t}\n}\n\ntype fakeTUIProgram struct {\n\tstarted chan struct{}\n\tquit    chan struct{}\n\tevents  chan runner.Event\n}\n\nfunc newFakeTUIProgram() *fakeTUIProgram {\n\treturn &fakeTUIProgram{\n\t\tstarted: make(chan struct{}),\n\t\tquit:    make(chan struct{}),\n\t\tevents:  make(chan runner.Event, 1),\n\t}\n}\n\nfunc (f *fakeTUIProgram) Start() error {\n\tclose(f.started)\n\treturn nil\n}\n\nfunc (f *fakeTUIProgram) Send(event runner.Event) {\n\tf.events <- event\n}\n\nfunc (f *fakeTUIProgram) Quit() {\n\tclose(f.quit)\n}\n\nfunc waitForSignal(t *testing.T, signal chan struct{}, label string) {\n\tt.Helper()\n\tselect {\n\tcase <-signal:\n\t\treturn\n\tcase <-time.After(200 * time.Millisecond):\n\t\tt.Fatalf(\"expected %s\", label)\n\t}\n}\n\nfunc TestRunOnceMainUsesTUIOnTTYByDefault(t *testing.T) {\n\tfakeProgram := newFakeTUIProgram()\n\tprevIsTerminal := isTerminal\n\tprevNewTUIProgram := newTUIProgram\n\tisTerminal = func(io.Writer) bool { return true }\n\tnewTUIProgram = func(stdout io.Writer) tuiProgram { return fakeProgram }\n\tt.Cleanup(func() {\n\t\tisTerminal = prevIsTerminal\n\t\tnewTUIProgram = prevNewTUIProgram\n\t})\n\n\trunOnce := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\"}, runOnce.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", code)\n\t}\n\tif runOnce.deps.Events == nil {\n\t\tt.Fatalf(\"expected events emitter to be set\")\n\t}\n\trunOnce.deps.Events.Emit(runner.Event{Type: runner.EventSelectTask})\n\twaitForSignal(t, fakeProgram.started, \"tui start\")\n\twaitForSignal(t, fakeProgram.quit, \"tui quit\")\n\tselect {\n\tcase <-fakeProgram.events:\n\t\treturn\n\tcase <-time.After(200 * time.Millisecond):\n\t\tt.Fatalf(\"expected event to be forwarded to TUI\")\n\t}\n}\n\nfunc TestRunOnceMainHeadlessDisablesTUI(t *testing.T) {\n\tcalled := false\n\tprevIsTerminal := isTerminal\n\tprevNewTUIProgram := newTUIProgram\n\tisTerminal = func(io.Writer) bool { return true }\n\tnewTUIProgram = func(stdout io.Writer) tuiProgram {\n\t\tcalled = true\n\t\treturn newFakeTUIProgram()\n\t}\n\tt.Cleanup(func() {\n\t\tisTerminal = prevIsTerminal\n\t\tnewTUIProgram = prevNewTUIProgram\n\t})\n\n\trunOnce := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\tstderr := &bytes.Buffer{}\n\n\tRunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\", \"--headless\"}, runOnce.Run, exit.Exit, out, stderr, beadsRunner, gitRunner)\n\n\tif called {\n\t\tt.Fatalf(\"expected TUI program not to start\")\n\t}\n\tif runOnce.deps.Events != nil {\n\t\tt.Fatalf(\"expected no events emitter in headless mode\")\n\t}\n}\n\nfunc TestOpenCodeRunDefaultsCreateConfigAndEnv(t *testing.T) {\n\ttempDir := t.TempDir()\n\trepoRoot := filepath.Join(tempDir, \"repo\")\n\tif err := os.MkdirAll(repoRoot, 0o755); err != nil {\n\t\tt.Fatalf(\"mkdir repo: %v\", err)\n\t}\n\tt.Setenv(\"HOME\", tempDir)\n\n\topenCodeRunner := &fakeOpenCodeRunner{}\n\topenCodeAdapter := openCodeAdapter{runner: openCodeRunner}\n\n\tconfigRoot := filepath.Join(tempDir, \".config\", \"opencode-runner\")\n\tconfigDir := filepath.Join(configRoot, \"opencode\")\n\tlogPath := filepath.Join(tempDir, \"runner-logs\", \"opencode\", \"issue-1.jsonl\")\n\n\tif err := openCodeAdapter.Run(\"issue-1\", repoRoot, \"prompt\", \"\", configRoot, configDir, logPath); err != nil {\n\t\tt.Fatalf(\"open code run error: %v\", err)\n\t}\n\n\tconfigFile := filepath.Join(configDir, \"opencode.json\")\n\tif _, err := os.Stat(configFile); err != nil {\n\t\tt.Fatalf(\"expected opencode.json to exist: %v\", err)\n\t}\n\texpectedConfigFile := filepath.Join(configDir, \"opencode.json\")\n\tif openCodeRunner.env[\"XDG_CONFIG_HOME\"] != configRoot {\n\t\tt.Fatalf(\"expected XDG_CONFIG_HOME set\")\n\t}\n\tif openCodeRunner.env[\"OPENCODE_CONFIG_DIR\"] != configDir {\n\t\tt.Fatalf(\"expected OPENCODE_CONFIG_DIR set\")\n\t}\n\tif openCodeRunner.env[\"OPENCODE_CONFIG\"] != expectedConfigFile {\n\t\tt.Fatalf(\"expected OPENCODE_CONFIG set\")\n\t}\n\tif openCodeRunner.env[\"OPENCODE_CONFIG_CONTENT\"] != \"{}\" {\n\t\tt.Fatalf(\"expected OPENCODE_CONFIG_CONTENT set\")\n\t}\n}\n","additions":4,"deletions":1},"truncated":false},"time":{"start":1768840856755,"end":1768840856915}},"metadata":{"openai":{"itemId":"fc_087023dacc9580d901696e5e96afe4819182ce944ccf7f2749"}}}}
{"type":"step_finish","timestamp":1768840857099,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd72185f7001rClduw2I2ukWi1","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd7217942001OH3eIsCOO9RFM4","type":"step-finish","reason":"tool-calls","snapshot":"6d54a61e2d0e28c366258c1f5bd9691213b517d6","cost":0,"tokens":{"input":763,"output":125,"reasoning":0,"cache":{"read":56960,"write":0}}}}
{"type":"step_start","timestamp":1768840857709,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd721886d0013MKRfz0YA4757r","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd721862d001eAZLcXIltBLeZ6","type":"step-start","snapshot":"b1539f3e1804083bf3d455e09797c47c9dffa2d7"}}
{"type":"tool_use","timestamp":1768840860442,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd721897b001L8wxRkfB5p4SPX","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd721862d001eAZLcXIltBLeZ6","type":"tool","callID":"call_F67D2aNicjk4ezArIt2RoWcy","tool":"edit","state":{"status":"completed","input":{"filePath":"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go","oldString":"\tselect {\n\tcase <-fakeProgram.events:\n\t\treturn\n\tcase <-time.After(200 * time.Millisecond):\n\t\tt.Fatalf(\"expected event to be forwarded to TUI\")\n\t}\n","newString":"\tselect {\n\tcase <-fakeProgram.events:\n\t\t// ok\n\tcase <-time.After(200 * time.Millisecond):\n\t\tt.Fatalf(\"expected event to be forwarded to TUI\")\n\t}\n"},"output":"Edit applied successfully.","title":"cmd/yolo-runner/main_test.go","metadata":{"diagnostics":{"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main.go":[],"/Users/egv/dev/yolo-runner/go.mod":[{"range":{"start":{"line":6,"character":44},"end":{"line":6,"character":55}},"severity":2,"source":"go mod tidy","message":"github.com/charmbracelet/bubbletea should be direct"},{"range":{"start":{"line":19,"character":26},"end":{"line":19,"character":37}},"severity":2,"source":"go mod tidy","message":"golang.org/x/term should be direct"}],"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go":[],"/Users/egv/dev/yolo-runner/bubbletea_test.go":[],"/Users/egv/dev/yolo-runner/opencode_adapter_v1.go":[{"range":{"start":{"line":24,"character":1},"end":{"line":24,"character":18}},"severity":2,"code":"default","codeDescription":{"href":"https://staticcheck.dev/docs/checks/#S1031"},"source":"S1031","message":"unnecessary nil check around range"}],"/Users/egv/dev/yolo-runner/internal/ui/tui/model.go":[],"/Users/egv/dev/yolo-runner/internal/runner/runner.go":[],"/Users/egv/dev/yolo-runner/internal/ui/tui/model_test.go":[],"/Users/egv/dev/yolo-runner/internal/runner/events.go":[],"/Users/egv/dev/yolo-runner/internal/runner/loop_test.go":[],"/Users/egv/dev/yolo-runner/internal/runner/runner_test.go":[],"/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/tea.go":[],"/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/tty_unix.go":[],"/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/tty.go":[],"/Users/egv/dev/yolo-runner/internal/opencode/watchdog.go":[],"/Users/egv/dev/yolo-runner/internal/opencode/client.go":[{"range":{"start":{"line":28,"character":1},"end":{"line":28,"character":18}},"severity":2,"code":"default","codeDescription":{"href":"https://staticcheck.dev/docs/checks/#S1031"},"source":"S1031","message":"unnecessary nil check around range"}],"/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/options.go":[],"/Users/egv/go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0/tty_windows.go":[{"range":{"start":{"line":3,"character":8},"end":{"line":3,"character":11}},"severity":2,"source":"go list","message":"This file is within module \"../../go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0\", which is not included in your workspace.\nTo fix this problem, you can add a go.work file that uses this directory.\nSee the documentation for more information on setting up your workspace:\nhttps://github.com/golang/tools/blob/master/gopls/doc/workspace.md.","data":{"Actions":[{"title":"Add a go.work file using this module","kind":"quickfix","command":{"title":"Run `go work init && go work use`","command":"gopls.run_go_work_command","arguments":[{"ViewID":"1","InitFirst":true,"Args":["use","../../go/pkg/mod/github.com/charmbracelet/bubbletea@v0.25.0"]}]}}]}}]},"diff":"Index: /Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go\n===================================================================\n--- /Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go\n+++ /Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go\n@@ -239,9 +239,9 @@\n \twaitForSignal(t, fakeProgram.started, \"tui start\")\n \twaitForSignal(t, fakeProgram.quit, \"tui quit\")\n \tselect {\n \tcase <-fakeProgram.events:\n-\t\treturn\n+\t\t// ok\n \tcase <-time.After(200 * time.Millisecond):\n \t\tt.Fatalf(\"expected event to be forwarded to TUI\")\n \t}\n }\n","filediff":{"file":"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go","before":"package main\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"yolo-runner/internal/opencode\"\n\t\"yolo-runner/internal/runner\"\n)\n\ntype fakeRunner struct {\n\tcalls []string\n}\n\nfunc (f *fakeRunner) Run(args ...string) (string, error) {\n\tf.calls = append(f.calls, strings.Join(args, \" \"))\n\treturn \"\", nil\n}\n\ntype fakeOpenCodeRunLogger struct {\n\tcalled     bool\n\tissueID    string\n\trepoRoot   string\n\tprompt     string\n\tmodel      string\n\tconfigRoot string\n\tconfigDir  string\n\tlogPath    string\n}\n\nfunc (f *fakeOpenCodeRunLogger) Run(issueID string, repoRoot string, prompt string, model string, configRoot string, configDir string, logPath string) error {\n\tf.called = true\n\tf.issueID = issueID\n\tf.repoRoot = repoRoot\n\tf.prompt = prompt\n\tf.model = model\n\tf.configRoot = configRoot\n\tf.configDir = configDir\n\tf.logPath = logPath\n\treturn nil\n}\n\ntype fakeOpenCodeRunner struct {\n\tenv map[string]string\n}\n\ntype fakeOpenCodeProcess struct{}\n\nfunc (fakeOpenCodeProcess) Wait() error { return nil }\n\nfunc (fakeOpenCodeProcess) Kill() error { return nil }\n\nfunc (f *fakeOpenCodeRunner) Start(args []string, env map[string]string, stdoutPath string) (opencode.Process, error) {\n\tf.env = env\n\treturn fakeOpenCodeProcess{}, nil\n}\n\ntype fakeGitRunner struct {\n\tcalls  []string\n\toutput string\n\terr    error\n}\n\nfunc (f *fakeGitRunner) Run(name string, args ...string) (string, error) {\n\tf.calls = append(f.calls, name+\" \"+strings.Join(args, \" \"))\n\treturn f.output, f.err\n}\n\ntype fakeExit struct {\n\tcode int\n}\n\nfunc (f *fakeExit) Exit(code int) {\n\tf.code = code\n}\n\ntype fakeRunOnce struct {\n\tcalled bool\n\topts   runner.RunOnceOptions\n\tdeps   runner.RunOnceDeps\n\tresult string\n\terr    error\n}\n\nfunc (f *fakeRunOnce) Run(opts runner.RunOnceOptions, deps runner.RunOnceDeps) (string, error) {\n\n\tf.called = true\n\tf.opts = opts\n\tf.deps = deps\n\treturn f.result, f.err\n}\n\nfunc TestRunOnceMainReturnsErrorCodeOnFailure(t *testing.T) {\n\trunner := &fakeRunOnce{err: errors.New(\"boom\")}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\n\tcode := RunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\"}, runner.Run, exit.Exit, out, out, nil, nil)\n\n\tif code != 1 {\n\t\tt.Fatalf(\"expected exit code 1, got %d\", code)\n\t}\n\tif exit.code != 1 {\n\t\tt.Fatalf(\"expected exit to be called with 1, got %d\", exit.code)\n\t}\n\tif !strings.Contains(out.String(), \"boom\") {\n\t\tt.Fatalf(\"expected error output, got %q\", out.String())\n\t}\n}\n\nfunc TestRunOnceMainWiresDependencies(t *testing.T) {\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tRunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\", \"--model\", \"model\", \"--dry-run\"}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif !runner.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n\tif runner.opts.RepoRoot != \"/repo\" || runner.opts.RootID != \"root\" || runner.opts.Model != \"model\" || !runner.opts.DryRun {\n\t\tt.Fatalf(\"unexpected options: %#v\", runner.opts)\n\t}\n\tif runner.opts.Out == nil {\n\t\tt.Fatalf(\"expected output writer\")\n\t}\n\tif runner.deps.Beads == nil || runner.deps.Git == nil || runner.deps.Prompt == nil || runner.deps.OpenCode == nil || runner.deps.Logger == nil {\n\t\tt.Fatalf(\"expected deps to be wired\")\n\t}\n\tif exit.code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", exit.code)\n\t}\n}\n\nfunc TestRunOnceMainDefaultsConfigPaths(t *testing.T) {\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tt.Setenv(\"HOME\", \"/home/user\")\n\n\tRunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\"}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif !runner.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n\tif runner.opts.ConfigRoot == \"\" {\n\t\tt.Fatalf(\"expected config root to be set\")\n\t}\n\tif runner.opts.ConfigDir == \"\" {\n\t\tt.Fatalf(\"expected config dir to be set\")\n\t}\n\texpectedConfigRoot := filepath.Join(\"/home/user\", \".config\", \"opencode-runner\")\n\tif runner.opts.ConfigRoot != expectedConfigRoot {\n\t\tt.Fatalf(\"expected config root %q, got %q\", expectedConfigRoot, runner.opts.ConfigRoot)\n\t}\n\texpectedConfigDir := filepath.Join(expectedConfigRoot, \"opencode\")\n\tif runner.opts.ConfigDir != expectedConfigDir {\n\t\tt.Fatalf(\"expected config dir %q, got %q\", expectedConfigDir, runner.opts.ConfigDir)\n\t}\n\tif exit.code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", exit.code)\n\t}\n}\n\ntype fakeTUIProgram struct {\n\tstarted chan struct{}\n\tquit    chan struct{}\n\tevents  chan runner.Event\n}\n\nfunc newFakeTUIProgram() *fakeTUIProgram {\n\treturn &fakeTUIProgram{\n\t\tstarted: make(chan struct{}),\n\t\tquit:    make(chan struct{}),\n\t\tevents:  make(chan runner.Event, 1),\n\t}\n}\n\nfunc (f *fakeTUIProgram) Start() error {\n\tclose(f.started)\n\treturn nil\n}\n\nfunc (f *fakeTUIProgram) Send(event runner.Event) {\n\tf.events <- event\n}\n\nfunc (f *fakeTUIProgram) Quit() {\n\tclose(f.quit)\n}\n\nfunc waitForSignal(t *testing.T, signal chan struct{}, label string) {\n\tt.Helper()\n\tselect {\n\tcase <-signal:\n\t\treturn\n\tcase <-time.After(200 * time.Millisecond):\n\t\tt.Fatalf(\"expected %s\", label)\n\t}\n}\n\nfunc TestRunOnceMainUsesTUIOnTTYByDefault(t *testing.T) {\n\tfakeProgram := newFakeTUIProgram()\n\tprevIsTerminal := isTerminal\n\tprevNewTUIProgram := newTUIProgram\n\tisTerminal = func(io.Writer) bool { return true }\n\tnewTUIProgram = func(stdout io.Writer) tuiProgram { return fakeProgram }\n\tt.Cleanup(func() {\n\t\tisTerminal = prevIsTerminal\n\t\tnewTUIProgram = prevNewTUIProgram\n\t})\n\n\trunOnce := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\"}, runOnce.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", code)\n\t}\n\tif runOnce.deps.Events == nil {\n\t\tt.Fatalf(\"expected events emitter to be set\")\n\t}\n\trunOnce.deps.Events.Emit(runner.Event{Type: runner.EventSelectTask})\n\twaitForSignal(t, fakeProgram.started, \"tui start\")\n\twaitForSignal(t, fakeProgram.quit, \"tui quit\")\n\tselect {\n\tcase <-fakeProgram.events:\n\t\treturn\n\tcase <-time.After(200 * time.Millisecond):\n\t\tt.Fatalf(\"expected event to be forwarded to TUI\")\n\t}\n}\n\nfunc TestRunOnceMainHeadlessDisablesTUI(t *testing.T) {\n\tcalled := false\n\tprevIsTerminal := isTerminal\n\tprevNewTUIProgram := newTUIProgram\n\tisTerminal = func(io.Writer) bool { return true }\n\tnewTUIProgram = func(stdout io.Writer) tuiProgram {\n\t\tcalled = true\n\t\treturn newFakeTUIProgram()\n\t}\n\tt.Cleanup(func() {\n\t\tisTerminal = prevIsTerminal\n\t\tnewTUIProgram = prevNewTUIProgram\n\t})\n\n\trunOnce := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\tstderr := &bytes.Buffer{}\n\n\tRunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\", \"--headless\"}, runOnce.Run, exit.Exit, out, stderr, beadsRunner, gitRunner)\n\n\tif called {\n\t\tt.Fatalf(\"expected TUI program not to start\")\n\t}\n\tif runOnce.deps.Events != nil {\n\t\tt.Fatalf(\"expected no events emitter in headless mode\")\n\t}\n}\n\nfunc TestOpenCodeRunDefaultsCreateConfigAndEnv(t *testing.T) {\n\ttempDir := t.TempDir()\n\trepoRoot := filepath.Join(tempDir, \"repo\")\n\tif err := os.MkdirAll(repoRoot, 0o755); err != nil {\n\t\tt.Fatalf(\"mkdir repo: %v\", err)\n\t}\n\tt.Setenv(\"HOME\", tempDir)\n\n\topenCodeRunner := &fakeOpenCodeRunner{}\n\topenCodeAdapter := openCodeAdapter{runner: openCodeRunner}\n\n\tconfigRoot := filepath.Join(tempDir, \".config\", \"opencode-runner\")\n\tconfigDir := filepath.Join(configRoot, \"opencode\")\n\tlogPath := filepath.Join(tempDir, \"runner-logs\", \"opencode\", \"issue-1.jsonl\")\n\n\tif err := openCodeAdapter.Run(\"issue-1\", repoRoot, \"prompt\", \"\", configRoot, configDir, logPath); err != nil {\n\t\tt.Fatalf(\"open code run error: %v\", err)\n\t}\n\n\tconfigFile := filepath.Join(configDir, \"opencode.json\")\n\tif _, err := os.Stat(configFile); err != nil {\n\t\tt.Fatalf(\"expected opencode.json to exist: %v\", err)\n\t}\n\texpectedConfigFile := filepath.Join(configDir, \"opencode.json\")\n\tif openCodeRunner.env[\"XDG_CONFIG_HOME\"] != configRoot {\n\t\tt.Fatalf(\"expected XDG_CONFIG_HOME set\")\n\t}\n\tif openCodeRunner.env[\"OPENCODE_CONFIG_DIR\"] != configDir {\n\t\tt.Fatalf(\"expected OPENCODE_CONFIG_DIR set\")\n\t}\n\tif openCodeRunner.env[\"OPENCODE_CONFIG\"] != expectedConfigFile {\n\t\tt.Fatalf(\"expected OPENCODE_CONFIG set\")\n\t}\n\tif openCodeRunner.env[\"OPENCODE_CONFIG_CONTENT\"] != \"{}\" {\n\t\tt.Fatalf(\"expected OPENCODE_CONFIG_CONTENT set\")\n\t}\n}\n","after":"package main\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"yolo-runner/internal/opencode\"\n\t\"yolo-runner/internal/runner\"\n)\n\ntype fakeRunner struct {\n\tcalls []string\n}\n\nfunc (f *fakeRunner) Run(args ...string) (string, error) {\n\tf.calls = append(f.calls, strings.Join(args, \" \"))\n\treturn \"\", nil\n}\n\ntype fakeOpenCodeRunLogger struct {\n\tcalled     bool\n\tissueID    string\n\trepoRoot   string\n\tprompt     string\n\tmodel      string\n\tconfigRoot string\n\tconfigDir  string\n\tlogPath    string\n}\n\nfunc (f *fakeOpenCodeRunLogger) Run(issueID string, repoRoot string, prompt string, model string, configRoot string, configDir string, logPath string) error {\n\tf.called = true\n\tf.issueID = issueID\n\tf.repoRoot = repoRoot\n\tf.prompt = prompt\n\tf.model = model\n\tf.configRoot = configRoot\n\tf.configDir = configDir\n\tf.logPath = logPath\n\treturn nil\n}\n\ntype fakeOpenCodeRunner struct {\n\tenv map[string]string\n}\n\ntype fakeOpenCodeProcess struct{}\n\nfunc (fakeOpenCodeProcess) Wait() error { return nil }\n\nfunc (fakeOpenCodeProcess) Kill() error { return nil }\n\nfunc (f *fakeOpenCodeRunner) Start(args []string, env map[string]string, stdoutPath string) (opencode.Process, error) {\n\tf.env = env\n\treturn fakeOpenCodeProcess{}, nil\n}\n\ntype fakeGitRunner struct {\n\tcalls  []string\n\toutput string\n\terr    error\n}\n\nfunc (f *fakeGitRunner) Run(name string, args ...string) (string, error) {\n\tf.calls = append(f.calls, name+\" \"+strings.Join(args, \" \"))\n\treturn f.output, f.err\n}\n\ntype fakeExit struct {\n\tcode int\n}\n\nfunc (f *fakeExit) Exit(code int) {\n\tf.code = code\n}\n\ntype fakeRunOnce struct {\n\tcalled bool\n\topts   runner.RunOnceOptions\n\tdeps   runner.RunOnceDeps\n\tresult string\n\terr    error\n}\n\nfunc (f *fakeRunOnce) Run(opts runner.RunOnceOptions, deps runner.RunOnceDeps) (string, error) {\n\n\tf.called = true\n\tf.opts = opts\n\tf.deps = deps\n\treturn f.result, f.err\n}\n\nfunc TestRunOnceMainReturnsErrorCodeOnFailure(t *testing.T) {\n\trunner := &fakeRunOnce{err: errors.New(\"boom\")}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\n\tcode := RunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\"}, runner.Run, exit.Exit, out, out, nil, nil)\n\n\tif code != 1 {\n\t\tt.Fatalf(\"expected exit code 1, got %d\", code)\n\t}\n\tif exit.code != 1 {\n\t\tt.Fatalf(\"expected exit to be called with 1, got %d\", exit.code)\n\t}\n\tif !strings.Contains(out.String(), \"boom\") {\n\t\tt.Fatalf(\"expected error output, got %q\", out.String())\n\t}\n}\n\nfunc TestRunOnceMainWiresDependencies(t *testing.T) {\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tRunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\", \"--model\", \"model\", \"--dry-run\"}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif !runner.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n\tif runner.opts.RepoRoot != \"/repo\" || runner.opts.RootID != \"root\" || runner.opts.Model != \"model\" || !runner.opts.DryRun {\n\t\tt.Fatalf(\"unexpected options: %#v\", runner.opts)\n\t}\n\tif runner.opts.Out == nil {\n\t\tt.Fatalf(\"expected output writer\")\n\t}\n\tif runner.deps.Beads == nil || runner.deps.Git == nil || runner.deps.Prompt == nil || runner.deps.OpenCode == nil || runner.deps.Logger == nil {\n\t\tt.Fatalf(\"expected deps to be wired\")\n\t}\n\tif exit.code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", exit.code)\n\t}\n}\n\nfunc TestRunOnceMainDefaultsConfigPaths(t *testing.T) {\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tt.Setenv(\"HOME\", \"/home/user\")\n\n\tRunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\"}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif !runner.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n\tif runner.opts.ConfigRoot == \"\" {\n\t\tt.Fatalf(\"expected config root to be set\")\n\t}\n\tif runner.opts.ConfigDir == \"\" {\n\t\tt.Fatalf(\"expected config dir to be set\")\n\t}\n\texpectedConfigRoot := filepath.Join(\"/home/user\", \".config\", \"opencode-runner\")\n\tif runner.opts.ConfigRoot != expectedConfigRoot {\n\t\tt.Fatalf(\"expected config root %q, got %q\", expectedConfigRoot, runner.opts.ConfigRoot)\n\t}\n\texpectedConfigDir := filepath.Join(expectedConfigRoot, \"opencode\")\n\tif runner.opts.ConfigDir != expectedConfigDir {\n\t\tt.Fatalf(\"expected config dir %q, got %q\", expectedConfigDir, runner.opts.ConfigDir)\n\t}\n\tif exit.code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", exit.code)\n\t}\n}\n\ntype fakeTUIProgram struct {\n\tstarted chan struct{}\n\tquit    chan struct{}\n\tevents  chan runner.Event\n}\n\nfunc newFakeTUIProgram() *fakeTUIProgram {\n\treturn &fakeTUIProgram{\n\t\tstarted: make(chan struct{}),\n\t\tquit:    make(chan struct{}),\n\t\tevents:  make(chan runner.Event, 1),\n\t}\n}\n\nfunc (f *fakeTUIProgram) Start() error {\n\tclose(f.started)\n\treturn nil\n}\n\nfunc (f *fakeTUIProgram) Send(event runner.Event) {\n\tf.events <- event\n}\n\nfunc (f *fakeTUIProgram) Quit() {\n\tclose(f.quit)\n}\n\nfunc waitForSignal(t *testing.T, signal chan struct{}, label string) {\n\tt.Helper()\n\tselect {\n\tcase <-signal:\n\t\treturn\n\tcase <-time.After(200 * time.Millisecond):\n\t\tt.Fatalf(\"expected %s\", label)\n\t}\n}\n\nfunc TestRunOnceMainUsesTUIOnTTYByDefault(t *testing.T) {\n\tfakeProgram := newFakeTUIProgram()\n\tprevIsTerminal := isTerminal\n\tprevNewTUIProgram := newTUIProgram\n\tisTerminal = func(io.Writer) bool { return true }\n\tnewTUIProgram = func(stdout io.Writer) tuiProgram { return fakeProgram }\n\tt.Cleanup(func() {\n\t\tisTerminal = prevIsTerminal\n\t\tnewTUIProgram = prevNewTUIProgram\n\t})\n\n\trunOnce := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\"}, runOnce.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", code)\n\t}\n\tif runOnce.deps.Events == nil {\n\t\tt.Fatalf(\"expected events emitter to be set\")\n\t}\n\trunOnce.deps.Events.Emit(runner.Event{Type: runner.EventSelectTask})\n\twaitForSignal(t, fakeProgram.started, \"tui start\")\n\twaitForSignal(t, fakeProgram.quit, \"tui quit\")\n\tselect {\n\tcase <-fakeProgram.events:\n\t\t// ok\n\tcase <-time.After(200 * time.Millisecond):\n\t\tt.Fatalf(\"expected event to be forwarded to TUI\")\n\t}\n}\n\nfunc TestRunOnceMainHeadlessDisablesTUI(t *testing.T) {\n\tcalled := false\n\tprevIsTerminal := isTerminal\n\tprevNewTUIProgram := newTUIProgram\n\tisTerminal = func(io.Writer) bool { return true }\n\tnewTUIProgram = func(stdout io.Writer) tuiProgram {\n\t\tcalled = true\n\t\treturn newFakeTUIProgram()\n\t}\n\tt.Cleanup(func() {\n\t\tisTerminal = prevIsTerminal\n\t\tnewTUIProgram = prevNewTUIProgram\n\t})\n\n\trunOnce := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\tstderr := &bytes.Buffer{}\n\n\tRunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\", \"--headless\"}, runOnce.Run, exit.Exit, out, stderr, beadsRunner, gitRunner)\n\n\tif called {\n\t\tt.Fatalf(\"expected TUI program not to start\")\n\t}\n\tif runOnce.deps.Events != nil {\n\t\tt.Fatalf(\"expected no events emitter in headless mode\")\n\t}\n}\n\nfunc TestOpenCodeRunDefaultsCreateConfigAndEnv(t *testing.T) {\n\ttempDir := t.TempDir()\n\trepoRoot := filepath.Join(tempDir, \"repo\")\n\tif err := os.MkdirAll(repoRoot, 0o755); err != nil {\n\t\tt.Fatalf(\"mkdir repo: %v\", err)\n\t}\n\tt.Setenv(\"HOME\", tempDir)\n\n\topenCodeRunner := &fakeOpenCodeRunner{}\n\topenCodeAdapter := openCodeAdapter{runner: openCodeRunner}\n\n\tconfigRoot := filepath.Join(tempDir, \".config\", \"opencode-runner\")\n\tconfigDir := filepath.Join(configRoot, \"opencode\")\n\tlogPath := filepath.Join(tempDir, \"runner-logs\", \"opencode\", \"issue-1.jsonl\")\n\n\tif err := openCodeAdapter.Run(\"issue-1\", repoRoot, \"prompt\", \"\", configRoot, configDir, logPath); err != nil {\n\t\tt.Fatalf(\"open code run error: %v\", err)\n\t}\n\n\tconfigFile := filepath.Join(configDir, \"opencode.json\")\n\tif _, err := os.Stat(configFile); err != nil {\n\t\tt.Fatalf(\"expected opencode.json to exist: %v\", err)\n\t}\n\texpectedConfigFile := filepath.Join(configDir, \"opencode.json\")\n\tif openCodeRunner.env[\"XDG_CONFIG_HOME\"] != configRoot {\n\t\tt.Fatalf(\"expected XDG_CONFIG_HOME set\")\n\t}\n\tif openCodeRunner.env[\"OPENCODE_CONFIG_DIR\"] != configDir {\n\t\tt.Fatalf(\"expected OPENCODE_CONFIG_DIR set\")\n\t}\n\tif openCodeRunner.env[\"OPENCODE_CONFIG\"] != expectedConfigFile {\n\t\tt.Fatalf(\"expected OPENCODE_CONFIG set\")\n\t}\n\tif openCodeRunner.env[\"OPENCODE_CONFIG_CONTENT\"] != \"{}\" {\n\t\tt.Fatalf(\"expected OPENCODE_CONFIG_CONTENT set\")\n\t}\n}\n","additions":1,"deletions":1},"truncated":false},"time":{"start":1768840860283,"end":1768840860441}},"metadata":{"openai":{"itemId":"fc_0fdddce74632386d01696e5e99f61881918b34a25e282fb2d7"}}}}
{"type":"step_finish","timestamp":1768840860463,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd721931a001BjXxHsdFZLH1YR","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd721862d001eAZLcXIltBLeZ6","type":"step-finish","reason":"tool-calls","snapshot":"3cc8691f555df09492b45187c6f85c4bce82e238","cost":0,"tokens":{"input":259,"output":143,"reasoning":0,"cache":{"read":57600,"write":0}}}}
{"type":"step_start","timestamp":1768840861180,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd72195fc001wcz2dxp7KPnoCE","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd7219355001qAKJk3kUaaqhdr","type":"step-start","snapshot":"83584dfaa4682cf224998f7427623924ba06d288"}}
{"type":"tool_use","timestamp":1768840863273,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd72198000010mu7aEhIvfbqgr","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd7219355001qAKJk3kUaaqhdr","type":"tool","callID":"call_FcNBmTDdhTn7njQ2ZYK6Qhmx","tool":"bash","state":{"status":"completed","input":{"command":"go test ./...","workdir":"/Users/egv/dev/yolo-runner","description":"Runs Go test suite"},"output":"ok  \tyolo-runner\t(cached)\nok  \tyolo-runner/cmd/yolo-runner\t0.344s\nok  \tyolo-runner/internal/beads\t(cached)\nok  \tyolo-runner/internal/logging\t(cached)\nok  \tyolo-runner/internal/opencode\t(cached)\nok  \tyolo-runner/internal/prompt\t(cached)\nok  \tyolo-runner/internal/runner\t(cached)\nok  \tyolo-runner/internal/ui/tui\t(cached)\nok  \tyolo-runner/internal/vcs/git\t(cached)\n","title":"Runs Go test suite","metadata":{"output":"ok  \tyolo-runner\t(cached)\nok  \tyolo-runner/cmd/yolo-runner\t0.344s\nok  \tyolo-runner/internal/beads\t(cached)\nok  \tyolo-runner/internal/logging\t(cached)\nok  \tyolo-runner/internal/opencode\t(cached)\nok  \tyolo-runner/internal/prompt\t(cached)\nok  \tyolo-runner/internal/runner\t(cached)\nok  \tyolo-runner/internal/ui/tui\t(cached)\nok  \tyolo-runner/internal/vcs/git\t(cached)\n","exit":0,"description":"Runs Go test suite","truncated":false},"time":{"start":1768840862712,"end":1768840863273}},"metadata":{"openai":{"itemId":"fc_0b8dabd8ef658b9301696e5e9db2a88191859a986749c54895"}}}}
{"type":"step_finish","timestamp":1768840863291,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd7219e29001KEKHaFEPr6Iy18","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd7219355001qAKJk3kUaaqhdr","type":"step-finish","reason":"tool-calls","snapshot":"6de8041066aa06901b177e9548785fb804027124","cost":0,"tokens":{"input":285,"output":42,"reasoning":0,"cache":{"read":57728,"write":0}}}}
{"type":"step_start","timestamp":1768840863958,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd721a0d5001KM6smzAXrgtNo5","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd7219e63001284QsQwkHvbX4A","type":"step-start","snapshot":"c5a009cd9ee32a38259ed1efb490d3edf80753df"}}
{"type":"tool_use","timestamp":1768840865281,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd721a401001HDIWrf7Z5VahJz","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd7219e63001284QsQwkHvbX4A","type":"tool","callID":"call_SWE4zxf9uISlP0K3H17ngMmX","tool":"bash","state":{"status":"completed","input":{"command":"git status --short","workdir":"/Users/egv/dev/yolo-runner","description":"Shows git status"},"output":" M .beads/issues.jsonl\n M cmd/yolo-runner/main.go\n M cmd/yolo-runner/main_test.go\n M runner-logs/beads_yolo_runner.jsonl\n?? runner-logs/opencode/yolo-runner-127.4.4.jsonl\n","title":"Shows git status","metadata":{"output":" M .beads/issues.jsonl\n M cmd/yolo-runner/main.go\n M cmd/yolo-runner/main_test.go\n M runner-logs/beads_yolo_runner.jsonl\n?? runner-logs/opencode/yolo-runner-127.4.4.jsonl\n","exit":0,"description":"Shows git status","truncated":false},"time":{"start":1768840865269,"end":1768840865281}},"metadata":{"openai":{"itemId":"fc_016f55257f6f885701696e5ea0c7788191892c439427668897"}}}}
{"type":"tool_use","timestamp":1768840866030,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd721a5f50010o7Z6E5pE4Olbx","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd7219e63001284QsQwkHvbX4A","type":"tool","callID":"call_gVwyPJ9KcbwSmFrQDSCvTE6B","tool":"bash","state":{"status":"completed","input":{"command":"git diff","workdir":"/Users/egv/dev/yolo-runner","description":"Shows git diff"},"output":"diff --git a/.beads/issues.jsonl b/.beads/issues.jsonl\nindex 8672415..d99de46 100644\n--- a/.beads/issues.jsonl\n+++ b/.beads/issues.jsonl\n@@ -17,7 +17,7 @@\n {\"id\":\"yolo-runner-127.4.1\",\"title\":\"v1.2: Add Bubble Tea dependency\",\"description\":\"Add Bubble Tea dependencies and minimal wiring.\\n\\nFiles:\\n- Modify: go.mod\\n- Modify: go.sum\\n\\nAcceptance:\\n- go test ./... passes\\n- Bubble Tea module is added and buildable\",\"acceptance_criteria\":\"- go test ./... passes\\n- Bubble Tea module is added and buildable\",\"status\":\"closed\",\"priority\":1,\"issue_type\":\"task\",\"owner\":\"g.evstratov@gmail.com\",\"created_at\":\"2026-01-19T15:55:27.195836+03:00\",\"created_by\":\"Gennady Evstratov\",\"updated_at\":\"2026-01-19T18:59:10.354843+03:00\",\"closed_at\":\"2026-01-19T18:59:10.354843+03:00\",\"close_reason\":\"Closed\",\"dependencies\":[{\"issue_id\":\"yolo-runner-127.4.1\",\"depends_on_id\":\"yolo-runner-127.4\",\"type\":\"parent-child\",\"created_at\":\"2026-01-19T15:55:27.196499+03:00\",\"created_by\":\"Gennady Evstratov\"}]}\n {\"id\":\"yolo-runner-127.4.2\",\"title\":\"v1.2: TUI model for runner status\",\"description\":\"Implement a Bubble Tea model that renders:\\n- current task (id + title)\\n- current phase/state string\\n- spinner that advances when new output is detected\\n- last-output age seconds\\n\\nFiles:\\n- Create: internal/ui/tui/model.go\\n- Create: internal/ui/tui/model_test.go\\n\\nAcceptance:\\n- Given status updates, view output contains task id/title and phase string\\n- Spinner advances when notified of new output\\n- Tests run without requiring a real TTY\\n- go test ./... passes\",\"acceptance_criteria\":\"- Renders task and phase\\n- Spinner advances on output events\\n- Tests are deterministic and non-TTY\\n- go test ./... passes\",\"status\":\"closed\",\"priority\":1,\"issue_type\":\"task\",\"owner\":\"g.evstratov@gmail.com\",\"created_at\":\"2026-01-19T15:55:27.275855+03:00\",\"created_by\":\"Gennady Evstratov\",\"updated_at\":\"2026-01-19T19:02:37.853373+03:00\",\"closed_at\":\"2026-01-19T19:02:37.853373+03:00\",\"close_reason\":\"Closed\",\"dependencies\":[{\"issue_id\":\"yolo-runner-127.4.2\",\"depends_on_id\":\"yolo-runner-127.4\",\"type\":\"parent-child\",\"created_at\":\"2026-01-19T15:55:27.276643+03:00\",\"created_by\":\"Gennady Evstratov\"}]}\n {\"id\":\"yolo-runner-127.4.3\",\"title\":\"v1.2: Wire runner phases into TUI\",\"description\":\"Plumb runner phase/state updates into the TUI.\\n\\nFiles:\\n- Modify: internal/runner/runner.go\\n- Create: internal/runner/events.go\\n\\nAcceptance:\\n- Runner emits structured events for: selecting task, bd update, opencode start/end, git add/status/commit, bd close/verify, bd sync\\n- TUI displays current phase based on latest event\\n- go test ./... passes\",\"acceptance_criteria\":\"- Runner emits phase events\\n- TUI updates from events\\n- go test ./... passes\",\"status\":\"closed\",\"priority\":1,\"issue_type\":\"task\",\"owner\":\"g.evstratov@gmail.com\",\"created_at\":\"2026-01-19T15:55:27.357111+03:00\",\"created_by\":\"Gennady Evstratov\",\"updated_at\":\"2026-01-19T19:24:34.458796+03:00\",\"closed_at\":\"2026-01-19T19:24:34.458796+03:00\",\"close_reason\":\"Closed\",\"dependencies\":[{\"issue_id\":\"yolo-runner-127.4.3\",\"depends_on_id\":\"yolo-runner-127.4\",\"type\":\"parent-child\",\"created_at\":\"2026-01-19T15:55:27.357695+03:00\",\"created_by\":\"Gennady Evstratov\"}]}\n-{\"id\":\"yolo-runner-127.4.4\",\"title\":\"v1.2: Headless mode flag\",\"description\":\"Add CLI flag --headless to force plain output (no Bubble Tea), even when stdout is a TTY.\\n\\nFiles:\\n- Modify: cmd/yolo-runner/main.go\\n- Modify: cmd/yolo-runner/main_test.go\\n\\nAcceptance:\\n- Given stdout is a TTY, default is TUI\\n- Given --headless, runner does not start Bubble Tea\\n- go test ./... passes\",\"acceptance_criteria\":\"- Default TUI on TTY\\n- --headless disables TUI\\n- go test ./... passes\",\"status\":\"open\",\"priority\":1,\"issue_type\":\"task\",\"owner\":\"g.evstratov@gmail.com\",\"created_at\":\"2026-01-19T15:55:27.438163+03:00\",\"created_by\":\"Gennady Evstratov\",\"updated_at\":\"2026-01-19T15:55:27.438163+03:00\",\"dependencies\":[{\"issue_id\":\"yolo-runner-127.4.4\",\"depends_on_id\":\"yolo-runner-127.4\",\"type\":\"parent-child\",\"created_at\":\"2026-01-19T15:55:27.438678+03:00\",\"created_by\":\"Gennady Evstratov\"}]}\n+{\"id\":\"yolo-runner-127.4.4\",\"title\":\"v1.2: Headless mode flag\",\"description\":\"Add CLI flag --headless to force plain output (no Bubble Tea), even when stdout is a TTY.\\n\\nFiles:\\n- Modify: cmd/yolo-runner/main.go\\n- Modify: cmd/yolo-runner/main_test.go\\n\\nAcceptance:\\n- Given stdout is a TTY, default is TUI\\n- Given --headless, runner does not start Bubble Tea\\n- go test ./... passes\",\"acceptance_criteria\":\"- Default TUI on TTY\\n- --headless disables TUI\\n- go test ./... passes\",\"status\":\"in_progress\",\"priority\":1,\"issue_type\":\"task\",\"owner\":\"g.evstratov@gmail.com\",\"created_at\":\"2026-01-19T15:55:27.438163+03:00\",\"created_by\":\"Gennady Evstratov\",\"updated_at\":\"2026-01-19T19:24:39.834437+03:00\",\"dependencies\":[{\"issue_id\":\"yolo-runner-127.4.4\",\"depends_on_id\":\"yolo-runner-127.4\",\"type\":\"parent-child\",\"created_at\":\"2026-01-19T15:55:27.438678+03:00\",\"created_by\":\"Gennady Evstratov\"}]}\n {\"id\":\"yolo-runner-127.4.5\",\"title\":\"v1.2: Detect OpenCode log growth for heartbeat\",\"description\":\"Implement a watcher that polls the per-task OpenCode JSONL log file size and sends an event when it grows.\\n\\nFiles:\\n- Create: internal/ui/tui/logwatch.go\\n- Create: internal/ui/tui/logwatch_test.go\\n\\nAcceptance:\\n- Given a file grows, watcher emits an \\\"output\\\" event\\n- Given no growth, watcher emits nothing\\n- Tests use temp files and a fake clock/ticker\\n- go test ./... passes\",\"acceptance_criteria\":\"- Emits event on file growth\\n- No event when no growth\\n- Deterministic tests\\n- go test ./... passes\",\"status\":\"open\",\"priority\":2,\"issue_type\":\"task\",\"owner\":\"g.evstratov@gmail.com\",\"created_at\":\"2026-01-19T15:55:27.519065+03:00\",\"created_by\":\"Gennady Evstratov\",\"updated_at\":\"2026-01-19T15:55:27.519065+03:00\",\"dependencies\":[{\"issue_id\":\"yolo-runner-127.4.5\",\"depends_on_id\":\"yolo-runner-127.4\",\"type\":\"parent-child\",\"created_at\":\"2026-01-19T15:55:27.519738+03:00\",\"created_by\":\"Gennady Evstratov\"}]}\n {\"id\":\"yolo-runner-127.4.6\",\"title\":\"v1.2: Update README for TUI/headless\",\"description\":\"Document the TUI behavior and the --headless flag.\\n\\nFiles:\\n- Modify: README.md\\n\\nAcceptance:\\n- README explains default TUI on TTY\\n- README documents --headless\\n- go test ./... passes\",\"acceptance_criteria\":\"- README documents TUI and --headless\",\"status\":\"open\",\"priority\":3,\"issue_type\":\"task\",\"owner\":\"g.evstratov@gmail.com\",\"created_at\":\"2026-01-19T15:55:27.595872+03:00\",\"created_by\":\"Gennady Evstratov\",\"updated_at\":\"2026-01-19T15:55:27.595872+03:00\",\"dependencies\":[{\"issue_id\":\"yolo-runner-127.4.6\",\"depends_on_id\":\"yolo-runner-127.4\",\"type\":\"parent-child\",\"created_at\":\"2026-01-19T15:55:27.596552+03:00\",\"created_by\":\"Gennady Evstratov\"}]}\n {\"id\":\"yolo-runner-127.4.7\",\"title\":\"v1.2: Detect default root (avoid hardcoded algi-8bt)\",\"description\":\"Fix the Go runner default --root behavior so it does not default to an unrelated project id (algi-8bt).\\n\\nGoal:\\n- If --root is omitted, infer a sensible default for this repo OR fail fast with a clear error.\\n\\nRecommended approach:\\n- If exactly one roadmap root exists (e.g., top-level epic titled \\\"Roadmap\\\"), default to that id.\\n- Otherwise, require --root and print instructions.\\n\\nFiles:\\n- Modify: cmd/yolo-runner/main.go\\n- Modify: cmd/yolo-runner/main_test.go\\n- Modify (if needed): internal/beads/client.go\\n\\nAcceptance:\\n- Given --root is not provided and a unique \\\"Roadmap\\\" epic exists, runner uses that id\\n- Given --root is not provided and no unique default can be inferred, runner exits non-zero with a clear message\\n- Given --root is provided, runner behavior unchanged\\n- go test ./... passes\",\"acceptance_criteria\":\"- Default root is inferred when unique Roadmap epic exists\\n- Otherwise runner fails fast with clear message\\n- Explicit --root still works\\n- go test ./... passes\",\"status\":\"open\",\"priority\":1,\"issue_type\":\"task\",\"owner\":\"g.evstratov@gmail.com\",\"created_at\":\"2026-01-19T16:12:48.996251+03:00\",\"created_by\":\"Gennady Evstratov\",\"updated_at\":\"2026-01-19T16:12:48.996251+03:00\",\"dependencies\":[{\"issue_id\":\"yolo-runner-127.4.7\",\"depends_on_id\":\"yolo-runner-127.4\",\"type\":\"parent-child\",\"created_at\":\"2026-01-19T16:12:48.996902+03:00\",\"created_by\":\"Gennady Evstratov\"}]}\ndiff --git a/cmd/yolo-runner/main.go b/cmd/yolo-runner/main.go\nindex ea7b1da..66f7f89 100644\n--- a/cmd/yolo-runner/main.go\n+++ b/cmd/yolo-runner/main.go\n@@ -12,7 +12,11 @@ import (\n \t\"yolo-runner/internal/opencode\"\n \t\"yolo-runner/internal/prompt\"\n \t\"yolo-runner/internal/runner\"\n+\t\"yolo-runner/internal/ui/tui\"\n \tgitadapter \"yolo-runner/internal/vcs/git\"\n+\n+\ttea \"github.com/charmbracelet/bubbletea\"\n+\t\"golang.org/x/term\"\n )\n \n type runOnceFunc func(opts runner.RunOnceOptions, deps runner.RunOnceDeps) (string, error)\n@@ -31,6 +35,60 @@ type openCodeRunner interface {\n \tStart(args []string, env map[string]string, stdoutPath string) (opencode.Process, error)\n }\n \n+type tuiProgram interface {\n+\tStart() error\n+\tSend(event runner.Event)\n+\tQuit()\n+}\n+\n+type tuiEmitter struct {\n+\tprogram tuiProgram\n+}\n+\n+func (t tuiEmitter) Emit(event runner.Event) {\n+\tif t.program == nil {\n+\t\treturn\n+\t}\n+\tgo t.program.Send(event)\n+}\n+\n+type bubbleTUIProgram struct {\n+\tprogram *tea.Program\n+}\n+\n+func (b bubbleTUIProgram) Start() error {\n+\tif b.program == nil {\n+\t\treturn nil\n+\t}\n+\treturn b.program.Start()\n+}\n+\n+func (b bubbleTUIProgram) Send(event runner.Event) {\n+\tif b.program == nil {\n+\t\treturn\n+\t}\n+\tb.program.Send(event)\n+}\n+\n+func (b bubbleTUIProgram) Quit() {\n+\tif b.program == nil {\n+\t\treturn\n+\t}\n+\tb.program.Quit()\n+}\n+\n+var isTerminal = func(writer io.Writer) bool {\n+\tif file, ok := writer.(*os.File); ok {\n+\t\treturn term.IsTerminal(int(file.Fd()))\n+\t}\n+\treturn false\n+}\n+\n+var newTUIProgram = func(stdout io.Writer) tuiProgram {\n+\tprogram := tea.NewProgram(tui.NewModel(nil), tea.WithInput(nil), tea.WithOutput(stdout))\n+\treturn bubbleTUIProgram{program: program}\n+}\n+\n type adapterRunner struct{}\n \n func (adapterRunner) Run(args ...string) (string, error) {\n@@ -59,6 +117,7 @@ func RunOnceMain(args []string, runOnce runOnceFunc, exit exitFunc, stdout io.Wr\n \trootID := fs.String(\"root\", \"algi-8bt\", \"Root bead/epic ID\")\n \tmodel := fs.String(\"model\", \"\", \"OpenCode model\")\n \tdryRun := fs.Bool(\"dry-run\", false, \"Print task and prompt without executing\")\n+\theadless := fs.Bool(\"headless\", false, \"Force plain output without TUI\")\n \tconfigRoot := fs.String(\"config-root\", \"\", \"OpenCode config root\")\n \tconfigDir := fs.String(\"config-dir\", \"\", \"OpenCode config dir\")\n \n@@ -122,7 +181,24 @@ func RunOnceMain(args []string, runOnce runOnceFunc, exit exitFunc, stdout io.Wr\n \t\tstderr = io.Discard\n \t}\n \n+\tvar program tuiProgram\n+\tif !*headless && isTerminal(stdout) {\n+\t\tprogram = newTUIProgram(stdout)\n+\t\tdeps.Events = tuiEmitter{program: program}\n+\t\tgo func() {\n+\t\t\tif err := program.Start(); err != nil {\n+\t\t\t\tfmt.Fprintln(stderr, err)\n+\t\t\t\tif exit != nil {\n+\t\t\t\t\texit(1)\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}()\n+\t}\n+\n \t_, err := runOnce(options, deps)\n+\tif program != nil {\n+\t\tprogram.Quit()\n+\t}\n \tif err != nil {\n \t\tfmt.Fprintln(stderr, err)\n \t\tif exit != nil {\ndiff --git a/cmd/yolo-runner/main_test.go b/cmd/yolo-runner/main_test.go\nindex db5ad71..6030750 100644\n--- a/cmd/yolo-runner/main_test.go\n+++ b/cmd/yolo-runner/main_test.go\n@@ -3,10 +3,12 @@ package main\n import (\n \t\"bytes\"\n \t\"errors\"\n+\t\"io\"\n \t\"os\"\n \t\"path/filepath\"\n \t\"strings\"\n \t\"testing\"\n+\t\"time\"\n \n \t\"yolo-runner/internal/opencode\"\n \t\"yolo-runner/internal/runner\"\n@@ -171,6 +173,110 @@ func TestRunOnceMainDefaultsConfigPaths(t *testing.T) {\n \t}\n }\n \n+type fakeTUIProgram struct {\n+\tstarted chan struct{}\n+\tquit    chan struct{}\n+\tevents  chan runner.Event\n+}\n+\n+func newFakeTUIProgram() *fakeTUIProgram {\n+\treturn &fakeTUIProgram{\n+\t\tstarted: make(chan struct{}),\n+\t\tquit:    make(chan struct{}),\n+\t\tevents:  make(chan runner.Event, 1),\n+\t}\n+}\n+\n+func (f *fakeTUIProgram) Start() error {\n+\tclose(f.started)\n+\treturn nil\n+}\n+\n+func (f *fakeTUIProgram) Send(event runner.Event) {\n+\tf.events <- event\n+}\n+\n+func (f *fakeTUIProgram) Quit() {\n+\tclose(f.quit)\n+}\n+\n+func waitForSignal(t *testing.T, signal chan struct{}, label string) {\n+\tt.Helper()\n+\tselect {\n+\tcase <-signal:\n+\t\treturn\n+\tcase <-time.After(200 * time.Millisecond):\n+\t\tt.Fatalf(\"expected %s\", label)\n+\t}\n+}\n+\n+func TestRunOnceMainUsesTUIOnTTYByDefault(t *testing.T) {\n+\tfakeProgram := newFakeTUIProgram()\n+\tprevIsTerminal := isTerminal\n+\tprevNewTUIProgram := newTUIProgram\n+\tisTerminal = func(io.Writer) bool { return true }\n+\tnewTUIProgram = func(stdout io.Writer) tuiProgram { return fakeProgram }\n+\tt.Cleanup(func() {\n+\t\tisTerminal = prevIsTerminal\n+\t\tnewTUIProgram = prevNewTUIProgram\n+\t})\n+\n+\trunOnce := &fakeRunOnce{result: \"no_tasks\"}\n+\texit := &fakeExit{}\n+\tout := &bytes.Buffer{}\n+\tbeadsRunner := &fakeRunner{}\n+\tgitRunner := &fakeGitRunner{}\n+\n+\tcode := RunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\"}, runOnce.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n+\n+\tif code != 0 {\n+\t\tt.Fatalf(\"expected exit code 0, got %d\", code)\n+\t}\n+\tif runOnce.deps.Events == nil {\n+\t\tt.Fatalf(\"expected events emitter to be set\")\n+\t}\n+\trunOnce.deps.Events.Emit(runner.Event{Type: runner.EventSelectTask})\n+\twaitForSignal(t, fakeProgram.started, \"tui start\")\n+\twaitForSignal(t, fakeProgram.quit, \"tui quit\")\n+\tselect {\n+\tcase <-fakeProgram.events:\n+\t\t// ok\n+\tcase <-time.After(200 * time.Millisecond):\n+\t\tt.Fatalf(\"expected event to be forwarded to TUI\")\n+\t}\n+}\n+\n+func TestRunOnceMainHeadlessDisablesTUI(t *testing.T) {\n+\tcalled := false\n+\tprevIsTerminal := isTerminal\n+\tprevNewTUIProgram := newTUIProgram\n+\tisTerminal = func(io.Writer) bool { return true }\n+\tnewTUIProgram = func(stdout io.Writer) tuiProgram {\n+\t\tcalled = true\n+\t\treturn newFakeTUIProgram()\n+\t}\n+\tt.Cleanup(func() {\n+\t\tisTerminal = prevIsTerminal\n+\t\tnewTUIProgram = prevNewTUIProgram\n+\t})\n+\n+\trunOnce := &fakeRunOnce{result: \"no_tasks\"}\n+\texit := &fakeExit{}\n+\tout := &bytes.Buffer{}\n+\tbeadsRunner := &fakeRunner{}\n+\tgitRunner := &fakeGitRunner{}\n+\tstderr := &bytes.Buffer{}\n+\n+\tRunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\", \"--headless\"}, runOnce.Run, exit.Exit, out, stderr, beadsRunner, gitRunner)\n+\n+\tif called {\n+\t\tt.Fatalf(\"expected TUI program not to start\")\n+\t}\n+\tif runOnce.deps.Events != nil {\n+\t\tt.Fatalf(\"expected no events emitter in headless mode\")\n+\t}\n+}\n+\n func TestOpenCodeRunDefaultsCreateConfigAndEnv(t *testing.T) {\n \ttempDir := t.TempDir()\n \trepoRoot := filepath.Join(tempDir, \"repo\")\ndiff --git a/runner-logs/beads_yolo_runner.jsonl b/runner-logs/beads_yolo_runner.jsonl\nindex f725320..49e3f3f 100644\n--- a/runner-logs/beads_yolo_runner.jsonl\n+++ b/runner-logs/beads_yolo_runner.jsonl\n@@ -11,3 +11,4 @@\n {\"timestamp\": \"2026-01-19T18:55:57Z\", \"issue_id\": \"yolo-runner-127.4.9.3\", \"title\": \"Align: Document OpenCode config isolation\", \"status\": \"completed\", \"commit_sha\": \"a8a41f8235365dbe9d6175da642b6474f0c85026\"}\n {\"timestamp\": \"2026-01-19T18:59:10Z\", \"issue_id\": \"yolo-runner-127.4.1\", \"title\": \"v1.2: Add Bubble Tea dependency\", \"status\": \"completed\", \"commit_sha\": \"cc8582a8a8b0e27afcbac3d06fdce45ad5f0a170\"}\n {\"timestamp\": \"2026-01-19T19:02:37Z\", \"issue_id\": \"yolo-runner-127.4.2\", \"title\": \"v1.2: TUI model for runner status\", \"status\": \"completed\", \"commit_sha\": \"8e8cc26b9970413399f384dd498a5ce08a2d3d37\"}\n+{\"timestamp\": \"2026-01-19T19:24:34Z\", \"issue_id\": \"yolo-runner-127.4.3\", \"title\": \"v1.2: Wire runner phases into TUI\", \"status\": \"completed\", \"commit_sha\": \"0585becefcbb776410c255013e4bac8bb0056e22\"}\n","title":"Shows git diff","metadata":{"output":"diff --git a/.beads/issues.jsonl b/.beads/issues.jsonl\nindex 8672415..d99de46 100644\n--- a/.beads/issues.jsonl\n+++ b/.beads/issues.jsonl\n@@ -17,7 +17,7 @@\n {\"id\":\"yolo-runner-127.4.1\",\"title\":\"v1.2: Add Bubble Tea dependency\",\"description\":\"Add Bubble Tea dependencies and minimal wiring.\\n\\nFiles:\\n- Modify: go.mod\\n- Modify: go.sum\\n\\nAcceptance:\\n- go test ./... passes\\n- Bubble Tea module is added and buildable\",\"acceptance_criteria\":\"- go test ./... passes\\n- Bubble Tea module is added and buildable\",\"status\":\"closed\",\"priority\":1,\"issue_type\":\"task\",\"owner\":\"g.evstratov@gmail.com\",\"created_at\":\"2026-01-19T15:55:27.195836+03:00\",\"created_by\":\"Gennady Evstratov\",\"updated_at\":\"2026-01-19T18:59:10.354843+03:00\",\"closed_at\":\"2026-01-19T18:59:10.354843+03:00\",\"close_reason\":\"Closed\",\"dependencies\":[{\"issue_id\":\"yolo-runner-127.4.1\",\"depends_on_id\":\"yolo-runner-127.4\",\"type\":\"parent-child\",\"created_at\":\"2026-01-19T15:55:27.196499+03:00\",\"created_by\":\"Gennady Evstratov\"}]}\n {\"id\":\"yolo-runner-127.4.2\",\"title\":\"v1.2: TUI model for runner status\",\"description\":\"Implement a Bubble Tea model that renders:\\n- current task (id + title)\\n- current phase/state string\\n- spinner that advances when new output is detected\\n- last-output age seconds\\n\\nFiles:\\n- Create: internal/ui/tui/model.go\\n- Create: internal/ui/tui/model_test.go\\n\\nAcceptance:\\n- Given status updates, view output contains task id/title and phase string\\n- Spinner advances when notified of new output\\n- Tests run without requiring a real TTY\\n- go test ./... passes\",\"acceptance_criteria\":\"- Renders task and phase\\n- Spinner advances on output events\\n- Tests are deterministic and non-TTY\\n- go test ./... passes\",\"status\":\"closed\",\"priority\":1,\"issue_type\":\"task\",\"owner\":\"g.evstratov@gmail.com\",\"created_at\":\"2026-01-19T15:55:27.275855+03:00\",\"created_by\":\"Gennady Evstratov\",\"updated_at\":\"2026-01-19T19:02:37.853373+03:00\",\"closed_at\":\"2026-01-19T19:02:37.853373+03:00\",\"close_reason\":\"Closed\",\"dependencies\":[{\"issue_id\":\"yolo-runner-127.4.2\",\"depends_on_id\":\"yolo-runner-127.4\",\"type\":\"parent-child\",\"created_at\":\"2026-01-19T15:55:27.276643+03:00\",\"created_by\":\"Gennady Evstratov\"}]}\n {\"id\":\"yolo-runner-127.4.3\",\"title\":\"v1.2: Wire runner phases into TUI\",\"description\":\"Plumb runner phase/state updates into the TUI.\\n\\nFiles:\\n- Modify: internal/runner/runner.go\\n- Create: internal/runner/events.go\\n\\nAcceptance:\\n- Runner emits structured events for: selecting task, bd update, opencode start/end, git add/status/commit, bd close/verify, bd sync\\n- TUI displays current phase based on latest event\\n- go test ./... passes\",\"acceptance_criteria\":\"- Runner emits phase events\\n- TUI updates from events\\n- go test ./... passes\",\"status\":\"closed\",\"priority\":1,\"issue_type\":\"task\",\"owner\":\"g.evstratov@gmail.com\",\"created_at\":\"2026-01-19T15:55:27.357111+03:00\",\"created_by\":\"Gennady Evstratov\",\"updated_at\":\"2026-01-19T19:24:34.458796+03:00\",\"closed_at\":\"2026-01-19T19:24:34.458796+03:00\",\"close_reason\":\"Closed\",\"dependencies\":[{\"issue_id\":\"yolo-runner-127.4.3\",\"depends_on_id\":\"yolo-runner-127.4\",\"type\":\"parent-child\",\"created_at\":\"2026-01-19T15:55:27.357695+03:00\",\"created_by\":\"Gennady Evstratov\"}]}\n-{\"id\":\"yolo-runner-127.4.4\",\"title\":\"v1.2: Headless mode flag\",\"description\":\"Add CLI flag --headless to force plain output (no Bubble Tea), even when stdout is a TTY.\\n\\nFiles:\\n- Modify: cmd/yolo-runner/main.go\\n- Modify: cmd/yolo-runner/main_test.go\\n\\nAcceptance:\\n- Given stdout is a TTY, default is TUI\\n- Given --headless, runner does not start Bubble Tea\\n- go test ./... passes\",\"acceptance_criteria\":\"- Default TUI on TTY\\n- --headless disables TUI\\n- go test ./... passes\",\"status\":\"open\",\"priority\":1,\"issue_type\":\"task\",\"owner\":\"g.evstratov@gmail.com\",\"created_at\":\"2026-01-19T15:55:27.438163+03:00\",\"created_by\":\"Gennady Evstratov\",\"updated_at\":\"2026-01-19T15:55:27.438163+03:00\",\"dependencies\":[{\"issue_id\":\"yolo-runner-127.4.4\",\"depends_on_id\":\"yolo-runner-127.4\",\"type\":\"parent-child\",\"created_at\":\"2026-01-19T15:55:27.438678+03:00\",\"created_by\":\"Gennady Evstratov\"}]}\n+{\"id\":\"yolo-runner-127.4.4\",\"title\":\"v1.2: Headless mode flag\",\"description\":\"Add CLI flag --headless to force plain output (no Bubble Tea), even when stdout is a TTY.\\n\\nFiles:\\n- Modify: cmd/yolo-runner/main.go\\n- Modify: cmd/yolo-runner/main_test.go\\n\\nAcceptance:\\n- Given stdout is a TTY, default is TUI\\n- Given --headless, runner does not start Bubble Tea\\n- go test ./... passes\",\"acceptance_criteria\":\"- Default TUI on TTY\\n- --headless disables TUI\\n- go test ./... passes\",\"status\":\"in_progress\",\"priority\":1,\"issue_type\":\"task\",\"owner\":\"g.evstratov@gmail.com\",\"created_at\":\"2026-01-19T15:55:27.438163+03:00\",\"created_by\":\"Gennady Evstratov\",\"updated_at\":\"2026-01-19T19:24:39.834437+03:00\",\"dependencies\":[{\"issue_id\":\"yolo-runner-127.4.4\",\"depends_on_id\":\"yolo-runner-127.4\",\"type\":\"parent-child\",\"created_at\":\"2026-01-19T15:55:27.438678+03:00\",\"created_by\":\"Gennady Evstratov\"}]}\n {\"id\":\"yolo-runner-127.4.5\",\"title\":\"v1.2: Detect OpenCode log growth for heartbeat\",\"description\":\"Implement a watcher that polls the per-task OpenCode JSONL log file size and sends an event when it grows.\\n\\nFiles:\\n- Create: internal/ui/tui/logwatch.go\\n- Create: internal/ui/tui/logwatch_test.go\\n\\nAcceptance:\\n- Given a file grows, watcher emits an \\\"output\\\" event\\n- Given no growth, watcher emits nothing\\n- Tests use temp files and a fake clock/ticker\\n- go test ./... passes\",\"acceptance_criteria\":\"- Emits event on file growth\\n- No event when no growth\\n- Deterministic tests\\n- go test ./... passes\",\"status\":\"open\",\"priority\":2,\"issue_type\":\"task\",\"owner\":\"g.evstratov@gmail.com\",\"created_at\":\"2026-01-19T15:55:27.519065+03:00\",\"created_by\":\"Gennady Evstratov\",\"updated_at\":\"2026-01-19T15:55:27.519065+03:00\",\"dependencies\":[{\"issue_id\":\"yolo-runner-127.4.5\",\"depends_on_id\":\"yolo-runner-127.4\",\"type\":\"parent-child\",\"created_at\":\"2026-01-19T15:55:27.519738+03:00\",\"created_by\":\"Gennady Evstratov\"}]}\n {\"id\":\"yolo-runner-127.4.6\",\"title\":\"v1.2: Update README for TUI/headless\",\"description\":\"Document the TUI behavior and the --headless flag.\\n\\nFiles:\\n- Modify: README.md\\n\\nAcceptance:\\n- README explains default TUI on TTY\\n- README documents --headless\\n- go test ./... passes\",\"acceptance_criteria\":\"- README documents TUI and --headless\",\"status\":\"open\",\"priority\":3,\"issue_type\":\"task\",\"owner\":\"g.evstratov@gmail.com\",\"created_at\":\"2026-01-19T15:55:27.595872+03:00\",\"created_by\":\"Gennady Evstratov\",\"updated_at\":\"2026-01-19T15:55:27.595872+03:00\",\"dependencies\":[{\"issue_id\":\"yolo-runner-127.4.6\",\"depends_on_id\":\"yolo-runner-127.4\",\"type\":\"parent-child\",\"created_at\":\"2026-01-19T15:55:27.596552+03:00\",\"created_by\":\"Gennady Evstratov\"}]}\n {\"id\":\"yolo-runner-127.4.7\",\"title\":\"v1.2: Detect default root (avoid hardcoded algi-8bt)\",\"description\":\"Fix the Go runner default --root behavior so it does not default to an unrelated project id (algi-8bt).\\n\\nGoal:\\n- If --root is omitted, infer a sensible default for this repo OR fail fast with a clear error.\\n\\nRecommended approach:\\n- If exactly one roadmap root exists (e.g., top-level epic titled \\\"Roadmap\\\"), default to that id.\\n- Otherwise, require --root and print instructions.\\n\\nFiles:\\n- Modify: cmd/yolo-runner/main.go\\n- Modify: cmd/yolo-runner/main_test.go\\n- Modify (if needed): internal/beads/client.go\\n\\nAcceptance:\\n- Given --root is not provided and a unique \\\"Roadmap\\\" epic exists, runner uses that id\\n- Given --root is not provided and no unique default can be inferred, runner exits non-zero with a clear message\\n- Given --root is provided, runner behavior unchanged\\n- go test ./... passes\",\"acceptance_criteria\":\"- Default root is inferred when unique Roadmap epic exists\\n- Otherwise runner fails fast with clear message\\n- Explicit --root still works\\n- go test ./... passes\",\"status\":\"open\",\"priority\":1,\"issue_type\":\"task\",\"owner\":\"g.evstratov@gmail.com\",\"created_at\":\"2026-01-19T16:12:48.996251+03:00\",\"created_by\":\"Gennady Evstratov\",\"updated_at\":\"2026-01-19T16:12:48.996251+03:00\",\"dependencies\":[{\"issue_id\":\"yolo-runner-127.4.7\",\"depends_on_id\":\"yolo-runner-127.4\",\"type\":\"parent-child\",\"created_at\":\"2026-01-19T16:12:48.996902+03:00\",\"created_by\":\"Gennady Evstratov\"}]}\ndiff --git a/cmd/yolo-runner/main.go b/cmd/yolo-runner/main.go\nindex ea7b1da..66f7f89 100644\n--- a/cmd/yolo-runner/main.go\n+++ b/cmd/yolo-runner/main.go\n@@ -12,7 +12,11 @@ import (\n \t\"yolo-runner/internal/opencode\"\n \t\"yolo-runner/internal/prompt\"\n \t\"yolo-runner/internal/runner\"\n+\t\"yolo-runner/internal/ui/tui\"\n \tgitadapter \"yolo-runner/internal/vcs/git\"\n+\n+\ttea \"github.com/charmbracelet/bubbletea\"\n+\t\"golang.org/x/term\"\n )\n \n type runOnceFunc func(opts runner.RunOnceOptions, deps runner.RunOnceDeps) (string, error)\n@@ -31,6 +35,60 @@ type openCodeRunner interface {\n \tStart(args []string, env map[string]string, stdoutPath string) (opencode.Process, error)\n }\n \n+type tuiProgram interface {\n+\tStart() error\n+\tSend(event runner.Event)\n+\tQuit()\n+}\n+\n+type tuiEmitter struct {\n+\tprogram tuiProgram\n+}\n+\n+func (t tuiEmitter) Emit(event runner.Event) {\n+\tif t.program == nil {\n+\t\treturn\n+\t}\n+\tgo t.program.Send(event)\n+}\n+\n+type bubbleTUIProgram struct {\n+\tprogram *tea.Program\n+}\n+\n+func (b bubbleTUIProgram) Start() error {\n+\tif b.program == nil {\n+\t\treturn nil\n+\t}\n+\treturn b.program.Start()\n+}\n+\n+func (b bubbleTUIProgram) Send(event runner.Event) {\n+\tif b.program == nil {\n+\t\treturn\n+\t}\n+\tb.program.Send(event)\n+}\n+\n+func (b bubbleTUIProgram) Quit() {\n+\tif b.program == nil {\n+\t\treturn\n+\t}\n+\tb.program.Quit()\n+}\n+\n+var isTerminal = func(writer io.Writer) bool {\n+\tif file, ok := writer.(*os.File); ok {\n+\t\treturn term.IsTerminal(int(file.Fd()))\n+\t}\n+\treturn false\n+}\n+\n+var newTUIProgram = func(stdout io.Writer) tuiProgram {\n+\tprogram := tea.NewProgram(tui.NewModel(nil), tea.WithInput(nil), tea.WithOutput(stdout))\n+\treturn bubbleTUIProgram{program: program}\n+}\n+\n type adapterRunner struct{}\n \n func (adapterRunner) Run(args ...string) (string, error) {\n@@ -59,6 +117,7 @@ func RunOnceMain(args []string, runOnce runOnceFunc, exit exitFunc, stdout io.Wr\n \trootID := fs.String(\"root\", \"algi-8bt\", \"Root bead/epic ID\")\n \tmodel := fs.String(\"model\", \"\", \"OpenCode model\")\n \tdryRun := fs.Bool(\"dry-run\", false, \"Print task and prompt without executing\")\n+\theadless := fs.Bool(\"headless\", false, \"Force plain output without TUI\")\n \tconfigRoot := fs.String(\"config-root\", \"\", \"OpenCode config root\")\n \tconfigDir := fs.String(\"config-dir\", \"\", \"OpenCode config dir\")\n \n@@ -122,7 +181,24 @@ func RunOnceMain(args []string, runOnce runOnceFunc, exit exitFunc, stdout io.Wr\n \t\tstderr = io.Discard\n \t}\n \n+\tvar program tuiProgram\n+\tif !*headless && isTerminal(stdout) {\n+\t\tprogram = newTUIProgram(stdout)\n+\t\tdeps.Events = tuiEmitter{program: program}\n+\t\tgo func() {\n+\t\t\tif err := program.Start(); err != nil {\n+\t\t\t\tfmt.Fprintln(stderr, err)\n+\t\t\t\tif exit != nil {\n+\t\t\t\t\texit(1)\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}()\n+\t}\n+\n \t_, err := runOnce(options, deps)\n+\tif program != nil {\n+\t\tprogram.Quit()\n+\t}\n \tif err != nil {\n \t\tfmt.Fprintln(stderr, err)\n \t\tif exit != nil {\ndiff --git a/cmd/yolo-runner/main_test.go b/cmd/yolo-runner/main_test.go\nindex db5ad71..6030750 100644\n--- a/cmd/yolo-runner/main_test.go\n+++ b/cmd/yolo-runner/main_test.go\n@@ -3,10 +3,12 @@ package main\n import (\n \t\"bytes\"\n \t\"errors\"\n+\t\"io\"\n \t\"os\"\n \t\"path/filepath\"\n \t\"strings\"\n \t\"testing\"\n+\t\"time\"\n \n \t\"yolo-runner/internal/opencode\"\n \t\"yolo-runner/internal/runner\"\n@@ -171,6 +173,110 @@ func TestRunOnceMainDefaultsConfigPaths(t *testing.T) {\n \t}\n }\n \n+type fakeTUIProgram struct {\n+\tstarted chan struct{}\n+\tquit    chan struct{}\n+\tevents  chan runner.Event\n+}\n+\n+func newFakeTUIProgram() *fakeTUIProgram {\n+\treturn &fakeTUIProgram{\n+\t\tstarted: make(chan struct{}),\n+\t\tquit:    make(chan struct{}),\n+\t\tevents:  make(chan runner.Event, 1),\n+\t}\n+}\n+\n+func (f *fakeTUIProgram) Start() error {\n+\tclose(f.started)\n+\treturn nil\n+}\n+\n+func (f *fakeTUIProgram) Send(event runner.Event) {\n+\tf.events <- event\n+}\n+\n+func (f *fakeTUIProgram) Quit() {\n+\tclose(f.quit)\n+}\n+\n+func waitForSignal(t *testing.T, signal chan struct{}, label string) {\n+\tt.Helper()\n+\tselect {\n+\tcase <-signal:\n+\t\treturn\n+\tcase <-time.After(200 * time.Millisecond):\n+\t\tt.Fatalf(\"expected %s\", label)\n+\t}\n+}\n+\n+func TestRunOnceMainUsesTUIOnTTYByDefault(t *testing.T) {\n+\tfakeProgram := newFakeTUIProgram()\n+\tprevIsTerminal := isTerminal\n+\tprevNewTUIProgram := newTUIProgram\n+\tisTerminal = func(io.Writer) bool { return true }\n+\tnewTUIProgram = func(stdout io.Writer) tuiProgram { return fakeProgram }\n+\tt.Cleanup(func() {\n+\t\tisTerminal = prevIsTerminal\n+\t\tnewTUIProgram = prevNewTUIProgram\n+\t})\n+\n+\trunOnce := &fakeRunOnce{result: \"no_tasks\"}\n+\texit := &fakeExit{}\n+\tout := &bytes.Buffer{}\n+\tbeadsRunner := &fakeRunner{}\n+\tgitRunner := &fakeGitRunner{}\n+\n+\tcode := RunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\"}, runOnce.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n+\n+\tif code != 0 {\n+\t\tt.Fatalf(\"expected exit code 0, got %d\", code)\n+\t}\n+\tif runOnce.deps.Events == nil {\n+\t\tt.Fatalf(\"expected events emitter to be set\")\n+\t}\n+\trunOnce.deps.Events.Emit(runner.Event{Type: runner.EventSelectTask})\n+\twaitForSignal(t, fakeProgram.started, \"tui start\")\n+\twaitForSignal(t, fakeProgram.quit, \"tui quit\")\n+\tselect {\n+\tcase <-fakeProgram.events:\n+\t\t// ok\n+\tcase <-time.After(200 * time.Millisecond):\n+\t\tt.Fatalf(\"expected event to be forwarded to TUI\")\n+\t}\n+}\n+\n+func TestRunOnceMainHeadlessDisablesTUI(t *testing.T) {\n+\tcalled := false\n+\tprevIsTerminal := isTerminal\n+\tprevNewTUIProgram := newTUIProgram\n+\tisTerminal = func(io.Writer) bool { return true }\n+\tnewTUIProgram = func(stdout io.Writer) tuiProgram {\n+\t\tcalled = true\n+\t\treturn newFakeTUIProgram()\n+\t}\n+\tt.Cleanup(func() {\n+\t\tisTerminal = prevIsTerminal\n+\t\tnewTUIProgram = prevNewTUIProgram\n+\t})\n+\n+\trunOnce := &fakeRunOnce{result: \"no_tasks\"}\n+\texit := &fakeExit{}\n+\tout := &bytes.Buffer{}\n+\tbeadsRunner := &fakeRunner{}\n+\tgitRunner := &fakeGitRunner{}\n+\tstderr := &bytes.Buffer{}\n+\n+\tRunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\", \"--headless\"}, runOnce.Run, exit.Exit, out, stderr, beadsRunner, gitRunner)\n+\n+\tif called {\n+\t\tt.Fatalf(\"expected TUI program not to start\")\n+\t}\n+\tif runOnce.deps.Events != nil {\n+\t\tt.Fatalf(\"expected no events emitter in headless mode\")\n+\t}\n+}\n+\n func TestOpenCodeRunDefaultsCreateConfigAndEnv(t *testing.T) {\n \ttempDir := t.TempDir()\n \trepoRoot := filepath.Join(tempDir, \"repo\")\ndiff --git a/runner-logs/beads_yolo_runner.jsonl b/runner-logs/beads_yolo_runner.jsonl\nindex f725320..49e3f3f 100644\n--- a/runner-logs/beads_yolo_runner.jsonl\n+++ b/runner-logs/beads_yolo_runner.jsonl\n@@ -11,3 +11,4 @@\n {\"timestamp\": \"2026-01-19T18:55:57Z\", \"issue_id\": \"yolo-runner-127.4.9.3\", \"title\": \"Align: Document OpenCode config isolation\", \"status\": \"completed\", \"commit_sha\": \"a8a41f8235365dbe9d6175da642b6474f0c85026\"}\n {\"timestamp\": \"2026-01-19T18:59:10Z\", \"issue_id\": \"yolo-runner-127.4.1\", \"title\": \"v1.2: Add Bubble Tea dependency\", \"status\": \"completed\", \"commit_sha\": \"cc8582a8a8b0e27afcbac3d06fdce45ad5f0a170\"}\n {\"timestamp\": \"2026-01-19T19:02:37Z\", \"issue_id\": \"yolo-runner-127.4.2\", \"title\": \"v1.2: TUI model for runner status\", \"status\": \"completed\", \"commit_sha\": \"8e8cc26b9970413399f384dd498a5ce08a2d3d37\"}\n+{\"timestamp\": \"2026-01-19T19:24:34Z\", \"issue_id\": \"yolo-runner-127.4.3\", \"title\": \"v1.2: Wire runner phases into TUI\", \"status\": \"completed\", \"commit_sha\": \"0585becefcbb776410c255013e4bac8bb0056e22\"}\n","exit":0,"description":"Shows git diff","truncated":false},"time":{"start":1768840866020,"end":1768840866030}},"metadata":{"openai":{"itemId":"fc_016f55257f6f885701696e5ea146c881919a166c908b5c8f13"}}}}
{"type":"step_finish","timestamp":1768840866117,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd721a930001zOfPVYX9oOHi2m","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd7219e63001284QsQwkHvbX4A","type":"step-finish","reason":"tool-calls","snapshot":"976119ee2c67b27064674c76e2b468efdb56747c","cost":0,"tokens":{"input":676,"output":92,"reasoning":0,"cache":{"read":28416,"write":0}}}}
{"type":"step_start","timestamp":1768840866561,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd721ab01001FD3lPhfsslOxMX","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd721a96a001o1kEtf9QcBJ1fK","type":"step-start","snapshot":"60a6ee4ba5a838ddea1e0915a563001154fad391"}}
{"type":"tool_use","timestamp":1768840874822,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd721c26d001tAhMm4bqhPmmnh","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd721a96a001o1kEtf9QcBJ1fK","type":"tool","callID":"call_cDBv8XJWwFpUGvxtqLmIa7Od","tool":"bash","state":{"status":"completed","input":{"command":"git add cmd/yolo-runner/main.go cmd/yolo-runner/main_test.go","workdir":"/Users/egv/dev/yolo-runner","description":"Stages headless flag changes"},"output":"","title":"Stages headless flag changes","metadata":{"output":"","exit":0,"description":"Stages headless flag changes","truncated":false},"time":{"start":1768840874810,"end":1768840874822}},"metadata":{"openai":{"itemId":"fc_0be93c424cd02f3b01696e5ea88fe08191a677c48ca12fb4a0"}}}}
{"type":"step_finish","timestamp":1768840874875,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd721cb69001GpIJto6iCs384g","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd721a96a001o1kEtf9QcBJ1fK","type":"step-finish","reason":"tool-calls","snapshot":"a42851637c5202abf2a31e2db6a28e9fd9da327c","cost":0,"tokens":{"input":5181,"output":250,"reasoning":192,"cache":{"read":58112,"write":0}}}}
{"type":"step_start","timestamp":1768840876750,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd721d2cd001aFUc6kUjiWmaSm","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd721cba3001neW2rQLhxCzygn","type":"step-start","snapshot":"60f188d9857f98844413ce80b3c2f4fbd80e9ea8"}}
{"type":"tool_use","timestamp":1768840877828,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd721d2cd002qLNdrBIby9fo1w","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd721cba3001neW2rQLhxCzygn","type":"tool","callID":"call_rurGhUeLHVeZQceL35nWVXVc","tool":"bash","state":{"status":"completed","input":{"command":"git commit -m \"feat: headless mode flag\"","workdir":"/Users/egv/dev/yolo-runner","description":"Commits headless flag changes"},"output":"[rewind/v1-go-cleanup 5f5d2ec] feat: headless mode flag\n 3 files changed, 183 insertions(+), 1 deletion(-)\n","title":"Commits headless flag changes","metadata":{"output":"[rewind/v1-go-cleanup 5f5d2ec] feat: headless mode flag\n 3 files changed, 183 insertions(+), 1 deletion(-)\n","exit":0,"description":"Commits headless flag changes","truncated":false},"time":{"start":1768840877549,"end":1768840877828}},"metadata":{"openai":{"itemId":"fc_07635223df1d6b5c01696e5eac5e888191b7cf870c073d82eb"}}}}
{"type":"step_finish","timestamp":1768840877848,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd721d704001xthHTG4JNZK5ku","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd721cba3001neW2rQLhxCzygn","type":"step-finish","reason":"tool-calls","snapshot":"edfc6aa9a571694c33aac57d3a6248163499b133","cost":0,"tokens":{"input":253,"output":52,"reasoning":0,"cache":{"read":63104,"write":0}}}}
{"type":"step_start","timestamp":1768840878268,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd721d8bb001aE8X1GqYyQOLV0","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd721d73f001xOo1RUDo4RDhAb","type":"step-start","snapshot":"2387e4c519833702d0707efab29ef518e52d0618"}}
{"type":"tool_use","timestamp":1768840879837,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd721dbb40013sbWPMfiNIDiI6","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd721d73f001xOo1RUDo4RDhAb","type":"tool","callID":"call_bgHlc8ttaFaPiXF12D2Zbhi4","tool":"bash","state":{"status":"completed","input":{"command":"git status --short","workdir":"/Users/egv/dev/yolo-runner","description":"Shows git status"},"output":" M runner-logs/beads_yolo_runner.jsonl\n?? runner-logs/opencode/yolo-runner-127.4.4.jsonl\n","title":"Shows git status","metadata":{"output":" M runner-logs/beads_yolo_runner.jsonl\n?? runner-logs/opencode/yolo-runner-127.4.4.jsonl\n","exit":0,"description":"Shows git status","truncated":false},"time":{"start":1768840879825,"end":1768840879837}},"metadata":{"openai":{"itemId":"fc_048c99f8e62ea24501696e5eaedf908191a63d26e9d1411553"}}}}
{"type":"step_finish","timestamp":1768840879864,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd721dee4001Ru655mYkciOuHc","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd721d73f001xOo1RUDo4RDhAb","type":"step-finish","reason":"tool-calls","snapshot":"bcecfd2734425be63023ea6c27ee38847feff1ff","cost":0,"tokens":{"input":224,"output":41,"reasoning":0,"cache":{"read":63232,"write":0}}}}
{"type":"step_start","timestamp":1768840880413,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd721e11c001m3N0bxmUvQWRMN","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd721df1a0011W7FtLRgrtON0j","type":"step-start","snapshot":"b67e5e4c2af24193bdbfa9c048305281689914ee"}}
{"type":"text","timestamp":1768840890857,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd721fc3e001OhBl1UkKdtm0BI","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd721df1a0011W7FtLRgrtON0j","type":"text","text":"Added a `--headless` flag and TTY-aware TUI wiring in `cmd/yolo-runner/main.go` so Bubble Tea starts only when stdout is a TTY and headless is false, with events forwarded through a TUI emitter; start/quit are handled around the run to avoid blocking the runner. Updated `cmd/yolo-runner/main_test.go` with TDD coverage for default TUI behavior and headless disabling, using an injectable terminal detector and fake program to assert event forwarding.\n\nTests:\n- `go test ./...`\n\nCommit:\n- `feat: headless mode flag`\n\nNotes:\n- There are unrelated local changes in `runner-logs/` not included in the commit.\n\nNext steps:\n1) `git push` if you want this published.","time":{"start":1768840890856,"end":1768840890856},"metadata":{"openai":{"itemId":"msg_012e719532bfd47801696e5eb7575881919185400e4624f7ac"}}}}
{"type":"step_finish","timestamp":1768840890943,"sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","part":{"id":"prt_bd7220a2d00160IZ3KF4EWaOOU","sessionID":"ses_428ed60a0ffeY7PPXehaYLAWzW","messageID":"msg_bd721df1a0011W7FtLRgrtON0j","type":"step-finish","reason":"stop","snapshot":"cf2a7a11fcba227b45fb719bb13d4126e387bc9f","cost":0,"tokens":{"input":176,"output":421,"reasoning":256,"cache":{"read":63360,"write":0}}}}
