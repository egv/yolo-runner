{"type":"step_start","timestamp":1768850624927,"sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","part":{"id":"prt_bd7b6919e001hEe7Pn5iTD4QR3","sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","messageID":"msg_bd7b68cd2001DIm17ZpnrE8jur","type":"step-start","snapshot":"9c52bd8fa18d01c617d56c02bd6c4e5d3f0e7560"}}
{"type":"tool_use","timestamp":1768850628009,"sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","part":{"id":"prt_bd7b69c980015hKE0BWdUPGipi","sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","messageID":"msg_bd7b68cd2001DIm17ZpnrE8jur","type":"tool","callID":"call_VkKsImTxVhpu8I9xLnk2vrlI","tool":"glob","state":{"status":"completed","input":{"pattern":"cmd/yolo-runner/*.go"},"output":"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go\n/Users/egv/dev/yolo-runner/cmd/yolo-runner/main.go\n/Users/egv/dev/yolo-runner/cmd/yolo-runner/exec.go\n/Users/egv/dev/yolo-runner/cmd/yolo-runner/exec_test.go","title":"","metadata":{"count":4,"truncated":false},"time":{"start":1768850628001,"end":1768850628009}},"metadata":{"openai":{"itemId":"fc_098f1bf51215225701696e84c3b980819194fc86565eb3cecf"}}}}
{"type":"tool_use","timestamp":1768850628387,"sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","part":{"id":"prt_bd7b69da30015W6u85WD6JHWip","sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","messageID":"msg_bd7b68cd2001DIm17ZpnrE8jur","type":"tool","callID":"call_rsU04QvMPLWz1FB1C6lttnco","tool":"glob","state":{"status":"completed","input":{"pattern":"internal/**/*.go"},"output":"/Users/egv/dev/yolo-runner/internal/ui/tui/logwatch_test.go\n/Users/egv/dev/yolo-runner/internal/ui/tui/logwatch.go\n/Users/egv/dev/yolo-runner/internal/runner/runner_test.go\n/Users/egv/dev/yolo-runner/internal/runner/runner_watchdog_test.go\n/Users/egv/dev/yolo-runner/internal/ui/tui/model.go\n/Users/egv/dev/yolo-runner/internal/runner/runner.go\n/Users/egv/dev/yolo-runner/internal/runner/events.go\n/Users/egv/dev/yolo-runner/internal/ui/tui/model_test.go\n/Users/egv/dev/yolo-runner/internal/opencode/client.go\n/Users/egv/dev/yolo-runner/internal/opencode/watchdog.go\n/Users/egv/dev/yolo-runner/internal/beads/beads_test.go\n/Users/egv/dev/yolo-runner/internal/beads/beads.go\n/Users/egv/dev/yolo-runner/internal/opencode/client_test.go\n/Users/egv/dev/yolo-runner/internal/opencode/watchdog_test.go\n/Users/egv/dev/yolo-runner/internal/runner/loop_test.go\n/Users/egv/dev/yolo-runner/internal/runner/select.go\n/Users/egv/dev/yolo-runner/internal/prompt/prompt.go\n/Users/egv/dev/yolo-runner/internal/prompt/prompt_test.go\n/Users/egv/dev/yolo-runner/internal/logging/jsonl.go\n/Users/egv/dev/yolo-runner/internal/logging/jsonl_test.go\n/Users/egv/dev/yolo-runner/internal/vcs/git/git.go\n/Users/egv/dev/yolo-runner/internal/vcs/git/git_test.go\n/Users/egv/dev/yolo-runner/internal/runner/select_test.go","title":"","metadata":{"count":23,"truncated":false},"time":{"start":1768850628379,"end":1768850628386}},"metadata":{"openai":{"itemId":"fc_098f1bf51215225701696e84c3eb588191b025dc53bffc0f85"}}}}
{"type":"step_finish","timestamp":1768850628401,"sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","part":{"id":"prt_bd7b69f23001u1iBOzR1UOTOxa","sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","messageID":"msg_bd7b68cd2001DIm17ZpnrE8jur","type":"step-finish","reason":"tool-calls","snapshot":"13c0f1b659e14833cb2bb8ead24c8fbe759f4f12","cost":0,"tokens":{"input":4776,"output":56,"reasoning":0,"cache":{"read":0,"write":0}}}}
{"type":"step_start","timestamp":1768850628775,"sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","part":{"id":"prt_bd7b6a0a5001S8kG136eAnJQaI","sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","messageID":"msg_bd7b69f3f001LrqYtO65lrMaxS","type":"step-start","snapshot":"f0a2e51c2b049bceb661a9eaabcd8e1d90381a12"}}
{"type":"tool_use","timestamp":1768850630100,"sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","part":{"id":"prt_bd7b6a3c5001mFqfWEnay9usZo","sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","messageID":"msg_bd7b69f3f001LrqYtO65lrMaxS","type":"tool","callID":"call_gtX1taqiqcPpf18oeRUI2EKs","tool":"read","state":{"status":"completed","input":{"filePath":"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main.go"},"output":"<file>\n00001| package main\n00002| \n00003| import (\n00004| \t\"bufio\"\n00005| \t\"encoding/json\"\n00006| \t\"errors\"\n00007| \t\"flag\"\n00008| \t\"fmt\"\n00009| \t\"io\"\n00010| \t\"os\"\n00011| \t\"path/filepath\"\n00012| \t\"strings\"\n00013| \n00014| \t\"yolo-runner/internal/beads\"\n00015| \t\"yolo-runner/internal/logging\"\n00016| \t\"yolo-runner/internal/opencode\"\n00017| \t\"yolo-runner/internal/prompt\"\n00018| \t\"yolo-runner/internal/runner\"\n00019| \t\"yolo-runner/internal/ui/tui\"\n00020| \tgitadapter \"yolo-runner/internal/vcs/git\"\n00021| \n00022| \ttea \"github.com/charmbracelet/bubbletea\"\n00023| \t\"golang.org/x/term\"\n00024| )\n00025| \n00026| type runOnceFunc func(opts runner.RunOnceOptions, deps runner.RunOnceDeps) (string, error)\n00027| \n00028| type exitFunc func(code int)\n00029| \n00030| type beadsRunner interface {\n00031| \tRun(args ...string) (string, error)\n00032| }\n00033| \n00034| type gitRunner interface {\n00035| \tRun(name string, args ...string) (string, error)\n00036| }\n00037| \n00038| type openCodeRunner interface {\n00039| \tStart(args []string, env map[string]string, stdoutPath string) (opencode.Process, error)\n00040| }\n00041| \n00042| type tuiProgram interface {\n00043| \tStart() error\n00044| \tSend(event runner.Event)\n00045| \tQuit()\n00046| }\n00047| \n00048| type tuiEmitter struct {\n00049| \tprogram tuiProgram\n00050| }\n00051| \n00052| func (t tuiEmitter) Emit(event runner.Event) {\n00053| \tif t.program == nil {\n00054| \t\treturn\n00055| \t}\n00056| \tgo t.program.Send(event)\n00057| }\n00058| \n00059| type bubbleTUIProgram struct {\n00060| \tprogram *tea.Program\n00061| }\n00062| \n00063| func (b bubbleTUIProgram) Start() error {\n00064| \tif b.program == nil {\n00065| \t\treturn nil\n00066| \t}\n00067| \treturn b.program.Start()\n00068| }\n00069| \n00070| func (b bubbleTUIProgram) Send(event runner.Event) {\n00071| \tif b.program == nil {\n00072| \t\treturn\n00073| \t}\n00074| \tb.program.Send(event)\n00075| }\n00076| \n00077| func (b bubbleTUIProgram) Quit() {\n00078| \tif b.program == nil {\n00079| \t\treturn\n00080| \t}\n00081| \tb.program.Quit()\n00082| }\n00083| \n00084| var isTerminal = func(writer io.Writer) bool {\n00085| \tif file, ok := writer.(*os.File); ok {\n00086| \t\treturn term.IsTerminal(int(file.Fd()))\n00087| \t}\n00088| \treturn false\n00089| }\n00090| \n00091| var newTUIProgram = func(stdout io.Writer) tuiProgram {\n00092| \tprogram := tea.NewProgram(tui.NewModel(nil), tea.WithInput(nil), tea.WithOutput(stdout))\n00093| \treturn bubbleTUIProgram{program: program}\n00094| }\n00095| \n00096| type adapterRunner struct{}\n00097| \n00098| func (adapterRunner) Run(args ...string) (string, error) {\n00099| \treturn runCommand(args...)\n00100| }\n00101| \n00102| type adapterGitRunner struct{}\n00103| \n00104| func (adapterGitRunner) Run(name string, args ...string) (string, error) {\n00105| \treturn runCommand(append([]string{name}, args...)...)\n00106| }\n00107| \n00108| type openCodeAdapter struct {\n00109| \trunner openCodeRunner\n00110| }\n00111| \n00112| func (o openCodeAdapter) Run(issueID string, repoRoot string, promptText string, model string, configRoot string, configDir string, logPath string) error {\n00113| \treturn opencode.Run(issueID, repoRoot, promptText, model, configRoot, configDir, logPath, o.runner)\n00114| }\n00115| \n00116| func RunOnceMain(args []string, runOnce runOnceFunc, exit exitFunc, stdout io.Writer, stderr io.Writer, beadsRunner beadsRunner, gitRunner gitRunner) int {\n00117| \tfs := flag.NewFlagSet(\"yolo-runner\", flag.ContinueOnError)\n00118| \tfs.SetOutput(stderr)\n00119| \n00120| \trepoRoot := fs.String(\"repo\", \".\", \"Repository root path\")\n00121| \trootID := fs.String(\"root\", \"\", \"Root bead/epic ID\")\n00122| \tmodel := fs.String(\"model\", \"\", \"OpenCode model\")\n00123| \tdryRun := fs.Bool(\"dry-run\", false, \"Print task and prompt without executing\")\n00124| \theadless := fs.Bool(\"headless\", false, \"Force plain output without TUI\")\n00125| \tconfigRoot := fs.String(\"config-root\", \"\", \"OpenCode config root\")\n00126| \tconfigDir := fs.String(\"config-dir\", \"\", \"OpenCode config dir\")\n00127| \n00128| \tif err := fs.Parse(args); err != nil {\n00129| \t\tfmt.Fprintln(stderr, err)\n00130| \t\tif exit != nil {\n00131| \t\t\texit(1)\n00132| \t\t}\n00133| \t\treturn 1\n00134| \t}\n00135| \n00136| \tif runOnce == nil {\n00137| \t\trunOnce = runner.RunOnce\n00138| \t}\n00139| \n00140| \tif beadsRunner == nil {\n00141| \t\tbeadsRunner = adapterRunner{}\n00142| \t}\n00143| \tif gitRunner == nil {\n00144| \t\tgitRunner = adapterGitRunner{}\n00145| \t}\n00146| \n00147| \tbeadsAdapter := beads.New(beadsRunner)\n00148| \tgitAdapter := gitadapter.New(gitRunner)\n00149| \topenCodeAdapter := openCodeAdapter{runner: defaultOpenCodeRunner{}}\n00150| \n00151| \tresolvedRootID := *rootID\n00152| \tif resolvedRootID == \"\" {\n00153| \t\tinferredRootID, err := inferDefaultRootID(*repoRoot)\n00154| \t\tif err != nil {\n00155| \t\t\tfmt.Fprintln(stderr, err)\n00156| \t\t\tif exit != nil {\n00157| \t\t\t\texit(1)\n00158| \t\t\t}\n00159| \t\t\treturn 1\n00160| \t\t}\n00161| \t\tresolvedRootID = inferredRootID\n00162| \t}\n00163| \n00164| \tdeps := runner.RunOnceDeps{\n00165| \t\tBeads:    beadsAdapter,\n00166| \t\tPrompt:   promptBuilder{},\n00167| \t\tOpenCode: openCodeAdapter,\n00168| \t\tGit:      gitAdapter,\n00169| \t\tLogger:   runnerLogger{},\n00170| \t}\n00171| \n00172| \tresolvedConfigRoot := *configRoot\n00173| \tresolvedConfigDir := *configDir\n00174| \tif resolvedConfigRoot == \"\" {\n00175| \t\thomeDir := os.Getenv(\"HOME\")\n00176| \t\tif homeDir != \"\" {\n00177| \t\t\tresolvedConfigRoot = filepath.Join(homeDir, \".config\", \"opencode-runner\")\n00178| \t\t}\n00179| \t}\n00180| \tif resolvedConfigDir == \"\" && resolvedConfigRoot != \"\" {\n00181| \t\tresolvedConfigDir = filepath.Join(resolvedConfigRoot, \"opencode\")\n00182| \t}\n00183| \n00184| \toptions := runner.RunOnceOptions{\n00185| \t\tRepoRoot:   *repoRoot,\n00186| \t\tRootID:     resolvedRootID,\n00187| \t\tModel:      *model,\n00188| \t\tConfigRoot: resolvedConfigRoot,\n00189| \t\tConfigDir:  resolvedConfigDir,\n00190| \t\tDryRun:     *dryRun,\n00191| \t\tOut:        stdout,\n00192| \t}\n00193| \n00194| \tif stdout == nil {\n00195| \t\toptions.Out = io.Discard\n00196| \t}\n00197| \tif stderr == nil {\n00198| \t\tstderr = io.Discard\n00199| \t}\n00200| \n00201| \tvar program tuiProgram\n00202| \tif !*headless && isTerminal(stdout) {\n00203| \t\tprogram = newTUIProgram(stdout)\n00204| \t\tdeps.Events = tuiEmitter{program: program}\n00205| \t\tgo func() {\n00206| \t\t\tif err := program.Start(); err != nil {\n00207| \t\t\t\tfmt.Fprintln(stderr, err)\n00208| \t\t\t\tif exit != nil {\n00209| \t\t\t\t\texit(1)\n00210| \t\t\t\t}\n00211| \t\t\t}\n00212| \t\t}()\n00213| \t}\n00214| \n00215| \t_, err := runOnce(options, deps)\n00216| \tif program != nil {\n00217| \t\tprogram.Quit()\n00218| \t}\n00219| \tif err != nil {\n00220| \t\tfmt.Fprintln(stderr, err)\n00221| \t\tif exit != nil {\n00222| \t\t\texit(1)\n00223| \t\t}\n00224| \t\treturn 1\n00225| \t}\n00226| \n00227| \tif exit != nil {\n00228| \t\texit(0)\n00229| \t}\n00230| \treturn 0\n00231| }\n00232| \n00233| func main() {\n00234| \tRunOnceMain(os.Args[1:], runner.RunOnce, os.Exit, os.Stdout, os.Stderr, nil, nil)\n00235| }\n00236| \n00237| type promptBuilder struct{}\n00238| \n00239| func (promptBuilder) Build(issueID string, title string, description string, acceptance string) string {\n00240| \treturn prompt.Build(issueID, title, description, acceptance)\n00241| }\n00242| \n00243| type runnerLogger struct{}\n00244| \n00245| func (runnerLogger) AppendRunnerSummary(repoRoot string, issueID string, title string, status string, commitSHA string) error {\n00246| \treturn logging.AppendRunnerSummary(repoRoot, issueID, title, status, commitSHA)\n00247| }\n00248| \n00249| type defaultOpenCodeRunner struct{}\n00250| \n00251| func (defaultOpenCodeRunner) Start(args []string, env map[string]string, stdoutPath string) (opencode.Process, error) {\n00252| \treturn startCommandWithEnv(args, env, stdoutPath)\n00253| }\n00254| \n00255| type roadmapCandidate struct {\n00256| \tID     string `json:\"id\"`\n00257| \tTitle  string `json:\"title\"`\n00258| \tType   string `json:\"issue_type\"`\n00259| \tStatus string `json:\"status\"`\n00260| }\n00261| \n00262| func inferDefaultRootID(repoRoot string) (string, error) {\n00263| \tissuesPath := filepath.Join(repoRoot, \".beads\", \"issues.jsonl\")\n00264| \tfile, err := os.Open(issuesPath)\n00265| \tif err != nil {\n00266| \t\treturn \"\", errors.New(\"missing --root and no readable .beads/issues.jsonl; pass --root explicitly\")\n00267| \t}\n00268| \tdefer file.Close()\n00269| \n00270| \tscanner := bufio.NewScanner(file)\n00271| \tcount := 0\n00272| \tvar match roadmapCandidate\n00273| \tfor scanner.Scan() {\n00274| \t\tline := strings.TrimSpace(scanner.Text())\n00275| \t\tif line == \"\" {\n00276| \t\t\tcontinue\n00277| \t\t}\n00278| \t\tvar item roadmapCandidate\n00279| \t\tif err := json.Unmarshal([]byte(line), &item); err != nil {\n00280| \t\t\tcontinue\n00281| \t\t}\n00282| \t\tif item.Title == \"Roadmap\" && item.Type == \"epic\" && (item.Status == \"open\" || item.Status == \"in_progress\") {\n00283| \t\t\tcount++\n00284| \t\t\tmatch = item\n00285| \t\t}\n00286| \t}\n00287| \tif err := scanner.Err(); err != nil {\n00288| \t\treturn \"\", errors.New(\"missing --root and unable to read .beads/issues.jsonl; pass --root explicitly\")\n00289| \t}\n00290| \tif count == 1 && match.ID != \"\" {\n00291| \t\treturn match.ID, nil\n00292| \t}\n00293| \treturn \"\", errors.New(\"missing --root and no unique Roadmap epic found; pass --root explicitly\")\n00294| }\n00295| \n\n(End of file - total 295 lines)\n</file>","title":"cmd/yolo-runner/main.go","metadata":{"preview":"package main\n\nimport (\n\t\"bufio\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"flag\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\n\t\"yolo-runner/internal/beads\"\n\t\"yolo-runner/internal/logging\"\n\t\"yolo-runner/internal/opencode\"\n\t\"yolo-runner/internal/prompt\"\n\t\"yolo-runner/internal/runner\"\n\t\"yolo-runner/internal/ui/tui\"\n\tgitadapter \"yolo-runner/internal/vcs/git\"","truncated":false},"time":{"start":1768850630098,"end":1768850630100}},"metadata":{"openai":{"itemId":"fc_0be5bf65751d80c401696e84c580f08191b77fd12cb561fafd"}}}}
{"type":"tool_use","timestamp":1768850630514,"sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","part":{"id":"prt_bd7b6a5d30018c3N5PeqZ0KVUr","sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","messageID":"msg_bd7b69f3f001LrqYtO65lrMaxS","type":"tool","callID":"call_4lH0qsdajifRtTVHYnw7Q1rR","tool":"read","state":{"status":"completed","input":{"filePath":"/Users/egv/dev/yolo-runner/internal/opencode/client.go"},"output":"<file>\n00001| package opencode\n00002| \n00003| import (\n00004| \t\"os\"\n00005| \t\"path/filepath\"\n00006| )\n00007| \n00008| type Runner interface {\n00009| \tStart(args []string, env map[string]string, stdoutPath string) (Process, error)\n00010| }\n00011| \n00012| type RunnerFunc func(args []string, env map[string]string, stdoutPath string) (Process, error)\n00013| \n00014| func (runner RunnerFunc) Start(args []string, env map[string]string, stdoutPath string) (Process, error) {\n00015| \treturn runner(args, env, stdoutPath)\n00016| }\n00017| \n00018| func BuildArgs(repoRoot string, prompt string, model string) []string {\n00019| \targs := []string{\"opencode\", \"run\", prompt, \"--agent\", \"yolo\", \"--format\", \"json\"}\n00020| \tif model != \"\" {\n00021| \t\targs = append(args, \"--model\", model)\n00022| \t}\n00023| \targs = append(args, repoRoot)\n00024| \treturn args\n00025| }\n00026| \n00027| func BuildEnv(baseEnv map[string]string, configRoot string, configDir string) map[string]string {\n00028| \tenv := map[string]string{}\n00029| \tif baseEnv != nil {\n00030| \t\tfor key, value := range baseEnv {\n00031| \t\t\tenv[key] = value\n00032| \t\t}\n00033| \t}\n00034| \tenv[\"OPENCODE_DISABLE_CLAUDE_CODE\"] = \"true\"\n00035| \tenv[\"OPENCODE_DISABLE_CLAUDE_CODE_SKILLS\"] = \"true\"\n00036| \tenv[\"OPENCODE_DISABLE_CLAUDE_CODE_PROMPT\"] = \"true\"\n00037| \tenv[\"OPENCODE_DISABLE_DEFAULT_PLUGINS\"] = \"true\"\n00038| \tenv[\"CI\"] = \"true\"\n00039| \n00040| \tif configRoot != \"\" {\n00041| \t\t_ = os.MkdirAll(configRoot, 0o755)\n00042| \t\tenv[\"XDG_CONFIG_HOME\"] = configRoot\n00043| \t}\n00044| \n00045| \tif configDir != \"\" {\n00046| \t\t_ = os.MkdirAll(configDir, 0o755)\n00047| \t\tconfigFile := filepath.Join(configDir, \"opencode.json\")\n00048| \t\tif _, err := os.Stat(configFile); os.IsNotExist(err) {\n00049| \t\t\t_ = os.WriteFile(configFile, []byte(\"{}\"), 0o644)\n00050| \t\t}\n00051| \t\tenv[\"OPENCODE_CONFIG_DIR\"] = configDir\n00052| \t\tenv[\"OPENCODE_CONFIG\"] = configFile\n00053| \t\tenv[\"OPENCODE_CONFIG_CONTENT\"] = \"{}\"\n00054| \t}\n00055| \n00056| \treturn env\n00057| }\n00058| \n00059| func Run(issueID string, repoRoot string, prompt string, model string, configRoot string, configDir string, logPath string, runner Runner) error {\n00060| \tif runner == nil {\n00061| \t\treturn nil\n00062| \t}\n00063| \tif configRoot != \"\" {\n00064| \t\tif err := os.MkdirAll(configRoot, 0o755); err != nil {\n00065| \t\t\treturn err\n00066| \t\t}\n00067| \t}\n00068| \tif configDir != \"\" {\n00069| \t\tif err := os.MkdirAll(configDir, 0o755); err != nil {\n00070| \t\t\treturn err\n00071| \t\t}\n00072| \t\tconfigFile := filepath.Join(configDir, \"opencode.json\")\n00073| \t\tif _, err := os.Stat(configFile); os.IsNotExist(err) {\n00074| \t\t\tif err := os.WriteFile(configFile, []byte(\"{}\"), 0o644); err != nil {\n00075| \t\t\t\treturn err\n00076| \t\t\t}\n00077| \t\t}\n00078| \t}\n00079| \tif logPath == \"\" {\n00080| \t\tlogPath = filepath.Join(repoRoot, \"runner-logs\", \"opencode\", issueID+\".jsonl\")\n00081| \t}\n00082| \tif err := os.MkdirAll(filepath.Dir(logPath), 0o755); err != nil {\n00083| \t\treturn err\n00084| \t}\n00085| \n00086| \targs := BuildArgs(repoRoot, prompt, model)\n00087| \tenv := BuildEnv(nil, configRoot, configDir)\n00088| \tprocess, err := runner.Start(args, env, logPath)\n00089| \tif err != nil {\n00090| \t\treturn err\n00091| \t}\n00092| \twatchdog := NewWatchdog(WatchdogConfig{\n00093| \t\tLogPath:        logPath,\n00094| \t\tOpenCodeLogDir: filepath.Join(os.Getenv(\"HOME\"), \".local\", \"share\", \"opencode\", \"log\"),\n00095| \t\tTailLines:      50,\n00096| \t})\n00097| \tif err := watchdog.Monitor(process); err != nil {\n00098| \t\treturn err\n00099| \t}\n00100| \treturn nil\n00101| }\n00102| \n\n(End of file - total 102 lines)\n</file>","title":"internal/opencode/client.go","metadata":{"preview":"package opencode\n\nimport (\n\t\"os\"\n\t\"path/filepath\"\n)\n\ntype Runner interface {\n\tStart(args []string, env map[string]string, stdoutPath string) (Process, error)\n}\n\ntype RunnerFunc func(args []string, env map[string]string, stdoutPath string) (Process, error)\n\nfunc (runner RunnerFunc) Start(args []string, env map[string]string, stdoutPath string) (Process, error) {\n\treturn runner(args, env, stdoutPath)\n}\n\nfunc BuildArgs(repoRoot string, prompt string, model string) []string {\n\targs := []string{\"opencode\", \"run\", prompt, \"--agent\", \"yolo\", \"--format\", \"json\"}\n\tif model != \"\" {","truncated":false},"time":{"start":1768850630511,"end":1768850630514}},"metadata":{"openai":{"itemId":"fc_0be5bf65751d80c401696e84c6001c81919fa6f9179378d377"}}}}
{"type":"tool_use","timestamp":1768850631248,"sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","part":{"id":"prt_bd7b6a772001C6K0P1I0bg5YHP","sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","messageID":"msg_bd7b69f3f001LrqYtO65lrMaxS","type":"tool","callID":"call_VHAW7zADJk8DbJYKHFHQH53q","tool":"read","state":{"status":"completed","input":{"filePath":"/Users/egv/dev/yolo-runner/internal/opencode/watchdog.go"},"output":"<file>\n00001| package opencode\n00002| \n00003| import (\n00004| \t\"bufio\"\n00005| \t\"errors\"\n00006| \t\"fmt\"\n00007| \t\"os\"\n00008| \t\"path/filepath\"\n00009| \t\"strings\"\n00010| \t\"time\"\n00011| )\n00012| \n00013| const defaultWatchdogTimeout = 10 * time.Minute\n00014| const defaultWatchdogInterval = 5 * time.Second\n00015| const defaultWatchdogLogTail = 20\n00016| \n00017| var defaultHomeDir = os.UserHomeDir\n00018| \n00019| const (\n00020| \tstallPermission = \"permission\"\n00021| \tstallQuestion   = \"question\"\n00022| \tstallNoOutput   = \"no_output\"\n00023| )\n00024| \n00025| type Process interface {\n00026| \tWait() error\n00027| \tKill() error\n00028| }\n00029| \n00030| type WatchdogConfig struct {\n00031| \tLogPath        string\n00032| \tOpenCodeLogDir string\n00033| \tTimeout        time.Duration\n00034| \tInterval       time.Duration\n00035| \tTailLines      int\n00036| \tNow            func() time.Time\n00037| }\n00038| \n00039| type Watchdog struct {\n00040| \tconfig WatchdogConfig\n00041| }\n00042| \n00043| type StallError struct {\n00044| \tCategory      string\n00045| \tOpenCodeLog   string\n00046| \tSessionID     string\n00047| \tLogPath       string\n00048| \tLastOutputAge time.Duration\n00049| \tTail          []string\n00050| }\n00051| \n00052| func (err *StallError) Error() string {\n00053| \tparts := []string{\n00054| \t\t\"opencode stall\",\n00055| \t\t\"category=\" + err.Category,\n00056| \t}\n00057| \tif err.LogPath != \"\" {\n00058| \t\tparts = append(parts, \"runner_log=\"+err.LogPath)\n00059| \t}\n00060| \tif err.OpenCodeLog != \"\" {\n00061| \t\tparts = append(parts, \"opencode_log=\"+err.OpenCodeLog)\n00062| \t}\n00063| \tif err.SessionID != \"\" {\n00064| \t\tparts = append(parts, \"session=\"+err.SessionID)\n00065| \t}\n00066| \tif err.LastOutputAge > 0 {\n00067| \t\tparts = append(parts, fmt.Sprintf(\"last_output_age=%s\", err.LastOutputAge))\n00068| \t}\n00069| \tif len(err.Tail) > 0 {\n00070| \t\tparts = append(parts, \"opencode_tail=\"+strings.Join(err.Tail, \" | \"))\n00071| \t}\n00072| \treturn strings.Join(parts, \" \")\n00073| }\n00074| \n00075| func NewWatchdog(config WatchdogConfig) *Watchdog {\n00076| \treturn &Watchdog{config: config}\n00077| }\n00078| \n00079| func (watchdog *Watchdog) Monitor(process Process) error {\n00080| \tif process == nil {\n00081| \t\treturn errors.New(\"watchdog requires process\")\n00082| \t}\n00083| \tconfig := watchdog.config\n00084| \tif config.Timeout <= 0 {\n00085| \t\tconfig.Timeout = defaultWatchdogTimeout\n00086| \t}\n00087| \tif config.Interval <= 0 {\n00088| \t\tconfig.Interval = defaultWatchdogInterval\n00089| \t}\n00090| \tif config.TailLines <= 0 {\n00091| \t\tconfig.TailLines = defaultWatchdogLogTail\n00092| \t}\n00093| \tif config.Now == nil {\n00094| \t\tconfig.Now = time.Now\n00095| \t}\n00096| \tif config.OpenCodeLogDir == \"\" {\n00097| \t\thome, err := defaultHomeDir()\n00098| \t\tif err == nil {\n00099| \t\t\tconfig.OpenCodeLogDir = filepath.Join(home, \".local\", \"share\", \"opencode\", \"log\")\n00100| \t\t}\n00101| \t}\n00102| \n00103| \tlastOutput, err := fileModTime(config.LogPath)\n00104| \tif err != nil {\n00105| \t\tlastOutput = config.Now()\n00106| \t}\n00107| \tlastSize := fileSize(config.LogPath)\n00108| \tstartTime := config.Now()\n00109| \tif config.LogPath == \"\" {\n00110| \t\tlastOutput = startTime\n00111| \t}\n00112| \n00113| \tdone := make(chan error, 1)\n00114| \tgo func() {\n00115| \t\tdone <- process.Wait()\n00116| \t}()\n00117| \n00118| \tticker := time.NewTicker(config.Interval)\n00119| \tdefer ticker.Stop()\n00120| \n00121| \tfor {\n00122| \t\tselect {\n00123| \t\tcase err := <-done:\n00124| \t\t\treturn err\n00125| \t\tcase <-ticker.C:\n00126| \t\t\tcurrentTime := config.Now()\n00127| \t\t\tcurrentSize := fileSize(config.LogPath)\n00128| \t\t\tif currentSize > lastSize {\n00129| \t\t\t\tlastSize = currentSize\n00130| \t\t\t\tif modTime, modErr := fileModTime(config.LogPath); modErr == nil {\n00131| \t\t\t\t\tlastOutput = modTime\n00132| \t\t\t\t} else {\n00133| \t\t\t\t\tlastOutput = currentTime\n00134| \t\t\t\t}\n00135| \t\t\t}\n00136| \t\t\tif currentTime.Sub(lastOutput) > config.Timeout {\n00137| \t\t\t\tstall := classifyStall(config, currentTime, lastOutput)\n00138| \t\t\t\t_ = process.Kill()\n00139| \t\t\t\treturn stall\n00140| \t\t\t}\n00141| \t\t}\n00142| \t}\n00143| }\n00144| \n00145| func classifyStall(config WatchdogConfig, now time.Time, lastOutput time.Time) *StallError {\n00146| \tlatestLog := latestLogPath(config.OpenCodeLogDir)\n00147| \tlines := tailLines(latestLog, config.TailLines)\n00148| \tcategory := stallNoOutput\n00149| \tfor _, line := range lines {\n00150| \t\tif strings.Contains(line, \"service=permission\") || strings.Contains(line, \"permission=doom_loop\") {\n00151| \t\t\tcategory = stallPermission\n00152| \t\t\tbreak\n00153| \t\t}\n00154| \t\tif strings.Contains(line, \"service=question\") || strings.Contains(line, \"permission=question\") {\n00155| \t\t\tcategory = stallQuestion\n00156| \t\t\tbreak\n00157| \t\t}\n00158| \t}\n00159| \tstall := &StallError{\n00160| \t\tCategory:      category,\n00161| \t\tOpenCodeLog:   latestLog,\n00162| \t\tSessionID:     extractSessionID(lines),\n00163| \t\tLogPath:       config.LogPath,\n00164| \t\tLastOutputAge: now.Sub(lastOutput),\n00165| \t\tTail:          lines,\n00166| \t}\n00167| \treturn stall\n00168| }\n00169| \n00170| func latestLogPath(dir string) string {\n00171| \tif dir == \"\" {\n00172| \t\treturn \"\"\n00173| \t}\n00174| \tentries, err := os.ReadDir(dir)\n00175| \tif err != nil {\n00176| \t\treturn \"\"\n00177| \t}\n00178| \tvar latest string\n00179| \tvar latestTime time.Time\n00180| \tfor _, entry := range entries {\n00181| \t\tif entry.IsDir() {\n00182| \t\t\tcontinue\n00183| \t\t}\n00184| \t\tinfo, err := entry.Info()\n00185| \t\tif err != nil {\n00186| \t\t\tcontinue\n00187| \t\t}\n00188| \t\tmod := info.ModTime()\n00189| \t\tif latest == \"\" || mod.After(latestTime) {\n00190| \t\t\tlatest = filepath.Join(dir, entry.Name())\n00191| \t\t\tlatestTime = mod\n00192| \t\t}\n00193| \t}\n00194| \treturn latest\n00195| }\n00196| \n00197| func tailLines(path string, limit int) []string {\n00198| \tif path == \"\" || limit <= 0 {\n00199| \t\treturn nil\n00200| \t}\n00201| \tfile, err := os.Open(path)\n00202| \tif err != nil {\n00203| \t\treturn nil\n00204| \t}\n00205| \tdefer file.Close()\n00206| \tlines := []string{}\n00207| \tscanner := bufio.NewScanner(file)\n00208| \tbuf := make([]byte, 0, 64*1024)\n00209| \tscanner.Buffer(buf, 1024*1024)\n00210| \tfor scanner.Scan() {\n00211| \t\tlines = append(lines, scanner.Text())\n00212| \t\tif len(lines) > limit {\n00213| \t\t\tlines = lines[1:]\n00214| \t\t}\n00215| \t}\n00216| \treturn lines\n00217| }\n00218| \n00219| func extractSessionID(lines []string) string {\n00220| \tfor _, line := range lines {\n00221| \t\tif strings.Contains(line, \"sessionID=\") {\n00222| \t\t\tparts := strings.Split(line, \"sessionID=\")\n00223| \t\t\tif len(parts) > 1 {\n00224| \t\t\t\trest := parts[1]\n00225| \t\t\t\tfor i, r := range rest {\n00226| \t\t\t\t\tif r == ' ' || r == '\\t' || r == ',' {\n00227| \t\t\t\t\t\treturn rest[:i]\n00228| \t\t\t\t\t}\n00229| \t\t\t\t}\n00230| \t\t\t\treturn rest\n00231| \t\t\t}\n00232| \t\t}\n00233| \t\tif strings.Contains(line, \"session id=\") {\n00234| \t\t\tparts := strings.Split(line, \"session id=\")\n00235| \t\t\tif len(parts) > 1 {\n00236| \t\t\t\trest := parts[1]\n00237| \t\t\t\tfor i, r := range rest {\n00238| \t\t\t\t\tif r == ' ' || r == '\\t' || r == ',' {\n00239| \t\t\t\t\t\treturn rest[:i]\n00240| \t\t\t\t\t}\n00241| \t\t\t\t}\n00242| \t\t\t\treturn rest\n00243| \t\t\t}\n00244| \t\t}\n00245| \t}\n00246| \treturn \"\"\n00247| }\n00248| \n00249| func fileSize(path string) int64 {\n00250| \tinfo, err := os.Stat(path)\n00251| \tif err != nil {\n00252| \t\treturn 0\n00253| \t}\n00254| \treturn info.Size()\n00255| }\n00256| \n00257| func fileModTime(path string) (time.Time, error) {\n00258| \tinfo, err := os.Stat(path)\n00259| \tif err != nil {\n00260| \t\treturn time.Time{}, err\n00261| \t}\n00262| \treturn info.ModTime(), nil\n00263| }\n00264| \n\n(End of file - total 264 lines)\n</file>","title":"internal/opencode/watchdog.go","metadata":{"preview":"package opencode\n\nimport (\n\t\"bufio\"\n\t\"errors\"\n\t\"fmt\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"time\"\n)\n\nconst defaultWatchdogTimeout = 10 * time.Minute\nconst defaultWatchdogInterval = 5 * time.Second\nconst defaultWatchdogLogTail = 20\n\nvar defaultHomeDir = os.UserHomeDir\n\nconst (\n\tstallPermission = \"permission\"","truncated":false},"time":{"start":1768850631246,"end":1768850631248}},"metadata":{"openai":{"itemId":"fc_0be5bf65751d80c401696e84c670348191a503bfa927364adb"}}}}
{"type":"step_finish","timestamp":1768850631266,"sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","part":{"id":"prt_bd7b6aa500017CKIzbs7XLP97a","sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","messageID":"msg_bd7b69f3f001LrqYtO65lrMaxS","type":"step-finish","reason":"tool-calls","snapshot":"0b836c21fe268880e4ff9ab7d68a36ba01cba50d","cost":0,"tokens":{"input":296,"output":108,"reasoning":0,"cache":{"read":3072,"write":0}}}}
{"type":"step_start","timestamp":1768850631583,"sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","part":{"id":"prt_bd7b6ab9e0013rbalHx06hHw8z","sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","messageID":"msg_bd7b6aa70001FZz71DxjiGP2XL","type":"step-start","snapshot":"d591b7256817a9aae860a1835370f1692dbcb551"}}
{"type":"tool_use","timestamp":1768850634336,"sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","part":{"id":"prt_bd7b6b526001cMiz9x4GI9SaVL","sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","messageID":"msg_bd7b6aa70001FZz71DxjiGP2XL","type":"tool","callID":"call_LkQWsNMbLwQO1RLTDDuc5t13","tool":"read","state":{"status":"completed","input":{"filePath":"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go"},"output":"<file>\n00001| package main\n00002| \n00003| import (\n00004| \t\"bytes\"\n00005| \t\"errors\"\n00006| \t\"io\"\n00007| \t\"os\"\n00008| \t\"path/filepath\"\n00009| \t\"strings\"\n00010| \t\"testing\"\n00011| \t\"time\"\n00012| \n00013| \t\"yolo-runner/internal/opencode\"\n00014| \t\"yolo-runner/internal/runner\"\n00015| )\n00016| \n00017| type fakeRunner struct {\n00018| \tcalls []string\n00019| }\n00020| \n00021| func (f *fakeRunner) Run(args ...string) (string, error) {\n00022| \tf.calls = append(f.calls, strings.Join(args, \" \"))\n00023| \treturn \"\", nil\n00024| }\n00025| \n00026| type fakeOpenCodeRunLogger struct {\n00027| \tcalled     bool\n00028| \tissueID    string\n00029| \trepoRoot   string\n00030| \tprompt     string\n00031| \tmodel      string\n00032| \tconfigRoot string\n00033| \tconfigDir  string\n00034| \tlogPath    string\n00035| }\n00036| \n00037| func (f *fakeOpenCodeRunLogger) Run(issueID string, repoRoot string, prompt string, model string, configRoot string, configDir string, logPath string) error {\n00038| \tf.called = true\n00039| \tf.issueID = issueID\n00040| \tf.repoRoot = repoRoot\n00041| \tf.prompt = prompt\n00042| \tf.model = model\n00043| \tf.configRoot = configRoot\n00044| \tf.configDir = configDir\n00045| \tf.logPath = logPath\n00046| \treturn nil\n00047| }\n00048| \n00049| type fakeOpenCodeRunner struct {\n00050| \tenv map[string]string\n00051| }\n00052| \n00053| type fakeOpenCodeProcess struct{}\n00054| \n00055| func (fakeOpenCodeProcess) Wait() error { return nil }\n00056| \n00057| func (fakeOpenCodeProcess) Kill() error { return nil }\n00058| \n00059| func (f *fakeOpenCodeRunner) Start(args []string, env map[string]string, stdoutPath string) (opencode.Process, error) {\n00060| \tf.env = env\n00061| \treturn fakeOpenCodeProcess{}, nil\n00062| }\n00063| \n00064| type fakeGitRunner struct {\n00065| \tcalls  []string\n00066| \toutput string\n00067| \terr    error\n00068| }\n00069| \n00070| func (f *fakeGitRunner) Run(name string, args ...string) (string, error) {\n00071| \tf.calls = append(f.calls, name+\" \"+strings.Join(args, \" \"))\n00072| \treturn f.output, f.err\n00073| }\n00074| \n00075| type fakeExit struct {\n00076| \tcode int\n00077| }\n00078| \n00079| func (f *fakeExit) Exit(code int) {\n00080| \tf.code = code\n00081| }\n00082| \n00083| type fakeRunOnce struct {\n00084| \tcalled bool\n00085| \topts   runner.RunOnceOptions\n00086| \tdeps   runner.RunOnceDeps\n00087| \tresult string\n00088| \terr    error\n00089| }\n00090| \n00091| func (f *fakeRunOnce) Run(opts runner.RunOnceOptions, deps runner.RunOnceDeps) (string, error) {\n00092| \n00093| \tf.called = true\n00094| \tf.opts = opts\n00095| \tf.deps = deps\n00096| \treturn f.result, f.err\n00097| }\n00098| \n00099| func TestRunOnceMainReturnsErrorCodeOnFailure(t *testing.T) {\n00100| \trunner := &fakeRunOnce{err: errors.New(\"boom\")}\n00101| \texit := &fakeExit{}\n00102| \tout := &bytes.Buffer{}\n00103| \n00104| \tcode := RunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\"}, runner.Run, exit.Exit, out, out, nil, nil)\n00105| \n00106| \tif code != 1 {\n00107| \t\tt.Fatalf(\"expected exit code 1, got %d\", code)\n00108| \t}\n00109| \tif exit.code != 1 {\n00110| \t\tt.Fatalf(\"expected exit to be called with 1, got %d\", exit.code)\n00111| \t}\n00112| \tif !strings.Contains(out.String(), \"boom\") {\n00113| \t\tt.Fatalf(\"expected error output, got %q\", out.String())\n00114| \t}\n00115| }\n00116| \n00117| func TestRunOnceMainWiresDependencies(t *testing.T) {\n00118| \trunner := &fakeRunOnce{result: \"no_tasks\"}\n00119| \texit := &fakeExit{}\n00120| \tout := &bytes.Buffer{}\n00121| \tbeadsRunner := &fakeRunner{}\n00122| \tgitRunner := &fakeGitRunner{}\n00123| \n00124| \tRunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\", \"--model\", \"model\", \"--dry-run\"}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n00125| \n00126| \tif !runner.called {\n00127| \t\tt.Fatalf(\"expected run once to be called\")\n00128| \t}\n00129| \tif runner.opts.RepoRoot != \"/repo\" || runner.opts.RootID != \"root\" || runner.opts.Model != \"model\" || !runner.opts.DryRun {\n00130| \t\tt.Fatalf(\"unexpected options: %#v\", runner.opts)\n00131| \t}\n00132| \tif runner.opts.Out == nil {\n00133| \t\tt.Fatalf(\"expected output writer\")\n00134| \t}\n00135| \tif runner.deps.Beads == nil || runner.deps.Git == nil || runner.deps.Prompt == nil || runner.deps.OpenCode == nil || runner.deps.Logger == nil {\n00136| \t\tt.Fatalf(\"expected deps to be wired\")\n00137| \t}\n00138| \tif exit.code != 0 {\n00139| \t\tt.Fatalf(\"expected exit code 0, got %d\", exit.code)\n00140| \t}\n00141| }\n00142| \n00143| func TestRunOnceMainDefaultsConfigPaths(t *testing.T) {\n00144| \trunner := &fakeRunOnce{result: \"no_tasks\"}\n00145| \texit := &fakeExit{}\n00146| \tout := &bytes.Buffer{}\n00147| \tbeadsRunner := &fakeRunner{}\n00148| \tgitRunner := &fakeGitRunner{}\n00149| \n00150| \tt.Setenv(\"HOME\", \"/home/user\")\n00151| \n00152| \tRunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\"}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n00153| \n00154| \tif !runner.called {\n00155| \t\tt.Fatalf(\"expected run once to be called\")\n00156| \t}\n00157| \tif runner.opts.ConfigRoot == \"\" {\n00158| \t\tt.Fatalf(\"expected config root to be set\")\n00159| \t}\n00160| \tif runner.opts.ConfigDir == \"\" {\n00161| \t\tt.Fatalf(\"expected config dir to be set\")\n00162| \t}\n00163| \texpectedConfigRoot := filepath.Join(\"/home/user\", \".config\", \"opencode-runner\")\n00164| \tif runner.opts.ConfigRoot != expectedConfigRoot {\n00165| \t\tt.Fatalf(\"expected config root %q, got %q\", expectedConfigRoot, runner.opts.ConfigRoot)\n00166| \t}\n00167| \texpectedConfigDir := filepath.Join(expectedConfigRoot, \"opencode\")\n00168| \tif runner.opts.ConfigDir != expectedConfigDir {\n00169| \t\tt.Fatalf(\"expected config dir %q, got %q\", expectedConfigDir, runner.opts.ConfigDir)\n00170| \t}\n00171| \tif exit.code != 0 {\n00172| \t\tt.Fatalf(\"expected exit code 0, got %d\", exit.code)\n00173| \t}\n00174| }\n00175| \n00176| func TestRunOnceMainInfersRoadmapRootWhenMissing(t *testing.T) {\n00177| \ttempDir := t.TempDir()\n00178| \twriteIssuesFile(t, tempDir, `{\"id\":\"roadmap-1\",\"title\":\"Roadmap\",\"issue_type\":\"epic\",\"status\":\"open\"}`)\n00179| \trunner := &fakeRunOnce{result: \"no_tasks\"}\n00180| \texit := &fakeExit{}\n00181| \tout := &bytes.Buffer{}\n00182| \tbeadsRunner := &fakeRunner{}\n00183| \tgitRunner := &fakeGitRunner{}\n00184| \n00185| \tcode := RunOnceMain([]string{\"--repo\", tempDir}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n00186| \n00187| \tif code != 0 {\n00188| \t\tt.Fatalf(\"expected exit code 0, got %d\", code)\n00189| \t}\n00190| \tif !runner.called {\n00191| \t\tt.Fatalf(\"expected run once to be called\")\n00192| \t}\n00193| \tif runner.opts.RootID != \"roadmap-1\" {\n00194| \t\tt.Fatalf(\"expected root id to be inferred, got %q\", runner.opts.RootID)\n00195| \t}\n00196| }\n00197| \n00198| func TestRunOnceMainInfersRoadmapRootWhenInProgress(t *testing.T) {\n00199| \ttempDir := t.TempDir()\n00200| \twriteIssuesFile(t, tempDir, `{\"id\":\"roadmap-2\",\"title\":\"Roadmap\",\"issue_type\":\"epic\",\"status\":\"in_progress\"}`)\n00201| \trunner := &fakeRunOnce{result: \"no_tasks\"}\n00202| \texit := &fakeExit{}\n00203| \tout := &bytes.Buffer{}\n00204| \tbeadsRunner := &fakeRunner{}\n00205| \tgitRunner := &fakeGitRunner{}\n00206| \n00207| \tcode := RunOnceMain([]string{\"--repo\", tempDir}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n00208| \n00209| \tif code != 0 {\n00210| \t\tt.Fatalf(\"expected exit code 0, got %d\", code)\n00211| \t}\n00212| \tif !runner.called {\n00213| \t\tt.Fatalf(\"expected run once to be called\")\n00214| \t}\n00215| \tif runner.opts.RootID != \"roadmap-2\" {\n00216| \t\tt.Fatalf(\"expected root id to be inferred, got %q\", runner.opts.RootID)\n00217| \t}\n00218| }\n00219| \n00220| func TestRunOnceMainMissingRootRequiresExplicitFlag(t *testing.T) {\n00221| \ttempDir := t.TempDir()\n00222| \twriteIssuesFile(t, tempDir, `{\"id\":\"epic-1\",\"title\":\"Other\",\"issue_type\":\"epic\",\"status\":\"open\"}`)\n00223| \trunner := &fakeRunOnce{result: \"no_tasks\"}\n00224| \texit := &fakeExit{}\n00225| \tstdout := &bytes.Buffer{}\n00226| \tstderr := &bytes.Buffer{}\n00227| \tbeadsRunner := &fakeRunner{}\n00228| \tgitRunner := &fakeGitRunner{}\n00229| \n00230| \tcode := RunOnceMain([]string{\"--repo\", tempDir}, runner.Run, exit.Exit, stdout, stderr, beadsRunner, gitRunner)\n00231| \n00232| \tif code != 1 {\n00233| \t\tt.Fatalf(\"expected exit code 1, got %d\", code)\n00234| \t}\n00235| \tif exit.code != 1 {\n00236| \t\tt.Fatalf(\"expected exit to be called with 1, got %d\", exit.code)\n00237| \t}\n00238| \tif runner.called {\n00239| \t\tt.Fatalf(\"expected run once not to be called\")\n00240| \t}\n00241| \tif !strings.Contains(stderr.String(), \"--root\") {\n00242| \t\tt.Fatalf(\"expected error to mention --root, got %q\", stderr.String())\n00243| \t}\n00244| \tif !strings.Contains(strings.ToLower(stderr.String()), \"roadmap\") {\n00245| \t\tt.Fatalf(\"expected error to mention roadmap, got %q\", stderr.String())\n00246| \t}\n00247| }\n00248| \n00249| type fakeTUIProgram struct {\n00250| \tstarted chan struct{}\n00251| \tquit    chan struct{}\n00252| \tevents  chan runner.Event\n00253| }\n00254| \n00255| func newFakeTUIProgram() *fakeTUIProgram {\n00256| \treturn &fakeTUIProgram{\n00257| \t\tstarted: make(chan struct{}),\n00258| \t\tquit:    make(chan struct{}),\n00259| \t\tevents:  make(chan runner.Event, 1),\n00260| \t}\n00261| }\n00262| \n00263| func (f *fakeTUIProgram) Start() error {\n00264| \tclose(f.started)\n00265| \treturn nil\n00266| }\n00267| \n00268| func (f *fakeTUIProgram) Send(event runner.Event) {\n00269| \tf.events <- event\n00270| }\n00271| \n00272| func (f *fakeTUIProgram) Quit() {\n00273| \tclose(f.quit)\n00274| }\n00275| \n00276| func waitForSignal(t *testing.T, signal chan struct{}, label string) {\n00277| \tt.Helper()\n00278| \tselect {\n00279| \tcase <-signal:\n00280| \t\treturn\n00281| \tcase <-time.After(200 * time.Millisecond):\n00282| \t\tt.Fatalf(\"expected %s\", label)\n00283| \t}\n00284| }\n00285| \n00286| func writeIssuesFile(t *testing.T, repoRoot string, payload string) {\n00287| \tt.Helper()\n00288| \tbeadsDir := filepath.Join(repoRoot, \".beads\")\n00289| \tif err := os.MkdirAll(beadsDir, 0o755); err != nil {\n00290| \t\tt.Fatalf(\"mkdir .beads: %v\", err)\n00291| \t}\n00292| \tissuesPath := filepath.Join(beadsDir, \"issues.jsonl\")\n00293| \tif err := os.WriteFile(issuesPath, []byte(payload+\"\\n\"), 0o644); err != nil {\n00294| \t\tt.Fatalf(\"write issues: %v\", err)\n00295| \t}\n00296| }\n00297| \n00298| func TestRunOnceMainUsesTUIOnTTYByDefault(t *testing.T) {\n00299| \tfakeProgram := newFakeTUIProgram()\n00300| \tprevIsTerminal := isTerminal\n00301| \tprevNewTUIProgram := newTUIProgram\n00302| \tisTerminal = func(io.Writer) bool { return true }\n00303| \tnewTUIProgram = func(stdout io.Writer) tuiProgram { return fakeProgram }\n00304| \tt.Cleanup(func() {\n00305| \t\tisTerminal = prevIsTerminal\n00306| \t\tnewTUIProgram = prevNewTUIProgram\n00307| \t})\n00308| \n00309| \trunOnce := &fakeRunOnce{result: \"no_tasks\"}\n00310| \texit := &fakeExit{}\n00311| \tout := &bytes.Buffer{}\n00312| \tbeadsRunner := &fakeRunner{}\n00313| \tgitRunner := &fakeGitRunner{}\n00314| \n00315| \tcode := RunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\"}, runOnce.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n00316| \n00317| \tif code != 0 {\n00318| \t\tt.Fatalf(\"expected exit code 0, got %d\", code)\n00319| \t}\n00320| \tif runOnce.deps.Events == nil {\n00321| \t\tt.Fatalf(\"expected events emitter to be set\")\n00322| \t}\n00323| \trunOnce.deps.Events.Emit(runner.Event{Type: runner.EventSelectTask})\n00324| \twaitForSignal(t, fakeProgram.started, \"tui start\")\n00325| \twaitForSignal(t, fakeProgram.quit, \"tui quit\")\n00326| \tselect {\n00327| \tcase <-fakeProgram.events:\n00328| \t\t// ok\n00329| \tcase <-time.After(200 * time.Millisecond):\n00330| \t\tt.Fatalf(\"expected event to be forwarded to TUI\")\n00331| \t}\n00332| }\n00333| \n00334| func TestRunOnceMainHeadlessDisablesTUI(t *testing.T) {\n00335| \tcalled := false\n00336| \tprevIsTerminal := isTerminal\n00337| \tprevNewTUIProgram := newTUIProgram\n00338| \tisTerminal = func(io.Writer) bool { return true }\n00339| \tnewTUIProgram = func(stdout io.Writer) tuiProgram {\n00340| \t\tcalled = true\n00341| \t\treturn newFakeTUIProgram()\n00342| \t}\n00343| \tt.Cleanup(func() {\n00344| \t\tisTerminal = prevIsTerminal\n00345| \t\tnewTUIProgram = prevNewTUIProgram\n00346| \t})\n00347| \n00348| \trunOnce := &fakeRunOnce{result: \"no_tasks\"}\n00349| \texit := &fakeExit{}\n00350| \tout := &bytes.Buffer{}\n00351| \tbeadsRunner := &fakeRunner{}\n00352| \tgitRunner := &fakeGitRunner{}\n00353| \tstderr := &bytes.Buffer{}\n00354| \n00355| \tRunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\", \"--headless\"}, runOnce.Run, exit.Exit, out, stderr, beadsRunner, gitRunner)\n00356| \n00357| \tif called {\n00358| \t\tt.Fatalf(\"expected TUI program not to start\")\n00359| \t}\n00360| \tif runOnce.deps.Events != nil {\n00361| \t\tt.Fatalf(\"expected no events emitter in headless mode\")\n00362| \t}\n00363| }\n00364| \n00365| func TestOpenCodeRunDefaultsCreateConfigAndEnv(t *testing.T) {\n00366| \ttempDir := t.TempDir()\n00367| \trepoRoot := filepath.Join(tempDir, \"repo\")\n00368| \tif err := os.MkdirAll(repoRoot, 0o755); err != nil {\n00369| \t\tt.Fatalf(\"mkdir repo: %v\", err)\n00370| \t}\n00371| \tt.Setenv(\"HOME\", tempDir)\n00372| \n00373| \topenCodeRunner := &fakeOpenCodeRunner{}\n00374| \topenCodeAdapter := openCodeAdapter{runner: openCodeRunner}\n00375| \n00376| \tconfigRoot := filepath.Join(tempDir, \".config\", \"opencode-runner\")\n00377| \tconfigDir := filepath.Join(configRoot, \"opencode\")\n00378| \tlogPath := filepath.Join(tempDir, \"runner-logs\", \"opencode\", \"issue-1.jsonl\")\n00379| \n00380| \tif err := openCodeAdapter.Run(\"issue-1\", repoRoot, \"prompt\", \"\", configRoot, configDir, logPath); err != nil {\n00381| \t\tt.Fatalf(\"open code run error: %v\", err)\n00382| \t}\n00383| \n00384| \tconfigFile := filepath.Join(configDir, \"opencode.json\")\n00385| \tif _, err := os.Stat(configFile); err != nil {\n00386| \t\tt.Fatalf(\"expected opencode.json to exist: %v\", err)\n00387| \t}\n00388| \texpectedConfigFile := filepath.Join(configDir, \"opencode.json\")\n00389| \tif openCodeRunner.env[\"XDG_CONFIG_HOME\"] != configRoot {\n00390| \t\tt.Fatalf(\"expected XDG_CONFIG_HOME set\")\n00391| \t}\n00392| \tif openCodeRunner.env[\"OPENCODE_CONFIG_DIR\"] != configDir {\n00393| \t\tt.Fatalf(\"expected OPENCODE_CONFIG_DIR set\")\n00394| \t}\n00395| \tif openCodeRunner.env[\"OPENCODE_CONFIG\"] != expectedConfigFile {\n00396| \t\tt.Fatalf(\"expected OPENCODE_CONFIG set\")\n00397| \t}\n00398| \tif openCodeRunner.env[\"OPENCODE_CONFIG_CONTENT\"] != \"{}\" {\n00399| \t\tt.Fatalf(\"expected OPENCODE_CONFIG_CONTENT set\")\n00400| \t}\n00401| }\n00402| \n\n(End of file - total 402 lines)\n</file>","title":"cmd/yolo-runner/main_test.go","metadata":{"preview":"package main\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"yolo-runner/internal/opencode\"\n\t\"yolo-runner/internal/runner\"\n)\n\ntype fakeRunner struct {\n\tcalls []string\n}\n","truncated":false},"time":{"start":1768850634334,"end":1768850634335}},"metadata":{"openai":{"itemId":"fc_03381b027dcebfe701696e84ca02a48191bc684c122b19a7d8"}}}}
{"type":"tool_use","timestamp":1768850634812,"sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","part":{"id":"prt_bd7b6b65f001jP6W1oBl16SNnI","sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","messageID":"msg_bd7b6aa70001FZz71DxjiGP2XL","type":"tool","callID":"call_TCu1McLBiSOZZakOrDvcJ5E5","tool":"read","state":{"status":"completed","input":{"filePath":"/Users/egv/dev/yolo-runner/cmd/yolo-runner/exec_test.go"},"output":"<file>\n00001| package main\n00002| \n00003| import (\n00004| \t\"os\"\n00005| \t\"path/filepath\"\n00006| \t\"strings\"\n00007| \t\"testing\"\n00008| )\n00009| \n00010| func TestStartCommandWithEnvSeparatesStdoutAndStderr(t *testing.T) {\n00011| \ttempDir := t.TempDir()\n00012| \tstdoutPath := filepath.Join(tempDir, \"output.jsonl\")\n00013| \targs := []string{\"/bin/sh\", \"-c\", \"printf '{\\\"ok\\\":true}\\\\n'; printf 'stderr-line\\\\n' 1>&2\"}\n00014| \n00015| \tprocess, err := startCommandWithEnv(args, nil, stdoutPath)\n00016| \tif err != nil {\n00017| \t\tt.Fatalf(\"startCommandWithEnv error: %v\", err)\n00018| \t}\n00019| \tif err := process.Wait(); err != nil {\n00020| \t\tt.Fatalf(\"process wait error: %v\", err)\n00021| \t}\n00022| \n00023| \tstdoutContent, err := os.ReadFile(stdoutPath)\n00024| \tif err != nil {\n00025| \t\tt.Fatalf(\"read stdout log: %v\", err)\n00026| \t}\n00027| \tif string(stdoutContent) != \"{\\\"ok\\\":true}\\n\" {\n00028| \t\tt.Fatalf(\"unexpected stdout log: %q\", string(stdoutContent))\n00029| \t}\n00030| \n00031| \tstderrPath := strings.TrimSuffix(stdoutPath, \".jsonl\") + \".stderr.log\"\n00032| \tstderrContent, err := os.ReadFile(stderrPath)\n00033| \tif err != nil {\n00034| \t\tt.Fatalf(\"read stderr log: %v\", err)\n00035| \t}\n00036| \tif string(stderrContent) != \"stderr-line\\n\" {\n00037| \t\tt.Fatalf(\"unexpected stderr log: %q\", string(stderrContent))\n00038| \t}\n00039| }\n00040| \n\n(End of file - total 40 lines)\n</file>","title":"cmd/yolo-runner/exec_test.go","metadata":{"preview":"package main\n\nimport (\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"testing\"\n)\n\nfunc TestStartCommandWithEnvSeparatesStdoutAndStderr(t *testing.T) {\n\ttempDir := t.TempDir()\n\tstdoutPath := filepath.Join(tempDir, \"output.jsonl\")\n\targs := []string{\"/bin/sh\", \"-c\", \"printf '{\\\"ok\\\":true}\\\\n'; printf 'stderr-line\\\\n' 1>&2\"}\n\n\tprocess, err := startCommandWithEnv(args, nil, stdoutPath)\n\tif err != nil {\n\t\tt.Fatalf(\"startCommandWithEnv error: %v\", err)\n\t}\n\tif err := process.Wait(); err != nil {\n\t\tt.Fatalf(\"process wait error: %v\", err)","truncated":false},"time":{"start":1768850634811,"end":1768850634812}},"metadata":{"openai":{"itemId":"fc_03381b027dcebfe701696e84ca52c88191b590d04dc0690961"}}}}
{"type":"step_finish","timestamp":1768850634829,"sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","part":{"id":"prt_bd7b6b83c001I3GZ2SGTxKXtl5","sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","messageID":"msg_bd7b6aa70001FZz71DxjiGP2XL","type":"step-finish","reason":"tool-calls","snapshot":"dd9bab0452cee7006542ced470f760297dcd8ea8","cost":0,"tokens":{"input":8454,"output":150,"reasoning":64,"cache":{"read":0,"write":0}}}}
{"type":"step_start","timestamp":1768850635150,"sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","part":{"id":"prt_bd7b6b98d001dOftLwaY15C3VC","sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","messageID":"msg_bd7b6b85c0019mLFS3hHYlcwMC","type":"step-start","snapshot":"cf7b402b7969b1d0a7e199bf87653a9fc1a00624"}}
{"type":"tool_use","timestamp":1768850688029,"sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","part":{"id":"prt_bd7b75032001d9vMs5MuLMcoc9","sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","messageID":"msg_bd7b6b85c0019mLFS3hHYlcwMC","type":"tool","callID":"call_dwQiHzzHYX1lPeF0pejmNr4S","tool":"edit","state":{"status":"completed","input":{"filePath":"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go","oldString":"func TestRunOnceMainDefaultsConfigPaths(t *testing.T) {\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tt.Setenv(\"HOME\", \"/home/user\")\n\n\tRunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\"}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif !runner.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n\tif runner.opts.ConfigRoot == \"\" {\n\t\tt.Fatalf(\"expected config root to be set\")\n\t}\n\tif runner.opts.ConfigDir == \"\" {\n\t\tt.Fatalf(\"expected config dir to be set\")\n\t}\n\texpectedConfigRoot := filepath.Join(\"/home/user\", \".config\", \"opencode-runner\")\n\tif runner.opts.ConfigRoot != expectedConfigRoot {\n\t\tt.Fatalf(\"expected config root %q, got %q\", expectedConfigRoot, runner.opts.ConfigRoot)\n\t}\n\texpectedConfigDir := filepath.Join(expectedConfigRoot, \"opencode\")\n\tif runner.opts.ConfigDir != expectedConfigDir {\n\t\tt.Fatalf(\"expected config dir %q, got %q\", expectedConfigDir, runner.opts.ConfigDir)\n\t}\n\tif exit.code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", exit.code)\n\t}\n}\n","newString":"func TestRunOnceMainDefaultsConfigPaths(t *testing.T) {\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tt.Setenv(\"HOME\", \"/home/user\")\n\n\tRunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\"}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif !runner.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n\tif runner.opts.ConfigRoot == \"\" {\n\t\tt.Fatalf(\"expected config root to be set\")\n\t}\n\tif runner.opts.ConfigDir == \"\" {\n\t\tt.Fatalf(\"expected config dir to be set\")\n\t}\n\texpectedConfigRoot := filepath.Join(\"/home/user\", \".config\", \"opencode-runner\")\n\tif runner.opts.ConfigRoot != expectedConfigRoot {\n\t\tt.Fatalf(\"expected config root %q, got %q\", expectedConfigRoot, runner.opts.ConfigRoot)\n\t}\n\texpectedConfigDir := filepath.Join(expectedConfigRoot, \"opencode\")\n\tif runner.opts.ConfigDir != expectedConfigDir {\n\t\tt.Fatalf(\"expected config dir %q, got %q\", expectedConfigDir, runner.opts.ConfigDir)\n\t}\n\tif exit.code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", exit.code)\n\t}\n}\n\nfunc TestRunOnceMainFailsWhenYoloAgentMissing(t *testing.T) {\n\ttempDir := t.TempDir()\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tstdout := &bytes.Buffer{}\n\tstderr := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\"}, runner.Run, exit.Exit, stdout, stderr, beadsRunner, gitRunner)\n\n\tif code != 1 {\n\t\tt.Fatalf(\"expected exit code 1, got %d\", code)\n\t}\n\tif exit.code != 1 {\n\t\tt.Fatalf(\"expected exit to be called with 1, got %d\", exit.code)\n\t}\n\tif runner.called {\n\t\tt.Fatalf(\"expected run once not to be called\")\n\t}\n\tif !strings.Contains(stderr.String(), \"yolo.md\") {\n\t\tt.Fatalf(\"expected error to mention yolo.md, got %q\", stderr.String())\n\t}\n}\n\nfunc TestRunOnceMainFailsWhenYoloAgentMissingPermission(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteAgentFile(t, tempDir, \"---\\nname: yolo\\n---\\n\")\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tstdout := &bytes.Buffer{}\n\tstderr := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\"}, runner.Run, exit.Exit, stdout, stderr, beadsRunner, gitRunner)\n\n\tif code != 1 {\n\t\tt.Fatalf(\"expected exit code 1, got %d\", code)\n\t}\n\tif exit.code != 1 {\n\t\tt.Fatalf(\"expected exit to be called with 1, got %d\", exit.code)\n\t}\n\tif runner.called {\n\t\tt.Fatalf(\"expected run once not to be called\")\n\t}\n\tif !strings.Contains(stderr.String(), \"permission: allow\") {\n\t\tt.Fatalf(\"expected error to mention permission allow, got %q\", stderr.String())\n\t}\n\tif !strings.Contains(strings.ToLower(stderr.String()), \"init\") {\n\t\tt.Fatalf(\"expected guidance to run init, got %q\", stderr.String())\n\t}\n}\n"},"output":"Edit applied successfully.\n\nLSP errors detected in this file, please fix:\n<diagnostics file=\"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go\">\nERROR [203:2] undefined: writeAgentFile\n</diagnostics>","title":"cmd/yolo-runner/main_test.go","metadata":{"diagnostics":{"/Users/egv/dev/yolo-runner/internal/opencode/client.go":[{"range":{"start":{"line":28,"character":1},"end":{"line":28,"character":18}},"severity":2,"code":"default","codeDescription":{"href":"https://staticcheck.dev/docs/checks/#S1031"},"source":"S1031","message":"unnecessary nil check around range"}],"/Users/egv/dev/yolo-runner/internal/opencode/watchdog.go":[],"/Users/egv/dev/yolo-runner/go.mod":[{"range":{"start":{"line":6,"character":44},"end":{"line":6,"character":55}},"severity":2,"source":"go mod tidy","message":"github.com/charmbracelet/bubbletea should be direct"},{"range":{"start":{"line":19,"character":26},"end":{"line":19,"character":37}},"severity":2,"source":"go mod tidy","message":"golang.org/x/term should be direct"}],"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main.go":[],"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go":[{"range":{"start":{"line":202,"character":1},"end":{"line":202,"character":15}},"severity":1,"code":"UndeclaredName","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UndeclaredName"},"source":"compiler","message":"undefined: writeAgentFile"}],"/Users/egv/dev/yolo-runner/cmd/yolo-runner/exec_test.go":[]},"diff":"Index: /Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go\n===================================================================\n--- /Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go\n+++ /Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go\n@@ -172,8 +172,62 @@\n \t\tt.Fatalf(\"expected exit code 0, got %d\", exit.code)\n \t}\n }\n \n+func TestRunOnceMainFailsWhenYoloAgentMissing(t *testing.T) {\n+\ttempDir := t.TempDir()\n+\trunner := &fakeRunOnce{result: \"no_tasks\"}\n+\texit := &fakeExit{}\n+\tstdout := &bytes.Buffer{}\n+\tstderr := &bytes.Buffer{}\n+\tbeadsRunner := &fakeRunner{}\n+\tgitRunner := &fakeGitRunner{}\n+\n+\tcode := RunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\"}, runner.Run, exit.Exit, stdout, stderr, beadsRunner, gitRunner)\n+\n+\tif code != 1 {\n+\t\tt.Fatalf(\"expected exit code 1, got %d\", code)\n+\t}\n+\tif exit.code != 1 {\n+\t\tt.Fatalf(\"expected exit to be called with 1, got %d\", exit.code)\n+\t}\n+\tif runner.called {\n+\t\tt.Fatalf(\"expected run once not to be called\")\n+\t}\n+\tif !strings.Contains(stderr.String(), \"yolo.md\") {\n+\t\tt.Fatalf(\"expected error to mention yolo.md, got %q\", stderr.String())\n+\t}\n+}\n+\n+func TestRunOnceMainFailsWhenYoloAgentMissingPermission(t *testing.T) {\n+\ttempDir := t.TempDir()\n+\twriteAgentFile(t, tempDir, \"---\\nname: yolo\\n---\\n\")\n+\trunner := &fakeRunOnce{result: \"no_tasks\"}\n+\texit := &fakeExit{}\n+\tstdout := &bytes.Buffer{}\n+\tstderr := &bytes.Buffer{}\n+\tbeadsRunner := &fakeRunner{}\n+\tgitRunner := &fakeGitRunner{}\n+\n+\tcode := RunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\"}, runner.Run, exit.Exit, stdout, stderr, beadsRunner, gitRunner)\n+\n+\tif code != 1 {\n+\t\tt.Fatalf(\"expected exit code 1, got %d\", code)\n+\t}\n+\tif exit.code != 1 {\n+\t\tt.Fatalf(\"expected exit to be called with 1, got %d\", exit.code)\n+\t}\n+\tif runner.called {\n+\t\tt.Fatalf(\"expected run once not to be called\")\n+\t}\n+\tif !strings.Contains(stderr.String(), \"permission: allow\") {\n+\t\tt.Fatalf(\"expected error to mention permission allow, got %q\", stderr.String())\n+\t}\n+\tif !strings.Contains(strings.ToLower(stderr.String()), \"init\") {\n+\t\tt.Fatalf(\"expected guidance to run init, got %q\", stderr.String())\n+\t}\n+}\n+\n func TestRunOnceMainInfersRoadmapRootWhenMissing(t *testing.T) {\n \ttempDir := t.TempDir()\n \twriteIssuesFile(t, tempDir, `{\"id\":\"roadmap-1\",\"title\":\"Roadmap\",\"issue_type\":\"epic\",\"status\":\"open\"}`)\n \trunner := &fakeRunOnce{result: \"no_tasks\"}\n","filediff":{"file":"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go","before":"package main\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"yolo-runner/internal/opencode\"\n\t\"yolo-runner/internal/runner\"\n)\n\ntype fakeRunner struct {\n\tcalls []string\n}\n\nfunc (f *fakeRunner) Run(args ...string) (string, error) {\n\tf.calls = append(f.calls, strings.Join(args, \" \"))\n\treturn \"\", nil\n}\n\ntype fakeOpenCodeRunLogger struct {\n\tcalled     bool\n\tissueID    string\n\trepoRoot   string\n\tprompt     string\n\tmodel      string\n\tconfigRoot string\n\tconfigDir  string\n\tlogPath    string\n}\n\nfunc (f *fakeOpenCodeRunLogger) Run(issueID string, repoRoot string, prompt string, model string, configRoot string, configDir string, logPath string) error {\n\tf.called = true\n\tf.issueID = issueID\n\tf.repoRoot = repoRoot\n\tf.prompt = prompt\n\tf.model = model\n\tf.configRoot = configRoot\n\tf.configDir = configDir\n\tf.logPath = logPath\n\treturn nil\n}\n\ntype fakeOpenCodeRunner struct {\n\tenv map[string]string\n}\n\ntype fakeOpenCodeProcess struct{}\n\nfunc (fakeOpenCodeProcess) Wait() error { return nil }\n\nfunc (fakeOpenCodeProcess) Kill() error { return nil }\n\nfunc (f *fakeOpenCodeRunner) Start(args []string, env map[string]string, stdoutPath string) (opencode.Process, error) {\n\tf.env = env\n\treturn fakeOpenCodeProcess{}, nil\n}\n\ntype fakeGitRunner struct {\n\tcalls  []string\n\toutput string\n\terr    error\n}\n\nfunc (f *fakeGitRunner) Run(name string, args ...string) (string, error) {\n\tf.calls = append(f.calls, name+\" \"+strings.Join(args, \" \"))\n\treturn f.output, f.err\n}\n\ntype fakeExit struct {\n\tcode int\n}\n\nfunc (f *fakeExit) Exit(code int) {\n\tf.code = code\n}\n\ntype fakeRunOnce struct {\n\tcalled bool\n\topts   runner.RunOnceOptions\n\tdeps   runner.RunOnceDeps\n\tresult string\n\terr    error\n}\n\nfunc (f *fakeRunOnce) Run(opts runner.RunOnceOptions, deps runner.RunOnceDeps) (string, error) {\n\n\tf.called = true\n\tf.opts = opts\n\tf.deps = deps\n\treturn f.result, f.err\n}\n\nfunc TestRunOnceMainReturnsErrorCodeOnFailure(t *testing.T) {\n\trunner := &fakeRunOnce{err: errors.New(\"boom\")}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\n\tcode := RunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\"}, runner.Run, exit.Exit, out, out, nil, nil)\n\n\tif code != 1 {\n\t\tt.Fatalf(\"expected exit code 1, got %d\", code)\n\t}\n\tif exit.code != 1 {\n\t\tt.Fatalf(\"expected exit to be called with 1, got %d\", exit.code)\n\t}\n\tif !strings.Contains(out.String(), \"boom\") {\n\t\tt.Fatalf(\"expected error output, got %q\", out.String())\n\t}\n}\n\nfunc TestRunOnceMainWiresDependencies(t *testing.T) {\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tRunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\", \"--model\", \"model\", \"--dry-run\"}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif !runner.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n\tif runner.opts.RepoRoot != \"/repo\" || runner.opts.RootID != \"root\" || runner.opts.Model != \"model\" || !runner.opts.DryRun {\n\t\tt.Fatalf(\"unexpected options: %#v\", runner.opts)\n\t}\n\tif runner.opts.Out == nil {\n\t\tt.Fatalf(\"expected output writer\")\n\t}\n\tif runner.deps.Beads == nil || runner.deps.Git == nil || runner.deps.Prompt == nil || runner.deps.OpenCode == nil || runner.deps.Logger == nil {\n\t\tt.Fatalf(\"expected deps to be wired\")\n\t}\n\tif exit.code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", exit.code)\n\t}\n}\n\nfunc TestRunOnceMainDefaultsConfigPaths(t *testing.T) {\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tt.Setenv(\"HOME\", \"/home/user\")\n\n\tRunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\"}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif !runner.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n\tif runner.opts.ConfigRoot == \"\" {\n\t\tt.Fatalf(\"expected config root to be set\")\n\t}\n\tif runner.opts.ConfigDir == \"\" {\n\t\tt.Fatalf(\"expected config dir to be set\")\n\t}\n\texpectedConfigRoot := filepath.Join(\"/home/user\", \".config\", \"opencode-runner\")\n\tif runner.opts.ConfigRoot != expectedConfigRoot {\n\t\tt.Fatalf(\"expected config root %q, got %q\", expectedConfigRoot, runner.opts.ConfigRoot)\n\t}\n\texpectedConfigDir := filepath.Join(expectedConfigRoot, \"opencode\")\n\tif runner.opts.ConfigDir != expectedConfigDir {\n\t\tt.Fatalf(\"expected config dir %q, got %q\", expectedConfigDir, runner.opts.ConfigDir)\n\t}\n\tif exit.code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", exit.code)\n\t}\n}\n\nfunc TestRunOnceMainInfersRoadmapRootWhenMissing(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteIssuesFile(t, tempDir, `{\"id\":\"roadmap-1\",\"title\":\"Roadmap\",\"issue_type\":\"epic\",\"status\":\"open\"}`)\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", code)\n\t}\n\tif !runner.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n\tif runner.opts.RootID != \"roadmap-1\" {\n\t\tt.Fatalf(\"expected root id to be inferred, got %q\", runner.opts.RootID)\n\t}\n}\n\nfunc TestRunOnceMainInfersRoadmapRootWhenInProgress(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteIssuesFile(t, tempDir, `{\"id\":\"roadmap-2\",\"title\":\"Roadmap\",\"issue_type\":\"epic\",\"status\":\"in_progress\"}`)\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", code)\n\t}\n\tif !runner.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n\tif runner.opts.RootID != \"roadmap-2\" {\n\t\tt.Fatalf(\"expected root id to be inferred, got %q\", runner.opts.RootID)\n\t}\n}\n\nfunc TestRunOnceMainMissingRootRequiresExplicitFlag(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteIssuesFile(t, tempDir, `{\"id\":\"epic-1\",\"title\":\"Other\",\"issue_type\":\"epic\",\"status\":\"open\"}`)\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tstdout := &bytes.Buffer{}\n\tstderr := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir}, runner.Run, exit.Exit, stdout, stderr, beadsRunner, gitRunner)\n\n\tif code != 1 {\n\t\tt.Fatalf(\"expected exit code 1, got %d\", code)\n\t}\n\tif exit.code != 1 {\n\t\tt.Fatalf(\"expected exit to be called with 1, got %d\", exit.code)\n\t}\n\tif runner.called {\n\t\tt.Fatalf(\"expected run once not to be called\")\n\t}\n\tif !strings.Contains(stderr.String(), \"--root\") {\n\t\tt.Fatalf(\"expected error to mention --root, got %q\", stderr.String())\n\t}\n\tif !strings.Contains(strings.ToLower(stderr.String()), \"roadmap\") {\n\t\tt.Fatalf(\"expected error to mention roadmap, got %q\", stderr.String())\n\t}\n}\n\ntype fakeTUIProgram struct {\n\tstarted chan struct{}\n\tquit    chan struct{}\n\tevents  chan runner.Event\n}\n\nfunc newFakeTUIProgram() *fakeTUIProgram {\n\treturn &fakeTUIProgram{\n\t\tstarted: make(chan struct{}),\n\t\tquit:    make(chan struct{}),\n\t\tevents:  make(chan runner.Event, 1),\n\t}\n}\n\nfunc (f *fakeTUIProgram) Start() error {\n\tclose(f.started)\n\treturn nil\n}\n\nfunc (f *fakeTUIProgram) Send(event runner.Event) {\n\tf.events <- event\n}\n\nfunc (f *fakeTUIProgram) Quit() {\n\tclose(f.quit)\n}\n\nfunc waitForSignal(t *testing.T, signal chan struct{}, label string) {\n\tt.Helper()\n\tselect {\n\tcase <-signal:\n\t\treturn\n\tcase <-time.After(200 * time.Millisecond):\n\t\tt.Fatalf(\"expected %s\", label)\n\t}\n}\n\nfunc writeIssuesFile(t *testing.T, repoRoot string, payload string) {\n\tt.Helper()\n\tbeadsDir := filepath.Join(repoRoot, \".beads\")\n\tif err := os.MkdirAll(beadsDir, 0o755); err != nil {\n\t\tt.Fatalf(\"mkdir .beads: %v\", err)\n\t}\n\tissuesPath := filepath.Join(beadsDir, \"issues.jsonl\")\n\tif err := os.WriteFile(issuesPath, []byte(payload+\"\\n\"), 0o644); err != nil {\n\t\tt.Fatalf(\"write issues: %v\", err)\n\t}\n}\n\nfunc TestRunOnceMainUsesTUIOnTTYByDefault(t *testing.T) {\n\tfakeProgram := newFakeTUIProgram()\n\tprevIsTerminal := isTerminal\n\tprevNewTUIProgram := newTUIProgram\n\tisTerminal = func(io.Writer) bool { return true }\n\tnewTUIProgram = func(stdout io.Writer) tuiProgram { return fakeProgram }\n\tt.Cleanup(func() {\n\t\tisTerminal = prevIsTerminal\n\t\tnewTUIProgram = prevNewTUIProgram\n\t})\n\n\trunOnce := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\"}, runOnce.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", code)\n\t}\n\tif runOnce.deps.Events == nil {\n\t\tt.Fatalf(\"expected events emitter to be set\")\n\t}\n\trunOnce.deps.Events.Emit(runner.Event{Type: runner.EventSelectTask})\n\twaitForSignal(t, fakeProgram.started, \"tui start\")\n\twaitForSignal(t, fakeProgram.quit, \"tui quit\")\n\tselect {\n\tcase <-fakeProgram.events:\n\t\t// ok\n\tcase <-time.After(200 * time.Millisecond):\n\t\tt.Fatalf(\"expected event to be forwarded to TUI\")\n\t}\n}\n\nfunc TestRunOnceMainHeadlessDisablesTUI(t *testing.T) {\n\tcalled := false\n\tprevIsTerminal := isTerminal\n\tprevNewTUIProgram := newTUIProgram\n\tisTerminal = func(io.Writer) bool { return true }\n\tnewTUIProgram = func(stdout io.Writer) tuiProgram {\n\t\tcalled = true\n\t\treturn newFakeTUIProgram()\n\t}\n\tt.Cleanup(func() {\n\t\tisTerminal = prevIsTerminal\n\t\tnewTUIProgram = prevNewTUIProgram\n\t})\n\n\trunOnce := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\tstderr := &bytes.Buffer{}\n\n\tRunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\", \"--headless\"}, runOnce.Run, exit.Exit, out, stderr, beadsRunner, gitRunner)\n\n\tif called {\n\t\tt.Fatalf(\"expected TUI program not to start\")\n\t}\n\tif runOnce.deps.Events != nil {\n\t\tt.Fatalf(\"expected no events emitter in headless mode\")\n\t}\n}\n\nfunc TestOpenCodeRunDefaultsCreateConfigAndEnv(t *testing.T) {\n\ttempDir := t.TempDir()\n\trepoRoot := filepath.Join(tempDir, \"repo\")\n\tif err := os.MkdirAll(repoRoot, 0o755); err != nil {\n\t\tt.Fatalf(\"mkdir repo: %v\", err)\n\t}\n\tt.Setenv(\"HOME\", tempDir)\n\n\topenCodeRunner := &fakeOpenCodeRunner{}\n\topenCodeAdapter := openCodeAdapter{runner: openCodeRunner}\n\n\tconfigRoot := filepath.Join(tempDir, \".config\", \"opencode-runner\")\n\tconfigDir := filepath.Join(configRoot, \"opencode\")\n\tlogPath := filepath.Join(tempDir, \"runner-logs\", \"opencode\", \"issue-1.jsonl\")\n\n\tif err := openCodeAdapter.Run(\"issue-1\", repoRoot, \"prompt\", \"\", configRoot, configDir, logPath); err != nil {\n\t\tt.Fatalf(\"open code run error: %v\", err)\n\t}\n\n\tconfigFile := filepath.Join(configDir, \"opencode.json\")\n\tif _, err := os.Stat(configFile); err != nil {\n\t\tt.Fatalf(\"expected opencode.json to exist: %v\", err)\n\t}\n\texpectedConfigFile := filepath.Join(configDir, \"opencode.json\")\n\tif openCodeRunner.env[\"XDG_CONFIG_HOME\"] != configRoot {\n\t\tt.Fatalf(\"expected XDG_CONFIG_HOME set\")\n\t}\n\tif openCodeRunner.env[\"OPENCODE_CONFIG_DIR\"] != configDir {\n\t\tt.Fatalf(\"expected OPENCODE_CONFIG_DIR set\")\n\t}\n\tif openCodeRunner.env[\"OPENCODE_CONFIG\"] != expectedConfigFile {\n\t\tt.Fatalf(\"expected OPENCODE_CONFIG set\")\n\t}\n\tif openCodeRunner.env[\"OPENCODE_CONFIG_CONTENT\"] != \"{}\" {\n\t\tt.Fatalf(\"expected OPENCODE_CONFIG_CONTENT set\")\n\t}\n}\n","after":"package main\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"yolo-runner/internal/opencode\"\n\t\"yolo-runner/internal/runner\"\n)\n\ntype fakeRunner struct {\n\tcalls []string\n}\n\nfunc (f *fakeRunner) Run(args ...string) (string, error) {\n\tf.calls = append(f.calls, strings.Join(args, \" \"))\n\treturn \"\", nil\n}\n\ntype fakeOpenCodeRunLogger struct {\n\tcalled     bool\n\tissueID    string\n\trepoRoot   string\n\tprompt     string\n\tmodel      string\n\tconfigRoot string\n\tconfigDir  string\n\tlogPath    string\n}\n\nfunc (f *fakeOpenCodeRunLogger) Run(issueID string, repoRoot string, prompt string, model string, configRoot string, configDir string, logPath string) error {\n\tf.called = true\n\tf.issueID = issueID\n\tf.repoRoot = repoRoot\n\tf.prompt = prompt\n\tf.model = model\n\tf.configRoot = configRoot\n\tf.configDir = configDir\n\tf.logPath = logPath\n\treturn nil\n}\n\ntype fakeOpenCodeRunner struct {\n\tenv map[string]string\n}\n\ntype fakeOpenCodeProcess struct{}\n\nfunc (fakeOpenCodeProcess) Wait() error { return nil }\n\nfunc (fakeOpenCodeProcess) Kill() error { return nil }\n\nfunc (f *fakeOpenCodeRunner) Start(args []string, env map[string]string, stdoutPath string) (opencode.Process, error) {\n\tf.env = env\n\treturn fakeOpenCodeProcess{}, nil\n}\n\ntype fakeGitRunner struct {\n\tcalls  []string\n\toutput string\n\terr    error\n}\n\nfunc (f *fakeGitRunner) Run(name string, args ...string) (string, error) {\n\tf.calls = append(f.calls, name+\" \"+strings.Join(args, \" \"))\n\treturn f.output, f.err\n}\n\ntype fakeExit struct {\n\tcode int\n}\n\nfunc (f *fakeExit) Exit(code int) {\n\tf.code = code\n}\n\ntype fakeRunOnce struct {\n\tcalled bool\n\topts   runner.RunOnceOptions\n\tdeps   runner.RunOnceDeps\n\tresult string\n\terr    error\n}\n\nfunc (f *fakeRunOnce) Run(opts runner.RunOnceOptions, deps runner.RunOnceDeps) (string, error) {\n\n\tf.called = true\n\tf.opts = opts\n\tf.deps = deps\n\treturn f.result, f.err\n}\n\nfunc TestRunOnceMainReturnsErrorCodeOnFailure(t *testing.T) {\n\trunner := &fakeRunOnce{err: errors.New(\"boom\")}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\n\tcode := RunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\"}, runner.Run, exit.Exit, out, out, nil, nil)\n\n\tif code != 1 {\n\t\tt.Fatalf(\"expected exit code 1, got %d\", code)\n\t}\n\tif exit.code != 1 {\n\t\tt.Fatalf(\"expected exit to be called with 1, got %d\", exit.code)\n\t}\n\tif !strings.Contains(out.String(), \"boom\") {\n\t\tt.Fatalf(\"expected error output, got %q\", out.String())\n\t}\n}\n\nfunc TestRunOnceMainWiresDependencies(t *testing.T) {\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tRunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\", \"--model\", \"model\", \"--dry-run\"}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif !runner.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n\tif runner.opts.RepoRoot != \"/repo\" || runner.opts.RootID != \"root\" || runner.opts.Model != \"model\" || !runner.opts.DryRun {\n\t\tt.Fatalf(\"unexpected options: %#v\", runner.opts)\n\t}\n\tif runner.opts.Out == nil {\n\t\tt.Fatalf(\"expected output writer\")\n\t}\n\tif runner.deps.Beads == nil || runner.deps.Git == nil || runner.deps.Prompt == nil || runner.deps.OpenCode == nil || runner.deps.Logger == nil {\n\t\tt.Fatalf(\"expected deps to be wired\")\n\t}\n\tif exit.code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", exit.code)\n\t}\n}\n\nfunc TestRunOnceMainDefaultsConfigPaths(t *testing.T) {\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tt.Setenv(\"HOME\", \"/home/user\")\n\n\tRunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\"}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif !runner.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n\tif runner.opts.ConfigRoot == \"\" {\n\t\tt.Fatalf(\"expected config root to be set\")\n\t}\n\tif runner.opts.ConfigDir == \"\" {\n\t\tt.Fatalf(\"expected config dir to be set\")\n\t}\n\texpectedConfigRoot := filepath.Join(\"/home/user\", \".config\", \"opencode-runner\")\n\tif runner.opts.ConfigRoot != expectedConfigRoot {\n\t\tt.Fatalf(\"expected config root %q, got %q\", expectedConfigRoot, runner.opts.ConfigRoot)\n\t}\n\texpectedConfigDir := filepath.Join(expectedConfigRoot, \"opencode\")\n\tif runner.opts.ConfigDir != expectedConfigDir {\n\t\tt.Fatalf(\"expected config dir %q, got %q\", expectedConfigDir, runner.opts.ConfigDir)\n\t}\n\tif exit.code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", exit.code)\n\t}\n}\n\nfunc TestRunOnceMainFailsWhenYoloAgentMissing(t *testing.T) {\n\ttempDir := t.TempDir()\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tstdout := &bytes.Buffer{}\n\tstderr := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\"}, runner.Run, exit.Exit, stdout, stderr, beadsRunner, gitRunner)\n\n\tif code != 1 {\n\t\tt.Fatalf(\"expected exit code 1, got %d\", code)\n\t}\n\tif exit.code != 1 {\n\t\tt.Fatalf(\"expected exit to be called with 1, got %d\", exit.code)\n\t}\n\tif runner.called {\n\t\tt.Fatalf(\"expected run once not to be called\")\n\t}\n\tif !strings.Contains(stderr.String(), \"yolo.md\") {\n\t\tt.Fatalf(\"expected error to mention yolo.md, got %q\", stderr.String())\n\t}\n}\n\nfunc TestRunOnceMainFailsWhenYoloAgentMissingPermission(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteAgentFile(t, tempDir, \"---\\nname: yolo\\n---\\n\")\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tstdout := &bytes.Buffer{}\n\tstderr := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\"}, runner.Run, exit.Exit, stdout, stderr, beadsRunner, gitRunner)\n\n\tif code != 1 {\n\t\tt.Fatalf(\"expected exit code 1, got %d\", code)\n\t}\n\tif exit.code != 1 {\n\t\tt.Fatalf(\"expected exit to be called with 1, got %d\", exit.code)\n\t}\n\tif runner.called {\n\t\tt.Fatalf(\"expected run once not to be called\")\n\t}\n\tif !strings.Contains(stderr.String(), \"permission: allow\") {\n\t\tt.Fatalf(\"expected error to mention permission allow, got %q\", stderr.String())\n\t}\n\tif !strings.Contains(strings.ToLower(stderr.String()), \"init\") {\n\t\tt.Fatalf(\"expected guidance to run init, got %q\", stderr.String())\n\t}\n}\n\nfunc TestRunOnceMainInfersRoadmapRootWhenMissing(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteIssuesFile(t, tempDir, `{\"id\":\"roadmap-1\",\"title\":\"Roadmap\",\"issue_type\":\"epic\",\"status\":\"open\"}`)\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", code)\n\t}\n\tif !runner.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n\tif runner.opts.RootID != \"roadmap-1\" {\n\t\tt.Fatalf(\"expected root id to be inferred, got %q\", runner.opts.RootID)\n\t}\n}\n\nfunc TestRunOnceMainInfersRoadmapRootWhenInProgress(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteIssuesFile(t, tempDir, `{\"id\":\"roadmap-2\",\"title\":\"Roadmap\",\"issue_type\":\"epic\",\"status\":\"in_progress\"}`)\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", code)\n\t}\n\tif !runner.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n\tif runner.opts.RootID != \"roadmap-2\" {\n\t\tt.Fatalf(\"expected root id to be inferred, got %q\", runner.opts.RootID)\n\t}\n}\n\nfunc TestRunOnceMainMissingRootRequiresExplicitFlag(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteIssuesFile(t, tempDir, `{\"id\":\"epic-1\",\"title\":\"Other\",\"issue_type\":\"epic\",\"status\":\"open\"}`)\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tstdout := &bytes.Buffer{}\n\tstderr := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir}, runner.Run, exit.Exit, stdout, stderr, beadsRunner, gitRunner)\n\n\tif code != 1 {\n\t\tt.Fatalf(\"expected exit code 1, got %d\", code)\n\t}\n\tif exit.code != 1 {\n\t\tt.Fatalf(\"expected exit to be called with 1, got %d\", exit.code)\n\t}\n\tif runner.called {\n\t\tt.Fatalf(\"expected run once not to be called\")\n\t}\n\tif !strings.Contains(stderr.String(), \"--root\") {\n\t\tt.Fatalf(\"expected error to mention --root, got %q\", stderr.String())\n\t}\n\tif !strings.Contains(strings.ToLower(stderr.String()), \"roadmap\") {\n\t\tt.Fatalf(\"expected error to mention roadmap, got %q\", stderr.String())\n\t}\n}\n\ntype fakeTUIProgram struct {\n\tstarted chan struct{}\n\tquit    chan struct{}\n\tevents  chan runner.Event\n}\n\nfunc newFakeTUIProgram() *fakeTUIProgram {\n\treturn &fakeTUIProgram{\n\t\tstarted: make(chan struct{}),\n\t\tquit:    make(chan struct{}),\n\t\tevents:  make(chan runner.Event, 1),\n\t}\n}\n\nfunc (f *fakeTUIProgram) Start() error {\n\tclose(f.started)\n\treturn nil\n}\n\nfunc (f *fakeTUIProgram) Send(event runner.Event) {\n\tf.events <- event\n}\n\nfunc (f *fakeTUIProgram) Quit() {\n\tclose(f.quit)\n}\n\nfunc waitForSignal(t *testing.T, signal chan struct{}, label string) {\n\tt.Helper()\n\tselect {\n\tcase <-signal:\n\t\treturn\n\tcase <-time.After(200 * time.Millisecond):\n\t\tt.Fatalf(\"expected %s\", label)\n\t}\n}\n\nfunc writeIssuesFile(t *testing.T, repoRoot string, payload string) {\n\tt.Helper()\n\tbeadsDir := filepath.Join(repoRoot, \".beads\")\n\tif err := os.MkdirAll(beadsDir, 0o755); err != nil {\n\t\tt.Fatalf(\"mkdir .beads: %v\", err)\n\t}\n\tissuesPath := filepath.Join(beadsDir, \"issues.jsonl\")\n\tif err := os.WriteFile(issuesPath, []byte(payload+\"\\n\"), 0o644); err != nil {\n\t\tt.Fatalf(\"write issues: %v\", err)\n\t}\n}\n\nfunc TestRunOnceMainUsesTUIOnTTYByDefault(t *testing.T) {\n\tfakeProgram := newFakeTUIProgram()\n\tprevIsTerminal := isTerminal\n\tprevNewTUIProgram := newTUIProgram\n\tisTerminal = func(io.Writer) bool { return true }\n\tnewTUIProgram = func(stdout io.Writer) tuiProgram { return fakeProgram }\n\tt.Cleanup(func() {\n\t\tisTerminal = prevIsTerminal\n\t\tnewTUIProgram = prevNewTUIProgram\n\t})\n\n\trunOnce := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\"}, runOnce.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", code)\n\t}\n\tif runOnce.deps.Events == nil {\n\t\tt.Fatalf(\"expected events emitter to be set\")\n\t}\n\trunOnce.deps.Events.Emit(runner.Event{Type: runner.EventSelectTask})\n\twaitForSignal(t, fakeProgram.started, \"tui start\")\n\twaitForSignal(t, fakeProgram.quit, \"tui quit\")\n\tselect {\n\tcase <-fakeProgram.events:\n\t\t// ok\n\tcase <-time.After(200 * time.Millisecond):\n\t\tt.Fatalf(\"expected event to be forwarded to TUI\")\n\t}\n}\n\nfunc TestRunOnceMainHeadlessDisablesTUI(t *testing.T) {\n\tcalled := false\n\tprevIsTerminal := isTerminal\n\tprevNewTUIProgram := newTUIProgram\n\tisTerminal = func(io.Writer) bool { return true }\n\tnewTUIProgram = func(stdout io.Writer) tuiProgram {\n\t\tcalled = true\n\t\treturn newFakeTUIProgram()\n\t}\n\tt.Cleanup(func() {\n\t\tisTerminal = prevIsTerminal\n\t\tnewTUIProgram = prevNewTUIProgram\n\t})\n\n\trunOnce := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\tstderr := &bytes.Buffer{}\n\n\tRunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\", \"--headless\"}, runOnce.Run, exit.Exit, out, stderr, beadsRunner, gitRunner)\n\n\tif called {\n\t\tt.Fatalf(\"expected TUI program not to start\")\n\t}\n\tif runOnce.deps.Events != nil {\n\t\tt.Fatalf(\"expected no events emitter in headless mode\")\n\t}\n}\n\nfunc TestOpenCodeRunDefaultsCreateConfigAndEnv(t *testing.T) {\n\ttempDir := t.TempDir()\n\trepoRoot := filepath.Join(tempDir, \"repo\")\n\tif err := os.MkdirAll(repoRoot, 0o755); err != nil {\n\t\tt.Fatalf(\"mkdir repo: %v\", err)\n\t}\n\tt.Setenv(\"HOME\", tempDir)\n\n\topenCodeRunner := &fakeOpenCodeRunner{}\n\topenCodeAdapter := openCodeAdapter{runner: openCodeRunner}\n\n\tconfigRoot := filepath.Join(tempDir, \".config\", \"opencode-runner\")\n\tconfigDir := filepath.Join(configRoot, \"opencode\")\n\tlogPath := filepath.Join(tempDir, \"runner-logs\", \"opencode\", \"issue-1.jsonl\")\n\n\tif err := openCodeAdapter.Run(\"issue-1\", repoRoot, \"prompt\", \"\", configRoot, configDir, logPath); err != nil {\n\t\tt.Fatalf(\"open code run error: %v\", err)\n\t}\n\n\tconfigFile := filepath.Join(configDir, \"opencode.json\")\n\tif _, err := os.Stat(configFile); err != nil {\n\t\tt.Fatalf(\"expected opencode.json to exist: %v\", err)\n\t}\n\texpectedConfigFile := filepath.Join(configDir, \"opencode.json\")\n\tif openCodeRunner.env[\"XDG_CONFIG_HOME\"] != configRoot {\n\t\tt.Fatalf(\"expected XDG_CONFIG_HOME set\")\n\t}\n\tif openCodeRunner.env[\"OPENCODE_CONFIG_DIR\"] != configDir {\n\t\tt.Fatalf(\"expected OPENCODE_CONFIG_DIR set\")\n\t}\n\tif openCodeRunner.env[\"OPENCODE_CONFIG\"] != expectedConfigFile {\n\t\tt.Fatalf(\"expected OPENCODE_CONFIG set\")\n\t}\n\tif openCodeRunner.env[\"OPENCODE_CONFIG_CONTENT\"] != \"{}\" {\n\t\tt.Fatalf(\"expected OPENCODE_CONFIG_CONTENT set\")\n\t}\n}\n","additions":54,"deletions":0},"truncated":false},"time":{"start":1768850687850,"end":1768850688028}},"metadata":{"openai":{"itemId":"fc_029c92720c0d4cb601696e84f1b158819181e1b0db35de22b3"}}}}
{"type":"step_finish","timestamp":1768850688046,"sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","part":{"id":"prt_bd7b7881d001PDPTYL4Gb6DIn1","sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","messageID":"msg_bd7b6b85c0019mLFS3hHYlcwMC","type":"step-finish","reason":"tool-calls","snapshot":"e65f93ca5ca0c5d97c2ce9ab18908b7a156c89a2","cost":0,"tokens":{"input":5389,"output":3212,"reasoning":1856,"cache":{"read":16768,"write":0}}}}
{"type":"step_start","timestamp":1768850688350,"sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","part":{"id":"prt_bd7b7895d001MNoaryRA06hewv","sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","messageID":"msg_bd7b7883d001k3aKei1MAZdtaA","type":"step-start","snapshot":"d5be195a5bf3c3d6ab7864e616709a2ffd7862b6"}}
{"type":"tool_use","timestamp":1768850696697,"sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","part":{"id":"prt_bd7b78b31001bvZazae1zMD6II","sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","messageID":"msg_bd7b7883d001k3aKei1MAZdtaA","type":"tool","callID":"call_XwzJgKbSi1pqBt1L0VXCw2pP","tool":"edit","state":{"status":"completed","input":{"filePath":"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go","oldString":"func writeIssuesFile(t *testing.T, repoRoot string, payload string) {\n\tt.Helper()\n\tbeadsDir := filepath.Join(repoRoot, \".beads\")\n\tif err := os.MkdirAll(beadsDir, 0o755); err != nil {\n\t\tt.Fatalf(\"mkdir .beads: %v\", err)\n\t}\n\tissuesPath := filepath.Join(beadsDir, \"issues.jsonl\")\n\tif err := os.WriteFile(issuesPath, []byte(payload+\"\\n\"), 0o644); err != nil {\n\t\tt.Fatalf(\"write issues: %v\", err)\n\t}\n}\n","newString":"func writeIssuesFile(t *testing.T, repoRoot string, payload string) {\n\tt.Helper()\n\tbeadsDir := filepath.Join(repoRoot, \".beads\")\n\tif err := os.MkdirAll(beadsDir, 0o755); err != nil {\n\t\tt.Fatalf(\"mkdir .beads: %v\", err)\n\t}\n\tissuesPath := filepath.Join(beadsDir, \"issues.jsonl\")\n\tif err := os.WriteFile(issuesPath, []byte(payload+\"\\n\"), 0o644); err != nil {\n\t\tt.Fatalf(\"write issues: %v\", err)\n\t}\n}\n\nfunc writeAgentFile(t *testing.T, repoRoot string, payload string) {\n\tt.Helper()\n\tagentDir := filepath.Join(repoRoot, \".opencode\", \"agent\")\n\tif err := os.MkdirAll(agentDir, 0o755); err != nil {\n\t\tt.Fatalf(\"mkdir agent dir: %v\", err)\n\t}\n\tagentPath := filepath.Join(agentDir, \"yolo.md\")\n\tif err := os.WriteFile(agentPath, []byte(payload), 0o644); err != nil {\n\t\tt.Fatalf(\"write agent file: %v\", err)\n\t}\n}\n"},"output":"Edit applied successfully.","title":"cmd/yolo-runner/main_test.go","metadata":{"diagnostics":{"/Users/egv/dev/yolo-runner/internal/opencode/client.go":[{"range":{"start":{"line":28,"character":1},"end":{"line":28,"character":18}},"severity":2,"code":"default","codeDescription":{"href":"https://staticcheck.dev/docs/checks/#S1031"},"source":"S1031","message":"unnecessary nil check around range"}],"/Users/egv/dev/yolo-runner/internal/opencode/watchdog.go":[],"/Users/egv/dev/yolo-runner/go.mod":[{"range":{"start":{"line":6,"character":44},"end":{"line":6,"character":55}},"severity":2,"source":"go mod tidy","message":"github.com/charmbracelet/bubbletea should be direct"},{"range":{"start":{"line":19,"character":26},"end":{"line":19,"character":37}},"severity":2,"source":"go mod tidy","message":"golang.org/x/term should be direct"}],"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main.go":[],"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go":[],"/Users/egv/dev/yolo-runner/cmd/yolo-runner/exec_test.go":[]},"diff":"Index: /Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go\n===================================================================\n--- /Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go\n+++ /Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go\n@@ -348,8 +348,20 @@\n \t\tt.Fatalf(\"write issues: %v\", err)\n \t}\n }\n \n+func writeAgentFile(t *testing.T, repoRoot string, payload string) {\n+\tt.Helper()\n+\tagentDir := filepath.Join(repoRoot, \".opencode\", \"agent\")\n+\tif err := os.MkdirAll(agentDir, 0o755); err != nil {\n+\t\tt.Fatalf(\"mkdir agent dir: %v\", err)\n+\t}\n+\tagentPath := filepath.Join(agentDir, \"yolo.md\")\n+\tif err := os.WriteFile(agentPath, []byte(payload), 0o644); err != nil {\n+\t\tt.Fatalf(\"write agent file: %v\", err)\n+\t}\n+}\n+\n func TestRunOnceMainUsesTUIOnTTYByDefault(t *testing.T) {\n \tfakeProgram := newFakeTUIProgram()\n \tprevIsTerminal := isTerminal\n \tprevNewTUIProgram := newTUIProgram\n","filediff":{"file":"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go","before":"package main\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"yolo-runner/internal/opencode\"\n\t\"yolo-runner/internal/runner\"\n)\n\ntype fakeRunner struct {\n\tcalls []string\n}\n\nfunc (f *fakeRunner) Run(args ...string) (string, error) {\n\tf.calls = append(f.calls, strings.Join(args, \" \"))\n\treturn \"\", nil\n}\n\ntype fakeOpenCodeRunLogger struct {\n\tcalled     bool\n\tissueID    string\n\trepoRoot   string\n\tprompt     string\n\tmodel      string\n\tconfigRoot string\n\tconfigDir  string\n\tlogPath    string\n}\n\nfunc (f *fakeOpenCodeRunLogger) Run(issueID string, repoRoot string, prompt string, model string, configRoot string, configDir string, logPath string) error {\n\tf.called = true\n\tf.issueID = issueID\n\tf.repoRoot = repoRoot\n\tf.prompt = prompt\n\tf.model = model\n\tf.configRoot = configRoot\n\tf.configDir = configDir\n\tf.logPath = logPath\n\treturn nil\n}\n\ntype fakeOpenCodeRunner struct {\n\tenv map[string]string\n}\n\ntype fakeOpenCodeProcess struct{}\n\nfunc (fakeOpenCodeProcess) Wait() error { return nil }\n\nfunc (fakeOpenCodeProcess) Kill() error { return nil }\n\nfunc (f *fakeOpenCodeRunner) Start(args []string, env map[string]string, stdoutPath string) (opencode.Process, error) {\n\tf.env = env\n\treturn fakeOpenCodeProcess{}, nil\n}\n\ntype fakeGitRunner struct {\n\tcalls  []string\n\toutput string\n\terr    error\n}\n\nfunc (f *fakeGitRunner) Run(name string, args ...string) (string, error) {\n\tf.calls = append(f.calls, name+\" \"+strings.Join(args, \" \"))\n\treturn f.output, f.err\n}\n\ntype fakeExit struct {\n\tcode int\n}\n\nfunc (f *fakeExit) Exit(code int) {\n\tf.code = code\n}\n\ntype fakeRunOnce struct {\n\tcalled bool\n\topts   runner.RunOnceOptions\n\tdeps   runner.RunOnceDeps\n\tresult string\n\terr    error\n}\n\nfunc (f *fakeRunOnce) Run(opts runner.RunOnceOptions, deps runner.RunOnceDeps) (string, error) {\n\n\tf.called = true\n\tf.opts = opts\n\tf.deps = deps\n\treturn f.result, f.err\n}\n\nfunc TestRunOnceMainReturnsErrorCodeOnFailure(t *testing.T) {\n\trunner := &fakeRunOnce{err: errors.New(\"boom\")}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\n\tcode := RunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\"}, runner.Run, exit.Exit, out, out, nil, nil)\n\n\tif code != 1 {\n\t\tt.Fatalf(\"expected exit code 1, got %d\", code)\n\t}\n\tif exit.code != 1 {\n\t\tt.Fatalf(\"expected exit to be called with 1, got %d\", exit.code)\n\t}\n\tif !strings.Contains(out.String(), \"boom\") {\n\t\tt.Fatalf(\"expected error output, got %q\", out.String())\n\t}\n}\n\nfunc TestRunOnceMainWiresDependencies(t *testing.T) {\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tRunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\", \"--model\", \"model\", \"--dry-run\"}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif !runner.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n\tif runner.opts.RepoRoot != \"/repo\" || runner.opts.RootID != \"root\" || runner.opts.Model != \"model\" || !runner.opts.DryRun {\n\t\tt.Fatalf(\"unexpected options: %#v\", runner.opts)\n\t}\n\tif runner.opts.Out == nil {\n\t\tt.Fatalf(\"expected output writer\")\n\t}\n\tif runner.deps.Beads == nil || runner.deps.Git == nil || runner.deps.Prompt == nil || runner.deps.OpenCode == nil || runner.deps.Logger == nil {\n\t\tt.Fatalf(\"expected deps to be wired\")\n\t}\n\tif exit.code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", exit.code)\n\t}\n}\n\nfunc TestRunOnceMainDefaultsConfigPaths(t *testing.T) {\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tt.Setenv(\"HOME\", \"/home/user\")\n\n\tRunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\"}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif !runner.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n\tif runner.opts.ConfigRoot == \"\" {\n\t\tt.Fatalf(\"expected config root to be set\")\n\t}\n\tif runner.opts.ConfigDir == \"\" {\n\t\tt.Fatalf(\"expected config dir to be set\")\n\t}\n\texpectedConfigRoot := filepath.Join(\"/home/user\", \".config\", \"opencode-runner\")\n\tif runner.opts.ConfigRoot != expectedConfigRoot {\n\t\tt.Fatalf(\"expected config root %q, got %q\", expectedConfigRoot, runner.opts.ConfigRoot)\n\t}\n\texpectedConfigDir := filepath.Join(expectedConfigRoot, \"opencode\")\n\tif runner.opts.ConfigDir != expectedConfigDir {\n\t\tt.Fatalf(\"expected config dir %q, got %q\", expectedConfigDir, runner.opts.ConfigDir)\n\t}\n\tif exit.code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", exit.code)\n\t}\n}\n\nfunc TestRunOnceMainFailsWhenYoloAgentMissing(t *testing.T) {\n\ttempDir := t.TempDir()\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tstdout := &bytes.Buffer{}\n\tstderr := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\"}, runner.Run, exit.Exit, stdout, stderr, beadsRunner, gitRunner)\n\n\tif code != 1 {\n\t\tt.Fatalf(\"expected exit code 1, got %d\", code)\n\t}\n\tif exit.code != 1 {\n\t\tt.Fatalf(\"expected exit to be called with 1, got %d\", exit.code)\n\t}\n\tif runner.called {\n\t\tt.Fatalf(\"expected run once not to be called\")\n\t}\n\tif !strings.Contains(stderr.String(), \"yolo.md\") {\n\t\tt.Fatalf(\"expected error to mention yolo.md, got %q\", stderr.String())\n\t}\n}\n\nfunc TestRunOnceMainFailsWhenYoloAgentMissingPermission(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteAgentFile(t, tempDir, \"---\\nname: yolo\\n---\\n\")\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tstdout := &bytes.Buffer{}\n\tstderr := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\"}, runner.Run, exit.Exit, stdout, stderr, beadsRunner, gitRunner)\n\n\tif code != 1 {\n\t\tt.Fatalf(\"expected exit code 1, got %d\", code)\n\t}\n\tif exit.code != 1 {\n\t\tt.Fatalf(\"expected exit to be called with 1, got %d\", exit.code)\n\t}\n\tif runner.called {\n\t\tt.Fatalf(\"expected run once not to be called\")\n\t}\n\tif !strings.Contains(stderr.String(), \"permission: allow\") {\n\t\tt.Fatalf(\"expected error to mention permission allow, got %q\", stderr.String())\n\t}\n\tif !strings.Contains(strings.ToLower(stderr.String()), \"init\") {\n\t\tt.Fatalf(\"expected guidance to run init, got %q\", stderr.String())\n\t}\n}\n\nfunc TestRunOnceMainInfersRoadmapRootWhenMissing(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteIssuesFile(t, tempDir, `{\"id\":\"roadmap-1\",\"title\":\"Roadmap\",\"issue_type\":\"epic\",\"status\":\"open\"}`)\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", code)\n\t}\n\tif !runner.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n\tif runner.opts.RootID != \"roadmap-1\" {\n\t\tt.Fatalf(\"expected root id to be inferred, got %q\", runner.opts.RootID)\n\t}\n}\n\nfunc TestRunOnceMainInfersRoadmapRootWhenInProgress(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteIssuesFile(t, tempDir, `{\"id\":\"roadmap-2\",\"title\":\"Roadmap\",\"issue_type\":\"epic\",\"status\":\"in_progress\"}`)\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", code)\n\t}\n\tif !runner.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n\tif runner.opts.RootID != \"roadmap-2\" {\n\t\tt.Fatalf(\"expected root id to be inferred, got %q\", runner.opts.RootID)\n\t}\n}\n\nfunc TestRunOnceMainMissingRootRequiresExplicitFlag(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteIssuesFile(t, tempDir, `{\"id\":\"epic-1\",\"title\":\"Other\",\"issue_type\":\"epic\",\"status\":\"open\"}`)\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tstdout := &bytes.Buffer{}\n\tstderr := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir}, runner.Run, exit.Exit, stdout, stderr, beadsRunner, gitRunner)\n\n\tif code != 1 {\n\t\tt.Fatalf(\"expected exit code 1, got %d\", code)\n\t}\n\tif exit.code != 1 {\n\t\tt.Fatalf(\"expected exit to be called with 1, got %d\", exit.code)\n\t}\n\tif runner.called {\n\t\tt.Fatalf(\"expected run once not to be called\")\n\t}\n\tif !strings.Contains(stderr.String(), \"--root\") {\n\t\tt.Fatalf(\"expected error to mention --root, got %q\", stderr.String())\n\t}\n\tif !strings.Contains(strings.ToLower(stderr.String()), \"roadmap\") {\n\t\tt.Fatalf(\"expected error to mention roadmap, got %q\", stderr.String())\n\t}\n}\n\ntype fakeTUIProgram struct {\n\tstarted chan struct{}\n\tquit    chan struct{}\n\tevents  chan runner.Event\n}\n\nfunc newFakeTUIProgram() *fakeTUIProgram {\n\treturn &fakeTUIProgram{\n\t\tstarted: make(chan struct{}),\n\t\tquit:    make(chan struct{}),\n\t\tevents:  make(chan runner.Event, 1),\n\t}\n}\n\nfunc (f *fakeTUIProgram) Start() error {\n\tclose(f.started)\n\treturn nil\n}\n\nfunc (f *fakeTUIProgram) Send(event runner.Event) {\n\tf.events <- event\n}\n\nfunc (f *fakeTUIProgram) Quit() {\n\tclose(f.quit)\n}\n\nfunc waitForSignal(t *testing.T, signal chan struct{}, label string) {\n\tt.Helper()\n\tselect {\n\tcase <-signal:\n\t\treturn\n\tcase <-time.After(200 * time.Millisecond):\n\t\tt.Fatalf(\"expected %s\", label)\n\t}\n}\n\nfunc writeIssuesFile(t *testing.T, repoRoot string, payload string) {\n\tt.Helper()\n\tbeadsDir := filepath.Join(repoRoot, \".beads\")\n\tif err := os.MkdirAll(beadsDir, 0o755); err != nil {\n\t\tt.Fatalf(\"mkdir .beads: %v\", err)\n\t}\n\tissuesPath := filepath.Join(beadsDir, \"issues.jsonl\")\n\tif err := os.WriteFile(issuesPath, []byte(payload+\"\\n\"), 0o644); err != nil {\n\t\tt.Fatalf(\"write issues: %v\", err)\n\t}\n}\n\nfunc TestRunOnceMainUsesTUIOnTTYByDefault(t *testing.T) {\n\tfakeProgram := newFakeTUIProgram()\n\tprevIsTerminal := isTerminal\n\tprevNewTUIProgram := newTUIProgram\n\tisTerminal = func(io.Writer) bool { return true }\n\tnewTUIProgram = func(stdout io.Writer) tuiProgram { return fakeProgram }\n\tt.Cleanup(func() {\n\t\tisTerminal = prevIsTerminal\n\t\tnewTUIProgram = prevNewTUIProgram\n\t})\n\n\trunOnce := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\"}, runOnce.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", code)\n\t}\n\tif runOnce.deps.Events == nil {\n\t\tt.Fatalf(\"expected events emitter to be set\")\n\t}\n\trunOnce.deps.Events.Emit(runner.Event{Type: runner.EventSelectTask})\n\twaitForSignal(t, fakeProgram.started, \"tui start\")\n\twaitForSignal(t, fakeProgram.quit, \"tui quit\")\n\tselect {\n\tcase <-fakeProgram.events:\n\t\t// ok\n\tcase <-time.After(200 * time.Millisecond):\n\t\tt.Fatalf(\"expected event to be forwarded to TUI\")\n\t}\n}\n\nfunc TestRunOnceMainHeadlessDisablesTUI(t *testing.T) {\n\tcalled := false\n\tprevIsTerminal := isTerminal\n\tprevNewTUIProgram := newTUIProgram\n\tisTerminal = func(io.Writer) bool { return true }\n\tnewTUIProgram = func(stdout io.Writer) tuiProgram {\n\t\tcalled = true\n\t\treturn newFakeTUIProgram()\n\t}\n\tt.Cleanup(func() {\n\t\tisTerminal = prevIsTerminal\n\t\tnewTUIProgram = prevNewTUIProgram\n\t})\n\n\trunOnce := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\tstderr := &bytes.Buffer{}\n\n\tRunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\", \"--headless\"}, runOnce.Run, exit.Exit, out, stderr, beadsRunner, gitRunner)\n\n\tif called {\n\t\tt.Fatalf(\"expected TUI program not to start\")\n\t}\n\tif runOnce.deps.Events != nil {\n\t\tt.Fatalf(\"expected no events emitter in headless mode\")\n\t}\n}\n\nfunc TestOpenCodeRunDefaultsCreateConfigAndEnv(t *testing.T) {\n\ttempDir := t.TempDir()\n\trepoRoot := filepath.Join(tempDir, \"repo\")\n\tif err := os.MkdirAll(repoRoot, 0o755); err != nil {\n\t\tt.Fatalf(\"mkdir repo: %v\", err)\n\t}\n\tt.Setenv(\"HOME\", tempDir)\n\n\topenCodeRunner := &fakeOpenCodeRunner{}\n\topenCodeAdapter := openCodeAdapter{runner: openCodeRunner}\n\n\tconfigRoot := filepath.Join(tempDir, \".config\", \"opencode-runner\")\n\tconfigDir := filepath.Join(configRoot, \"opencode\")\n\tlogPath := filepath.Join(tempDir, \"runner-logs\", \"opencode\", \"issue-1.jsonl\")\n\n\tif err := openCodeAdapter.Run(\"issue-1\", repoRoot, \"prompt\", \"\", configRoot, configDir, logPath); err != nil {\n\t\tt.Fatalf(\"open code run error: %v\", err)\n\t}\n\n\tconfigFile := filepath.Join(configDir, \"opencode.json\")\n\tif _, err := os.Stat(configFile); err != nil {\n\t\tt.Fatalf(\"expected opencode.json to exist: %v\", err)\n\t}\n\texpectedConfigFile := filepath.Join(configDir, \"opencode.json\")\n\tif openCodeRunner.env[\"XDG_CONFIG_HOME\"] != configRoot {\n\t\tt.Fatalf(\"expected XDG_CONFIG_HOME set\")\n\t}\n\tif openCodeRunner.env[\"OPENCODE_CONFIG_DIR\"] != configDir {\n\t\tt.Fatalf(\"expected OPENCODE_CONFIG_DIR set\")\n\t}\n\tif openCodeRunner.env[\"OPENCODE_CONFIG\"] != expectedConfigFile {\n\t\tt.Fatalf(\"expected OPENCODE_CONFIG set\")\n\t}\n\tif openCodeRunner.env[\"OPENCODE_CONFIG_CONTENT\"] != \"{}\" {\n\t\tt.Fatalf(\"expected OPENCODE_CONFIG_CONTENT set\")\n\t}\n}\n","after":"package main\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"yolo-runner/internal/opencode\"\n\t\"yolo-runner/internal/runner\"\n)\n\ntype fakeRunner struct {\n\tcalls []string\n}\n\nfunc (f *fakeRunner) Run(args ...string) (string, error) {\n\tf.calls = append(f.calls, strings.Join(args, \" \"))\n\treturn \"\", nil\n}\n\ntype fakeOpenCodeRunLogger struct {\n\tcalled     bool\n\tissueID    string\n\trepoRoot   string\n\tprompt     string\n\tmodel      string\n\tconfigRoot string\n\tconfigDir  string\n\tlogPath    string\n}\n\nfunc (f *fakeOpenCodeRunLogger) Run(issueID string, repoRoot string, prompt string, model string, configRoot string, configDir string, logPath string) error {\n\tf.called = true\n\tf.issueID = issueID\n\tf.repoRoot = repoRoot\n\tf.prompt = prompt\n\tf.model = model\n\tf.configRoot = configRoot\n\tf.configDir = configDir\n\tf.logPath = logPath\n\treturn nil\n}\n\ntype fakeOpenCodeRunner struct {\n\tenv map[string]string\n}\n\ntype fakeOpenCodeProcess struct{}\n\nfunc (fakeOpenCodeProcess) Wait() error { return nil }\n\nfunc (fakeOpenCodeProcess) Kill() error { return nil }\n\nfunc (f *fakeOpenCodeRunner) Start(args []string, env map[string]string, stdoutPath string) (opencode.Process, error) {\n\tf.env = env\n\treturn fakeOpenCodeProcess{}, nil\n}\n\ntype fakeGitRunner struct {\n\tcalls  []string\n\toutput string\n\terr    error\n}\n\nfunc (f *fakeGitRunner) Run(name string, args ...string) (string, error) {\n\tf.calls = append(f.calls, name+\" \"+strings.Join(args, \" \"))\n\treturn f.output, f.err\n}\n\ntype fakeExit struct {\n\tcode int\n}\n\nfunc (f *fakeExit) Exit(code int) {\n\tf.code = code\n}\n\ntype fakeRunOnce struct {\n\tcalled bool\n\topts   runner.RunOnceOptions\n\tdeps   runner.RunOnceDeps\n\tresult string\n\terr    error\n}\n\nfunc (f *fakeRunOnce) Run(opts runner.RunOnceOptions, deps runner.RunOnceDeps) (string, error) {\n\n\tf.called = true\n\tf.opts = opts\n\tf.deps = deps\n\treturn f.result, f.err\n}\n\nfunc TestRunOnceMainReturnsErrorCodeOnFailure(t *testing.T) {\n\trunner := &fakeRunOnce{err: errors.New(\"boom\")}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\n\tcode := RunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\"}, runner.Run, exit.Exit, out, out, nil, nil)\n\n\tif code != 1 {\n\t\tt.Fatalf(\"expected exit code 1, got %d\", code)\n\t}\n\tif exit.code != 1 {\n\t\tt.Fatalf(\"expected exit to be called with 1, got %d\", exit.code)\n\t}\n\tif !strings.Contains(out.String(), \"boom\") {\n\t\tt.Fatalf(\"expected error output, got %q\", out.String())\n\t}\n}\n\nfunc TestRunOnceMainWiresDependencies(t *testing.T) {\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tRunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\", \"--model\", \"model\", \"--dry-run\"}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif !runner.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n\tif runner.opts.RepoRoot != \"/repo\" || runner.opts.RootID != \"root\" || runner.opts.Model != \"model\" || !runner.opts.DryRun {\n\t\tt.Fatalf(\"unexpected options: %#v\", runner.opts)\n\t}\n\tif runner.opts.Out == nil {\n\t\tt.Fatalf(\"expected output writer\")\n\t}\n\tif runner.deps.Beads == nil || runner.deps.Git == nil || runner.deps.Prompt == nil || runner.deps.OpenCode == nil || runner.deps.Logger == nil {\n\t\tt.Fatalf(\"expected deps to be wired\")\n\t}\n\tif exit.code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", exit.code)\n\t}\n}\n\nfunc TestRunOnceMainDefaultsConfigPaths(t *testing.T) {\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tt.Setenv(\"HOME\", \"/home/user\")\n\n\tRunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\"}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif !runner.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n\tif runner.opts.ConfigRoot == \"\" {\n\t\tt.Fatalf(\"expected config root to be set\")\n\t}\n\tif runner.opts.ConfigDir == \"\" {\n\t\tt.Fatalf(\"expected config dir to be set\")\n\t}\n\texpectedConfigRoot := filepath.Join(\"/home/user\", \".config\", \"opencode-runner\")\n\tif runner.opts.ConfigRoot != expectedConfigRoot {\n\t\tt.Fatalf(\"expected config root %q, got %q\", expectedConfigRoot, runner.opts.ConfigRoot)\n\t}\n\texpectedConfigDir := filepath.Join(expectedConfigRoot, \"opencode\")\n\tif runner.opts.ConfigDir != expectedConfigDir {\n\t\tt.Fatalf(\"expected config dir %q, got %q\", expectedConfigDir, runner.opts.ConfigDir)\n\t}\n\tif exit.code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", exit.code)\n\t}\n}\n\nfunc TestRunOnceMainFailsWhenYoloAgentMissing(t *testing.T) {\n\ttempDir := t.TempDir()\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tstdout := &bytes.Buffer{}\n\tstderr := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\"}, runner.Run, exit.Exit, stdout, stderr, beadsRunner, gitRunner)\n\n\tif code != 1 {\n\t\tt.Fatalf(\"expected exit code 1, got %d\", code)\n\t}\n\tif exit.code != 1 {\n\t\tt.Fatalf(\"expected exit to be called with 1, got %d\", exit.code)\n\t}\n\tif runner.called {\n\t\tt.Fatalf(\"expected run once not to be called\")\n\t}\n\tif !strings.Contains(stderr.String(), \"yolo.md\") {\n\t\tt.Fatalf(\"expected error to mention yolo.md, got %q\", stderr.String())\n\t}\n}\n\nfunc TestRunOnceMainFailsWhenYoloAgentMissingPermission(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteAgentFile(t, tempDir, \"---\\nname: yolo\\n---\\n\")\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tstdout := &bytes.Buffer{}\n\tstderr := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\"}, runner.Run, exit.Exit, stdout, stderr, beadsRunner, gitRunner)\n\n\tif code != 1 {\n\t\tt.Fatalf(\"expected exit code 1, got %d\", code)\n\t}\n\tif exit.code != 1 {\n\t\tt.Fatalf(\"expected exit to be called with 1, got %d\", exit.code)\n\t}\n\tif runner.called {\n\t\tt.Fatalf(\"expected run once not to be called\")\n\t}\n\tif !strings.Contains(stderr.String(), \"permission: allow\") {\n\t\tt.Fatalf(\"expected error to mention permission allow, got %q\", stderr.String())\n\t}\n\tif !strings.Contains(strings.ToLower(stderr.String()), \"init\") {\n\t\tt.Fatalf(\"expected guidance to run init, got %q\", stderr.String())\n\t}\n}\n\nfunc TestRunOnceMainInfersRoadmapRootWhenMissing(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteIssuesFile(t, tempDir, `{\"id\":\"roadmap-1\",\"title\":\"Roadmap\",\"issue_type\":\"epic\",\"status\":\"open\"}`)\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", code)\n\t}\n\tif !runner.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n\tif runner.opts.RootID != \"roadmap-1\" {\n\t\tt.Fatalf(\"expected root id to be inferred, got %q\", runner.opts.RootID)\n\t}\n}\n\nfunc TestRunOnceMainInfersRoadmapRootWhenInProgress(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteIssuesFile(t, tempDir, `{\"id\":\"roadmap-2\",\"title\":\"Roadmap\",\"issue_type\":\"epic\",\"status\":\"in_progress\"}`)\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", code)\n\t}\n\tif !runner.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n\tif runner.opts.RootID != \"roadmap-2\" {\n\t\tt.Fatalf(\"expected root id to be inferred, got %q\", runner.opts.RootID)\n\t}\n}\n\nfunc TestRunOnceMainMissingRootRequiresExplicitFlag(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteIssuesFile(t, tempDir, `{\"id\":\"epic-1\",\"title\":\"Other\",\"issue_type\":\"epic\",\"status\":\"open\"}`)\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tstdout := &bytes.Buffer{}\n\tstderr := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir}, runner.Run, exit.Exit, stdout, stderr, beadsRunner, gitRunner)\n\n\tif code != 1 {\n\t\tt.Fatalf(\"expected exit code 1, got %d\", code)\n\t}\n\tif exit.code != 1 {\n\t\tt.Fatalf(\"expected exit to be called with 1, got %d\", exit.code)\n\t}\n\tif runner.called {\n\t\tt.Fatalf(\"expected run once not to be called\")\n\t}\n\tif !strings.Contains(stderr.String(), \"--root\") {\n\t\tt.Fatalf(\"expected error to mention --root, got %q\", stderr.String())\n\t}\n\tif !strings.Contains(strings.ToLower(stderr.String()), \"roadmap\") {\n\t\tt.Fatalf(\"expected error to mention roadmap, got %q\", stderr.String())\n\t}\n}\n\ntype fakeTUIProgram struct {\n\tstarted chan struct{}\n\tquit    chan struct{}\n\tevents  chan runner.Event\n}\n\nfunc newFakeTUIProgram() *fakeTUIProgram {\n\treturn &fakeTUIProgram{\n\t\tstarted: make(chan struct{}),\n\t\tquit:    make(chan struct{}),\n\t\tevents:  make(chan runner.Event, 1),\n\t}\n}\n\nfunc (f *fakeTUIProgram) Start() error {\n\tclose(f.started)\n\treturn nil\n}\n\nfunc (f *fakeTUIProgram) Send(event runner.Event) {\n\tf.events <- event\n}\n\nfunc (f *fakeTUIProgram) Quit() {\n\tclose(f.quit)\n}\n\nfunc waitForSignal(t *testing.T, signal chan struct{}, label string) {\n\tt.Helper()\n\tselect {\n\tcase <-signal:\n\t\treturn\n\tcase <-time.After(200 * time.Millisecond):\n\t\tt.Fatalf(\"expected %s\", label)\n\t}\n}\n\nfunc writeIssuesFile(t *testing.T, repoRoot string, payload string) {\n\tt.Helper()\n\tbeadsDir := filepath.Join(repoRoot, \".beads\")\n\tif err := os.MkdirAll(beadsDir, 0o755); err != nil {\n\t\tt.Fatalf(\"mkdir .beads: %v\", err)\n\t}\n\tissuesPath := filepath.Join(beadsDir, \"issues.jsonl\")\n\tif err := os.WriteFile(issuesPath, []byte(payload+\"\\n\"), 0o644); err != nil {\n\t\tt.Fatalf(\"write issues: %v\", err)\n\t}\n}\n\nfunc writeAgentFile(t *testing.T, repoRoot string, payload string) {\n\tt.Helper()\n\tagentDir := filepath.Join(repoRoot, \".opencode\", \"agent\")\n\tif err := os.MkdirAll(agentDir, 0o755); err != nil {\n\t\tt.Fatalf(\"mkdir agent dir: %v\", err)\n\t}\n\tagentPath := filepath.Join(agentDir, \"yolo.md\")\n\tif err := os.WriteFile(agentPath, []byte(payload), 0o644); err != nil {\n\t\tt.Fatalf(\"write agent file: %v\", err)\n\t}\n}\n\nfunc TestRunOnceMainUsesTUIOnTTYByDefault(t *testing.T) {\n\tfakeProgram := newFakeTUIProgram()\n\tprevIsTerminal := isTerminal\n\tprevNewTUIProgram := newTUIProgram\n\tisTerminal = func(io.Writer) bool { return true }\n\tnewTUIProgram = func(stdout io.Writer) tuiProgram { return fakeProgram }\n\tt.Cleanup(func() {\n\t\tisTerminal = prevIsTerminal\n\t\tnewTUIProgram = prevNewTUIProgram\n\t})\n\n\trunOnce := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\"}, runOnce.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", code)\n\t}\n\tif runOnce.deps.Events == nil {\n\t\tt.Fatalf(\"expected events emitter to be set\")\n\t}\n\trunOnce.deps.Events.Emit(runner.Event{Type: runner.EventSelectTask})\n\twaitForSignal(t, fakeProgram.started, \"tui start\")\n\twaitForSignal(t, fakeProgram.quit, \"tui quit\")\n\tselect {\n\tcase <-fakeProgram.events:\n\t\t// ok\n\tcase <-time.After(200 * time.Millisecond):\n\t\tt.Fatalf(\"expected event to be forwarded to TUI\")\n\t}\n}\n\nfunc TestRunOnceMainHeadlessDisablesTUI(t *testing.T) {\n\tcalled := false\n\tprevIsTerminal := isTerminal\n\tprevNewTUIProgram := newTUIProgram\n\tisTerminal = func(io.Writer) bool { return true }\n\tnewTUIProgram = func(stdout io.Writer) tuiProgram {\n\t\tcalled = true\n\t\treturn newFakeTUIProgram()\n\t}\n\tt.Cleanup(func() {\n\t\tisTerminal = prevIsTerminal\n\t\tnewTUIProgram = prevNewTUIProgram\n\t})\n\n\trunOnce := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\tstderr := &bytes.Buffer{}\n\n\tRunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\", \"--headless\"}, runOnce.Run, exit.Exit, out, stderr, beadsRunner, gitRunner)\n\n\tif called {\n\t\tt.Fatalf(\"expected TUI program not to start\")\n\t}\n\tif runOnce.deps.Events != nil {\n\t\tt.Fatalf(\"expected no events emitter in headless mode\")\n\t}\n}\n\nfunc TestOpenCodeRunDefaultsCreateConfigAndEnv(t *testing.T) {\n\ttempDir := t.TempDir()\n\trepoRoot := filepath.Join(tempDir, \"repo\")\n\tif err := os.MkdirAll(repoRoot, 0o755); err != nil {\n\t\tt.Fatalf(\"mkdir repo: %v\", err)\n\t}\n\tt.Setenv(\"HOME\", tempDir)\n\n\topenCodeRunner := &fakeOpenCodeRunner{}\n\topenCodeAdapter := openCodeAdapter{runner: openCodeRunner}\n\n\tconfigRoot := filepath.Join(tempDir, \".config\", \"opencode-runner\")\n\tconfigDir := filepath.Join(configRoot, \"opencode\")\n\tlogPath := filepath.Join(tempDir, \"runner-logs\", \"opencode\", \"issue-1.jsonl\")\n\n\tif err := openCodeAdapter.Run(\"issue-1\", repoRoot, \"prompt\", \"\", configRoot, configDir, logPath); err != nil {\n\t\tt.Fatalf(\"open code run error: %v\", err)\n\t}\n\n\tconfigFile := filepath.Join(configDir, \"opencode.json\")\n\tif _, err := os.Stat(configFile); err != nil {\n\t\tt.Fatalf(\"expected opencode.json to exist: %v\", err)\n\t}\n\texpectedConfigFile := filepath.Join(configDir, \"opencode.json\")\n\tif openCodeRunner.env[\"XDG_CONFIG_HOME\"] != configRoot {\n\t\tt.Fatalf(\"expected XDG_CONFIG_HOME set\")\n\t}\n\tif openCodeRunner.env[\"OPENCODE_CONFIG_DIR\"] != configDir {\n\t\tt.Fatalf(\"expected OPENCODE_CONFIG_DIR set\")\n\t}\n\tif openCodeRunner.env[\"OPENCODE_CONFIG\"] != expectedConfigFile {\n\t\tt.Fatalf(\"expected OPENCODE_CONFIG set\")\n\t}\n\tif openCodeRunner.env[\"OPENCODE_CONFIG_CONTENT\"] != \"{}\" {\n\t\tt.Fatalf(\"expected OPENCODE_CONFIG_CONTENT set\")\n\t}\n}\n","additions":12,"deletions":0},"truncated":false},"time":{"start":1768850696534,"end":1768850696696}},"metadata":{"openai":{"itemId":"fc_0327b59ec7b549c801696e8500cf588191862b90a08817e476"}}}}
{"type":"step_finish","timestamp":1768850696711,"sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","part":{"id":"prt_bd7b7a9f8001t4NI6wsan0xnOx","sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","messageID":"msg_bd7b7883d001k3aKei1MAZdtaA","type":"step-finish","reason":"tool-calls","snapshot":"0d850c1c998d65046a988af1b37f383745e062b9","cost":0,"tokens":{"input":2453,"output":482,"reasoning":0,"cache":{"read":21120,"write":0}}}}
{"type":"step_start","timestamp":1768850697050,"sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","part":{"id":"prt_bd7b7ab5a001j6lMHnLQa9KFaM","sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","messageID":"msg_bd7b7aa17001iCJ53uqODk4bMq","type":"step-start","snapshot":"724ce5b9413f12c8b30f63cbd0bb30e6a2f76287"}}
{"type":"tool_use","timestamp":1768850699841,"sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","part":{"id":"prt_bd7b7ae01001b3fUNuwfYvryhr","sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","messageID":"msg_bd7b7aa17001iCJ53uqODk4bMq","type":"tool","callID":"call_jxsiSWp5EHm3FSyuhHhf1XNP","tool":"bash","state":{"status":"completed","input":{"command":"go test ./...","description":"Runs full Go test suite"},"output":"ok  \tyolo-runner\t1.223s\n--- FAIL: TestRunOnceMainFailsWhenYoloAgentMissing (0.00s)\n    main_test.go:188: expected exit code 1, got 0\n--- FAIL: TestRunOnceMainFailsWhenYoloAgentMissingPermission (0.00s)\n    main_test.go:214: expected exit code 1, got 0\nFAIL\nFAIL\tyolo-runner/cmd/yolo-runner\t0.592s\nok  \tyolo-runner/internal/beads\t(cached)\nok  \tyolo-runner/internal/logging\t0.924s\nok  \tyolo-runner/internal/opencode\t(cached)\nok  \tyolo-runner/internal/prompt\t(cached)\nok  \tyolo-runner/internal/runner\t(cached)\nok  \tyolo-runner/internal/ui/tui\t(cached)\nok  \tyolo-runner/internal/vcs/git\t(cached)\nFAIL\n","title":"Runs full Go test suite","metadata":{"output":"ok  \tyolo-runner\t1.223s\n--- FAIL: TestRunOnceMainFailsWhenYoloAgentMissing (0.00s)\n    main_test.go:188: expected exit code 1, got 0\n--- FAIL: TestRunOnceMainFailsWhenYoloAgentMissingPermission (0.00s)\n    main_test.go:214: expected exit code 1, got 0\nFAIL\nFAIL\tyolo-runner/cmd/yolo-runner\t0.592s\nok  \tyolo-runner/internal/beads\t(cached)\nok  \tyolo-runner/internal/logging\t0.924s\nok  \tyolo-runner/internal/opencode\t(cached)\nok  \tyolo-runner/internal/prompt\t(cached)\nok  \tyolo-runner/internal/runner\t(cached)\nok  \tyolo-runner/internal/ui/tui\t(cached)\nok  \tyolo-runner/internal/vcs/git\t(cached)\nFAIL\n","exit":1,"description":"Runs full Go test suite","truncated":false},"time":{"start":1768850698257,"end":1768850699840}},"metadata":{"openai":{"itemId":"fc_0a8d9ed400af117901696e8509a33481918c7df7ec056a73ac"}}}}
{"type":"step_finish","timestamp":1768850699856,"sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","part":{"id":"prt_bd7b7b641001jevPvpFhIhEiJN","sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","messageID":"msg_bd7b7aa17001iCJ53uqODk4bMq","type":"step-finish","reason":"tool-calls","snapshot":"614e4e8ca7e543ed26a1df8729d87c36bf58fe46","cost":0,"tokens":{"input":898,"output":29,"reasoning":0,"cache":{"read":23168,"write":0}}}}
{"type":"step_start","timestamp":1768850700107,"sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","part":{"id":"prt_bd7b7b74a001wWiaf7vrheQCgh","sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","messageID":"msg_bd7b7b662001zvK5KYmhf3UHZ6","type":"step-start","snapshot":"33919efd015d4331572438b2375df82f68cb46d0"}}
{"type":"tool_use","timestamp":1768850720034,"sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","part":{"id":"prt_bd7b7e39500101gGdBAH6DFpxq","sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","messageID":"msg_bd7b7b662001zvK5KYmhf3UHZ6","type":"tool","callID":"call_WSMWgYcumxjIpesae98saw0D","tool":"write","state":{"status":"completed","input":{"filePath":"/Users/egv/dev/yolo-runner/internal/opencode/agent_test.go","content":"package opencode\n\nimport (\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"testing\"\n)\n\nfunc TestValidateAgentMissingFile(t *testing.T) {\n\trepoRoot := t.TempDir()\n\n\terr := ValidateAgent(repoRoot)\n\n\tif err == nil {\n\t\tt.Fatalf(\"expected error\")\n\t}\n\tif !strings.Contains(err.Error(), \"yolo.md\") {\n\t\tt.Fatalf(\"expected error to mention yolo.md, got %q\", err.Error())\n\t}\n}\n\nfunc TestValidateAgentMissingPermission(t *testing.T) {\n\trepoRoot := t.TempDir()\n\tagentDir := filepath.Join(repoRoot, \".opencode\", \"agent\")\n\tif err := os.MkdirAll(agentDir, 0o755); err != nil {\n\t\tt.Fatalf(\"mkdir agent dir: %v\", err)\n\t}\n\tagentPath := filepath.Join(agentDir, \"yolo.md\")\n\tif err := os.WriteFile(agentPath, []byte(\"---\\nname: yolo\\n---\\n\"), 0o644); err != nil {\n\t\tt.Fatalf(\"write agent file: %v\", err)\n\t}\n\n\terr := ValidateAgent(repoRoot)\n\n\tif err == nil {\n\t\tt.Fatalf(\"expected error\")\n\t}\n\tif !strings.Contains(err.Error(), \"permission: allow\") {\n\t\tt.Fatalf(\"expected error to mention permission allow, got %q\", err.Error())\n\t}\n\tif !strings.Contains(strings.ToLower(err.Error()), \"init\") {\n\t\tt.Fatalf(\"expected guidance to run init, got %q\", err.Error())\n\t}\n}\n\nfunc TestValidateAgentAllowsPermissionAllow(t *testing.T) {\n\trepoRoot := t.TempDir()\n\tagentDir := filepath.Join(repoRoot, \".opencode\", \"agent\")\n\tif err := os.MkdirAll(agentDir, 0o755); err != nil {\n\t\tt.Fatalf(\"mkdir agent dir: %v\", err)\n\t}\n\tagentPath := filepath.Join(agentDir, \"yolo.md\")\n\tcontent := \"---\\nname: yolo\\npermission: allow\\n---\\n\"\n\tif err := os.WriteFile(agentPath, []byte(content), 0o644); err != nil {\n\t\tt.Fatalf(\"write agent file: %v\", err)\n\t}\n\n\terr := ValidateAgent(repoRoot)\n\n\tif err != nil {\n\t\tt.Fatalf(\"expected no error, got %v\", err)\n\t}\n}\n"},"output":"Wrote file successfully.\n\nLSP errors detected in this file, please fix:\n<diagnostics file=\"/Users/egv/dev/yolo-runner/internal/opencode/agent_test.go\">\nERROR [13:9] undefined: ValidateAgent\nERROR [34:9] undefined: ValidateAgent\nERROR [59:9] undefined: ValidateAgent\n</diagnostics>","title":"internal/opencode/agent_test.go","metadata":{"diagnostics":{"/Users/egv/dev/yolo-runner/internal/opencode/client.go":[],"/Users/egv/dev/yolo-runner/internal/opencode/watchdog.go":[],"/Users/egv/dev/yolo-runner/go.mod":[{"range":{"start":{"line":6,"character":44},"end":{"line":6,"character":55}},"severity":2,"source":"go mod tidy","message":"github.com/charmbracelet/bubbletea should be direct"},{"range":{"start":{"line":19,"character":26},"end":{"line":19,"character":37}},"severity":2,"source":"go mod tidy","message":"golang.org/x/term should be direct"}],"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main.go":[{"range":{"start":{"line":66,"character":8},"end":{"line":66,"character":23}},"severity":4,"code":"default","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/gopls/internal/analysis/deprecated"},"source":"deprecated","message":"b.program.Start is deprecated: please use [Program.Run] instead.","tags":[2]}],"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go":[],"/Users/egv/dev/yolo-runner/cmd/yolo-runner/exec_test.go":[],"/Users/egv/dev/yolo-runner/internal/opencode/agent_test.go":[{"range":{"start":{"line":12,"character":8},"end":{"line":12,"character":21}},"severity":1,"code":"UndeclaredName","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UndeclaredName"},"source":"compiler","message":"undefined: ValidateAgent"},{"range":{"start":{"line":33,"character":8},"end":{"line":33,"character":21}},"severity":1,"code":"UndeclaredName","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UndeclaredName"},"source":"compiler","message":"undefined: ValidateAgent"},{"range":{"start":{"line":58,"character":8},"end":{"line":58,"character":21}},"severity":1,"code":"UndeclaredName","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UndeclaredName"},"source":"compiler","message":"undefined: ValidateAgent"}]},"filepath":"/Users/egv/dev/yolo-runner/internal/opencode/agent_test.go","exists":false,"truncated":false},"time":{"start":1768850719751,"end":1768850720033}},"metadata":{"openai":{"itemId":"fc_0d92e1ffa82d5dc401696e85176f108191b08f719b3b96c6a6"}}}}
{"type":"step_finish","timestamp":1768850720053,"sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","part":{"id":"prt_bd7b80522001QJIUta6T73c42f","sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","messageID":"msg_bd7b7b662001zvK5KYmhf3UHZ6","type":"step-finish","reason":"tool-calls","snapshot":"da213ab7811a3b7beba04337850e7f214f8b52cd","cost":0,"tokens":{"input":368,"output":1151,"reasoning":512,"cache":{"read":23936,"write":0}}}}
{"type":"step_start","timestamp":1768850720567,"sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","part":{"id":"prt_bd7b80736001BYbSBMY8RwkoTs","sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","messageID":"msg_bd7b80545001iKhlNILMTgjXKs","type":"step-start","snapshot":"441c33a4b2e8024848efc2f4f7e9a4135b945819"}}
{"type":"tool_use","timestamp":1768850722630,"sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","part":{"id":"prt_bd7b80c4f001DYSHNZNOHLbQCn","sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","messageID":"msg_bd7b80545001iKhlNILMTgjXKs","type":"tool","callID":"call_YxL7p33a2ZjZ1ZqMDKzeOom9","tool":"bash","state":{"status":"completed","input":{"command":"go test ./...","description":"Runs full Go test suite"},"output":"# yolo-runner/internal/opencode [yolo-runner/internal/opencode.test]\ninternal/opencode/agent_test.go:13:9: undefined: ValidateAgent\ninternal/opencode/agent_test.go:34:9: undefined: ValidateAgent\ninternal/opencode/agent_test.go:59:9: undefined: ValidateAgent\nok  \tyolo-runner\t(cached)\n--- FAIL: TestRunOnceMainFailsWhenYoloAgentMissing (0.00s)\n    main_test.go:188: expected exit code 1, got 0\n--- FAIL: TestRunOnceMainFailsWhenYoloAgentMissingPermission (0.00s)\n    main_test.go:214: expected exit code 1, got 0\nFAIL\nFAIL\tyolo-runner/cmd/yolo-runner\t0.231s\nok  \tyolo-runner/internal/beads\t(cached)\nok  \tyolo-runner/internal/logging\t(cached)\nFAIL\tyolo-runner/internal/opencode [build failed]\nok  \tyolo-runner/internal/prompt\t(cached)\nok  \tyolo-runner/internal/runner\t(cached)\nok  \tyolo-runner/internal/ui/tui\t(cached)\nok  \tyolo-runner/internal/vcs/git\t(cached)\nFAIL\n","title":"Runs full Go test suite","metadata":{"output":"# yolo-runner/internal/opencode [yolo-runner/internal/opencode.test]\ninternal/opencode/agent_test.go:13:9: undefined: ValidateAgent\ninternal/opencode/agent_test.go:34:9: undefined: ValidateAgent\ninternal/opencode/agent_test.go:59:9: undefined: ValidateAgent\nok  \tyolo-runner\t(cached)\n--- FAIL: TestRunOnceMainFailsWhenYoloAgentMissing (0.00s)\n    main_test.go:188: expected exit code 1, got 0\n--- FAIL: TestRunOnceMainFailsWhenYoloAgentMissingPermission (0.00s)\n    main_test.go:214: expected exit code 1, got 0\nFAIL\nFAIL\tyolo-runner/cmd/yolo-runner\t0.231s\nok  \tyolo-runner/internal/beads\t(cached)\nok  \tyolo-runner/internal/logging\t(cached)\nFAIL\tyolo-runner/internal/opencode [build failed]\nok  \tyolo-runner/internal/prompt\t(cached)\nok  \tyolo-runner/internal/runner\t(cached)\nok  \tyolo-runner/internal/ui/tui\t(cached)\nok  \tyolo-runner/internal/vcs/git\t(cached)\nFAIL\n","exit":1,"description":"Runs full Go test suite","truncated":false},"time":{"start":1768850722229,"end":1768850722629}},"metadata":{"openai":{"itemId":"fc_0ebe13b9018db7ee01696e8521c03c8191a1fe037df5365aeb"}}}}
{"type":"step_finish","timestamp":1768850722645,"sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","part":{"id":"prt_bd7b80f46001G3Txiq29A8W6R5","sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","messageID":"msg_bd7b80545001iKhlNILMTgjXKs","type":"step-finish","reason":"tool-calls","snapshot":"9418f959251ea6ffb8c5d6b7ad95ea178f8ab426","cost":0,"tokens":{"input":831,"output":29,"reasoning":0,"cache":{"read":24192,"write":0}}}}
{"type":"step_start","timestamp":1768850722950,"sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","part":{"id":"prt_bd7b81085001gbTIGV4fhtNN6T","sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","messageID":"msg_bd7b80f69001VW0sYrg3Ta733b","type":"step-start","snapshot":"9880008ec092f81e7b07cae01b7c54deca7a4b00"}}
{"type":"tool_use","timestamp":1768850731038,"sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","part":{"id":"prt_bd7b8131c001wmXx08rqAyKaVx","sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","messageID":"msg_bd7b80f69001VW0sYrg3Ta733b","type":"tool","callID":"call_kOEbLA1rlIlCLx49Mq48fjZd","tool":"write","state":{"status":"completed","input":{"filePath":"/Users/egv/dev/yolo-runner/internal/opencode/agent.go","content":"package opencode\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n)\n\nconst (\n\tagentRelativePath = \".opencode/agent/yolo.md\"\n)\n\nvar (\n\tErrAgentMissing         = errors.New(\"yolo agent missing\")\n\tErrAgentPermissionUnset = errors.New(\"yolo agent missing permission allow\")\n)\n\nfunc ValidateAgent(repoRoot string) error {\n\tagentPath := filepath.Join(repoRoot, agentRelativePath)\n\tcontent, err := os.ReadFile(agentPath)\n\tif err != nil {\n\t\tif os.IsNotExist(err) {\n\t\t\treturn fmt.Errorf(\"missing yolo agent file at %s\", agentRelativePath)\n\t\t}\n\t\treturn err\n\t}\n\tif !hasPermissionAllow(content) {\n\t\treturn fmt.Errorf(\"yolo agent missing permission: allow; run opencode init\")\n\t}\n\treturn nil\n}\n\nfunc hasPermissionAllow(content []byte) bool {\n\tlines := strings.Split(string(content), \"\\n\")\n\tfor _, line := range lines {\n\t\tif strings.TrimSpace(line) == \"permission: allow\" {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n"},"output":"Wrote file successfully.\n\nLSP errors detected in other files:\n<diagnostics file=\"/Users/egv/dev/yolo-runner/internal/opencode/agent_test.go\">\nERROR [13:9] undefined: ValidateAgent\nERROR [34:9] undefined: ValidateAgent\nERROR [59:9] undefined: ValidateAgent\n</diagnostics>","title":"internal/opencode/agent.go","metadata":{"diagnostics":{"/Users/egv/dev/yolo-runner/internal/opencode/client.go":[],"/Users/egv/dev/yolo-runner/internal/opencode/watchdog.go":[],"/Users/egv/dev/yolo-runner/go.mod":[{"range":{"start":{"line":6,"character":44},"end":{"line":6,"character":55}},"severity":2,"source":"go mod tidy","message":"github.com/charmbracelet/bubbletea should be direct"},{"range":{"start":{"line":19,"character":26},"end":{"line":19,"character":37}},"severity":2,"source":"go mod tidy","message":"golang.org/x/term should be direct"}],"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main.go":[{"range":{"start":{"line":66,"character":8},"end":{"line":66,"character":23}},"severity":4,"code":"default","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/gopls/internal/analysis/deprecated"},"source":"deprecated","message":"b.program.Start is deprecated: please use [Program.Run] instead.","tags":[2]}],"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go":[],"/Users/egv/dev/yolo-runner/cmd/yolo-runner/exec_test.go":[],"/Users/egv/dev/yolo-runner/internal/opencode/agent_test.go":[{"range":{"start":{"line":12,"character":8},"end":{"line":12,"character":21}},"severity":1,"code":"UndeclaredName","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UndeclaredName"},"source":"compiler","message":"undefined: ValidateAgent"},{"range":{"start":{"line":33,"character":8},"end":{"line":33,"character":21}},"severity":1,"code":"UndeclaredName","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UndeclaredName"},"source":"compiler","message":"undefined: ValidateAgent"},{"range":{"start":{"line":58,"character":8},"end":{"line":58,"character":21}},"severity":1,"code":"UndeclaredName","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/internal/typesinternal#UndeclaredName"},"source":"compiler","message":"undefined: ValidateAgent"}],"/Users/egv/dev/yolo-runner/internal/opencode/agent.go":[]},"filepath":"/Users/egv/dev/yolo-runner/internal/opencode/agent.go","exists":false,"truncated":false},"time":{"start":1768850730760,"end":1768850731038}},"metadata":{"openai":{"itemId":"fc_081887c2e54a334d01696e85237f088191b82863f0b5002c6b"}}}}
{"type":"step_finish","timestamp":1768850731054,"sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","part":{"id":"prt_bd7b8301e001Yo5p0kPpzFzhxn","sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","messageID":"msg_bd7b80f69001VW0sYrg3Ta733b","type":"step-finish","reason":"tool-calls","snapshot":"d781884e0969e42e37d1f97c1483118952871d95","cost":0,"tokens":{"input":365,"output":334,"reasoning":0,"cache":{"read":24960,"write":0}}}}
{"type":"step_start","timestamp":1768850731341,"sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","part":{"id":"prt_bd7b8314d001HTMFlYpNGBYJ4i","sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","messageID":"msg_bd7b83042001wFylPXyzJWLYe7","type":"step-start","snapshot":"258c34fd523fe28253b7b8e19e53c1092b2b7368"}}
{"type":"tool_use","timestamp":1768850753012,"sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","part":{"id":"prt_bd7b879da001j0AwnkV3KhXyK2","sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","messageID":"msg_bd7b83042001wFylPXyzJWLYe7","type":"tool","callID":"call_U8Grnh6GGSPn4JOQLKqRDdKD","tool":"edit","state":{"status":"completed","input":{"filePath":"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go","oldString":"\trunner := &fakeRunOnce{err: errors.New(\"boom\")}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\n\tcode := RunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\"}, runner.Run, exit.Exit, out, out, nil, nil)\n","newString":"\ttempDir := t.TempDir()\n\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n\trunner := &fakeRunOnce{err: errors.New(\"boom\")}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\"}, runner.Run, exit.Exit, out, out, nil, nil)\n"},"output":"Edit applied successfully.","title":"cmd/yolo-runner/main_test.go","metadata":{"diagnostics":{"/Users/egv/dev/yolo-runner/internal/opencode/client.go":[{"range":{"start":{"line":28,"character":1},"end":{"line":28,"character":18}},"severity":2,"code":"default","codeDescription":{"href":"https://staticcheck.dev/docs/checks/#S1031"},"source":"S1031","message":"unnecessary nil check around range"}],"/Users/egv/dev/yolo-runner/internal/opencode/watchdog.go":[],"/Users/egv/dev/yolo-runner/go.mod":[{"range":{"start":{"line":6,"character":44},"end":{"line":6,"character":55}},"severity":2,"source":"go mod tidy","message":"github.com/charmbracelet/bubbletea should be direct"},{"range":{"start":{"line":19,"character":26},"end":{"line":19,"character":37}},"severity":2,"source":"go mod tidy","message":"golang.org/x/term should be direct"}],"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main.go":[],"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go":[],"/Users/egv/dev/yolo-runner/cmd/yolo-runner/exec_test.go":[],"/Users/egv/dev/yolo-runner/internal/opencode/agent_test.go":[],"/Users/egv/dev/yolo-runner/internal/opencode/agent.go":[]},"diff":"Index: /Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go\n===================================================================\n--- /Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go\n+++ /Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go\n@@ -96,13 +96,15 @@\n \treturn f.result, f.err\n }\n \n func TestRunOnceMainReturnsErrorCodeOnFailure(t *testing.T) {\n+\ttempDir := t.TempDir()\n+\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n \trunner := &fakeRunOnce{err: errors.New(\"boom\")}\n \texit := &fakeExit{}\n \tout := &bytes.Buffer{}\n \n-\tcode := RunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\"}, runner.Run, exit.Exit, out, out, nil, nil)\n+\tcode := RunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\"}, runner.Run, exit.Exit, out, out, nil, nil)\n \n \tif code != 1 {\n \t\tt.Fatalf(\"expected exit code 1, got %d\", code)\n \t}\n","filediff":{"file":"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go","before":"package main\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"yolo-runner/internal/opencode\"\n\t\"yolo-runner/internal/runner\"\n)\n\ntype fakeRunner struct {\n\tcalls []string\n}\n\nfunc (f *fakeRunner) Run(args ...string) (string, error) {\n\tf.calls = append(f.calls, strings.Join(args, \" \"))\n\treturn \"\", nil\n}\n\ntype fakeOpenCodeRunLogger struct {\n\tcalled     bool\n\tissueID    string\n\trepoRoot   string\n\tprompt     string\n\tmodel      string\n\tconfigRoot string\n\tconfigDir  string\n\tlogPath    string\n}\n\nfunc (f *fakeOpenCodeRunLogger) Run(issueID string, repoRoot string, prompt string, model string, configRoot string, configDir string, logPath string) error {\n\tf.called = true\n\tf.issueID = issueID\n\tf.repoRoot = repoRoot\n\tf.prompt = prompt\n\tf.model = model\n\tf.configRoot = configRoot\n\tf.configDir = configDir\n\tf.logPath = logPath\n\treturn nil\n}\n\ntype fakeOpenCodeRunner struct {\n\tenv map[string]string\n}\n\ntype fakeOpenCodeProcess struct{}\n\nfunc (fakeOpenCodeProcess) Wait() error { return nil }\n\nfunc (fakeOpenCodeProcess) Kill() error { return nil }\n\nfunc (f *fakeOpenCodeRunner) Start(args []string, env map[string]string, stdoutPath string) (opencode.Process, error) {\n\tf.env = env\n\treturn fakeOpenCodeProcess{}, nil\n}\n\ntype fakeGitRunner struct {\n\tcalls  []string\n\toutput string\n\terr    error\n}\n\nfunc (f *fakeGitRunner) Run(name string, args ...string) (string, error) {\n\tf.calls = append(f.calls, name+\" \"+strings.Join(args, \" \"))\n\treturn f.output, f.err\n}\n\ntype fakeExit struct {\n\tcode int\n}\n\nfunc (f *fakeExit) Exit(code int) {\n\tf.code = code\n}\n\ntype fakeRunOnce struct {\n\tcalled bool\n\topts   runner.RunOnceOptions\n\tdeps   runner.RunOnceDeps\n\tresult string\n\terr    error\n}\n\nfunc (f *fakeRunOnce) Run(opts runner.RunOnceOptions, deps runner.RunOnceDeps) (string, error) {\n\n\tf.called = true\n\tf.opts = opts\n\tf.deps = deps\n\treturn f.result, f.err\n}\n\nfunc TestRunOnceMainReturnsErrorCodeOnFailure(t *testing.T) {\n\trunner := &fakeRunOnce{err: errors.New(\"boom\")}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\n\tcode := RunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\"}, runner.Run, exit.Exit, out, out, nil, nil)\n\n\tif code != 1 {\n\t\tt.Fatalf(\"expected exit code 1, got %d\", code)\n\t}\n\tif exit.code != 1 {\n\t\tt.Fatalf(\"expected exit to be called with 1, got %d\", exit.code)\n\t}\n\tif !strings.Contains(out.String(), \"boom\") {\n\t\tt.Fatalf(\"expected error output, got %q\", out.String())\n\t}\n}\n\nfunc TestRunOnceMainWiresDependencies(t *testing.T) {\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tRunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\", \"--model\", \"model\", \"--dry-run\"}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif !runner.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n\tif runner.opts.RepoRoot != \"/repo\" || runner.opts.RootID != \"root\" || runner.opts.Model != \"model\" || !runner.opts.DryRun {\n\t\tt.Fatalf(\"unexpected options: %#v\", runner.opts)\n\t}\n\tif runner.opts.Out == nil {\n\t\tt.Fatalf(\"expected output writer\")\n\t}\n\tif runner.deps.Beads == nil || runner.deps.Git == nil || runner.deps.Prompt == nil || runner.deps.OpenCode == nil || runner.deps.Logger == nil {\n\t\tt.Fatalf(\"expected deps to be wired\")\n\t}\n\tif exit.code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", exit.code)\n\t}\n}\n\nfunc TestRunOnceMainDefaultsConfigPaths(t *testing.T) {\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tt.Setenv(\"HOME\", \"/home/user\")\n\n\tRunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\"}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif !runner.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n\tif runner.opts.ConfigRoot == \"\" {\n\t\tt.Fatalf(\"expected config root to be set\")\n\t}\n\tif runner.opts.ConfigDir == \"\" {\n\t\tt.Fatalf(\"expected config dir to be set\")\n\t}\n\texpectedConfigRoot := filepath.Join(\"/home/user\", \".config\", \"opencode-runner\")\n\tif runner.opts.ConfigRoot != expectedConfigRoot {\n\t\tt.Fatalf(\"expected config root %q, got %q\", expectedConfigRoot, runner.opts.ConfigRoot)\n\t}\n\texpectedConfigDir := filepath.Join(expectedConfigRoot, \"opencode\")\n\tif runner.opts.ConfigDir != expectedConfigDir {\n\t\tt.Fatalf(\"expected config dir %q, got %q\", expectedConfigDir, runner.opts.ConfigDir)\n\t}\n\tif exit.code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", exit.code)\n\t}\n}\n\nfunc TestRunOnceMainFailsWhenYoloAgentMissing(t *testing.T) {\n\ttempDir := t.TempDir()\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tstdout := &bytes.Buffer{}\n\tstderr := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\"}, runner.Run, exit.Exit, stdout, stderr, beadsRunner, gitRunner)\n\n\tif code != 1 {\n\t\tt.Fatalf(\"expected exit code 1, got %d\", code)\n\t}\n\tif exit.code != 1 {\n\t\tt.Fatalf(\"expected exit to be called with 1, got %d\", exit.code)\n\t}\n\tif runner.called {\n\t\tt.Fatalf(\"expected run once not to be called\")\n\t}\n\tif !strings.Contains(stderr.String(), \"yolo.md\") {\n\t\tt.Fatalf(\"expected error to mention yolo.md, got %q\", stderr.String())\n\t}\n}\n\nfunc TestRunOnceMainFailsWhenYoloAgentMissingPermission(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteAgentFile(t, tempDir, \"---\\nname: yolo\\n---\\n\")\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tstdout := &bytes.Buffer{}\n\tstderr := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\"}, runner.Run, exit.Exit, stdout, stderr, beadsRunner, gitRunner)\n\n\tif code != 1 {\n\t\tt.Fatalf(\"expected exit code 1, got %d\", code)\n\t}\n\tif exit.code != 1 {\n\t\tt.Fatalf(\"expected exit to be called with 1, got %d\", exit.code)\n\t}\n\tif runner.called {\n\t\tt.Fatalf(\"expected run once not to be called\")\n\t}\n\tif !strings.Contains(stderr.String(), \"permission: allow\") {\n\t\tt.Fatalf(\"expected error to mention permission allow, got %q\", stderr.String())\n\t}\n\tif !strings.Contains(strings.ToLower(stderr.String()), \"init\") {\n\t\tt.Fatalf(\"expected guidance to run init, got %q\", stderr.String())\n\t}\n}\n\nfunc TestRunOnceMainInfersRoadmapRootWhenMissing(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteIssuesFile(t, tempDir, `{\"id\":\"roadmap-1\",\"title\":\"Roadmap\",\"issue_type\":\"epic\",\"status\":\"open\"}`)\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", code)\n\t}\n\tif !runner.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n\tif runner.opts.RootID != \"roadmap-1\" {\n\t\tt.Fatalf(\"expected root id to be inferred, got %q\", runner.opts.RootID)\n\t}\n}\n\nfunc TestRunOnceMainInfersRoadmapRootWhenInProgress(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteIssuesFile(t, tempDir, `{\"id\":\"roadmap-2\",\"title\":\"Roadmap\",\"issue_type\":\"epic\",\"status\":\"in_progress\"}`)\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", code)\n\t}\n\tif !runner.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n\tif runner.opts.RootID != \"roadmap-2\" {\n\t\tt.Fatalf(\"expected root id to be inferred, got %q\", runner.opts.RootID)\n\t}\n}\n\nfunc TestRunOnceMainMissingRootRequiresExplicitFlag(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteIssuesFile(t, tempDir, `{\"id\":\"epic-1\",\"title\":\"Other\",\"issue_type\":\"epic\",\"status\":\"open\"}`)\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tstdout := &bytes.Buffer{}\n\tstderr := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir}, runner.Run, exit.Exit, stdout, stderr, beadsRunner, gitRunner)\n\n\tif code != 1 {\n\t\tt.Fatalf(\"expected exit code 1, got %d\", code)\n\t}\n\tif exit.code != 1 {\n\t\tt.Fatalf(\"expected exit to be called with 1, got %d\", exit.code)\n\t}\n\tif runner.called {\n\t\tt.Fatalf(\"expected run once not to be called\")\n\t}\n\tif !strings.Contains(stderr.String(), \"--root\") {\n\t\tt.Fatalf(\"expected error to mention --root, got %q\", stderr.String())\n\t}\n\tif !strings.Contains(strings.ToLower(stderr.String()), \"roadmap\") {\n\t\tt.Fatalf(\"expected error to mention roadmap, got %q\", stderr.String())\n\t}\n}\n\ntype fakeTUIProgram struct {\n\tstarted chan struct{}\n\tquit    chan struct{}\n\tevents  chan runner.Event\n}\n\nfunc newFakeTUIProgram() *fakeTUIProgram {\n\treturn &fakeTUIProgram{\n\t\tstarted: make(chan struct{}),\n\t\tquit:    make(chan struct{}),\n\t\tevents:  make(chan runner.Event, 1),\n\t}\n}\n\nfunc (f *fakeTUIProgram) Start() error {\n\tclose(f.started)\n\treturn nil\n}\n\nfunc (f *fakeTUIProgram) Send(event runner.Event) {\n\tf.events <- event\n}\n\nfunc (f *fakeTUIProgram) Quit() {\n\tclose(f.quit)\n}\n\nfunc waitForSignal(t *testing.T, signal chan struct{}, label string) {\n\tt.Helper()\n\tselect {\n\tcase <-signal:\n\t\treturn\n\tcase <-time.After(200 * time.Millisecond):\n\t\tt.Fatalf(\"expected %s\", label)\n\t}\n}\n\nfunc writeIssuesFile(t *testing.T, repoRoot string, payload string) {\n\tt.Helper()\n\tbeadsDir := filepath.Join(repoRoot, \".beads\")\n\tif err := os.MkdirAll(beadsDir, 0o755); err != nil {\n\t\tt.Fatalf(\"mkdir .beads: %v\", err)\n\t}\n\tissuesPath := filepath.Join(beadsDir, \"issues.jsonl\")\n\tif err := os.WriteFile(issuesPath, []byte(payload+\"\\n\"), 0o644); err != nil {\n\t\tt.Fatalf(\"write issues: %v\", err)\n\t}\n}\n\nfunc writeAgentFile(t *testing.T, repoRoot string, payload string) {\n\tt.Helper()\n\tagentDir := filepath.Join(repoRoot, \".opencode\", \"agent\")\n\tif err := os.MkdirAll(agentDir, 0o755); err != nil {\n\t\tt.Fatalf(\"mkdir agent dir: %v\", err)\n\t}\n\tagentPath := filepath.Join(agentDir, \"yolo.md\")\n\tif err := os.WriteFile(agentPath, []byte(payload), 0o644); err != nil {\n\t\tt.Fatalf(\"write agent file: %v\", err)\n\t}\n}\n\nfunc TestRunOnceMainUsesTUIOnTTYByDefault(t *testing.T) {\n\tfakeProgram := newFakeTUIProgram()\n\tprevIsTerminal := isTerminal\n\tprevNewTUIProgram := newTUIProgram\n\tisTerminal = func(io.Writer) bool { return true }\n\tnewTUIProgram = func(stdout io.Writer) tuiProgram { return fakeProgram }\n\tt.Cleanup(func() {\n\t\tisTerminal = prevIsTerminal\n\t\tnewTUIProgram = prevNewTUIProgram\n\t})\n\n\trunOnce := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\"}, runOnce.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", code)\n\t}\n\tif runOnce.deps.Events == nil {\n\t\tt.Fatalf(\"expected events emitter to be set\")\n\t}\n\trunOnce.deps.Events.Emit(runner.Event{Type: runner.EventSelectTask})\n\twaitForSignal(t, fakeProgram.started, \"tui start\")\n\twaitForSignal(t, fakeProgram.quit, \"tui quit\")\n\tselect {\n\tcase <-fakeProgram.events:\n\t\t// ok\n\tcase <-time.After(200 * time.Millisecond):\n\t\tt.Fatalf(\"expected event to be forwarded to TUI\")\n\t}\n}\n\nfunc TestRunOnceMainHeadlessDisablesTUI(t *testing.T) {\n\tcalled := false\n\tprevIsTerminal := isTerminal\n\tprevNewTUIProgram := newTUIProgram\n\tisTerminal = func(io.Writer) bool { return true }\n\tnewTUIProgram = func(stdout io.Writer) tuiProgram {\n\t\tcalled = true\n\t\treturn newFakeTUIProgram()\n\t}\n\tt.Cleanup(func() {\n\t\tisTerminal = prevIsTerminal\n\t\tnewTUIProgram = prevNewTUIProgram\n\t})\n\n\trunOnce := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\tstderr := &bytes.Buffer{}\n\n\tRunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\", \"--headless\"}, runOnce.Run, exit.Exit, out, stderr, beadsRunner, gitRunner)\n\n\tif called {\n\t\tt.Fatalf(\"expected TUI program not to start\")\n\t}\n\tif runOnce.deps.Events != nil {\n\t\tt.Fatalf(\"expected no events emitter in headless mode\")\n\t}\n}\n\nfunc TestOpenCodeRunDefaultsCreateConfigAndEnv(t *testing.T) {\n\ttempDir := t.TempDir()\n\trepoRoot := filepath.Join(tempDir, \"repo\")\n\tif err := os.MkdirAll(repoRoot, 0o755); err != nil {\n\t\tt.Fatalf(\"mkdir repo: %v\", err)\n\t}\n\tt.Setenv(\"HOME\", tempDir)\n\n\topenCodeRunner := &fakeOpenCodeRunner{}\n\topenCodeAdapter := openCodeAdapter{runner: openCodeRunner}\n\n\tconfigRoot := filepath.Join(tempDir, \".config\", \"opencode-runner\")\n\tconfigDir := filepath.Join(configRoot, \"opencode\")\n\tlogPath := filepath.Join(tempDir, \"runner-logs\", \"opencode\", \"issue-1.jsonl\")\n\n\tif err := openCodeAdapter.Run(\"issue-1\", repoRoot, \"prompt\", \"\", configRoot, configDir, logPath); err != nil {\n\t\tt.Fatalf(\"open code run error: %v\", err)\n\t}\n\n\tconfigFile := filepath.Join(configDir, \"opencode.json\")\n\tif _, err := os.Stat(configFile); err != nil {\n\t\tt.Fatalf(\"expected opencode.json to exist: %v\", err)\n\t}\n\texpectedConfigFile := filepath.Join(configDir, \"opencode.json\")\n\tif openCodeRunner.env[\"XDG_CONFIG_HOME\"] != configRoot {\n\t\tt.Fatalf(\"expected XDG_CONFIG_HOME set\")\n\t}\n\tif openCodeRunner.env[\"OPENCODE_CONFIG_DIR\"] != configDir {\n\t\tt.Fatalf(\"expected OPENCODE_CONFIG_DIR set\")\n\t}\n\tif openCodeRunner.env[\"OPENCODE_CONFIG\"] != expectedConfigFile {\n\t\tt.Fatalf(\"expected OPENCODE_CONFIG set\")\n\t}\n\tif openCodeRunner.env[\"OPENCODE_CONFIG_CONTENT\"] != \"{}\" {\n\t\tt.Fatalf(\"expected OPENCODE_CONFIG_CONTENT set\")\n\t}\n}\n","after":"package main\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"yolo-runner/internal/opencode\"\n\t\"yolo-runner/internal/runner\"\n)\n\ntype fakeRunner struct {\n\tcalls []string\n}\n\nfunc (f *fakeRunner) Run(args ...string) (string, error) {\n\tf.calls = append(f.calls, strings.Join(args, \" \"))\n\treturn \"\", nil\n}\n\ntype fakeOpenCodeRunLogger struct {\n\tcalled     bool\n\tissueID    string\n\trepoRoot   string\n\tprompt     string\n\tmodel      string\n\tconfigRoot string\n\tconfigDir  string\n\tlogPath    string\n}\n\nfunc (f *fakeOpenCodeRunLogger) Run(issueID string, repoRoot string, prompt string, model string, configRoot string, configDir string, logPath string) error {\n\tf.called = true\n\tf.issueID = issueID\n\tf.repoRoot = repoRoot\n\tf.prompt = prompt\n\tf.model = model\n\tf.configRoot = configRoot\n\tf.configDir = configDir\n\tf.logPath = logPath\n\treturn nil\n}\n\ntype fakeOpenCodeRunner struct {\n\tenv map[string]string\n}\n\ntype fakeOpenCodeProcess struct{}\n\nfunc (fakeOpenCodeProcess) Wait() error { return nil }\n\nfunc (fakeOpenCodeProcess) Kill() error { return nil }\n\nfunc (f *fakeOpenCodeRunner) Start(args []string, env map[string]string, stdoutPath string) (opencode.Process, error) {\n\tf.env = env\n\treturn fakeOpenCodeProcess{}, nil\n}\n\ntype fakeGitRunner struct {\n\tcalls  []string\n\toutput string\n\terr    error\n}\n\nfunc (f *fakeGitRunner) Run(name string, args ...string) (string, error) {\n\tf.calls = append(f.calls, name+\" \"+strings.Join(args, \" \"))\n\treturn f.output, f.err\n}\n\ntype fakeExit struct {\n\tcode int\n}\n\nfunc (f *fakeExit) Exit(code int) {\n\tf.code = code\n}\n\ntype fakeRunOnce struct {\n\tcalled bool\n\topts   runner.RunOnceOptions\n\tdeps   runner.RunOnceDeps\n\tresult string\n\terr    error\n}\n\nfunc (f *fakeRunOnce) Run(opts runner.RunOnceOptions, deps runner.RunOnceDeps) (string, error) {\n\n\tf.called = true\n\tf.opts = opts\n\tf.deps = deps\n\treturn f.result, f.err\n}\n\nfunc TestRunOnceMainReturnsErrorCodeOnFailure(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n\trunner := &fakeRunOnce{err: errors.New(\"boom\")}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\"}, runner.Run, exit.Exit, out, out, nil, nil)\n\n\tif code != 1 {\n\t\tt.Fatalf(\"expected exit code 1, got %d\", code)\n\t}\n\tif exit.code != 1 {\n\t\tt.Fatalf(\"expected exit to be called with 1, got %d\", exit.code)\n\t}\n\tif !strings.Contains(out.String(), \"boom\") {\n\t\tt.Fatalf(\"expected error output, got %q\", out.String())\n\t}\n}\n\nfunc TestRunOnceMainWiresDependencies(t *testing.T) {\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tRunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\", \"--model\", \"model\", \"--dry-run\"}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif !runner.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n\tif runner.opts.RepoRoot != \"/repo\" || runner.opts.RootID != \"root\" || runner.opts.Model != \"model\" || !runner.opts.DryRun {\n\t\tt.Fatalf(\"unexpected options: %#v\", runner.opts)\n\t}\n\tif runner.opts.Out == nil {\n\t\tt.Fatalf(\"expected output writer\")\n\t}\n\tif runner.deps.Beads == nil || runner.deps.Git == nil || runner.deps.Prompt == nil || runner.deps.OpenCode == nil || runner.deps.Logger == nil {\n\t\tt.Fatalf(\"expected deps to be wired\")\n\t}\n\tif exit.code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", exit.code)\n\t}\n}\n\nfunc TestRunOnceMainDefaultsConfigPaths(t *testing.T) {\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tt.Setenv(\"HOME\", \"/home/user\")\n\n\tRunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\"}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif !runner.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n\tif runner.opts.ConfigRoot == \"\" {\n\t\tt.Fatalf(\"expected config root to be set\")\n\t}\n\tif runner.opts.ConfigDir == \"\" {\n\t\tt.Fatalf(\"expected config dir to be set\")\n\t}\n\texpectedConfigRoot := filepath.Join(\"/home/user\", \".config\", \"opencode-runner\")\n\tif runner.opts.ConfigRoot != expectedConfigRoot {\n\t\tt.Fatalf(\"expected config root %q, got %q\", expectedConfigRoot, runner.opts.ConfigRoot)\n\t}\n\texpectedConfigDir := filepath.Join(expectedConfigRoot, \"opencode\")\n\tif runner.opts.ConfigDir != expectedConfigDir {\n\t\tt.Fatalf(\"expected config dir %q, got %q\", expectedConfigDir, runner.opts.ConfigDir)\n\t}\n\tif exit.code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", exit.code)\n\t}\n}\n\nfunc TestRunOnceMainFailsWhenYoloAgentMissing(t *testing.T) {\n\ttempDir := t.TempDir()\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tstdout := &bytes.Buffer{}\n\tstderr := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\"}, runner.Run, exit.Exit, stdout, stderr, beadsRunner, gitRunner)\n\n\tif code != 1 {\n\t\tt.Fatalf(\"expected exit code 1, got %d\", code)\n\t}\n\tif exit.code != 1 {\n\t\tt.Fatalf(\"expected exit to be called with 1, got %d\", exit.code)\n\t}\n\tif runner.called {\n\t\tt.Fatalf(\"expected run once not to be called\")\n\t}\n\tif !strings.Contains(stderr.String(), \"yolo.md\") {\n\t\tt.Fatalf(\"expected error to mention yolo.md, got %q\", stderr.String())\n\t}\n}\n\nfunc TestRunOnceMainFailsWhenYoloAgentMissingPermission(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteAgentFile(t, tempDir, \"---\\nname: yolo\\n---\\n\")\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tstdout := &bytes.Buffer{}\n\tstderr := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\"}, runner.Run, exit.Exit, stdout, stderr, beadsRunner, gitRunner)\n\n\tif code != 1 {\n\t\tt.Fatalf(\"expected exit code 1, got %d\", code)\n\t}\n\tif exit.code != 1 {\n\t\tt.Fatalf(\"expected exit to be called with 1, got %d\", exit.code)\n\t}\n\tif runner.called {\n\t\tt.Fatalf(\"expected run once not to be called\")\n\t}\n\tif !strings.Contains(stderr.String(), \"permission: allow\") {\n\t\tt.Fatalf(\"expected error to mention permission allow, got %q\", stderr.String())\n\t}\n\tif !strings.Contains(strings.ToLower(stderr.String()), \"init\") {\n\t\tt.Fatalf(\"expected guidance to run init, got %q\", stderr.String())\n\t}\n}\n\nfunc TestRunOnceMainInfersRoadmapRootWhenMissing(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteIssuesFile(t, tempDir, `{\"id\":\"roadmap-1\",\"title\":\"Roadmap\",\"issue_type\":\"epic\",\"status\":\"open\"}`)\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", code)\n\t}\n\tif !runner.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n\tif runner.opts.RootID != \"roadmap-1\" {\n\t\tt.Fatalf(\"expected root id to be inferred, got %q\", runner.opts.RootID)\n\t}\n}\n\nfunc TestRunOnceMainInfersRoadmapRootWhenInProgress(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteIssuesFile(t, tempDir, `{\"id\":\"roadmap-2\",\"title\":\"Roadmap\",\"issue_type\":\"epic\",\"status\":\"in_progress\"}`)\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", code)\n\t}\n\tif !runner.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n\tif runner.opts.RootID != \"roadmap-2\" {\n\t\tt.Fatalf(\"expected root id to be inferred, got %q\", runner.opts.RootID)\n\t}\n}\n\nfunc TestRunOnceMainMissingRootRequiresExplicitFlag(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteIssuesFile(t, tempDir, `{\"id\":\"epic-1\",\"title\":\"Other\",\"issue_type\":\"epic\",\"status\":\"open\"}`)\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tstdout := &bytes.Buffer{}\n\tstderr := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir}, runner.Run, exit.Exit, stdout, stderr, beadsRunner, gitRunner)\n\n\tif code != 1 {\n\t\tt.Fatalf(\"expected exit code 1, got %d\", code)\n\t}\n\tif exit.code != 1 {\n\t\tt.Fatalf(\"expected exit to be called with 1, got %d\", exit.code)\n\t}\n\tif runner.called {\n\t\tt.Fatalf(\"expected run once not to be called\")\n\t}\n\tif !strings.Contains(stderr.String(), \"--root\") {\n\t\tt.Fatalf(\"expected error to mention --root, got %q\", stderr.String())\n\t}\n\tif !strings.Contains(strings.ToLower(stderr.String()), \"roadmap\") {\n\t\tt.Fatalf(\"expected error to mention roadmap, got %q\", stderr.String())\n\t}\n}\n\ntype fakeTUIProgram struct {\n\tstarted chan struct{}\n\tquit    chan struct{}\n\tevents  chan runner.Event\n}\n\nfunc newFakeTUIProgram() *fakeTUIProgram {\n\treturn &fakeTUIProgram{\n\t\tstarted: make(chan struct{}),\n\t\tquit:    make(chan struct{}),\n\t\tevents:  make(chan runner.Event, 1),\n\t}\n}\n\nfunc (f *fakeTUIProgram) Start() error {\n\tclose(f.started)\n\treturn nil\n}\n\nfunc (f *fakeTUIProgram) Send(event runner.Event) {\n\tf.events <- event\n}\n\nfunc (f *fakeTUIProgram) Quit() {\n\tclose(f.quit)\n}\n\nfunc waitForSignal(t *testing.T, signal chan struct{}, label string) {\n\tt.Helper()\n\tselect {\n\tcase <-signal:\n\t\treturn\n\tcase <-time.After(200 * time.Millisecond):\n\t\tt.Fatalf(\"expected %s\", label)\n\t}\n}\n\nfunc writeIssuesFile(t *testing.T, repoRoot string, payload string) {\n\tt.Helper()\n\tbeadsDir := filepath.Join(repoRoot, \".beads\")\n\tif err := os.MkdirAll(beadsDir, 0o755); err != nil {\n\t\tt.Fatalf(\"mkdir .beads: %v\", err)\n\t}\n\tissuesPath := filepath.Join(beadsDir, \"issues.jsonl\")\n\tif err := os.WriteFile(issuesPath, []byte(payload+\"\\n\"), 0o644); err != nil {\n\t\tt.Fatalf(\"write issues: %v\", err)\n\t}\n}\n\nfunc writeAgentFile(t *testing.T, repoRoot string, payload string) {\n\tt.Helper()\n\tagentDir := filepath.Join(repoRoot, \".opencode\", \"agent\")\n\tif err := os.MkdirAll(agentDir, 0o755); err != nil {\n\t\tt.Fatalf(\"mkdir agent dir: %v\", err)\n\t}\n\tagentPath := filepath.Join(agentDir, \"yolo.md\")\n\tif err := os.WriteFile(agentPath, []byte(payload), 0o644); err != nil {\n\t\tt.Fatalf(\"write agent file: %v\", err)\n\t}\n}\n\nfunc TestRunOnceMainUsesTUIOnTTYByDefault(t *testing.T) {\n\tfakeProgram := newFakeTUIProgram()\n\tprevIsTerminal := isTerminal\n\tprevNewTUIProgram := newTUIProgram\n\tisTerminal = func(io.Writer) bool { return true }\n\tnewTUIProgram = func(stdout io.Writer) tuiProgram { return fakeProgram }\n\tt.Cleanup(func() {\n\t\tisTerminal = prevIsTerminal\n\t\tnewTUIProgram = prevNewTUIProgram\n\t})\n\n\trunOnce := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\"}, runOnce.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", code)\n\t}\n\tif runOnce.deps.Events == nil {\n\t\tt.Fatalf(\"expected events emitter to be set\")\n\t}\n\trunOnce.deps.Events.Emit(runner.Event{Type: runner.EventSelectTask})\n\twaitForSignal(t, fakeProgram.started, \"tui start\")\n\twaitForSignal(t, fakeProgram.quit, \"tui quit\")\n\tselect {\n\tcase <-fakeProgram.events:\n\t\t// ok\n\tcase <-time.After(200 * time.Millisecond):\n\t\tt.Fatalf(\"expected event to be forwarded to TUI\")\n\t}\n}\n\nfunc TestRunOnceMainHeadlessDisablesTUI(t *testing.T) {\n\tcalled := false\n\tprevIsTerminal := isTerminal\n\tprevNewTUIProgram := newTUIProgram\n\tisTerminal = func(io.Writer) bool { return true }\n\tnewTUIProgram = func(stdout io.Writer) tuiProgram {\n\t\tcalled = true\n\t\treturn newFakeTUIProgram()\n\t}\n\tt.Cleanup(func() {\n\t\tisTerminal = prevIsTerminal\n\t\tnewTUIProgram = prevNewTUIProgram\n\t})\n\n\trunOnce := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\tstderr := &bytes.Buffer{}\n\n\tRunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\", \"--headless\"}, runOnce.Run, exit.Exit, out, stderr, beadsRunner, gitRunner)\n\n\tif called {\n\t\tt.Fatalf(\"expected TUI program not to start\")\n\t}\n\tif runOnce.deps.Events != nil {\n\t\tt.Fatalf(\"expected no events emitter in headless mode\")\n\t}\n}\n\nfunc TestOpenCodeRunDefaultsCreateConfigAndEnv(t *testing.T) {\n\ttempDir := t.TempDir()\n\trepoRoot := filepath.Join(tempDir, \"repo\")\n\tif err := os.MkdirAll(repoRoot, 0o755); err != nil {\n\t\tt.Fatalf(\"mkdir repo: %v\", err)\n\t}\n\tt.Setenv(\"HOME\", tempDir)\n\n\topenCodeRunner := &fakeOpenCodeRunner{}\n\topenCodeAdapter := openCodeAdapter{runner: openCodeRunner}\n\n\tconfigRoot := filepath.Join(tempDir, \".config\", \"opencode-runner\")\n\tconfigDir := filepath.Join(configRoot, \"opencode\")\n\tlogPath := filepath.Join(tempDir, \"runner-logs\", \"opencode\", \"issue-1.jsonl\")\n\n\tif err := openCodeAdapter.Run(\"issue-1\", repoRoot, \"prompt\", \"\", configRoot, configDir, logPath); err != nil {\n\t\tt.Fatalf(\"open code run error: %v\", err)\n\t}\n\n\tconfigFile := filepath.Join(configDir, \"opencode.json\")\n\tif _, err := os.Stat(configFile); err != nil {\n\t\tt.Fatalf(\"expected opencode.json to exist: %v\", err)\n\t}\n\texpectedConfigFile := filepath.Join(configDir, \"opencode.json\")\n\tif openCodeRunner.env[\"XDG_CONFIG_HOME\"] != configRoot {\n\t\tt.Fatalf(\"expected XDG_CONFIG_HOME set\")\n\t}\n\tif openCodeRunner.env[\"OPENCODE_CONFIG_DIR\"] != configDir {\n\t\tt.Fatalf(\"expected OPENCODE_CONFIG_DIR set\")\n\t}\n\tif openCodeRunner.env[\"OPENCODE_CONFIG\"] != expectedConfigFile {\n\t\tt.Fatalf(\"expected OPENCODE_CONFIG set\")\n\t}\n\tif openCodeRunner.env[\"OPENCODE_CONFIG_CONTENT\"] != \"{}\" {\n\t\tt.Fatalf(\"expected OPENCODE_CONFIG_CONTENT set\")\n\t}\n}\n","additions":3,"deletions":1},"truncated":false},"time":{"start":1768850752848,"end":1768850753011}},"metadata":{"openai":{"itemId":"fc_0612662162acf4f501696e853de5b88191b86f0d6d4e252d59"}}}}
{"type":"step_finish","timestamp":1768850753030,"sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","part":{"id":"prt_bd7b885f3001LmBD2uBvmWqda8","sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","messageID":"msg_bd7b83042001wFylPXyzJWLYe7","type":"step-finish","reason":"tool-calls","snapshot":"6090227dc97a09926d9237ef07806fbc5a06ee65","cost":0,"tokens":{"input":523,"output":1061,"reasoning":832,"cache":{"read":25216,"write":0}}}}
{"type":"step_start","timestamp":1768850753354,"sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","part":{"id":"prt_bd7b88749001ocBqMTNkOpFsAE","sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","messageID":"msg_bd7b88615001SSy9vq7zOxJvwV","type":"step-start","snapshot":"bf95d57ddcba445f121c25ea94cb66d79b43bb75"}}
{"type":"tool_use","timestamp":1768850759320,"sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","part":{"id":"prt_bd7b88b78001f1jhuclFbeW8vy","sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","messageID":"msg_bd7b88615001SSy9vq7zOxJvwV","type":"tool","callID":"call_6UC9lVryKEKpGED6j8bvnWzX","tool":"edit","state":{"status":"completed","input":{"filePath":"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go","oldString":"\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tRunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\", \"--model\", \"model\", \"--dry-run\"}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n","newString":"\ttempDir := t.TempDir()\n\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tRunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\", \"--model\", \"model\", \"--dry-run\"}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n"},"output":"Edit applied successfully.","title":"cmd/yolo-runner/main_test.go","metadata":{"diagnostics":{"/Users/egv/dev/yolo-runner/internal/opencode/client.go":[{"range":{"start":{"line":28,"character":1},"end":{"line":28,"character":18}},"severity":2,"code":"default","codeDescription":{"href":"https://staticcheck.dev/docs/checks/#S1031"},"source":"S1031","message":"unnecessary nil check around range"}],"/Users/egv/dev/yolo-runner/internal/opencode/watchdog.go":[],"/Users/egv/dev/yolo-runner/go.mod":[{"range":{"start":{"line":6,"character":44},"end":{"line":6,"character":55}},"severity":2,"source":"go mod tidy","message":"github.com/charmbracelet/bubbletea should be direct"},{"range":{"start":{"line":19,"character":26},"end":{"line":19,"character":37}},"severity":2,"source":"go mod tidy","message":"golang.org/x/term should be direct"}],"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main.go":[],"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go":[],"/Users/egv/dev/yolo-runner/cmd/yolo-runner/exec_test.go":[],"/Users/egv/dev/yolo-runner/internal/opencode/agent_test.go":[],"/Users/egv/dev/yolo-runner/internal/opencode/agent.go":[]},"diff":"Index: /Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go\n===================================================================\n--- /Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go\n+++ /Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go\n@@ -116,15 +116,17 @@\n \t}\n }\n \n func TestRunOnceMainWiresDependencies(t *testing.T) {\n+\ttempDir := t.TempDir()\n+\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n \trunner := &fakeRunOnce{result: \"no_tasks\"}\n \texit := &fakeExit{}\n \tout := &bytes.Buffer{}\n \tbeadsRunner := &fakeRunner{}\n \tgitRunner := &fakeGitRunner{}\n \n-\tRunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\", \"--model\", \"model\", \"--dry-run\"}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n+\tRunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\", \"--model\", \"model\", \"--dry-run\"}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n \n \tif !runner.called {\n \t\tt.Fatalf(\"expected run once to be called\")\n \t}\n","filediff":{"file":"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go","before":"package main\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"yolo-runner/internal/opencode\"\n\t\"yolo-runner/internal/runner\"\n)\n\ntype fakeRunner struct {\n\tcalls []string\n}\n\nfunc (f *fakeRunner) Run(args ...string) (string, error) {\n\tf.calls = append(f.calls, strings.Join(args, \" \"))\n\treturn \"\", nil\n}\n\ntype fakeOpenCodeRunLogger struct {\n\tcalled     bool\n\tissueID    string\n\trepoRoot   string\n\tprompt     string\n\tmodel      string\n\tconfigRoot string\n\tconfigDir  string\n\tlogPath    string\n}\n\nfunc (f *fakeOpenCodeRunLogger) Run(issueID string, repoRoot string, prompt string, model string, configRoot string, configDir string, logPath string) error {\n\tf.called = true\n\tf.issueID = issueID\n\tf.repoRoot = repoRoot\n\tf.prompt = prompt\n\tf.model = model\n\tf.configRoot = configRoot\n\tf.configDir = configDir\n\tf.logPath = logPath\n\treturn nil\n}\n\ntype fakeOpenCodeRunner struct {\n\tenv map[string]string\n}\n\ntype fakeOpenCodeProcess struct{}\n\nfunc (fakeOpenCodeProcess) Wait() error { return nil }\n\nfunc (fakeOpenCodeProcess) Kill() error { return nil }\n\nfunc (f *fakeOpenCodeRunner) Start(args []string, env map[string]string, stdoutPath string) (opencode.Process, error) {\n\tf.env = env\n\treturn fakeOpenCodeProcess{}, nil\n}\n\ntype fakeGitRunner struct {\n\tcalls  []string\n\toutput string\n\terr    error\n}\n\nfunc (f *fakeGitRunner) Run(name string, args ...string) (string, error) {\n\tf.calls = append(f.calls, name+\" \"+strings.Join(args, \" \"))\n\treturn f.output, f.err\n}\n\ntype fakeExit struct {\n\tcode int\n}\n\nfunc (f *fakeExit) Exit(code int) {\n\tf.code = code\n}\n\ntype fakeRunOnce struct {\n\tcalled bool\n\topts   runner.RunOnceOptions\n\tdeps   runner.RunOnceDeps\n\tresult string\n\terr    error\n}\n\nfunc (f *fakeRunOnce) Run(opts runner.RunOnceOptions, deps runner.RunOnceDeps) (string, error) {\n\n\tf.called = true\n\tf.opts = opts\n\tf.deps = deps\n\treturn f.result, f.err\n}\n\nfunc TestRunOnceMainReturnsErrorCodeOnFailure(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n\trunner := &fakeRunOnce{err: errors.New(\"boom\")}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\"}, runner.Run, exit.Exit, out, out, nil, nil)\n\n\tif code != 1 {\n\t\tt.Fatalf(\"expected exit code 1, got %d\", code)\n\t}\n\tif exit.code != 1 {\n\t\tt.Fatalf(\"expected exit to be called with 1, got %d\", exit.code)\n\t}\n\tif !strings.Contains(out.String(), \"boom\") {\n\t\tt.Fatalf(\"expected error output, got %q\", out.String())\n\t}\n}\n\nfunc TestRunOnceMainWiresDependencies(t *testing.T) {\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tRunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\", \"--model\", \"model\", \"--dry-run\"}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif !runner.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n\tif runner.opts.RepoRoot != \"/repo\" || runner.opts.RootID != \"root\" || runner.opts.Model != \"model\" || !runner.opts.DryRun {\n\t\tt.Fatalf(\"unexpected options: %#v\", runner.opts)\n\t}\n\tif runner.opts.Out == nil {\n\t\tt.Fatalf(\"expected output writer\")\n\t}\n\tif runner.deps.Beads == nil || runner.deps.Git == nil || runner.deps.Prompt == nil || runner.deps.OpenCode == nil || runner.deps.Logger == nil {\n\t\tt.Fatalf(\"expected deps to be wired\")\n\t}\n\tif exit.code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", exit.code)\n\t}\n}\n\nfunc TestRunOnceMainDefaultsConfigPaths(t *testing.T) {\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tt.Setenv(\"HOME\", \"/home/user\")\n\n\tRunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\"}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif !runner.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n\tif runner.opts.ConfigRoot == \"\" {\n\t\tt.Fatalf(\"expected config root to be set\")\n\t}\n\tif runner.opts.ConfigDir == \"\" {\n\t\tt.Fatalf(\"expected config dir to be set\")\n\t}\n\texpectedConfigRoot := filepath.Join(\"/home/user\", \".config\", \"opencode-runner\")\n\tif runner.opts.ConfigRoot != expectedConfigRoot {\n\t\tt.Fatalf(\"expected config root %q, got %q\", expectedConfigRoot, runner.opts.ConfigRoot)\n\t}\n\texpectedConfigDir := filepath.Join(expectedConfigRoot, \"opencode\")\n\tif runner.opts.ConfigDir != expectedConfigDir {\n\t\tt.Fatalf(\"expected config dir %q, got %q\", expectedConfigDir, runner.opts.ConfigDir)\n\t}\n\tif exit.code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", exit.code)\n\t}\n}\n\nfunc TestRunOnceMainFailsWhenYoloAgentMissing(t *testing.T) {\n\ttempDir := t.TempDir()\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tstdout := &bytes.Buffer{}\n\tstderr := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\"}, runner.Run, exit.Exit, stdout, stderr, beadsRunner, gitRunner)\n\n\tif code != 1 {\n\t\tt.Fatalf(\"expected exit code 1, got %d\", code)\n\t}\n\tif exit.code != 1 {\n\t\tt.Fatalf(\"expected exit to be called with 1, got %d\", exit.code)\n\t}\n\tif runner.called {\n\t\tt.Fatalf(\"expected run once not to be called\")\n\t}\n\tif !strings.Contains(stderr.String(), \"yolo.md\") {\n\t\tt.Fatalf(\"expected error to mention yolo.md, got %q\", stderr.String())\n\t}\n}\n\nfunc TestRunOnceMainFailsWhenYoloAgentMissingPermission(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteAgentFile(t, tempDir, \"---\\nname: yolo\\n---\\n\")\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tstdout := &bytes.Buffer{}\n\tstderr := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\"}, runner.Run, exit.Exit, stdout, stderr, beadsRunner, gitRunner)\n\n\tif code != 1 {\n\t\tt.Fatalf(\"expected exit code 1, got %d\", code)\n\t}\n\tif exit.code != 1 {\n\t\tt.Fatalf(\"expected exit to be called with 1, got %d\", exit.code)\n\t}\n\tif runner.called {\n\t\tt.Fatalf(\"expected run once not to be called\")\n\t}\n\tif !strings.Contains(stderr.String(), \"permission: allow\") {\n\t\tt.Fatalf(\"expected error to mention permission allow, got %q\", stderr.String())\n\t}\n\tif !strings.Contains(strings.ToLower(stderr.String()), \"init\") {\n\t\tt.Fatalf(\"expected guidance to run init, got %q\", stderr.String())\n\t}\n}\n\nfunc TestRunOnceMainInfersRoadmapRootWhenMissing(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteIssuesFile(t, tempDir, `{\"id\":\"roadmap-1\",\"title\":\"Roadmap\",\"issue_type\":\"epic\",\"status\":\"open\"}`)\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", code)\n\t}\n\tif !runner.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n\tif runner.opts.RootID != \"roadmap-1\" {\n\t\tt.Fatalf(\"expected root id to be inferred, got %q\", runner.opts.RootID)\n\t}\n}\n\nfunc TestRunOnceMainInfersRoadmapRootWhenInProgress(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteIssuesFile(t, tempDir, `{\"id\":\"roadmap-2\",\"title\":\"Roadmap\",\"issue_type\":\"epic\",\"status\":\"in_progress\"}`)\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", code)\n\t}\n\tif !runner.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n\tif runner.opts.RootID != \"roadmap-2\" {\n\t\tt.Fatalf(\"expected root id to be inferred, got %q\", runner.opts.RootID)\n\t}\n}\n\nfunc TestRunOnceMainMissingRootRequiresExplicitFlag(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteIssuesFile(t, tempDir, `{\"id\":\"epic-1\",\"title\":\"Other\",\"issue_type\":\"epic\",\"status\":\"open\"}`)\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tstdout := &bytes.Buffer{}\n\tstderr := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir}, runner.Run, exit.Exit, stdout, stderr, beadsRunner, gitRunner)\n\n\tif code != 1 {\n\t\tt.Fatalf(\"expected exit code 1, got %d\", code)\n\t}\n\tif exit.code != 1 {\n\t\tt.Fatalf(\"expected exit to be called with 1, got %d\", exit.code)\n\t}\n\tif runner.called {\n\t\tt.Fatalf(\"expected run once not to be called\")\n\t}\n\tif !strings.Contains(stderr.String(), \"--root\") {\n\t\tt.Fatalf(\"expected error to mention --root, got %q\", stderr.String())\n\t}\n\tif !strings.Contains(strings.ToLower(stderr.String()), \"roadmap\") {\n\t\tt.Fatalf(\"expected error to mention roadmap, got %q\", stderr.String())\n\t}\n}\n\ntype fakeTUIProgram struct {\n\tstarted chan struct{}\n\tquit    chan struct{}\n\tevents  chan runner.Event\n}\n\nfunc newFakeTUIProgram() *fakeTUIProgram {\n\treturn &fakeTUIProgram{\n\t\tstarted: make(chan struct{}),\n\t\tquit:    make(chan struct{}),\n\t\tevents:  make(chan runner.Event, 1),\n\t}\n}\n\nfunc (f *fakeTUIProgram) Start() error {\n\tclose(f.started)\n\treturn nil\n}\n\nfunc (f *fakeTUIProgram) Send(event runner.Event) {\n\tf.events <- event\n}\n\nfunc (f *fakeTUIProgram) Quit() {\n\tclose(f.quit)\n}\n\nfunc waitForSignal(t *testing.T, signal chan struct{}, label string) {\n\tt.Helper()\n\tselect {\n\tcase <-signal:\n\t\treturn\n\tcase <-time.After(200 * time.Millisecond):\n\t\tt.Fatalf(\"expected %s\", label)\n\t}\n}\n\nfunc writeIssuesFile(t *testing.T, repoRoot string, payload string) {\n\tt.Helper()\n\tbeadsDir := filepath.Join(repoRoot, \".beads\")\n\tif err := os.MkdirAll(beadsDir, 0o755); err != nil {\n\t\tt.Fatalf(\"mkdir .beads: %v\", err)\n\t}\n\tissuesPath := filepath.Join(beadsDir, \"issues.jsonl\")\n\tif err := os.WriteFile(issuesPath, []byte(payload+\"\\n\"), 0o644); err != nil {\n\t\tt.Fatalf(\"write issues: %v\", err)\n\t}\n}\n\nfunc writeAgentFile(t *testing.T, repoRoot string, payload string) {\n\tt.Helper()\n\tagentDir := filepath.Join(repoRoot, \".opencode\", \"agent\")\n\tif err := os.MkdirAll(agentDir, 0o755); err != nil {\n\t\tt.Fatalf(\"mkdir agent dir: %v\", err)\n\t}\n\tagentPath := filepath.Join(agentDir, \"yolo.md\")\n\tif err := os.WriteFile(agentPath, []byte(payload), 0o644); err != nil {\n\t\tt.Fatalf(\"write agent file: %v\", err)\n\t}\n}\n\nfunc TestRunOnceMainUsesTUIOnTTYByDefault(t *testing.T) {\n\tfakeProgram := newFakeTUIProgram()\n\tprevIsTerminal := isTerminal\n\tprevNewTUIProgram := newTUIProgram\n\tisTerminal = func(io.Writer) bool { return true }\n\tnewTUIProgram = func(stdout io.Writer) tuiProgram { return fakeProgram }\n\tt.Cleanup(func() {\n\t\tisTerminal = prevIsTerminal\n\t\tnewTUIProgram = prevNewTUIProgram\n\t})\n\n\trunOnce := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\"}, runOnce.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", code)\n\t}\n\tif runOnce.deps.Events == nil {\n\t\tt.Fatalf(\"expected events emitter to be set\")\n\t}\n\trunOnce.deps.Events.Emit(runner.Event{Type: runner.EventSelectTask})\n\twaitForSignal(t, fakeProgram.started, \"tui start\")\n\twaitForSignal(t, fakeProgram.quit, \"tui quit\")\n\tselect {\n\tcase <-fakeProgram.events:\n\t\t// ok\n\tcase <-time.After(200 * time.Millisecond):\n\t\tt.Fatalf(\"expected event to be forwarded to TUI\")\n\t}\n}\n\nfunc TestRunOnceMainHeadlessDisablesTUI(t *testing.T) {\n\tcalled := false\n\tprevIsTerminal := isTerminal\n\tprevNewTUIProgram := newTUIProgram\n\tisTerminal = func(io.Writer) bool { return true }\n\tnewTUIProgram = func(stdout io.Writer) tuiProgram {\n\t\tcalled = true\n\t\treturn newFakeTUIProgram()\n\t}\n\tt.Cleanup(func() {\n\t\tisTerminal = prevIsTerminal\n\t\tnewTUIProgram = prevNewTUIProgram\n\t})\n\n\trunOnce := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\tstderr := &bytes.Buffer{}\n\n\tRunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\", \"--headless\"}, runOnce.Run, exit.Exit, out, stderr, beadsRunner, gitRunner)\n\n\tif called {\n\t\tt.Fatalf(\"expected TUI program not to start\")\n\t}\n\tif runOnce.deps.Events != nil {\n\t\tt.Fatalf(\"expected no events emitter in headless mode\")\n\t}\n}\n\nfunc TestOpenCodeRunDefaultsCreateConfigAndEnv(t *testing.T) {\n\ttempDir := t.TempDir()\n\trepoRoot := filepath.Join(tempDir, \"repo\")\n\tif err := os.MkdirAll(repoRoot, 0o755); err != nil {\n\t\tt.Fatalf(\"mkdir repo: %v\", err)\n\t}\n\tt.Setenv(\"HOME\", tempDir)\n\n\topenCodeRunner := &fakeOpenCodeRunner{}\n\topenCodeAdapter := openCodeAdapter{runner: openCodeRunner}\n\n\tconfigRoot := filepath.Join(tempDir, \".config\", \"opencode-runner\")\n\tconfigDir := filepath.Join(configRoot, \"opencode\")\n\tlogPath := filepath.Join(tempDir, \"runner-logs\", \"opencode\", \"issue-1.jsonl\")\n\n\tif err := openCodeAdapter.Run(\"issue-1\", repoRoot, \"prompt\", \"\", configRoot, configDir, logPath); err != nil {\n\t\tt.Fatalf(\"open code run error: %v\", err)\n\t}\n\n\tconfigFile := filepath.Join(configDir, \"opencode.json\")\n\tif _, err := os.Stat(configFile); err != nil {\n\t\tt.Fatalf(\"expected opencode.json to exist: %v\", err)\n\t}\n\texpectedConfigFile := filepath.Join(configDir, \"opencode.json\")\n\tif openCodeRunner.env[\"XDG_CONFIG_HOME\"] != configRoot {\n\t\tt.Fatalf(\"expected XDG_CONFIG_HOME set\")\n\t}\n\tif openCodeRunner.env[\"OPENCODE_CONFIG_DIR\"] != configDir {\n\t\tt.Fatalf(\"expected OPENCODE_CONFIG_DIR set\")\n\t}\n\tif openCodeRunner.env[\"OPENCODE_CONFIG\"] != expectedConfigFile {\n\t\tt.Fatalf(\"expected OPENCODE_CONFIG set\")\n\t}\n\tif openCodeRunner.env[\"OPENCODE_CONFIG_CONTENT\"] != \"{}\" {\n\t\tt.Fatalf(\"expected OPENCODE_CONFIG_CONTENT set\")\n\t}\n}\n","after":"package main\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"yolo-runner/internal/opencode\"\n\t\"yolo-runner/internal/runner\"\n)\n\ntype fakeRunner struct {\n\tcalls []string\n}\n\nfunc (f *fakeRunner) Run(args ...string) (string, error) {\n\tf.calls = append(f.calls, strings.Join(args, \" \"))\n\treturn \"\", nil\n}\n\ntype fakeOpenCodeRunLogger struct {\n\tcalled     bool\n\tissueID    string\n\trepoRoot   string\n\tprompt     string\n\tmodel      string\n\tconfigRoot string\n\tconfigDir  string\n\tlogPath    string\n}\n\nfunc (f *fakeOpenCodeRunLogger) Run(issueID string, repoRoot string, prompt string, model string, configRoot string, configDir string, logPath string) error {\n\tf.called = true\n\tf.issueID = issueID\n\tf.repoRoot = repoRoot\n\tf.prompt = prompt\n\tf.model = model\n\tf.configRoot = configRoot\n\tf.configDir = configDir\n\tf.logPath = logPath\n\treturn nil\n}\n\ntype fakeOpenCodeRunner struct {\n\tenv map[string]string\n}\n\ntype fakeOpenCodeProcess struct{}\n\nfunc (fakeOpenCodeProcess) Wait() error { return nil }\n\nfunc (fakeOpenCodeProcess) Kill() error { return nil }\n\nfunc (f *fakeOpenCodeRunner) Start(args []string, env map[string]string, stdoutPath string) (opencode.Process, error) {\n\tf.env = env\n\treturn fakeOpenCodeProcess{}, nil\n}\n\ntype fakeGitRunner struct {\n\tcalls  []string\n\toutput string\n\terr    error\n}\n\nfunc (f *fakeGitRunner) Run(name string, args ...string) (string, error) {\n\tf.calls = append(f.calls, name+\" \"+strings.Join(args, \" \"))\n\treturn f.output, f.err\n}\n\ntype fakeExit struct {\n\tcode int\n}\n\nfunc (f *fakeExit) Exit(code int) {\n\tf.code = code\n}\n\ntype fakeRunOnce struct {\n\tcalled bool\n\topts   runner.RunOnceOptions\n\tdeps   runner.RunOnceDeps\n\tresult string\n\terr    error\n}\n\nfunc (f *fakeRunOnce) Run(opts runner.RunOnceOptions, deps runner.RunOnceDeps) (string, error) {\n\n\tf.called = true\n\tf.opts = opts\n\tf.deps = deps\n\treturn f.result, f.err\n}\n\nfunc TestRunOnceMainReturnsErrorCodeOnFailure(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n\trunner := &fakeRunOnce{err: errors.New(\"boom\")}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\"}, runner.Run, exit.Exit, out, out, nil, nil)\n\n\tif code != 1 {\n\t\tt.Fatalf(\"expected exit code 1, got %d\", code)\n\t}\n\tif exit.code != 1 {\n\t\tt.Fatalf(\"expected exit to be called with 1, got %d\", exit.code)\n\t}\n\tif !strings.Contains(out.String(), \"boom\") {\n\t\tt.Fatalf(\"expected error output, got %q\", out.String())\n\t}\n}\n\nfunc TestRunOnceMainWiresDependencies(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tRunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\", \"--model\", \"model\", \"--dry-run\"}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif !runner.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n\tif runner.opts.RepoRoot != \"/repo\" || runner.opts.RootID != \"root\" || runner.opts.Model != \"model\" || !runner.opts.DryRun {\n\t\tt.Fatalf(\"unexpected options: %#v\", runner.opts)\n\t}\n\tif runner.opts.Out == nil {\n\t\tt.Fatalf(\"expected output writer\")\n\t}\n\tif runner.deps.Beads == nil || runner.deps.Git == nil || runner.deps.Prompt == nil || runner.deps.OpenCode == nil || runner.deps.Logger == nil {\n\t\tt.Fatalf(\"expected deps to be wired\")\n\t}\n\tif exit.code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", exit.code)\n\t}\n}\n\nfunc TestRunOnceMainDefaultsConfigPaths(t *testing.T) {\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tt.Setenv(\"HOME\", \"/home/user\")\n\n\tRunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\"}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif !runner.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n\tif runner.opts.ConfigRoot == \"\" {\n\t\tt.Fatalf(\"expected config root to be set\")\n\t}\n\tif runner.opts.ConfigDir == \"\" {\n\t\tt.Fatalf(\"expected config dir to be set\")\n\t}\n\texpectedConfigRoot := filepath.Join(\"/home/user\", \".config\", \"opencode-runner\")\n\tif runner.opts.ConfigRoot != expectedConfigRoot {\n\t\tt.Fatalf(\"expected config root %q, got %q\", expectedConfigRoot, runner.opts.ConfigRoot)\n\t}\n\texpectedConfigDir := filepath.Join(expectedConfigRoot, \"opencode\")\n\tif runner.opts.ConfigDir != expectedConfigDir {\n\t\tt.Fatalf(\"expected config dir %q, got %q\", expectedConfigDir, runner.opts.ConfigDir)\n\t}\n\tif exit.code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", exit.code)\n\t}\n}\n\nfunc TestRunOnceMainFailsWhenYoloAgentMissing(t *testing.T) {\n\ttempDir := t.TempDir()\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tstdout := &bytes.Buffer{}\n\tstderr := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\"}, runner.Run, exit.Exit, stdout, stderr, beadsRunner, gitRunner)\n\n\tif code != 1 {\n\t\tt.Fatalf(\"expected exit code 1, got %d\", code)\n\t}\n\tif exit.code != 1 {\n\t\tt.Fatalf(\"expected exit to be called with 1, got %d\", exit.code)\n\t}\n\tif runner.called {\n\t\tt.Fatalf(\"expected run once not to be called\")\n\t}\n\tif !strings.Contains(stderr.String(), \"yolo.md\") {\n\t\tt.Fatalf(\"expected error to mention yolo.md, got %q\", stderr.String())\n\t}\n}\n\nfunc TestRunOnceMainFailsWhenYoloAgentMissingPermission(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteAgentFile(t, tempDir, \"---\\nname: yolo\\n---\\n\")\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tstdout := &bytes.Buffer{}\n\tstderr := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\"}, runner.Run, exit.Exit, stdout, stderr, beadsRunner, gitRunner)\n\n\tif code != 1 {\n\t\tt.Fatalf(\"expected exit code 1, got %d\", code)\n\t}\n\tif exit.code != 1 {\n\t\tt.Fatalf(\"expected exit to be called with 1, got %d\", exit.code)\n\t}\n\tif runner.called {\n\t\tt.Fatalf(\"expected run once not to be called\")\n\t}\n\tif !strings.Contains(stderr.String(), \"permission: allow\") {\n\t\tt.Fatalf(\"expected error to mention permission allow, got %q\", stderr.String())\n\t}\n\tif !strings.Contains(strings.ToLower(stderr.String()), \"init\") {\n\t\tt.Fatalf(\"expected guidance to run init, got %q\", stderr.String())\n\t}\n}\n\nfunc TestRunOnceMainInfersRoadmapRootWhenMissing(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteIssuesFile(t, tempDir, `{\"id\":\"roadmap-1\",\"title\":\"Roadmap\",\"issue_type\":\"epic\",\"status\":\"open\"}`)\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", code)\n\t}\n\tif !runner.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n\tif runner.opts.RootID != \"roadmap-1\" {\n\t\tt.Fatalf(\"expected root id to be inferred, got %q\", runner.opts.RootID)\n\t}\n}\n\nfunc TestRunOnceMainInfersRoadmapRootWhenInProgress(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteIssuesFile(t, tempDir, `{\"id\":\"roadmap-2\",\"title\":\"Roadmap\",\"issue_type\":\"epic\",\"status\":\"in_progress\"}`)\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", code)\n\t}\n\tif !runner.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n\tif runner.opts.RootID != \"roadmap-2\" {\n\t\tt.Fatalf(\"expected root id to be inferred, got %q\", runner.opts.RootID)\n\t}\n}\n\nfunc TestRunOnceMainMissingRootRequiresExplicitFlag(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteIssuesFile(t, tempDir, `{\"id\":\"epic-1\",\"title\":\"Other\",\"issue_type\":\"epic\",\"status\":\"open\"}`)\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tstdout := &bytes.Buffer{}\n\tstderr := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir}, runner.Run, exit.Exit, stdout, stderr, beadsRunner, gitRunner)\n\n\tif code != 1 {\n\t\tt.Fatalf(\"expected exit code 1, got %d\", code)\n\t}\n\tif exit.code != 1 {\n\t\tt.Fatalf(\"expected exit to be called with 1, got %d\", exit.code)\n\t}\n\tif runner.called {\n\t\tt.Fatalf(\"expected run once not to be called\")\n\t}\n\tif !strings.Contains(stderr.String(), \"--root\") {\n\t\tt.Fatalf(\"expected error to mention --root, got %q\", stderr.String())\n\t}\n\tif !strings.Contains(strings.ToLower(stderr.String()), \"roadmap\") {\n\t\tt.Fatalf(\"expected error to mention roadmap, got %q\", stderr.String())\n\t}\n}\n\ntype fakeTUIProgram struct {\n\tstarted chan struct{}\n\tquit    chan struct{}\n\tevents  chan runner.Event\n}\n\nfunc newFakeTUIProgram() *fakeTUIProgram {\n\treturn &fakeTUIProgram{\n\t\tstarted: make(chan struct{}),\n\t\tquit:    make(chan struct{}),\n\t\tevents:  make(chan runner.Event, 1),\n\t}\n}\n\nfunc (f *fakeTUIProgram) Start() error {\n\tclose(f.started)\n\treturn nil\n}\n\nfunc (f *fakeTUIProgram) Send(event runner.Event) {\n\tf.events <- event\n}\n\nfunc (f *fakeTUIProgram) Quit() {\n\tclose(f.quit)\n}\n\nfunc waitForSignal(t *testing.T, signal chan struct{}, label string) {\n\tt.Helper()\n\tselect {\n\tcase <-signal:\n\t\treturn\n\tcase <-time.After(200 * time.Millisecond):\n\t\tt.Fatalf(\"expected %s\", label)\n\t}\n}\n\nfunc writeIssuesFile(t *testing.T, repoRoot string, payload string) {\n\tt.Helper()\n\tbeadsDir := filepath.Join(repoRoot, \".beads\")\n\tif err := os.MkdirAll(beadsDir, 0o755); err != nil {\n\t\tt.Fatalf(\"mkdir .beads: %v\", err)\n\t}\n\tissuesPath := filepath.Join(beadsDir, \"issues.jsonl\")\n\tif err := os.WriteFile(issuesPath, []byte(payload+\"\\n\"), 0o644); err != nil {\n\t\tt.Fatalf(\"write issues: %v\", err)\n\t}\n}\n\nfunc writeAgentFile(t *testing.T, repoRoot string, payload string) {\n\tt.Helper()\n\tagentDir := filepath.Join(repoRoot, \".opencode\", \"agent\")\n\tif err := os.MkdirAll(agentDir, 0o755); err != nil {\n\t\tt.Fatalf(\"mkdir agent dir: %v\", err)\n\t}\n\tagentPath := filepath.Join(agentDir, \"yolo.md\")\n\tif err := os.WriteFile(agentPath, []byte(payload), 0o644); err != nil {\n\t\tt.Fatalf(\"write agent file: %v\", err)\n\t}\n}\n\nfunc TestRunOnceMainUsesTUIOnTTYByDefault(t *testing.T) {\n\tfakeProgram := newFakeTUIProgram()\n\tprevIsTerminal := isTerminal\n\tprevNewTUIProgram := newTUIProgram\n\tisTerminal = func(io.Writer) bool { return true }\n\tnewTUIProgram = func(stdout io.Writer) tuiProgram { return fakeProgram }\n\tt.Cleanup(func() {\n\t\tisTerminal = prevIsTerminal\n\t\tnewTUIProgram = prevNewTUIProgram\n\t})\n\n\trunOnce := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\"}, runOnce.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", code)\n\t}\n\tif runOnce.deps.Events == nil {\n\t\tt.Fatalf(\"expected events emitter to be set\")\n\t}\n\trunOnce.deps.Events.Emit(runner.Event{Type: runner.EventSelectTask})\n\twaitForSignal(t, fakeProgram.started, \"tui start\")\n\twaitForSignal(t, fakeProgram.quit, \"tui quit\")\n\tselect {\n\tcase <-fakeProgram.events:\n\t\t// ok\n\tcase <-time.After(200 * time.Millisecond):\n\t\tt.Fatalf(\"expected event to be forwarded to TUI\")\n\t}\n}\n\nfunc TestRunOnceMainHeadlessDisablesTUI(t *testing.T) {\n\tcalled := false\n\tprevIsTerminal := isTerminal\n\tprevNewTUIProgram := newTUIProgram\n\tisTerminal = func(io.Writer) bool { return true }\n\tnewTUIProgram = func(stdout io.Writer) tuiProgram {\n\t\tcalled = true\n\t\treturn newFakeTUIProgram()\n\t}\n\tt.Cleanup(func() {\n\t\tisTerminal = prevIsTerminal\n\t\tnewTUIProgram = prevNewTUIProgram\n\t})\n\n\trunOnce := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\tstderr := &bytes.Buffer{}\n\n\tRunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\", \"--headless\"}, runOnce.Run, exit.Exit, out, stderr, beadsRunner, gitRunner)\n\n\tif called {\n\t\tt.Fatalf(\"expected TUI program not to start\")\n\t}\n\tif runOnce.deps.Events != nil {\n\t\tt.Fatalf(\"expected no events emitter in headless mode\")\n\t}\n}\n\nfunc TestOpenCodeRunDefaultsCreateConfigAndEnv(t *testing.T) {\n\ttempDir := t.TempDir()\n\trepoRoot := filepath.Join(tempDir, \"repo\")\n\tif err := os.MkdirAll(repoRoot, 0o755); err != nil {\n\t\tt.Fatalf(\"mkdir repo: %v\", err)\n\t}\n\tt.Setenv(\"HOME\", tempDir)\n\n\topenCodeRunner := &fakeOpenCodeRunner{}\n\topenCodeAdapter := openCodeAdapter{runner: openCodeRunner}\n\n\tconfigRoot := filepath.Join(tempDir, \".config\", \"opencode-runner\")\n\tconfigDir := filepath.Join(configRoot, \"opencode\")\n\tlogPath := filepath.Join(tempDir, \"runner-logs\", \"opencode\", \"issue-1.jsonl\")\n\n\tif err := openCodeAdapter.Run(\"issue-1\", repoRoot, \"prompt\", \"\", configRoot, configDir, logPath); err != nil {\n\t\tt.Fatalf(\"open code run error: %v\", err)\n\t}\n\n\tconfigFile := filepath.Join(configDir, \"opencode.json\")\n\tif _, err := os.Stat(configFile); err != nil {\n\t\tt.Fatalf(\"expected opencode.json to exist: %v\", err)\n\t}\n\texpectedConfigFile := filepath.Join(configDir, \"opencode.json\")\n\tif openCodeRunner.env[\"XDG_CONFIG_HOME\"] != configRoot {\n\t\tt.Fatalf(\"expected XDG_CONFIG_HOME set\")\n\t}\n\tif openCodeRunner.env[\"OPENCODE_CONFIG_DIR\"] != configDir {\n\t\tt.Fatalf(\"expected OPENCODE_CONFIG_DIR set\")\n\t}\n\tif openCodeRunner.env[\"OPENCODE_CONFIG\"] != expectedConfigFile {\n\t\tt.Fatalf(\"expected OPENCODE_CONFIG set\")\n\t}\n\tif openCodeRunner.env[\"OPENCODE_CONFIG_CONTENT\"] != \"{}\" {\n\t\tt.Fatalf(\"expected OPENCODE_CONFIG_CONTENT set\")\n\t}\n}\n","additions":3,"deletions":1},"truncated":false},"time":{"start":1768850759158,"end":1768850759319}},"metadata":{"openai":{"itemId":"fc_04fbbdfc1dca7c8301696e85426a84819189597a68cf4e1877"}}}}
{"type":"step_finish","timestamp":1768850759340,"sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","part":{"id":"prt_bd7b89e980016zLcUbgsRfJ8Bn","sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","messageID":"msg_bd7b88615001SSy9vq7zOxJvwV","type":"step-finish","reason":"tool-calls","snapshot":"717bb454a01340b61901e5cd2276be5aea4bc019","cost":0,"tokens":{"input":761,"output":289,"reasoning":0,"cache":{"read":25216,"write":0}}}}
{"type":"step_start","timestamp":1768850759622,"sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","part":{"id":"prt_bd7b89fc5001wU8hyMXTWlYcCR","sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","messageID":"msg_bd7b89ec00018ycCxvkm567dwF","type":"step-start","snapshot":"5c468e0dd818cf81293787a2b50cfcf1b710df0a"}}
{"type":"tool_use","timestamp":1768850765002,"sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","part":{"id":"prt_bd7b8a1ce001ITmHbsCgNLz1cX","sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","messageID":"msg_bd7b89ec00018ycCxvkm567dwF","type":"tool","callID":"call_1qkj8ZkeWfYilW51MBlnnjUN","tool":"edit","state":{"status":"completed","input":{"filePath":"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go","oldString":"\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tt.Setenv(\"HOME\", \"/home/user\")\n\n\tRunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\"}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n","newString":"\ttempDir := t.TempDir()\n\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tt.Setenv(\"HOME\", \"/home/user\")\n\n\tRunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\"}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n"},"output":"Edit applied successfully.","title":"cmd/yolo-runner/main_test.go","metadata":{"diagnostics":{"/Users/egv/dev/yolo-runner/internal/opencode/client.go":[{"range":{"start":{"line":28,"character":1},"end":{"line":28,"character":18}},"severity":2,"code":"default","codeDescription":{"href":"https://staticcheck.dev/docs/checks/#S1031"},"source":"S1031","message":"unnecessary nil check around range"}],"/Users/egv/dev/yolo-runner/internal/opencode/watchdog.go":[],"/Users/egv/dev/yolo-runner/go.mod":[{"range":{"start":{"line":6,"character":44},"end":{"line":6,"character":55}},"severity":2,"source":"go mod tidy","message":"github.com/charmbracelet/bubbletea should be direct"},{"range":{"start":{"line":19,"character":26},"end":{"line":19,"character":37}},"severity":2,"source":"go mod tidy","message":"golang.org/x/term should be direct"}],"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main.go":[],"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go":[],"/Users/egv/dev/yolo-runner/cmd/yolo-runner/exec_test.go":[],"/Users/egv/dev/yolo-runner/internal/opencode/agent_test.go":[],"/Users/egv/dev/yolo-runner/internal/opencode/agent.go":[]},"diff":"Index: /Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go\n===================================================================\n--- /Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go\n+++ /Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go\n@@ -144,17 +144,19 @@\n \t}\n }\n \n func TestRunOnceMainDefaultsConfigPaths(t *testing.T) {\n+\ttempDir := t.TempDir()\n+\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n \trunner := &fakeRunOnce{result: \"no_tasks\"}\n \texit := &fakeExit{}\n \tout := &bytes.Buffer{}\n \tbeadsRunner := &fakeRunner{}\n \tgitRunner := &fakeGitRunner{}\n \n \tt.Setenv(\"HOME\", \"/home/user\")\n \n-\tRunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\"}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n+\tRunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\"}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n \n \tif !runner.called {\n \t\tt.Fatalf(\"expected run once to be called\")\n \t}\n","filediff":{"file":"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go","before":"package main\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"yolo-runner/internal/opencode\"\n\t\"yolo-runner/internal/runner\"\n)\n\ntype fakeRunner struct {\n\tcalls []string\n}\n\nfunc (f *fakeRunner) Run(args ...string) (string, error) {\n\tf.calls = append(f.calls, strings.Join(args, \" \"))\n\treturn \"\", nil\n}\n\ntype fakeOpenCodeRunLogger struct {\n\tcalled     bool\n\tissueID    string\n\trepoRoot   string\n\tprompt     string\n\tmodel      string\n\tconfigRoot string\n\tconfigDir  string\n\tlogPath    string\n}\n\nfunc (f *fakeOpenCodeRunLogger) Run(issueID string, repoRoot string, prompt string, model string, configRoot string, configDir string, logPath string) error {\n\tf.called = true\n\tf.issueID = issueID\n\tf.repoRoot = repoRoot\n\tf.prompt = prompt\n\tf.model = model\n\tf.configRoot = configRoot\n\tf.configDir = configDir\n\tf.logPath = logPath\n\treturn nil\n}\n\ntype fakeOpenCodeRunner struct {\n\tenv map[string]string\n}\n\ntype fakeOpenCodeProcess struct{}\n\nfunc (fakeOpenCodeProcess) Wait() error { return nil }\n\nfunc (fakeOpenCodeProcess) Kill() error { return nil }\n\nfunc (f *fakeOpenCodeRunner) Start(args []string, env map[string]string, stdoutPath string) (opencode.Process, error) {\n\tf.env = env\n\treturn fakeOpenCodeProcess{}, nil\n}\n\ntype fakeGitRunner struct {\n\tcalls  []string\n\toutput string\n\terr    error\n}\n\nfunc (f *fakeGitRunner) Run(name string, args ...string) (string, error) {\n\tf.calls = append(f.calls, name+\" \"+strings.Join(args, \" \"))\n\treturn f.output, f.err\n}\n\ntype fakeExit struct {\n\tcode int\n}\n\nfunc (f *fakeExit) Exit(code int) {\n\tf.code = code\n}\n\ntype fakeRunOnce struct {\n\tcalled bool\n\topts   runner.RunOnceOptions\n\tdeps   runner.RunOnceDeps\n\tresult string\n\terr    error\n}\n\nfunc (f *fakeRunOnce) Run(opts runner.RunOnceOptions, deps runner.RunOnceDeps) (string, error) {\n\n\tf.called = true\n\tf.opts = opts\n\tf.deps = deps\n\treturn f.result, f.err\n}\n\nfunc TestRunOnceMainReturnsErrorCodeOnFailure(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n\trunner := &fakeRunOnce{err: errors.New(\"boom\")}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\"}, runner.Run, exit.Exit, out, out, nil, nil)\n\n\tif code != 1 {\n\t\tt.Fatalf(\"expected exit code 1, got %d\", code)\n\t}\n\tif exit.code != 1 {\n\t\tt.Fatalf(\"expected exit to be called with 1, got %d\", exit.code)\n\t}\n\tif !strings.Contains(out.String(), \"boom\") {\n\t\tt.Fatalf(\"expected error output, got %q\", out.String())\n\t}\n}\n\nfunc TestRunOnceMainWiresDependencies(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tRunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\", \"--model\", \"model\", \"--dry-run\"}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif !runner.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n\tif runner.opts.RepoRoot != \"/repo\" || runner.opts.RootID != \"root\" || runner.opts.Model != \"model\" || !runner.opts.DryRun {\n\t\tt.Fatalf(\"unexpected options: %#v\", runner.opts)\n\t}\n\tif runner.opts.Out == nil {\n\t\tt.Fatalf(\"expected output writer\")\n\t}\n\tif runner.deps.Beads == nil || runner.deps.Git == nil || runner.deps.Prompt == nil || runner.deps.OpenCode == nil || runner.deps.Logger == nil {\n\t\tt.Fatalf(\"expected deps to be wired\")\n\t}\n\tif exit.code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", exit.code)\n\t}\n}\n\nfunc TestRunOnceMainDefaultsConfigPaths(t *testing.T) {\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tt.Setenv(\"HOME\", \"/home/user\")\n\n\tRunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\"}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif !runner.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n\tif runner.opts.ConfigRoot == \"\" {\n\t\tt.Fatalf(\"expected config root to be set\")\n\t}\n\tif runner.opts.ConfigDir == \"\" {\n\t\tt.Fatalf(\"expected config dir to be set\")\n\t}\n\texpectedConfigRoot := filepath.Join(\"/home/user\", \".config\", \"opencode-runner\")\n\tif runner.opts.ConfigRoot != expectedConfigRoot {\n\t\tt.Fatalf(\"expected config root %q, got %q\", expectedConfigRoot, runner.opts.ConfigRoot)\n\t}\n\texpectedConfigDir := filepath.Join(expectedConfigRoot, \"opencode\")\n\tif runner.opts.ConfigDir != expectedConfigDir {\n\t\tt.Fatalf(\"expected config dir %q, got %q\", expectedConfigDir, runner.opts.ConfigDir)\n\t}\n\tif exit.code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", exit.code)\n\t}\n}\n\nfunc TestRunOnceMainFailsWhenYoloAgentMissing(t *testing.T) {\n\ttempDir := t.TempDir()\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tstdout := &bytes.Buffer{}\n\tstderr := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\"}, runner.Run, exit.Exit, stdout, stderr, beadsRunner, gitRunner)\n\n\tif code != 1 {\n\t\tt.Fatalf(\"expected exit code 1, got %d\", code)\n\t}\n\tif exit.code != 1 {\n\t\tt.Fatalf(\"expected exit to be called with 1, got %d\", exit.code)\n\t}\n\tif runner.called {\n\t\tt.Fatalf(\"expected run once not to be called\")\n\t}\n\tif !strings.Contains(stderr.String(), \"yolo.md\") {\n\t\tt.Fatalf(\"expected error to mention yolo.md, got %q\", stderr.String())\n\t}\n}\n\nfunc TestRunOnceMainFailsWhenYoloAgentMissingPermission(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteAgentFile(t, tempDir, \"---\\nname: yolo\\n---\\n\")\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tstdout := &bytes.Buffer{}\n\tstderr := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\"}, runner.Run, exit.Exit, stdout, stderr, beadsRunner, gitRunner)\n\n\tif code != 1 {\n\t\tt.Fatalf(\"expected exit code 1, got %d\", code)\n\t}\n\tif exit.code != 1 {\n\t\tt.Fatalf(\"expected exit to be called with 1, got %d\", exit.code)\n\t}\n\tif runner.called {\n\t\tt.Fatalf(\"expected run once not to be called\")\n\t}\n\tif !strings.Contains(stderr.String(), \"permission: allow\") {\n\t\tt.Fatalf(\"expected error to mention permission allow, got %q\", stderr.String())\n\t}\n\tif !strings.Contains(strings.ToLower(stderr.String()), \"init\") {\n\t\tt.Fatalf(\"expected guidance to run init, got %q\", stderr.String())\n\t}\n}\n\nfunc TestRunOnceMainInfersRoadmapRootWhenMissing(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteIssuesFile(t, tempDir, `{\"id\":\"roadmap-1\",\"title\":\"Roadmap\",\"issue_type\":\"epic\",\"status\":\"open\"}`)\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", code)\n\t}\n\tif !runner.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n\tif runner.opts.RootID != \"roadmap-1\" {\n\t\tt.Fatalf(\"expected root id to be inferred, got %q\", runner.opts.RootID)\n\t}\n}\n\nfunc TestRunOnceMainInfersRoadmapRootWhenInProgress(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteIssuesFile(t, tempDir, `{\"id\":\"roadmap-2\",\"title\":\"Roadmap\",\"issue_type\":\"epic\",\"status\":\"in_progress\"}`)\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", code)\n\t}\n\tif !runner.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n\tif runner.opts.RootID != \"roadmap-2\" {\n\t\tt.Fatalf(\"expected root id to be inferred, got %q\", runner.opts.RootID)\n\t}\n}\n\nfunc TestRunOnceMainMissingRootRequiresExplicitFlag(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteIssuesFile(t, tempDir, `{\"id\":\"epic-1\",\"title\":\"Other\",\"issue_type\":\"epic\",\"status\":\"open\"}`)\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tstdout := &bytes.Buffer{}\n\tstderr := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir}, runner.Run, exit.Exit, stdout, stderr, beadsRunner, gitRunner)\n\n\tif code != 1 {\n\t\tt.Fatalf(\"expected exit code 1, got %d\", code)\n\t}\n\tif exit.code != 1 {\n\t\tt.Fatalf(\"expected exit to be called with 1, got %d\", exit.code)\n\t}\n\tif runner.called {\n\t\tt.Fatalf(\"expected run once not to be called\")\n\t}\n\tif !strings.Contains(stderr.String(), \"--root\") {\n\t\tt.Fatalf(\"expected error to mention --root, got %q\", stderr.String())\n\t}\n\tif !strings.Contains(strings.ToLower(stderr.String()), \"roadmap\") {\n\t\tt.Fatalf(\"expected error to mention roadmap, got %q\", stderr.String())\n\t}\n}\n\ntype fakeTUIProgram struct {\n\tstarted chan struct{}\n\tquit    chan struct{}\n\tevents  chan runner.Event\n}\n\nfunc newFakeTUIProgram() *fakeTUIProgram {\n\treturn &fakeTUIProgram{\n\t\tstarted: make(chan struct{}),\n\t\tquit:    make(chan struct{}),\n\t\tevents:  make(chan runner.Event, 1),\n\t}\n}\n\nfunc (f *fakeTUIProgram) Start() error {\n\tclose(f.started)\n\treturn nil\n}\n\nfunc (f *fakeTUIProgram) Send(event runner.Event) {\n\tf.events <- event\n}\n\nfunc (f *fakeTUIProgram) Quit() {\n\tclose(f.quit)\n}\n\nfunc waitForSignal(t *testing.T, signal chan struct{}, label string) {\n\tt.Helper()\n\tselect {\n\tcase <-signal:\n\t\treturn\n\tcase <-time.After(200 * time.Millisecond):\n\t\tt.Fatalf(\"expected %s\", label)\n\t}\n}\n\nfunc writeIssuesFile(t *testing.T, repoRoot string, payload string) {\n\tt.Helper()\n\tbeadsDir := filepath.Join(repoRoot, \".beads\")\n\tif err := os.MkdirAll(beadsDir, 0o755); err != nil {\n\t\tt.Fatalf(\"mkdir .beads: %v\", err)\n\t}\n\tissuesPath := filepath.Join(beadsDir, \"issues.jsonl\")\n\tif err := os.WriteFile(issuesPath, []byte(payload+\"\\n\"), 0o644); err != nil {\n\t\tt.Fatalf(\"write issues: %v\", err)\n\t}\n}\n\nfunc writeAgentFile(t *testing.T, repoRoot string, payload string) {\n\tt.Helper()\n\tagentDir := filepath.Join(repoRoot, \".opencode\", \"agent\")\n\tif err := os.MkdirAll(agentDir, 0o755); err != nil {\n\t\tt.Fatalf(\"mkdir agent dir: %v\", err)\n\t}\n\tagentPath := filepath.Join(agentDir, \"yolo.md\")\n\tif err := os.WriteFile(agentPath, []byte(payload), 0o644); err != nil {\n\t\tt.Fatalf(\"write agent file: %v\", err)\n\t}\n}\n\nfunc TestRunOnceMainUsesTUIOnTTYByDefault(t *testing.T) {\n\tfakeProgram := newFakeTUIProgram()\n\tprevIsTerminal := isTerminal\n\tprevNewTUIProgram := newTUIProgram\n\tisTerminal = func(io.Writer) bool { return true }\n\tnewTUIProgram = func(stdout io.Writer) tuiProgram { return fakeProgram }\n\tt.Cleanup(func() {\n\t\tisTerminal = prevIsTerminal\n\t\tnewTUIProgram = prevNewTUIProgram\n\t})\n\n\trunOnce := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\"}, runOnce.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", code)\n\t}\n\tif runOnce.deps.Events == nil {\n\t\tt.Fatalf(\"expected events emitter to be set\")\n\t}\n\trunOnce.deps.Events.Emit(runner.Event{Type: runner.EventSelectTask})\n\twaitForSignal(t, fakeProgram.started, \"tui start\")\n\twaitForSignal(t, fakeProgram.quit, \"tui quit\")\n\tselect {\n\tcase <-fakeProgram.events:\n\t\t// ok\n\tcase <-time.After(200 * time.Millisecond):\n\t\tt.Fatalf(\"expected event to be forwarded to TUI\")\n\t}\n}\n\nfunc TestRunOnceMainHeadlessDisablesTUI(t *testing.T) {\n\tcalled := false\n\tprevIsTerminal := isTerminal\n\tprevNewTUIProgram := newTUIProgram\n\tisTerminal = func(io.Writer) bool { return true }\n\tnewTUIProgram = func(stdout io.Writer) tuiProgram {\n\t\tcalled = true\n\t\treturn newFakeTUIProgram()\n\t}\n\tt.Cleanup(func() {\n\t\tisTerminal = prevIsTerminal\n\t\tnewTUIProgram = prevNewTUIProgram\n\t})\n\n\trunOnce := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\tstderr := &bytes.Buffer{}\n\n\tRunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\", \"--headless\"}, runOnce.Run, exit.Exit, out, stderr, beadsRunner, gitRunner)\n\n\tif called {\n\t\tt.Fatalf(\"expected TUI program not to start\")\n\t}\n\tif runOnce.deps.Events != nil {\n\t\tt.Fatalf(\"expected no events emitter in headless mode\")\n\t}\n}\n\nfunc TestOpenCodeRunDefaultsCreateConfigAndEnv(t *testing.T) {\n\ttempDir := t.TempDir()\n\trepoRoot := filepath.Join(tempDir, \"repo\")\n\tif err := os.MkdirAll(repoRoot, 0o755); err != nil {\n\t\tt.Fatalf(\"mkdir repo: %v\", err)\n\t}\n\tt.Setenv(\"HOME\", tempDir)\n\n\topenCodeRunner := &fakeOpenCodeRunner{}\n\topenCodeAdapter := openCodeAdapter{runner: openCodeRunner}\n\n\tconfigRoot := filepath.Join(tempDir, \".config\", \"opencode-runner\")\n\tconfigDir := filepath.Join(configRoot, \"opencode\")\n\tlogPath := filepath.Join(tempDir, \"runner-logs\", \"opencode\", \"issue-1.jsonl\")\n\n\tif err := openCodeAdapter.Run(\"issue-1\", repoRoot, \"prompt\", \"\", configRoot, configDir, logPath); err != nil {\n\t\tt.Fatalf(\"open code run error: %v\", err)\n\t}\n\n\tconfigFile := filepath.Join(configDir, \"opencode.json\")\n\tif _, err := os.Stat(configFile); err != nil {\n\t\tt.Fatalf(\"expected opencode.json to exist: %v\", err)\n\t}\n\texpectedConfigFile := filepath.Join(configDir, \"opencode.json\")\n\tif openCodeRunner.env[\"XDG_CONFIG_HOME\"] != configRoot {\n\t\tt.Fatalf(\"expected XDG_CONFIG_HOME set\")\n\t}\n\tif openCodeRunner.env[\"OPENCODE_CONFIG_DIR\"] != configDir {\n\t\tt.Fatalf(\"expected OPENCODE_CONFIG_DIR set\")\n\t}\n\tif openCodeRunner.env[\"OPENCODE_CONFIG\"] != expectedConfigFile {\n\t\tt.Fatalf(\"expected OPENCODE_CONFIG set\")\n\t}\n\tif openCodeRunner.env[\"OPENCODE_CONFIG_CONTENT\"] != \"{}\" {\n\t\tt.Fatalf(\"expected OPENCODE_CONFIG_CONTENT set\")\n\t}\n}\n","after":"package main\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"yolo-runner/internal/opencode\"\n\t\"yolo-runner/internal/runner\"\n)\n\ntype fakeRunner struct {\n\tcalls []string\n}\n\nfunc (f *fakeRunner) Run(args ...string) (string, error) {\n\tf.calls = append(f.calls, strings.Join(args, \" \"))\n\treturn \"\", nil\n}\n\ntype fakeOpenCodeRunLogger struct {\n\tcalled     bool\n\tissueID    string\n\trepoRoot   string\n\tprompt     string\n\tmodel      string\n\tconfigRoot string\n\tconfigDir  string\n\tlogPath    string\n}\n\nfunc (f *fakeOpenCodeRunLogger) Run(issueID string, repoRoot string, prompt string, model string, configRoot string, configDir string, logPath string) error {\n\tf.called = true\n\tf.issueID = issueID\n\tf.repoRoot = repoRoot\n\tf.prompt = prompt\n\tf.model = model\n\tf.configRoot = configRoot\n\tf.configDir = configDir\n\tf.logPath = logPath\n\treturn nil\n}\n\ntype fakeOpenCodeRunner struct {\n\tenv map[string]string\n}\n\ntype fakeOpenCodeProcess struct{}\n\nfunc (fakeOpenCodeProcess) Wait() error { return nil }\n\nfunc (fakeOpenCodeProcess) Kill() error { return nil }\n\nfunc (f *fakeOpenCodeRunner) Start(args []string, env map[string]string, stdoutPath string) (opencode.Process, error) {\n\tf.env = env\n\treturn fakeOpenCodeProcess{}, nil\n}\n\ntype fakeGitRunner struct {\n\tcalls  []string\n\toutput string\n\terr    error\n}\n\nfunc (f *fakeGitRunner) Run(name string, args ...string) (string, error) {\n\tf.calls = append(f.calls, name+\" \"+strings.Join(args, \" \"))\n\treturn f.output, f.err\n}\n\ntype fakeExit struct {\n\tcode int\n}\n\nfunc (f *fakeExit) Exit(code int) {\n\tf.code = code\n}\n\ntype fakeRunOnce struct {\n\tcalled bool\n\topts   runner.RunOnceOptions\n\tdeps   runner.RunOnceDeps\n\tresult string\n\terr    error\n}\n\nfunc (f *fakeRunOnce) Run(opts runner.RunOnceOptions, deps runner.RunOnceDeps) (string, error) {\n\n\tf.called = true\n\tf.opts = opts\n\tf.deps = deps\n\treturn f.result, f.err\n}\n\nfunc TestRunOnceMainReturnsErrorCodeOnFailure(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n\trunner := &fakeRunOnce{err: errors.New(\"boom\")}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\"}, runner.Run, exit.Exit, out, out, nil, nil)\n\n\tif code != 1 {\n\t\tt.Fatalf(\"expected exit code 1, got %d\", code)\n\t}\n\tif exit.code != 1 {\n\t\tt.Fatalf(\"expected exit to be called with 1, got %d\", exit.code)\n\t}\n\tif !strings.Contains(out.String(), \"boom\") {\n\t\tt.Fatalf(\"expected error output, got %q\", out.String())\n\t}\n}\n\nfunc TestRunOnceMainWiresDependencies(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tRunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\", \"--model\", \"model\", \"--dry-run\"}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif !runner.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n\tif runner.opts.RepoRoot != \"/repo\" || runner.opts.RootID != \"root\" || runner.opts.Model != \"model\" || !runner.opts.DryRun {\n\t\tt.Fatalf(\"unexpected options: %#v\", runner.opts)\n\t}\n\tif runner.opts.Out == nil {\n\t\tt.Fatalf(\"expected output writer\")\n\t}\n\tif runner.deps.Beads == nil || runner.deps.Git == nil || runner.deps.Prompt == nil || runner.deps.OpenCode == nil || runner.deps.Logger == nil {\n\t\tt.Fatalf(\"expected deps to be wired\")\n\t}\n\tif exit.code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", exit.code)\n\t}\n}\n\nfunc TestRunOnceMainDefaultsConfigPaths(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tt.Setenv(\"HOME\", \"/home/user\")\n\n\tRunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\"}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif !runner.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n\tif runner.opts.ConfigRoot == \"\" {\n\t\tt.Fatalf(\"expected config root to be set\")\n\t}\n\tif runner.opts.ConfigDir == \"\" {\n\t\tt.Fatalf(\"expected config dir to be set\")\n\t}\n\texpectedConfigRoot := filepath.Join(\"/home/user\", \".config\", \"opencode-runner\")\n\tif runner.opts.ConfigRoot != expectedConfigRoot {\n\t\tt.Fatalf(\"expected config root %q, got %q\", expectedConfigRoot, runner.opts.ConfigRoot)\n\t}\n\texpectedConfigDir := filepath.Join(expectedConfigRoot, \"opencode\")\n\tif runner.opts.ConfigDir != expectedConfigDir {\n\t\tt.Fatalf(\"expected config dir %q, got %q\", expectedConfigDir, runner.opts.ConfigDir)\n\t}\n\tif exit.code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", exit.code)\n\t}\n}\n\nfunc TestRunOnceMainFailsWhenYoloAgentMissing(t *testing.T) {\n\ttempDir := t.TempDir()\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tstdout := &bytes.Buffer{}\n\tstderr := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\"}, runner.Run, exit.Exit, stdout, stderr, beadsRunner, gitRunner)\n\n\tif code != 1 {\n\t\tt.Fatalf(\"expected exit code 1, got %d\", code)\n\t}\n\tif exit.code != 1 {\n\t\tt.Fatalf(\"expected exit to be called with 1, got %d\", exit.code)\n\t}\n\tif runner.called {\n\t\tt.Fatalf(\"expected run once not to be called\")\n\t}\n\tif !strings.Contains(stderr.String(), \"yolo.md\") {\n\t\tt.Fatalf(\"expected error to mention yolo.md, got %q\", stderr.String())\n\t}\n}\n\nfunc TestRunOnceMainFailsWhenYoloAgentMissingPermission(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteAgentFile(t, tempDir, \"---\\nname: yolo\\n---\\n\")\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tstdout := &bytes.Buffer{}\n\tstderr := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\"}, runner.Run, exit.Exit, stdout, stderr, beadsRunner, gitRunner)\n\n\tif code != 1 {\n\t\tt.Fatalf(\"expected exit code 1, got %d\", code)\n\t}\n\tif exit.code != 1 {\n\t\tt.Fatalf(\"expected exit to be called with 1, got %d\", exit.code)\n\t}\n\tif runner.called {\n\t\tt.Fatalf(\"expected run once not to be called\")\n\t}\n\tif !strings.Contains(stderr.String(), \"permission: allow\") {\n\t\tt.Fatalf(\"expected error to mention permission allow, got %q\", stderr.String())\n\t}\n\tif !strings.Contains(strings.ToLower(stderr.String()), \"init\") {\n\t\tt.Fatalf(\"expected guidance to run init, got %q\", stderr.String())\n\t}\n}\n\nfunc TestRunOnceMainInfersRoadmapRootWhenMissing(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteIssuesFile(t, tempDir, `{\"id\":\"roadmap-1\",\"title\":\"Roadmap\",\"issue_type\":\"epic\",\"status\":\"open\"}`)\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", code)\n\t}\n\tif !runner.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n\tif runner.opts.RootID != \"roadmap-1\" {\n\t\tt.Fatalf(\"expected root id to be inferred, got %q\", runner.opts.RootID)\n\t}\n}\n\nfunc TestRunOnceMainInfersRoadmapRootWhenInProgress(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteIssuesFile(t, tempDir, `{\"id\":\"roadmap-2\",\"title\":\"Roadmap\",\"issue_type\":\"epic\",\"status\":\"in_progress\"}`)\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", code)\n\t}\n\tif !runner.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n\tif runner.opts.RootID != \"roadmap-2\" {\n\t\tt.Fatalf(\"expected root id to be inferred, got %q\", runner.opts.RootID)\n\t}\n}\n\nfunc TestRunOnceMainMissingRootRequiresExplicitFlag(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteIssuesFile(t, tempDir, `{\"id\":\"epic-1\",\"title\":\"Other\",\"issue_type\":\"epic\",\"status\":\"open\"}`)\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tstdout := &bytes.Buffer{}\n\tstderr := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir}, runner.Run, exit.Exit, stdout, stderr, beadsRunner, gitRunner)\n\n\tif code != 1 {\n\t\tt.Fatalf(\"expected exit code 1, got %d\", code)\n\t}\n\tif exit.code != 1 {\n\t\tt.Fatalf(\"expected exit to be called with 1, got %d\", exit.code)\n\t}\n\tif runner.called {\n\t\tt.Fatalf(\"expected run once not to be called\")\n\t}\n\tif !strings.Contains(stderr.String(), \"--root\") {\n\t\tt.Fatalf(\"expected error to mention --root, got %q\", stderr.String())\n\t}\n\tif !strings.Contains(strings.ToLower(stderr.String()), \"roadmap\") {\n\t\tt.Fatalf(\"expected error to mention roadmap, got %q\", stderr.String())\n\t}\n}\n\ntype fakeTUIProgram struct {\n\tstarted chan struct{}\n\tquit    chan struct{}\n\tevents  chan runner.Event\n}\n\nfunc newFakeTUIProgram() *fakeTUIProgram {\n\treturn &fakeTUIProgram{\n\t\tstarted: make(chan struct{}),\n\t\tquit:    make(chan struct{}),\n\t\tevents:  make(chan runner.Event, 1),\n\t}\n}\n\nfunc (f *fakeTUIProgram) Start() error {\n\tclose(f.started)\n\treturn nil\n}\n\nfunc (f *fakeTUIProgram) Send(event runner.Event) {\n\tf.events <- event\n}\n\nfunc (f *fakeTUIProgram) Quit() {\n\tclose(f.quit)\n}\n\nfunc waitForSignal(t *testing.T, signal chan struct{}, label string) {\n\tt.Helper()\n\tselect {\n\tcase <-signal:\n\t\treturn\n\tcase <-time.After(200 * time.Millisecond):\n\t\tt.Fatalf(\"expected %s\", label)\n\t}\n}\n\nfunc writeIssuesFile(t *testing.T, repoRoot string, payload string) {\n\tt.Helper()\n\tbeadsDir := filepath.Join(repoRoot, \".beads\")\n\tif err := os.MkdirAll(beadsDir, 0o755); err != nil {\n\t\tt.Fatalf(\"mkdir .beads: %v\", err)\n\t}\n\tissuesPath := filepath.Join(beadsDir, \"issues.jsonl\")\n\tif err := os.WriteFile(issuesPath, []byte(payload+\"\\n\"), 0o644); err != nil {\n\t\tt.Fatalf(\"write issues: %v\", err)\n\t}\n}\n\nfunc writeAgentFile(t *testing.T, repoRoot string, payload string) {\n\tt.Helper()\n\tagentDir := filepath.Join(repoRoot, \".opencode\", \"agent\")\n\tif err := os.MkdirAll(agentDir, 0o755); err != nil {\n\t\tt.Fatalf(\"mkdir agent dir: %v\", err)\n\t}\n\tagentPath := filepath.Join(agentDir, \"yolo.md\")\n\tif err := os.WriteFile(agentPath, []byte(payload), 0o644); err != nil {\n\t\tt.Fatalf(\"write agent file: %v\", err)\n\t}\n}\n\nfunc TestRunOnceMainUsesTUIOnTTYByDefault(t *testing.T) {\n\tfakeProgram := newFakeTUIProgram()\n\tprevIsTerminal := isTerminal\n\tprevNewTUIProgram := newTUIProgram\n\tisTerminal = func(io.Writer) bool { return true }\n\tnewTUIProgram = func(stdout io.Writer) tuiProgram { return fakeProgram }\n\tt.Cleanup(func() {\n\t\tisTerminal = prevIsTerminal\n\t\tnewTUIProgram = prevNewTUIProgram\n\t})\n\n\trunOnce := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\"}, runOnce.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", code)\n\t}\n\tif runOnce.deps.Events == nil {\n\t\tt.Fatalf(\"expected events emitter to be set\")\n\t}\n\trunOnce.deps.Events.Emit(runner.Event{Type: runner.EventSelectTask})\n\twaitForSignal(t, fakeProgram.started, \"tui start\")\n\twaitForSignal(t, fakeProgram.quit, \"tui quit\")\n\tselect {\n\tcase <-fakeProgram.events:\n\t\t// ok\n\tcase <-time.After(200 * time.Millisecond):\n\t\tt.Fatalf(\"expected event to be forwarded to TUI\")\n\t}\n}\n\nfunc TestRunOnceMainHeadlessDisablesTUI(t *testing.T) {\n\tcalled := false\n\tprevIsTerminal := isTerminal\n\tprevNewTUIProgram := newTUIProgram\n\tisTerminal = func(io.Writer) bool { return true }\n\tnewTUIProgram = func(stdout io.Writer) tuiProgram {\n\t\tcalled = true\n\t\treturn newFakeTUIProgram()\n\t}\n\tt.Cleanup(func() {\n\t\tisTerminal = prevIsTerminal\n\t\tnewTUIProgram = prevNewTUIProgram\n\t})\n\n\trunOnce := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\tstderr := &bytes.Buffer{}\n\n\tRunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\", \"--headless\"}, runOnce.Run, exit.Exit, out, stderr, beadsRunner, gitRunner)\n\n\tif called {\n\t\tt.Fatalf(\"expected TUI program not to start\")\n\t}\n\tif runOnce.deps.Events != nil {\n\t\tt.Fatalf(\"expected no events emitter in headless mode\")\n\t}\n}\n\nfunc TestOpenCodeRunDefaultsCreateConfigAndEnv(t *testing.T) {\n\ttempDir := t.TempDir()\n\trepoRoot := filepath.Join(tempDir, \"repo\")\n\tif err := os.MkdirAll(repoRoot, 0o755); err != nil {\n\t\tt.Fatalf(\"mkdir repo: %v\", err)\n\t}\n\tt.Setenv(\"HOME\", tempDir)\n\n\topenCodeRunner := &fakeOpenCodeRunner{}\n\topenCodeAdapter := openCodeAdapter{runner: openCodeRunner}\n\n\tconfigRoot := filepath.Join(tempDir, \".config\", \"opencode-runner\")\n\tconfigDir := filepath.Join(configRoot, \"opencode\")\n\tlogPath := filepath.Join(tempDir, \"runner-logs\", \"opencode\", \"issue-1.jsonl\")\n\n\tif err := openCodeAdapter.Run(\"issue-1\", repoRoot, \"prompt\", \"\", configRoot, configDir, logPath); err != nil {\n\t\tt.Fatalf(\"open code run error: %v\", err)\n\t}\n\n\tconfigFile := filepath.Join(configDir, \"opencode.json\")\n\tif _, err := os.Stat(configFile); err != nil {\n\t\tt.Fatalf(\"expected opencode.json to exist: %v\", err)\n\t}\n\texpectedConfigFile := filepath.Join(configDir, \"opencode.json\")\n\tif openCodeRunner.env[\"XDG_CONFIG_HOME\"] != configRoot {\n\t\tt.Fatalf(\"expected XDG_CONFIG_HOME set\")\n\t}\n\tif openCodeRunner.env[\"OPENCODE_CONFIG_DIR\"] != configDir {\n\t\tt.Fatalf(\"expected OPENCODE_CONFIG_DIR set\")\n\t}\n\tif openCodeRunner.env[\"OPENCODE_CONFIG\"] != expectedConfigFile {\n\t\tt.Fatalf(\"expected OPENCODE_CONFIG set\")\n\t}\n\tif openCodeRunner.env[\"OPENCODE_CONFIG_CONTENT\"] != \"{}\" {\n\t\tt.Fatalf(\"expected OPENCODE_CONFIG_CONTENT set\")\n\t}\n}\n","additions":3,"deletions":1},"truncated":false},"time":{"start":1768850764840,"end":1768850765001}},"metadata":{"openai":{"itemId":"fc_0ad2b7e5e2e3a25f01696e85481fb48191b76817df67dfaa23"}}}}
{"type":"step_finish","timestamp":1768850765024,"sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","part":{"id":"prt_bd7b8b4ca001kjYXFOI7YIVzkE","sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","messageID":"msg_bd7b89ec00018ycCxvkm567dwF","type":"step-finish","reason":"tool-calls","snapshot":"8243444e390a66befb9ef1ed4f0dfd245ca72756","cost":0,"tokens":{"input":1061,"output":295,"reasoning":0,"cache":{"read":25216,"write":0}}}}
{"type":"step_start","timestamp":1768850765405,"sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","part":{"id":"prt_bd7b8b65d001XHmOaBXMb9bHT8","sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","messageID":"msg_bd7b8b4f4001lcB5UVlkYWvRX0","type":"step-start","snapshot":"62acc2cd30e4ec37b8bc9feb68ca8e0bdf48ef53"}}
{"type":"tool_use","timestamp":1768850771570,"sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","part":{"id":"prt_bd7b8b8c1001tBRBxd0yYcxx04","sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","messageID":"msg_bd7b8b4f4001lcB5UVlkYWvRX0","type":"tool","callID":"call_yOM4okw7j6ICtcM5yFPZ7V5o","tool":"edit","state":{"status":"completed","input":{"filePath":"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go","oldString":"\ttempDir := t.TempDir()\n\twriteIssuesFile(t, tempDir, `{\"id\":\"roadmap-1\",\"title\":\"Roadmap\",\"issue_type\":\"epic\",\"status\":\"open\"}`)\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n","newString":"\ttempDir := t.TempDir()\n\twriteIssuesFile(t, tempDir, `{\"id\":\"roadmap-1\",\"title\":\"Roadmap\",\"issue_type\":\"epic\",\"status\":\"open\"}`)\n\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n"},"output":"Edit applied successfully.","title":"cmd/yolo-runner/main_test.go","metadata":{"diagnostics":{"/Users/egv/dev/yolo-runner/internal/opencode/client.go":[{"range":{"start":{"line":28,"character":1},"end":{"line":28,"character":18}},"severity":2,"code":"default","codeDescription":{"href":"https://staticcheck.dev/docs/checks/#S1031"},"source":"S1031","message":"unnecessary nil check around range"}],"/Users/egv/dev/yolo-runner/internal/opencode/watchdog.go":[],"/Users/egv/dev/yolo-runner/go.mod":[{"range":{"start":{"line":6,"character":44},"end":{"line":6,"character":55}},"severity":2,"source":"go mod tidy","message":"github.com/charmbracelet/bubbletea should be direct"},{"range":{"start":{"line":19,"character":26},"end":{"line":19,"character":37}},"severity":2,"source":"go mod tidy","message":"golang.org/x/term should be direct"}],"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main.go":[],"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go":[],"/Users/egv/dev/yolo-runner/cmd/yolo-runner/exec_test.go":[],"/Users/egv/dev/yolo-runner/internal/opencode/agent_test.go":[],"/Users/egv/dev/yolo-runner/internal/opencode/agent.go":[]},"diff":"Index: /Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go\n===================================================================\n--- /Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go\n+++ /Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go\n@@ -235,8 +235,9 @@\n \n func TestRunOnceMainInfersRoadmapRootWhenMissing(t *testing.T) {\n \ttempDir := t.TempDir()\n \twriteIssuesFile(t, tempDir, `{\"id\":\"roadmap-1\",\"title\":\"Roadmap\",\"issue_type\":\"epic\",\"status\":\"open\"}`)\n+\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n \trunner := &fakeRunOnce{result: \"no_tasks\"}\n \texit := &fakeExit{}\n \tout := &bytes.Buffer{}\n \tbeadsRunner := &fakeRunner{}\n","filediff":{"file":"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go","before":"package main\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"yolo-runner/internal/opencode\"\n\t\"yolo-runner/internal/runner\"\n)\n\ntype fakeRunner struct {\n\tcalls []string\n}\n\nfunc (f *fakeRunner) Run(args ...string) (string, error) {\n\tf.calls = append(f.calls, strings.Join(args, \" \"))\n\treturn \"\", nil\n}\n\ntype fakeOpenCodeRunLogger struct {\n\tcalled     bool\n\tissueID    string\n\trepoRoot   string\n\tprompt     string\n\tmodel      string\n\tconfigRoot string\n\tconfigDir  string\n\tlogPath    string\n}\n\nfunc (f *fakeOpenCodeRunLogger) Run(issueID string, repoRoot string, prompt string, model string, configRoot string, configDir string, logPath string) error {\n\tf.called = true\n\tf.issueID = issueID\n\tf.repoRoot = repoRoot\n\tf.prompt = prompt\n\tf.model = model\n\tf.configRoot = configRoot\n\tf.configDir = configDir\n\tf.logPath = logPath\n\treturn nil\n}\n\ntype fakeOpenCodeRunner struct {\n\tenv map[string]string\n}\n\ntype fakeOpenCodeProcess struct{}\n\nfunc (fakeOpenCodeProcess) Wait() error { return nil }\n\nfunc (fakeOpenCodeProcess) Kill() error { return nil }\n\nfunc (f *fakeOpenCodeRunner) Start(args []string, env map[string]string, stdoutPath string) (opencode.Process, error) {\n\tf.env = env\n\treturn fakeOpenCodeProcess{}, nil\n}\n\ntype fakeGitRunner struct {\n\tcalls  []string\n\toutput string\n\terr    error\n}\n\nfunc (f *fakeGitRunner) Run(name string, args ...string) (string, error) {\n\tf.calls = append(f.calls, name+\" \"+strings.Join(args, \" \"))\n\treturn f.output, f.err\n}\n\ntype fakeExit struct {\n\tcode int\n}\n\nfunc (f *fakeExit) Exit(code int) {\n\tf.code = code\n}\n\ntype fakeRunOnce struct {\n\tcalled bool\n\topts   runner.RunOnceOptions\n\tdeps   runner.RunOnceDeps\n\tresult string\n\terr    error\n}\n\nfunc (f *fakeRunOnce) Run(opts runner.RunOnceOptions, deps runner.RunOnceDeps) (string, error) {\n\n\tf.called = true\n\tf.opts = opts\n\tf.deps = deps\n\treturn f.result, f.err\n}\n\nfunc TestRunOnceMainReturnsErrorCodeOnFailure(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n\trunner := &fakeRunOnce{err: errors.New(\"boom\")}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\"}, runner.Run, exit.Exit, out, out, nil, nil)\n\n\tif code != 1 {\n\t\tt.Fatalf(\"expected exit code 1, got %d\", code)\n\t}\n\tif exit.code != 1 {\n\t\tt.Fatalf(\"expected exit to be called with 1, got %d\", exit.code)\n\t}\n\tif !strings.Contains(out.String(), \"boom\") {\n\t\tt.Fatalf(\"expected error output, got %q\", out.String())\n\t}\n}\n\nfunc TestRunOnceMainWiresDependencies(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tRunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\", \"--model\", \"model\", \"--dry-run\"}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif !runner.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n\tif runner.opts.RepoRoot != \"/repo\" || runner.opts.RootID != \"root\" || runner.opts.Model != \"model\" || !runner.opts.DryRun {\n\t\tt.Fatalf(\"unexpected options: %#v\", runner.opts)\n\t}\n\tif runner.opts.Out == nil {\n\t\tt.Fatalf(\"expected output writer\")\n\t}\n\tif runner.deps.Beads == nil || runner.deps.Git == nil || runner.deps.Prompt == nil || runner.deps.OpenCode == nil || runner.deps.Logger == nil {\n\t\tt.Fatalf(\"expected deps to be wired\")\n\t}\n\tif exit.code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", exit.code)\n\t}\n}\n\nfunc TestRunOnceMainDefaultsConfigPaths(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tt.Setenv(\"HOME\", \"/home/user\")\n\n\tRunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\"}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif !runner.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n\tif runner.opts.ConfigRoot == \"\" {\n\t\tt.Fatalf(\"expected config root to be set\")\n\t}\n\tif runner.opts.ConfigDir == \"\" {\n\t\tt.Fatalf(\"expected config dir to be set\")\n\t}\n\texpectedConfigRoot := filepath.Join(\"/home/user\", \".config\", \"opencode-runner\")\n\tif runner.opts.ConfigRoot != expectedConfigRoot {\n\t\tt.Fatalf(\"expected config root %q, got %q\", expectedConfigRoot, runner.opts.ConfigRoot)\n\t}\n\texpectedConfigDir := filepath.Join(expectedConfigRoot, \"opencode\")\n\tif runner.opts.ConfigDir != expectedConfigDir {\n\t\tt.Fatalf(\"expected config dir %q, got %q\", expectedConfigDir, runner.opts.ConfigDir)\n\t}\n\tif exit.code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", exit.code)\n\t}\n}\n\nfunc TestRunOnceMainFailsWhenYoloAgentMissing(t *testing.T) {\n\ttempDir := t.TempDir()\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tstdout := &bytes.Buffer{}\n\tstderr := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\"}, runner.Run, exit.Exit, stdout, stderr, beadsRunner, gitRunner)\n\n\tif code != 1 {\n\t\tt.Fatalf(\"expected exit code 1, got %d\", code)\n\t}\n\tif exit.code != 1 {\n\t\tt.Fatalf(\"expected exit to be called with 1, got %d\", exit.code)\n\t}\n\tif runner.called {\n\t\tt.Fatalf(\"expected run once not to be called\")\n\t}\n\tif !strings.Contains(stderr.String(), \"yolo.md\") {\n\t\tt.Fatalf(\"expected error to mention yolo.md, got %q\", stderr.String())\n\t}\n}\n\nfunc TestRunOnceMainFailsWhenYoloAgentMissingPermission(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteAgentFile(t, tempDir, \"---\\nname: yolo\\n---\\n\")\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tstdout := &bytes.Buffer{}\n\tstderr := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\"}, runner.Run, exit.Exit, stdout, stderr, beadsRunner, gitRunner)\n\n\tif code != 1 {\n\t\tt.Fatalf(\"expected exit code 1, got %d\", code)\n\t}\n\tif exit.code != 1 {\n\t\tt.Fatalf(\"expected exit to be called with 1, got %d\", exit.code)\n\t}\n\tif runner.called {\n\t\tt.Fatalf(\"expected run once not to be called\")\n\t}\n\tif !strings.Contains(stderr.String(), \"permission: allow\") {\n\t\tt.Fatalf(\"expected error to mention permission allow, got %q\", stderr.String())\n\t}\n\tif !strings.Contains(strings.ToLower(stderr.String()), \"init\") {\n\t\tt.Fatalf(\"expected guidance to run init, got %q\", stderr.String())\n\t}\n}\n\nfunc TestRunOnceMainInfersRoadmapRootWhenMissing(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteIssuesFile(t, tempDir, `{\"id\":\"roadmap-1\",\"title\":\"Roadmap\",\"issue_type\":\"epic\",\"status\":\"open\"}`)\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", code)\n\t}\n\tif !runner.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n\tif runner.opts.RootID != \"roadmap-1\" {\n\t\tt.Fatalf(\"expected root id to be inferred, got %q\", runner.opts.RootID)\n\t}\n}\n\nfunc TestRunOnceMainInfersRoadmapRootWhenInProgress(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteIssuesFile(t, tempDir, `{\"id\":\"roadmap-2\",\"title\":\"Roadmap\",\"issue_type\":\"epic\",\"status\":\"in_progress\"}`)\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", code)\n\t}\n\tif !runner.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n\tif runner.opts.RootID != \"roadmap-2\" {\n\t\tt.Fatalf(\"expected root id to be inferred, got %q\", runner.opts.RootID)\n\t}\n}\n\nfunc TestRunOnceMainMissingRootRequiresExplicitFlag(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteIssuesFile(t, tempDir, `{\"id\":\"epic-1\",\"title\":\"Other\",\"issue_type\":\"epic\",\"status\":\"open\"}`)\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tstdout := &bytes.Buffer{}\n\tstderr := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir}, runner.Run, exit.Exit, stdout, stderr, beadsRunner, gitRunner)\n\n\tif code != 1 {\n\t\tt.Fatalf(\"expected exit code 1, got %d\", code)\n\t}\n\tif exit.code != 1 {\n\t\tt.Fatalf(\"expected exit to be called with 1, got %d\", exit.code)\n\t}\n\tif runner.called {\n\t\tt.Fatalf(\"expected run once not to be called\")\n\t}\n\tif !strings.Contains(stderr.String(), \"--root\") {\n\t\tt.Fatalf(\"expected error to mention --root, got %q\", stderr.String())\n\t}\n\tif !strings.Contains(strings.ToLower(stderr.String()), \"roadmap\") {\n\t\tt.Fatalf(\"expected error to mention roadmap, got %q\", stderr.String())\n\t}\n}\n\ntype fakeTUIProgram struct {\n\tstarted chan struct{}\n\tquit    chan struct{}\n\tevents  chan runner.Event\n}\n\nfunc newFakeTUIProgram() *fakeTUIProgram {\n\treturn &fakeTUIProgram{\n\t\tstarted: make(chan struct{}),\n\t\tquit:    make(chan struct{}),\n\t\tevents:  make(chan runner.Event, 1),\n\t}\n}\n\nfunc (f *fakeTUIProgram) Start() error {\n\tclose(f.started)\n\treturn nil\n}\n\nfunc (f *fakeTUIProgram) Send(event runner.Event) {\n\tf.events <- event\n}\n\nfunc (f *fakeTUIProgram) Quit() {\n\tclose(f.quit)\n}\n\nfunc waitForSignal(t *testing.T, signal chan struct{}, label string) {\n\tt.Helper()\n\tselect {\n\tcase <-signal:\n\t\treturn\n\tcase <-time.After(200 * time.Millisecond):\n\t\tt.Fatalf(\"expected %s\", label)\n\t}\n}\n\nfunc writeIssuesFile(t *testing.T, repoRoot string, payload string) {\n\tt.Helper()\n\tbeadsDir := filepath.Join(repoRoot, \".beads\")\n\tif err := os.MkdirAll(beadsDir, 0o755); err != nil {\n\t\tt.Fatalf(\"mkdir .beads: %v\", err)\n\t}\n\tissuesPath := filepath.Join(beadsDir, \"issues.jsonl\")\n\tif err := os.WriteFile(issuesPath, []byte(payload+\"\\n\"), 0o644); err != nil {\n\t\tt.Fatalf(\"write issues: %v\", err)\n\t}\n}\n\nfunc writeAgentFile(t *testing.T, repoRoot string, payload string) {\n\tt.Helper()\n\tagentDir := filepath.Join(repoRoot, \".opencode\", \"agent\")\n\tif err := os.MkdirAll(agentDir, 0o755); err != nil {\n\t\tt.Fatalf(\"mkdir agent dir: %v\", err)\n\t}\n\tagentPath := filepath.Join(agentDir, \"yolo.md\")\n\tif err := os.WriteFile(agentPath, []byte(payload), 0o644); err != nil {\n\t\tt.Fatalf(\"write agent file: %v\", err)\n\t}\n}\n\nfunc TestRunOnceMainUsesTUIOnTTYByDefault(t *testing.T) {\n\tfakeProgram := newFakeTUIProgram()\n\tprevIsTerminal := isTerminal\n\tprevNewTUIProgram := newTUIProgram\n\tisTerminal = func(io.Writer) bool { return true }\n\tnewTUIProgram = func(stdout io.Writer) tuiProgram { return fakeProgram }\n\tt.Cleanup(func() {\n\t\tisTerminal = prevIsTerminal\n\t\tnewTUIProgram = prevNewTUIProgram\n\t})\n\n\trunOnce := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\"}, runOnce.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", code)\n\t}\n\tif runOnce.deps.Events == nil {\n\t\tt.Fatalf(\"expected events emitter to be set\")\n\t}\n\trunOnce.deps.Events.Emit(runner.Event{Type: runner.EventSelectTask})\n\twaitForSignal(t, fakeProgram.started, \"tui start\")\n\twaitForSignal(t, fakeProgram.quit, \"tui quit\")\n\tselect {\n\tcase <-fakeProgram.events:\n\t\t// ok\n\tcase <-time.After(200 * time.Millisecond):\n\t\tt.Fatalf(\"expected event to be forwarded to TUI\")\n\t}\n}\n\nfunc TestRunOnceMainHeadlessDisablesTUI(t *testing.T) {\n\tcalled := false\n\tprevIsTerminal := isTerminal\n\tprevNewTUIProgram := newTUIProgram\n\tisTerminal = func(io.Writer) bool { return true }\n\tnewTUIProgram = func(stdout io.Writer) tuiProgram {\n\t\tcalled = true\n\t\treturn newFakeTUIProgram()\n\t}\n\tt.Cleanup(func() {\n\t\tisTerminal = prevIsTerminal\n\t\tnewTUIProgram = prevNewTUIProgram\n\t})\n\n\trunOnce := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\tstderr := &bytes.Buffer{}\n\n\tRunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\", \"--headless\"}, runOnce.Run, exit.Exit, out, stderr, beadsRunner, gitRunner)\n\n\tif called {\n\t\tt.Fatalf(\"expected TUI program not to start\")\n\t}\n\tif runOnce.deps.Events != nil {\n\t\tt.Fatalf(\"expected no events emitter in headless mode\")\n\t}\n}\n\nfunc TestOpenCodeRunDefaultsCreateConfigAndEnv(t *testing.T) {\n\ttempDir := t.TempDir()\n\trepoRoot := filepath.Join(tempDir, \"repo\")\n\tif err := os.MkdirAll(repoRoot, 0o755); err != nil {\n\t\tt.Fatalf(\"mkdir repo: %v\", err)\n\t}\n\tt.Setenv(\"HOME\", tempDir)\n\n\topenCodeRunner := &fakeOpenCodeRunner{}\n\topenCodeAdapter := openCodeAdapter{runner: openCodeRunner}\n\n\tconfigRoot := filepath.Join(tempDir, \".config\", \"opencode-runner\")\n\tconfigDir := filepath.Join(configRoot, \"opencode\")\n\tlogPath := filepath.Join(tempDir, \"runner-logs\", \"opencode\", \"issue-1.jsonl\")\n\n\tif err := openCodeAdapter.Run(\"issue-1\", repoRoot, \"prompt\", \"\", configRoot, configDir, logPath); err != nil {\n\t\tt.Fatalf(\"open code run error: %v\", err)\n\t}\n\n\tconfigFile := filepath.Join(configDir, \"opencode.json\")\n\tif _, err := os.Stat(configFile); err != nil {\n\t\tt.Fatalf(\"expected opencode.json to exist: %v\", err)\n\t}\n\texpectedConfigFile := filepath.Join(configDir, \"opencode.json\")\n\tif openCodeRunner.env[\"XDG_CONFIG_HOME\"] != configRoot {\n\t\tt.Fatalf(\"expected XDG_CONFIG_HOME set\")\n\t}\n\tif openCodeRunner.env[\"OPENCODE_CONFIG_DIR\"] != configDir {\n\t\tt.Fatalf(\"expected OPENCODE_CONFIG_DIR set\")\n\t}\n\tif openCodeRunner.env[\"OPENCODE_CONFIG\"] != expectedConfigFile {\n\t\tt.Fatalf(\"expected OPENCODE_CONFIG set\")\n\t}\n\tif openCodeRunner.env[\"OPENCODE_CONFIG_CONTENT\"] != \"{}\" {\n\t\tt.Fatalf(\"expected OPENCODE_CONFIG_CONTENT set\")\n\t}\n}\n","after":"package main\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"yolo-runner/internal/opencode\"\n\t\"yolo-runner/internal/runner\"\n)\n\ntype fakeRunner struct {\n\tcalls []string\n}\n\nfunc (f *fakeRunner) Run(args ...string) (string, error) {\n\tf.calls = append(f.calls, strings.Join(args, \" \"))\n\treturn \"\", nil\n}\n\ntype fakeOpenCodeRunLogger struct {\n\tcalled     bool\n\tissueID    string\n\trepoRoot   string\n\tprompt     string\n\tmodel      string\n\tconfigRoot string\n\tconfigDir  string\n\tlogPath    string\n}\n\nfunc (f *fakeOpenCodeRunLogger) Run(issueID string, repoRoot string, prompt string, model string, configRoot string, configDir string, logPath string) error {\n\tf.called = true\n\tf.issueID = issueID\n\tf.repoRoot = repoRoot\n\tf.prompt = prompt\n\tf.model = model\n\tf.configRoot = configRoot\n\tf.configDir = configDir\n\tf.logPath = logPath\n\treturn nil\n}\n\ntype fakeOpenCodeRunner struct {\n\tenv map[string]string\n}\n\ntype fakeOpenCodeProcess struct{}\n\nfunc (fakeOpenCodeProcess) Wait() error { return nil }\n\nfunc (fakeOpenCodeProcess) Kill() error { return nil }\n\nfunc (f *fakeOpenCodeRunner) Start(args []string, env map[string]string, stdoutPath string) (opencode.Process, error) {\n\tf.env = env\n\treturn fakeOpenCodeProcess{}, nil\n}\n\ntype fakeGitRunner struct {\n\tcalls  []string\n\toutput string\n\terr    error\n}\n\nfunc (f *fakeGitRunner) Run(name string, args ...string) (string, error) {\n\tf.calls = append(f.calls, name+\" \"+strings.Join(args, \" \"))\n\treturn f.output, f.err\n}\n\ntype fakeExit struct {\n\tcode int\n}\n\nfunc (f *fakeExit) Exit(code int) {\n\tf.code = code\n}\n\ntype fakeRunOnce struct {\n\tcalled bool\n\topts   runner.RunOnceOptions\n\tdeps   runner.RunOnceDeps\n\tresult string\n\terr    error\n}\n\nfunc (f *fakeRunOnce) Run(opts runner.RunOnceOptions, deps runner.RunOnceDeps) (string, error) {\n\n\tf.called = true\n\tf.opts = opts\n\tf.deps = deps\n\treturn f.result, f.err\n}\n\nfunc TestRunOnceMainReturnsErrorCodeOnFailure(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n\trunner := &fakeRunOnce{err: errors.New(\"boom\")}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\"}, runner.Run, exit.Exit, out, out, nil, nil)\n\n\tif code != 1 {\n\t\tt.Fatalf(\"expected exit code 1, got %d\", code)\n\t}\n\tif exit.code != 1 {\n\t\tt.Fatalf(\"expected exit to be called with 1, got %d\", exit.code)\n\t}\n\tif !strings.Contains(out.String(), \"boom\") {\n\t\tt.Fatalf(\"expected error output, got %q\", out.String())\n\t}\n}\n\nfunc TestRunOnceMainWiresDependencies(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tRunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\", \"--model\", \"model\", \"--dry-run\"}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif !runner.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n\tif runner.opts.RepoRoot != \"/repo\" || runner.opts.RootID != \"root\" || runner.opts.Model != \"model\" || !runner.opts.DryRun {\n\t\tt.Fatalf(\"unexpected options: %#v\", runner.opts)\n\t}\n\tif runner.opts.Out == nil {\n\t\tt.Fatalf(\"expected output writer\")\n\t}\n\tif runner.deps.Beads == nil || runner.deps.Git == nil || runner.deps.Prompt == nil || runner.deps.OpenCode == nil || runner.deps.Logger == nil {\n\t\tt.Fatalf(\"expected deps to be wired\")\n\t}\n\tif exit.code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", exit.code)\n\t}\n}\n\nfunc TestRunOnceMainDefaultsConfigPaths(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tt.Setenv(\"HOME\", \"/home/user\")\n\n\tRunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\"}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif !runner.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n\tif runner.opts.ConfigRoot == \"\" {\n\t\tt.Fatalf(\"expected config root to be set\")\n\t}\n\tif runner.opts.ConfigDir == \"\" {\n\t\tt.Fatalf(\"expected config dir to be set\")\n\t}\n\texpectedConfigRoot := filepath.Join(\"/home/user\", \".config\", \"opencode-runner\")\n\tif runner.opts.ConfigRoot != expectedConfigRoot {\n\t\tt.Fatalf(\"expected config root %q, got %q\", expectedConfigRoot, runner.opts.ConfigRoot)\n\t}\n\texpectedConfigDir := filepath.Join(expectedConfigRoot, \"opencode\")\n\tif runner.opts.ConfigDir != expectedConfigDir {\n\t\tt.Fatalf(\"expected config dir %q, got %q\", expectedConfigDir, runner.opts.ConfigDir)\n\t}\n\tif exit.code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", exit.code)\n\t}\n}\n\nfunc TestRunOnceMainFailsWhenYoloAgentMissing(t *testing.T) {\n\ttempDir := t.TempDir()\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tstdout := &bytes.Buffer{}\n\tstderr := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\"}, runner.Run, exit.Exit, stdout, stderr, beadsRunner, gitRunner)\n\n\tif code != 1 {\n\t\tt.Fatalf(\"expected exit code 1, got %d\", code)\n\t}\n\tif exit.code != 1 {\n\t\tt.Fatalf(\"expected exit to be called with 1, got %d\", exit.code)\n\t}\n\tif runner.called {\n\t\tt.Fatalf(\"expected run once not to be called\")\n\t}\n\tif !strings.Contains(stderr.String(), \"yolo.md\") {\n\t\tt.Fatalf(\"expected error to mention yolo.md, got %q\", stderr.String())\n\t}\n}\n\nfunc TestRunOnceMainFailsWhenYoloAgentMissingPermission(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteAgentFile(t, tempDir, \"---\\nname: yolo\\n---\\n\")\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tstdout := &bytes.Buffer{}\n\tstderr := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\"}, runner.Run, exit.Exit, stdout, stderr, beadsRunner, gitRunner)\n\n\tif code != 1 {\n\t\tt.Fatalf(\"expected exit code 1, got %d\", code)\n\t}\n\tif exit.code != 1 {\n\t\tt.Fatalf(\"expected exit to be called with 1, got %d\", exit.code)\n\t}\n\tif runner.called {\n\t\tt.Fatalf(\"expected run once not to be called\")\n\t}\n\tif !strings.Contains(stderr.String(), \"permission: allow\") {\n\t\tt.Fatalf(\"expected error to mention permission allow, got %q\", stderr.String())\n\t}\n\tif !strings.Contains(strings.ToLower(stderr.String()), \"init\") {\n\t\tt.Fatalf(\"expected guidance to run init, got %q\", stderr.String())\n\t}\n}\n\nfunc TestRunOnceMainInfersRoadmapRootWhenMissing(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteIssuesFile(t, tempDir, `{\"id\":\"roadmap-1\",\"title\":\"Roadmap\",\"issue_type\":\"epic\",\"status\":\"open\"}`)\n\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", code)\n\t}\n\tif !runner.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n\tif runner.opts.RootID != \"roadmap-1\" {\n\t\tt.Fatalf(\"expected root id to be inferred, got %q\", runner.opts.RootID)\n\t}\n}\n\nfunc TestRunOnceMainInfersRoadmapRootWhenInProgress(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteIssuesFile(t, tempDir, `{\"id\":\"roadmap-2\",\"title\":\"Roadmap\",\"issue_type\":\"epic\",\"status\":\"in_progress\"}`)\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", code)\n\t}\n\tif !runner.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n\tif runner.opts.RootID != \"roadmap-2\" {\n\t\tt.Fatalf(\"expected root id to be inferred, got %q\", runner.opts.RootID)\n\t}\n}\n\nfunc TestRunOnceMainMissingRootRequiresExplicitFlag(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteIssuesFile(t, tempDir, `{\"id\":\"epic-1\",\"title\":\"Other\",\"issue_type\":\"epic\",\"status\":\"open\"}`)\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tstdout := &bytes.Buffer{}\n\tstderr := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir}, runner.Run, exit.Exit, stdout, stderr, beadsRunner, gitRunner)\n\n\tif code != 1 {\n\t\tt.Fatalf(\"expected exit code 1, got %d\", code)\n\t}\n\tif exit.code != 1 {\n\t\tt.Fatalf(\"expected exit to be called with 1, got %d\", exit.code)\n\t}\n\tif runner.called {\n\t\tt.Fatalf(\"expected run once not to be called\")\n\t}\n\tif !strings.Contains(stderr.String(), \"--root\") {\n\t\tt.Fatalf(\"expected error to mention --root, got %q\", stderr.String())\n\t}\n\tif !strings.Contains(strings.ToLower(stderr.String()), \"roadmap\") {\n\t\tt.Fatalf(\"expected error to mention roadmap, got %q\", stderr.String())\n\t}\n}\n\ntype fakeTUIProgram struct {\n\tstarted chan struct{}\n\tquit    chan struct{}\n\tevents  chan runner.Event\n}\n\nfunc newFakeTUIProgram() *fakeTUIProgram {\n\treturn &fakeTUIProgram{\n\t\tstarted: make(chan struct{}),\n\t\tquit:    make(chan struct{}),\n\t\tevents:  make(chan runner.Event, 1),\n\t}\n}\n\nfunc (f *fakeTUIProgram) Start() error {\n\tclose(f.started)\n\treturn nil\n}\n\nfunc (f *fakeTUIProgram) Send(event runner.Event) {\n\tf.events <- event\n}\n\nfunc (f *fakeTUIProgram) Quit() {\n\tclose(f.quit)\n}\n\nfunc waitForSignal(t *testing.T, signal chan struct{}, label string) {\n\tt.Helper()\n\tselect {\n\tcase <-signal:\n\t\treturn\n\tcase <-time.After(200 * time.Millisecond):\n\t\tt.Fatalf(\"expected %s\", label)\n\t}\n}\n\nfunc writeIssuesFile(t *testing.T, repoRoot string, payload string) {\n\tt.Helper()\n\tbeadsDir := filepath.Join(repoRoot, \".beads\")\n\tif err := os.MkdirAll(beadsDir, 0o755); err != nil {\n\t\tt.Fatalf(\"mkdir .beads: %v\", err)\n\t}\n\tissuesPath := filepath.Join(beadsDir, \"issues.jsonl\")\n\tif err := os.WriteFile(issuesPath, []byte(payload+\"\\n\"), 0o644); err != nil {\n\t\tt.Fatalf(\"write issues: %v\", err)\n\t}\n}\n\nfunc writeAgentFile(t *testing.T, repoRoot string, payload string) {\n\tt.Helper()\n\tagentDir := filepath.Join(repoRoot, \".opencode\", \"agent\")\n\tif err := os.MkdirAll(agentDir, 0o755); err != nil {\n\t\tt.Fatalf(\"mkdir agent dir: %v\", err)\n\t}\n\tagentPath := filepath.Join(agentDir, \"yolo.md\")\n\tif err := os.WriteFile(agentPath, []byte(payload), 0o644); err != nil {\n\t\tt.Fatalf(\"write agent file: %v\", err)\n\t}\n}\n\nfunc TestRunOnceMainUsesTUIOnTTYByDefault(t *testing.T) {\n\tfakeProgram := newFakeTUIProgram()\n\tprevIsTerminal := isTerminal\n\tprevNewTUIProgram := newTUIProgram\n\tisTerminal = func(io.Writer) bool { return true }\n\tnewTUIProgram = func(stdout io.Writer) tuiProgram { return fakeProgram }\n\tt.Cleanup(func() {\n\t\tisTerminal = prevIsTerminal\n\t\tnewTUIProgram = prevNewTUIProgram\n\t})\n\n\trunOnce := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\"}, runOnce.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", code)\n\t}\n\tif runOnce.deps.Events == nil {\n\t\tt.Fatalf(\"expected events emitter to be set\")\n\t}\n\trunOnce.deps.Events.Emit(runner.Event{Type: runner.EventSelectTask})\n\twaitForSignal(t, fakeProgram.started, \"tui start\")\n\twaitForSignal(t, fakeProgram.quit, \"tui quit\")\n\tselect {\n\tcase <-fakeProgram.events:\n\t\t// ok\n\tcase <-time.After(200 * time.Millisecond):\n\t\tt.Fatalf(\"expected event to be forwarded to TUI\")\n\t}\n}\n\nfunc TestRunOnceMainHeadlessDisablesTUI(t *testing.T) {\n\tcalled := false\n\tprevIsTerminal := isTerminal\n\tprevNewTUIProgram := newTUIProgram\n\tisTerminal = func(io.Writer) bool { return true }\n\tnewTUIProgram = func(stdout io.Writer) tuiProgram {\n\t\tcalled = true\n\t\treturn newFakeTUIProgram()\n\t}\n\tt.Cleanup(func() {\n\t\tisTerminal = prevIsTerminal\n\t\tnewTUIProgram = prevNewTUIProgram\n\t})\n\n\trunOnce := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\tstderr := &bytes.Buffer{}\n\n\tRunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\", \"--headless\"}, runOnce.Run, exit.Exit, out, stderr, beadsRunner, gitRunner)\n\n\tif called {\n\t\tt.Fatalf(\"expected TUI program not to start\")\n\t}\n\tif runOnce.deps.Events != nil {\n\t\tt.Fatalf(\"expected no events emitter in headless mode\")\n\t}\n}\n\nfunc TestOpenCodeRunDefaultsCreateConfigAndEnv(t *testing.T) {\n\ttempDir := t.TempDir()\n\trepoRoot := filepath.Join(tempDir, \"repo\")\n\tif err := os.MkdirAll(repoRoot, 0o755); err != nil {\n\t\tt.Fatalf(\"mkdir repo: %v\", err)\n\t}\n\tt.Setenv(\"HOME\", tempDir)\n\n\topenCodeRunner := &fakeOpenCodeRunner{}\n\topenCodeAdapter := openCodeAdapter{runner: openCodeRunner}\n\n\tconfigRoot := filepath.Join(tempDir, \".config\", \"opencode-runner\")\n\tconfigDir := filepath.Join(configRoot, \"opencode\")\n\tlogPath := filepath.Join(tempDir, \"runner-logs\", \"opencode\", \"issue-1.jsonl\")\n\n\tif err := openCodeAdapter.Run(\"issue-1\", repoRoot, \"prompt\", \"\", configRoot, configDir, logPath); err != nil {\n\t\tt.Fatalf(\"open code run error: %v\", err)\n\t}\n\n\tconfigFile := filepath.Join(configDir, \"opencode.json\")\n\tif _, err := os.Stat(configFile); err != nil {\n\t\tt.Fatalf(\"expected opencode.json to exist: %v\", err)\n\t}\n\texpectedConfigFile := filepath.Join(configDir, \"opencode.json\")\n\tif openCodeRunner.env[\"XDG_CONFIG_HOME\"] != configRoot {\n\t\tt.Fatalf(\"expected XDG_CONFIG_HOME set\")\n\t}\n\tif openCodeRunner.env[\"OPENCODE_CONFIG_DIR\"] != configDir {\n\t\tt.Fatalf(\"expected OPENCODE_CONFIG_DIR set\")\n\t}\n\tif openCodeRunner.env[\"OPENCODE_CONFIG\"] != expectedConfigFile {\n\t\tt.Fatalf(\"expected OPENCODE_CONFIG set\")\n\t}\n\tif openCodeRunner.env[\"OPENCODE_CONFIG_CONTENT\"] != \"{}\" {\n\t\tt.Fatalf(\"expected OPENCODE_CONFIG_CONTENT set\")\n\t}\n}\n","additions":1,"deletions":0},"truncated":false},"time":{"start":1768850771409,"end":1768850771569}},"metadata":{"openai":{"itemId":"fc_0e32e3b0ef10e09701696e854e01a88191aba033cd7b744243"}}}}
{"type":"step_finish","timestamp":1768850771587,"sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","part":{"id":"prt_bd7b8ce72001VbiAicYPDit3GM","sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","messageID":"msg_bd7b8b4f4001lcB5UVlkYWvRX0","type":"step-finish","reason":"tool-calls","snapshot":"dbd98156c222cfc109d59e660dbb2c258eaff336","cost":0,"tokens":{"input":1367,"output":334,"reasoning":0,"cache":{"read":25216,"write":0}}}}
{"type":"step_start","timestamp":1768850771969,"sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","part":{"id":"prt_bd7b8d000001bCjxuo4h9yLIlC","sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","messageID":"msg_bd7b8ce96001Scx8F7unXgqe21","type":"step-start","snapshot":"f6ed111404b0ec4c4efd380627b05f35ac7e08ba"}}
{"type":"tool_use","timestamp":1768850778109,"sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","part":{"id":"prt_bd7b8d26d001ZmPxfUR3BC7ODm","sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","messageID":"msg_bd7b8ce96001Scx8F7unXgqe21","type":"tool","callID":"call_6QPL75uI0rcwokAKWhY2Pz2D","tool":"edit","state":{"status":"completed","input":{"filePath":"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go","oldString":"\ttempDir := t.TempDir()\n\twriteIssuesFile(t, tempDir, `{\"id\":\"roadmap-2\",\"title\":\"Roadmap\",\"issue_type\":\"epic\",\"status\":\"in_progress\"}`)\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n","newString":"\ttempDir := t.TempDir()\n\twriteIssuesFile(t, tempDir, `{\"id\":\"roadmap-2\",\"title\":\"Roadmap\",\"issue_type\":\"epic\",\"status\":\"in_progress\"}`)\n\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n"},"output":"Edit applied successfully.","title":"cmd/yolo-runner/main_test.go","metadata":{"diagnostics":{"/Users/egv/dev/yolo-runner/internal/opencode/client.go":[{"range":{"start":{"line":28,"character":1},"end":{"line":28,"character":18}},"severity":2,"code":"default","codeDescription":{"href":"https://staticcheck.dev/docs/checks/#S1031"},"source":"S1031","message":"unnecessary nil check around range"}],"/Users/egv/dev/yolo-runner/internal/opencode/watchdog.go":[],"/Users/egv/dev/yolo-runner/go.mod":[{"range":{"start":{"line":6,"character":44},"end":{"line":6,"character":55}},"severity":2,"source":"go mod tidy","message":"github.com/charmbracelet/bubbletea should be direct"},{"range":{"start":{"line":19,"character":26},"end":{"line":19,"character":37}},"severity":2,"source":"go mod tidy","message":"golang.org/x/term should be direct"}],"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main.go":[],"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go":[],"/Users/egv/dev/yolo-runner/cmd/yolo-runner/exec_test.go":[],"/Users/egv/dev/yolo-runner/internal/opencode/agent_test.go":[],"/Users/egv/dev/yolo-runner/internal/opencode/agent.go":[]},"diff":"Index: /Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go\n===================================================================\n--- /Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go\n+++ /Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go\n@@ -258,8 +258,9 @@\n \n func TestRunOnceMainInfersRoadmapRootWhenInProgress(t *testing.T) {\n \ttempDir := t.TempDir()\n \twriteIssuesFile(t, tempDir, `{\"id\":\"roadmap-2\",\"title\":\"Roadmap\",\"issue_type\":\"epic\",\"status\":\"in_progress\"}`)\n+\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n \trunner := &fakeRunOnce{result: \"no_tasks\"}\n \texit := &fakeExit{}\n \tout := &bytes.Buffer{}\n \tbeadsRunner := &fakeRunner{}\n","filediff":{"file":"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go","before":"package main\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"yolo-runner/internal/opencode\"\n\t\"yolo-runner/internal/runner\"\n)\n\ntype fakeRunner struct {\n\tcalls []string\n}\n\nfunc (f *fakeRunner) Run(args ...string) (string, error) {\n\tf.calls = append(f.calls, strings.Join(args, \" \"))\n\treturn \"\", nil\n}\n\ntype fakeOpenCodeRunLogger struct {\n\tcalled     bool\n\tissueID    string\n\trepoRoot   string\n\tprompt     string\n\tmodel      string\n\tconfigRoot string\n\tconfigDir  string\n\tlogPath    string\n}\n\nfunc (f *fakeOpenCodeRunLogger) Run(issueID string, repoRoot string, prompt string, model string, configRoot string, configDir string, logPath string) error {\n\tf.called = true\n\tf.issueID = issueID\n\tf.repoRoot = repoRoot\n\tf.prompt = prompt\n\tf.model = model\n\tf.configRoot = configRoot\n\tf.configDir = configDir\n\tf.logPath = logPath\n\treturn nil\n}\n\ntype fakeOpenCodeRunner struct {\n\tenv map[string]string\n}\n\ntype fakeOpenCodeProcess struct{}\n\nfunc (fakeOpenCodeProcess) Wait() error { return nil }\n\nfunc (fakeOpenCodeProcess) Kill() error { return nil }\n\nfunc (f *fakeOpenCodeRunner) Start(args []string, env map[string]string, stdoutPath string) (opencode.Process, error) {\n\tf.env = env\n\treturn fakeOpenCodeProcess{}, nil\n}\n\ntype fakeGitRunner struct {\n\tcalls  []string\n\toutput string\n\terr    error\n}\n\nfunc (f *fakeGitRunner) Run(name string, args ...string) (string, error) {\n\tf.calls = append(f.calls, name+\" \"+strings.Join(args, \" \"))\n\treturn f.output, f.err\n}\n\ntype fakeExit struct {\n\tcode int\n}\n\nfunc (f *fakeExit) Exit(code int) {\n\tf.code = code\n}\n\ntype fakeRunOnce struct {\n\tcalled bool\n\topts   runner.RunOnceOptions\n\tdeps   runner.RunOnceDeps\n\tresult string\n\terr    error\n}\n\nfunc (f *fakeRunOnce) Run(opts runner.RunOnceOptions, deps runner.RunOnceDeps) (string, error) {\n\n\tf.called = true\n\tf.opts = opts\n\tf.deps = deps\n\treturn f.result, f.err\n}\n\nfunc TestRunOnceMainReturnsErrorCodeOnFailure(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n\trunner := &fakeRunOnce{err: errors.New(\"boom\")}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\"}, runner.Run, exit.Exit, out, out, nil, nil)\n\n\tif code != 1 {\n\t\tt.Fatalf(\"expected exit code 1, got %d\", code)\n\t}\n\tif exit.code != 1 {\n\t\tt.Fatalf(\"expected exit to be called with 1, got %d\", exit.code)\n\t}\n\tif !strings.Contains(out.String(), \"boom\") {\n\t\tt.Fatalf(\"expected error output, got %q\", out.String())\n\t}\n}\n\nfunc TestRunOnceMainWiresDependencies(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tRunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\", \"--model\", \"model\", \"--dry-run\"}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif !runner.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n\tif runner.opts.RepoRoot != \"/repo\" || runner.opts.RootID != \"root\" || runner.opts.Model != \"model\" || !runner.opts.DryRun {\n\t\tt.Fatalf(\"unexpected options: %#v\", runner.opts)\n\t}\n\tif runner.opts.Out == nil {\n\t\tt.Fatalf(\"expected output writer\")\n\t}\n\tif runner.deps.Beads == nil || runner.deps.Git == nil || runner.deps.Prompt == nil || runner.deps.OpenCode == nil || runner.deps.Logger == nil {\n\t\tt.Fatalf(\"expected deps to be wired\")\n\t}\n\tif exit.code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", exit.code)\n\t}\n}\n\nfunc TestRunOnceMainDefaultsConfigPaths(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tt.Setenv(\"HOME\", \"/home/user\")\n\n\tRunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\"}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif !runner.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n\tif runner.opts.ConfigRoot == \"\" {\n\t\tt.Fatalf(\"expected config root to be set\")\n\t}\n\tif runner.opts.ConfigDir == \"\" {\n\t\tt.Fatalf(\"expected config dir to be set\")\n\t}\n\texpectedConfigRoot := filepath.Join(\"/home/user\", \".config\", \"opencode-runner\")\n\tif runner.opts.ConfigRoot != expectedConfigRoot {\n\t\tt.Fatalf(\"expected config root %q, got %q\", expectedConfigRoot, runner.opts.ConfigRoot)\n\t}\n\texpectedConfigDir := filepath.Join(expectedConfigRoot, \"opencode\")\n\tif runner.opts.ConfigDir != expectedConfigDir {\n\t\tt.Fatalf(\"expected config dir %q, got %q\", expectedConfigDir, runner.opts.ConfigDir)\n\t}\n\tif exit.code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", exit.code)\n\t}\n}\n\nfunc TestRunOnceMainFailsWhenYoloAgentMissing(t *testing.T) {\n\ttempDir := t.TempDir()\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tstdout := &bytes.Buffer{}\n\tstderr := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\"}, runner.Run, exit.Exit, stdout, stderr, beadsRunner, gitRunner)\n\n\tif code != 1 {\n\t\tt.Fatalf(\"expected exit code 1, got %d\", code)\n\t}\n\tif exit.code != 1 {\n\t\tt.Fatalf(\"expected exit to be called with 1, got %d\", exit.code)\n\t}\n\tif runner.called {\n\t\tt.Fatalf(\"expected run once not to be called\")\n\t}\n\tif !strings.Contains(stderr.String(), \"yolo.md\") {\n\t\tt.Fatalf(\"expected error to mention yolo.md, got %q\", stderr.String())\n\t}\n}\n\nfunc TestRunOnceMainFailsWhenYoloAgentMissingPermission(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteAgentFile(t, tempDir, \"---\\nname: yolo\\n---\\n\")\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tstdout := &bytes.Buffer{}\n\tstderr := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\"}, runner.Run, exit.Exit, stdout, stderr, beadsRunner, gitRunner)\n\n\tif code != 1 {\n\t\tt.Fatalf(\"expected exit code 1, got %d\", code)\n\t}\n\tif exit.code != 1 {\n\t\tt.Fatalf(\"expected exit to be called with 1, got %d\", exit.code)\n\t}\n\tif runner.called {\n\t\tt.Fatalf(\"expected run once not to be called\")\n\t}\n\tif !strings.Contains(stderr.String(), \"permission: allow\") {\n\t\tt.Fatalf(\"expected error to mention permission allow, got %q\", stderr.String())\n\t}\n\tif !strings.Contains(strings.ToLower(stderr.String()), \"init\") {\n\t\tt.Fatalf(\"expected guidance to run init, got %q\", stderr.String())\n\t}\n}\n\nfunc TestRunOnceMainInfersRoadmapRootWhenMissing(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteIssuesFile(t, tempDir, `{\"id\":\"roadmap-1\",\"title\":\"Roadmap\",\"issue_type\":\"epic\",\"status\":\"open\"}`)\n\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", code)\n\t}\n\tif !runner.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n\tif runner.opts.RootID != \"roadmap-1\" {\n\t\tt.Fatalf(\"expected root id to be inferred, got %q\", runner.opts.RootID)\n\t}\n}\n\nfunc TestRunOnceMainInfersRoadmapRootWhenInProgress(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteIssuesFile(t, tempDir, `{\"id\":\"roadmap-2\",\"title\":\"Roadmap\",\"issue_type\":\"epic\",\"status\":\"in_progress\"}`)\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", code)\n\t}\n\tif !runner.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n\tif runner.opts.RootID != \"roadmap-2\" {\n\t\tt.Fatalf(\"expected root id to be inferred, got %q\", runner.opts.RootID)\n\t}\n}\n\nfunc TestRunOnceMainMissingRootRequiresExplicitFlag(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteIssuesFile(t, tempDir, `{\"id\":\"epic-1\",\"title\":\"Other\",\"issue_type\":\"epic\",\"status\":\"open\"}`)\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tstdout := &bytes.Buffer{}\n\tstderr := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir}, runner.Run, exit.Exit, stdout, stderr, beadsRunner, gitRunner)\n\n\tif code != 1 {\n\t\tt.Fatalf(\"expected exit code 1, got %d\", code)\n\t}\n\tif exit.code != 1 {\n\t\tt.Fatalf(\"expected exit to be called with 1, got %d\", exit.code)\n\t}\n\tif runner.called {\n\t\tt.Fatalf(\"expected run once not to be called\")\n\t}\n\tif !strings.Contains(stderr.String(), \"--root\") {\n\t\tt.Fatalf(\"expected error to mention --root, got %q\", stderr.String())\n\t}\n\tif !strings.Contains(strings.ToLower(stderr.String()), \"roadmap\") {\n\t\tt.Fatalf(\"expected error to mention roadmap, got %q\", stderr.String())\n\t}\n}\n\ntype fakeTUIProgram struct {\n\tstarted chan struct{}\n\tquit    chan struct{}\n\tevents  chan runner.Event\n}\n\nfunc newFakeTUIProgram() *fakeTUIProgram {\n\treturn &fakeTUIProgram{\n\t\tstarted: make(chan struct{}),\n\t\tquit:    make(chan struct{}),\n\t\tevents:  make(chan runner.Event, 1),\n\t}\n}\n\nfunc (f *fakeTUIProgram) Start() error {\n\tclose(f.started)\n\treturn nil\n}\n\nfunc (f *fakeTUIProgram) Send(event runner.Event) {\n\tf.events <- event\n}\n\nfunc (f *fakeTUIProgram) Quit() {\n\tclose(f.quit)\n}\n\nfunc waitForSignal(t *testing.T, signal chan struct{}, label string) {\n\tt.Helper()\n\tselect {\n\tcase <-signal:\n\t\treturn\n\tcase <-time.After(200 * time.Millisecond):\n\t\tt.Fatalf(\"expected %s\", label)\n\t}\n}\n\nfunc writeIssuesFile(t *testing.T, repoRoot string, payload string) {\n\tt.Helper()\n\tbeadsDir := filepath.Join(repoRoot, \".beads\")\n\tif err := os.MkdirAll(beadsDir, 0o755); err != nil {\n\t\tt.Fatalf(\"mkdir .beads: %v\", err)\n\t}\n\tissuesPath := filepath.Join(beadsDir, \"issues.jsonl\")\n\tif err := os.WriteFile(issuesPath, []byte(payload+\"\\n\"), 0o644); err != nil {\n\t\tt.Fatalf(\"write issues: %v\", err)\n\t}\n}\n\nfunc writeAgentFile(t *testing.T, repoRoot string, payload string) {\n\tt.Helper()\n\tagentDir := filepath.Join(repoRoot, \".opencode\", \"agent\")\n\tif err := os.MkdirAll(agentDir, 0o755); err != nil {\n\t\tt.Fatalf(\"mkdir agent dir: %v\", err)\n\t}\n\tagentPath := filepath.Join(agentDir, \"yolo.md\")\n\tif err := os.WriteFile(agentPath, []byte(payload), 0o644); err != nil {\n\t\tt.Fatalf(\"write agent file: %v\", err)\n\t}\n}\n\nfunc TestRunOnceMainUsesTUIOnTTYByDefault(t *testing.T) {\n\tfakeProgram := newFakeTUIProgram()\n\tprevIsTerminal := isTerminal\n\tprevNewTUIProgram := newTUIProgram\n\tisTerminal = func(io.Writer) bool { return true }\n\tnewTUIProgram = func(stdout io.Writer) tuiProgram { return fakeProgram }\n\tt.Cleanup(func() {\n\t\tisTerminal = prevIsTerminal\n\t\tnewTUIProgram = prevNewTUIProgram\n\t})\n\n\trunOnce := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\"}, runOnce.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", code)\n\t}\n\tif runOnce.deps.Events == nil {\n\t\tt.Fatalf(\"expected events emitter to be set\")\n\t}\n\trunOnce.deps.Events.Emit(runner.Event{Type: runner.EventSelectTask})\n\twaitForSignal(t, fakeProgram.started, \"tui start\")\n\twaitForSignal(t, fakeProgram.quit, \"tui quit\")\n\tselect {\n\tcase <-fakeProgram.events:\n\t\t// ok\n\tcase <-time.After(200 * time.Millisecond):\n\t\tt.Fatalf(\"expected event to be forwarded to TUI\")\n\t}\n}\n\nfunc TestRunOnceMainHeadlessDisablesTUI(t *testing.T) {\n\tcalled := false\n\tprevIsTerminal := isTerminal\n\tprevNewTUIProgram := newTUIProgram\n\tisTerminal = func(io.Writer) bool { return true }\n\tnewTUIProgram = func(stdout io.Writer) tuiProgram {\n\t\tcalled = true\n\t\treturn newFakeTUIProgram()\n\t}\n\tt.Cleanup(func() {\n\t\tisTerminal = prevIsTerminal\n\t\tnewTUIProgram = prevNewTUIProgram\n\t})\n\n\trunOnce := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\tstderr := &bytes.Buffer{}\n\n\tRunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\", \"--headless\"}, runOnce.Run, exit.Exit, out, stderr, beadsRunner, gitRunner)\n\n\tif called {\n\t\tt.Fatalf(\"expected TUI program not to start\")\n\t}\n\tif runOnce.deps.Events != nil {\n\t\tt.Fatalf(\"expected no events emitter in headless mode\")\n\t}\n}\n\nfunc TestOpenCodeRunDefaultsCreateConfigAndEnv(t *testing.T) {\n\ttempDir := t.TempDir()\n\trepoRoot := filepath.Join(tempDir, \"repo\")\n\tif err := os.MkdirAll(repoRoot, 0o755); err != nil {\n\t\tt.Fatalf(\"mkdir repo: %v\", err)\n\t}\n\tt.Setenv(\"HOME\", tempDir)\n\n\topenCodeRunner := &fakeOpenCodeRunner{}\n\topenCodeAdapter := openCodeAdapter{runner: openCodeRunner}\n\n\tconfigRoot := filepath.Join(tempDir, \".config\", \"opencode-runner\")\n\tconfigDir := filepath.Join(configRoot, \"opencode\")\n\tlogPath := filepath.Join(tempDir, \"runner-logs\", \"opencode\", \"issue-1.jsonl\")\n\n\tif err := openCodeAdapter.Run(\"issue-1\", repoRoot, \"prompt\", \"\", configRoot, configDir, logPath); err != nil {\n\t\tt.Fatalf(\"open code run error: %v\", err)\n\t}\n\n\tconfigFile := filepath.Join(configDir, \"opencode.json\")\n\tif _, err := os.Stat(configFile); err != nil {\n\t\tt.Fatalf(\"expected opencode.json to exist: %v\", err)\n\t}\n\texpectedConfigFile := filepath.Join(configDir, \"opencode.json\")\n\tif openCodeRunner.env[\"XDG_CONFIG_HOME\"] != configRoot {\n\t\tt.Fatalf(\"expected XDG_CONFIG_HOME set\")\n\t}\n\tif openCodeRunner.env[\"OPENCODE_CONFIG_DIR\"] != configDir {\n\t\tt.Fatalf(\"expected OPENCODE_CONFIG_DIR set\")\n\t}\n\tif openCodeRunner.env[\"OPENCODE_CONFIG\"] != expectedConfigFile {\n\t\tt.Fatalf(\"expected OPENCODE_CONFIG set\")\n\t}\n\tif openCodeRunner.env[\"OPENCODE_CONFIG_CONTENT\"] != \"{}\" {\n\t\tt.Fatalf(\"expected OPENCODE_CONFIG_CONTENT set\")\n\t}\n}\n","after":"package main\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"yolo-runner/internal/opencode\"\n\t\"yolo-runner/internal/runner\"\n)\n\ntype fakeRunner struct {\n\tcalls []string\n}\n\nfunc (f *fakeRunner) Run(args ...string) (string, error) {\n\tf.calls = append(f.calls, strings.Join(args, \" \"))\n\treturn \"\", nil\n}\n\ntype fakeOpenCodeRunLogger struct {\n\tcalled     bool\n\tissueID    string\n\trepoRoot   string\n\tprompt     string\n\tmodel      string\n\tconfigRoot string\n\tconfigDir  string\n\tlogPath    string\n}\n\nfunc (f *fakeOpenCodeRunLogger) Run(issueID string, repoRoot string, prompt string, model string, configRoot string, configDir string, logPath string) error {\n\tf.called = true\n\tf.issueID = issueID\n\tf.repoRoot = repoRoot\n\tf.prompt = prompt\n\tf.model = model\n\tf.configRoot = configRoot\n\tf.configDir = configDir\n\tf.logPath = logPath\n\treturn nil\n}\n\ntype fakeOpenCodeRunner struct {\n\tenv map[string]string\n}\n\ntype fakeOpenCodeProcess struct{}\n\nfunc (fakeOpenCodeProcess) Wait() error { return nil }\n\nfunc (fakeOpenCodeProcess) Kill() error { return nil }\n\nfunc (f *fakeOpenCodeRunner) Start(args []string, env map[string]string, stdoutPath string) (opencode.Process, error) {\n\tf.env = env\n\treturn fakeOpenCodeProcess{}, nil\n}\n\ntype fakeGitRunner struct {\n\tcalls  []string\n\toutput string\n\terr    error\n}\n\nfunc (f *fakeGitRunner) Run(name string, args ...string) (string, error) {\n\tf.calls = append(f.calls, name+\" \"+strings.Join(args, \" \"))\n\treturn f.output, f.err\n}\n\ntype fakeExit struct {\n\tcode int\n}\n\nfunc (f *fakeExit) Exit(code int) {\n\tf.code = code\n}\n\ntype fakeRunOnce struct {\n\tcalled bool\n\topts   runner.RunOnceOptions\n\tdeps   runner.RunOnceDeps\n\tresult string\n\terr    error\n}\n\nfunc (f *fakeRunOnce) Run(opts runner.RunOnceOptions, deps runner.RunOnceDeps) (string, error) {\n\n\tf.called = true\n\tf.opts = opts\n\tf.deps = deps\n\treturn f.result, f.err\n}\n\nfunc TestRunOnceMainReturnsErrorCodeOnFailure(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n\trunner := &fakeRunOnce{err: errors.New(\"boom\")}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\"}, runner.Run, exit.Exit, out, out, nil, nil)\n\n\tif code != 1 {\n\t\tt.Fatalf(\"expected exit code 1, got %d\", code)\n\t}\n\tif exit.code != 1 {\n\t\tt.Fatalf(\"expected exit to be called with 1, got %d\", exit.code)\n\t}\n\tif !strings.Contains(out.String(), \"boom\") {\n\t\tt.Fatalf(\"expected error output, got %q\", out.String())\n\t}\n}\n\nfunc TestRunOnceMainWiresDependencies(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tRunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\", \"--model\", \"model\", \"--dry-run\"}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif !runner.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n\tif runner.opts.RepoRoot != \"/repo\" || runner.opts.RootID != \"root\" || runner.opts.Model != \"model\" || !runner.opts.DryRun {\n\t\tt.Fatalf(\"unexpected options: %#v\", runner.opts)\n\t}\n\tif runner.opts.Out == nil {\n\t\tt.Fatalf(\"expected output writer\")\n\t}\n\tif runner.deps.Beads == nil || runner.deps.Git == nil || runner.deps.Prompt == nil || runner.deps.OpenCode == nil || runner.deps.Logger == nil {\n\t\tt.Fatalf(\"expected deps to be wired\")\n\t}\n\tif exit.code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", exit.code)\n\t}\n}\n\nfunc TestRunOnceMainDefaultsConfigPaths(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tt.Setenv(\"HOME\", \"/home/user\")\n\n\tRunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\"}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif !runner.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n\tif runner.opts.ConfigRoot == \"\" {\n\t\tt.Fatalf(\"expected config root to be set\")\n\t}\n\tif runner.opts.ConfigDir == \"\" {\n\t\tt.Fatalf(\"expected config dir to be set\")\n\t}\n\texpectedConfigRoot := filepath.Join(\"/home/user\", \".config\", \"opencode-runner\")\n\tif runner.opts.ConfigRoot != expectedConfigRoot {\n\t\tt.Fatalf(\"expected config root %q, got %q\", expectedConfigRoot, runner.opts.ConfigRoot)\n\t}\n\texpectedConfigDir := filepath.Join(expectedConfigRoot, \"opencode\")\n\tif runner.opts.ConfigDir != expectedConfigDir {\n\t\tt.Fatalf(\"expected config dir %q, got %q\", expectedConfigDir, runner.opts.ConfigDir)\n\t}\n\tif exit.code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", exit.code)\n\t}\n}\n\nfunc TestRunOnceMainFailsWhenYoloAgentMissing(t *testing.T) {\n\ttempDir := t.TempDir()\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tstdout := &bytes.Buffer{}\n\tstderr := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\"}, runner.Run, exit.Exit, stdout, stderr, beadsRunner, gitRunner)\n\n\tif code != 1 {\n\t\tt.Fatalf(\"expected exit code 1, got %d\", code)\n\t}\n\tif exit.code != 1 {\n\t\tt.Fatalf(\"expected exit to be called with 1, got %d\", exit.code)\n\t}\n\tif runner.called {\n\t\tt.Fatalf(\"expected run once not to be called\")\n\t}\n\tif !strings.Contains(stderr.String(), \"yolo.md\") {\n\t\tt.Fatalf(\"expected error to mention yolo.md, got %q\", stderr.String())\n\t}\n}\n\nfunc TestRunOnceMainFailsWhenYoloAgentMissingPermission(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteAgentFile(t, tempDir, \"---\\nname: yolo\\n---\\n\")\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tstdout := &bytes.Buffer{}\n\tstderr := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\"}, runner.Run, exit.Exit, stdout, stderr, beadsRunner, gitRunner)\n\n\tif code != 1 {\n\t\tt.Fatalf(\"expected exit code 1, got %d\", code)\n\t}\n\tif exit.code != 1 {\n\t\tt.Fatalf(\"expected exit to be called with 1, got %d\", exit.code)\n\t}\n\tif runner.called {\n\t\tt.Fatalf(\"expected run once not to be called\")\n\t}\n\tif !strings.Contains(stderr.String(), \"permission: allow\") {\n\t\tt.Fatalf(\"expected error to mention permission allow, got %q\", stderr.String())\n\t}\n\tif !strings.Contains(strings.ToLower(stderr.String()), \"init\") {\n\t\tt.Fatalf(\"expected guidance to run init, got %q\", stderr.String())\n\t}\n}\n\nfunc TestRunOnceMainInfersRoadmapRootWhenMissing(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteIssuesFile(t, tempDir, `{\"id\":\"roadmap-1\",\"title\":\"Roadmap\",\"issue_type\":\"epic\",\"status\":\"open\"}`)\n\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", code)\n\t}\n\tif !runner.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n\tif runner.opts.RootID != \"roadmap-1\" {\n\t\tt.Fatalf(\"expected root id to be inferred, got %q\", runner.opts.RootID)\n\t}\n}\n\nfunc TestRunOnceMainInfersRoadmapRootWhenInProgress(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteIssuesFile(t, tempDir, `{\"id\":\"roadmap-2\",\"title\":\"Roadmap\",\"issue_type\":\"epic\",\"status\":\"in_progress\"}`)\n\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", code)\n\t}\n\tif !runner.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n\tif runner.opts.RootID != \"roadmap-2\" {\n\t\tt.Fatalf(\"expected root id to be inferred, got %q\", runner.opts.RootID)\n\t}\n}\n\nfunc TestRunOnceMainMissingRootRequiresExplicitFlag(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteIssuesFile(t, tempDir, `{\"id\":\"epic-1\",\"title\":\"Other\",\"issue_type\":\"epic\",\"status\":\"open\"}`)\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tstdout := &bytes.Buffer{}\n\tstderr := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir}, runner.Run, exit.Exit, stdout, stderr, beadsRunner, gitRunner)\n\n\tif code != 1 {\n\t\tt.Fatalf(\"expected exit code 1, got %d\", code)\n\t}\n\tif exit.code != 1 {\n\t\tt.Fatalf(\"expected exit to be called with 1, got %d\", exit.code)\n\t}\n\tif runner.called {\n\t\tt.Fatalf(\"expected run once not to be called\")\n\t}\n\tif !strings.Contains(stderr.String(), \"--root\") {\n\t\tt.Fatalf(\"expected error to mention --root, got %q\", stderr.String())\n\t}\n\tif !strings.Contains(strings.ToLower(stderr.String()), \"roadmap\") {\n\t\tt.Fatalf(\"expected error to mention roadmap, got %q\", stderr.String())\n\t}\n}\n\ntype fakeTUIProgram struct {\n\tstarted chan struct{}\n\tquit    chan struct{}\n\tevents  chan runner.Event\n}\n\nfunc newFakeTUIProgram() *fakeTUIProgram {\n\treturn &fakeTUIProgram{\n\t\tstarted: make(chan struct{}),\n\t\tquit:    make(chan struct{}),\n\t\tevents:  make(chan runner.Event, 1),\n\t}\n}\n\nfunc (f *fakeTUIProgram) Start() error {\n\tclose(f.started)\n\treturn nil\n}\n\nfunc (f *fakeTUIProgram) Send(event runner.Event) {\n\tf.events <- event\n}\n\nfunc (f *fakeTUIProgram) Quit() {\n\tclose(f.quit)\n}\n\nfunc waitForSignal(t *testing.T, signal chan struct{}, label string) {\n\tt.Helper()\n\tselect {\n\tcase <-signal:\n\t\treturn\n\tcase <-time.After(200 * time.Millisecond):\n\t\tt.Fatalf(\"expected %s\", label)\n\t}\n}\n\nfunc writeIssuesFile(t *testing.T, repoRoot string, payload string) {\n\tt.Helper()\n\tbeadsDir := filepath.Join(repoRoot, \".beads\")\n\tif err := os.MkdirAll(beadsDir, 0o755); err != nil {\n\t\tt.Fatalf(\"mkdir .beads: %v\", err)\n\t}\n\tissuesPath := filepath.Join(beadsDir, \"issues.jsonl\")\n\tif err := os.WriteFile(issuesPath, []byte(payload+\"\\n\"), 0o644); err != nil {\n\t\tt.Fatalf(\"write issues: %v\", err)\n\t}\n}\n\nfunc writeAgentFile(t *testing.T, repoRoot string, payload string) {\n\tt.Helper()\n\tagentDir := filepath.Join(repoRoot, \".opencode\", \"agent\")\n\tif err := os.MkdirAll(agentDir, 0o755); err != nil {\n\t\tt.Fatalf(\"mkdir agent dir: %v\", err)\n\t}\n\tagentPath := filepath.Join(agentDir, \"yolo.md\")\n\tif err := os.WriteFile(agentPath, []byte(payload), 0o644); err != nil {\n\t\tt.Fatalf(\"write agent file: %v\", err)\n\t}\n}\n\nfunc TestRunOnceMainUsesTUIOnTTYByDefault(t *testing.T) {\n\tfakeProgram := newFakeTUIProgram()\n\tprevIsTerminal := isTerminal\n\tprevNewTUIProgram := newTUIProgram\n\tisTerminal = func(io.Writer) bool { return true }\n\tnewTUIProgram = func(stdout io.Writer) tuiProgram { return fakeProgram }\n\tt.Cleanup(func() {\n\t\tisTerminal = prevIsTerminal\n\t\tnewTUIProgram = prevNewTUIProgram\n\t})\n\n\trunOnce := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\"}, runOnce.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", code)\n\t}\n\tif runOnce.deps.Events == nil {\n\t\tt.Fatalf(\"expected events emitter to be set\")\n\t}\n\trunOnce.deps.Events.Emit(runner.Event{Type: runner.EventSelectTask})\n\twaitForSignal(t, fakeProgram.started, \"tui start\")\n\twaitForSignal(t, fakeProgram.quit, \"tui quit\")\n\tselect {\n\tcase <-fakeProgram.events:\n\t\t// ok\n\tcase <-time.After(200 * time.Millisecond):\n\t\tt.Fatalf(\"expected event to be forwarded to TUI\")\n\t}\n}\n\nfunc TestRunOnceMainHeadlessDisablesTUI(t *testing.T) {\n\tcalled := false\n\tprevIsTerminal := isTerminal\n\tprevNewTUIProgram := newTUIProgram\n\tisTerminal = func(io.Writer) bool { return true }\n\tnewTUIProgram = func(stdout io.Writer) tuiProgram {\n\t\tcalled = true\n\t\treturn newFakeTUIProgram()\n\t}\n\tt.Cleanup(func() {\n\t\tisTerminal = prevIsTerminal\n\t\tnewTUIProgram = prevNewTUIProgram\n\t})\n\n\trunOnce := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\tstderr := &bytes.Buffer{}\n\n\tRunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\", \"--headless\"}, runOnce.Run, exit.Exit, out, stderr, beadsRunner, gitRunner)\n\n\tif called {\n\t\tt.Fatalf(\"expected TUI program not to start\")\n\t}\n\tif runOnce.deps.Events != nil {\n\t\tt.Fatalf(\"expected no events emitter in headless mode\")\n\t}\n}\n\nfunc TestOpenCodeRunDefaultsCreateConfigAndEnv(t *testing.T) {\n\ttempDir := t.TempDir()\n\trepoRoot := filepath.Join(tempDir, \"repo\")\n\tif err := os.MkdirAll(repoRoot, 0o755); err != nil {\n\t\tt.Fatalf(\"mkdir repo: %v\", err)\n\t}\n\tt.Setenv(\"HOME\", tempDir)\n\n\topenCodeRunner := &fakeOpenCodeRunner{}\n\topenCodeAdapter := openCodeAdapter{runner: openCodeRunner}\n\n\tconfigRoot := filepath.Join(tempDir, \".config\", \"opencode-runner\")\n\tconfigDir := filepath.Join(configRoot, \"opencode\")\n\tlogPath := filepath.Join(tempDir, \"runner-logs\", \"opencode\", \"issue-1.jsonl\")\n\n\tif err := openCodeAdapter.Run(\"issue-1\", repoRoot, \"prompt\", \"\", configRoot, configDir, logPath); err != nil {\n\t\tt.Fatalf(\"open code run error: %v\", err)\n\t}\n\n\tconfigFile := filepath.Join(configDir, \"opencode.json\")\n\tif _, err := os.Stat(configFile); err != nil {\n\t\tt.Fatalf(\"expected opencode.json to exist: %v\", err)\n\t}\n\texpectedConfigFile := filepath.Join(configDir, \"opencode.json\")\n\tif openCodeRunner.env[\"XDG_CONFIG_HOME\"] != configRoot {\n\t\tt.Fatalf(\"expected XDG_CONFIG_HOME set\")\n\t}\n\tif openCodeRunner.env[\"OPENCODE_CONFIG_DIR\"] != configDir {\n\t\tt.Fatalf(\"expected OPENCODE_CONFIG_DIR set\")\n\t}\n\tif openCodeRunner.env[\"OPENCODE_CONFIG\"] != expectedConfigFile {\n\t\tt.Fatalf(\"expected OPENCODE_CONFIG set\")\n\t}\n\tif openCodeRunner.env[\"OPENCODE_CONFIG_CONTENT\"] != \"{}\" {\n\t\tt.Fatalf(\"expected OPENCODE_CONFIG_CONTENT set\")\n\t}\n}\n","additions":1,"deletions":0},"truncated":false},"time":{"start":1768850777946,"end":1768850778108}},"metadata":{"openai":{"itemId":"fc_05fa46e58d0d4c1201696e85548f2481918227df8003adbbb0"}}}}
{"type":"step_finish","timestamp":1768850778127,"sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","part":{"id":"prt_bd7b8e7fd001eMzSllfbmaPaGk","sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","messageID":"msg_bd7b8ce96001Scx8F7unXgqe21","type":"step-finish","reason":"tool-calls","snapshot":"9f9bf2fc87f31089969cf33c30a4e99f14251463","cost":0,"tokens":{"input":688,"output":336,"reasoning":0,"cache":{"read":26240,"write":0}}}}
{"type":"step_start","timestamp":1768850778487,"sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","part":{"id":"prt_bd7b8e977001KWYKw6try0qCXe","sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","messageID":"msg_bd7b8e825001x4dEMlIoZQuV5K","type":"step-start","snapshot":"371316b71633ab1ceb019ba3938555b30ab6db2e"}}
{"type":"tool_use","timestamp":1768850784743,"sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","part":{"id":"prt_bd7b8eb9f001tT97FS2TZk4uci","sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","messageID":"msg_bd7b8e825001x4dEMlIoZQuV5K","type":"tool","callID":"call_LTm0Ki0J0G37zW92J84Adq54","tool":"edit","state":{"status":"completed","input":{"filePath":"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go","oldString":"\ttempDir := t.TempDir()\n\twriteIssuesFile(t, tempDir, `{\"id\":\"epic-1\",\"title\":\"Other\",\"issue_type\":\"epic\",\"status\":\"open\"}`)\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tstdout := &bytes.Buffer{}\n\tstderr := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir}, runner.Run, exit.Exit, stdout, stderr, beadsRunner, gitRunner)\n","newString":"\ttempDir := t.TempDir()\n\twriteIssuesFile(t, tempDir, `{\"id\":\"epic-1\",\"title\":\"Other\",\"issue_type\":\"epic\",\"status\":\"open\"}`)\n\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tstdout := &bytes.Buffer{}\n\tstderr := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir}, runner.Run, exit.Exit, stdout, stderr, beadsRunner, gitRunner)\n"},"output":"Edit applied successfully.","title":"cmd/yolo-runner/main_test.go","metadata":{"diagnostics":{"/Users/egv/dev/yolo-runner/internal/opencode/client.go":[{"range":{"start":{"line":28,"character":1},"end":{"line":28,"character":18}},"severity":2,"code":"default","codeDescription":{"href":"https://staticcheck.dev/docs/checks/#S1031"},"source":"S1031","message":"unnecessary nil check around range"}],"/Users/egv/dev/yolo-runner/internal/opencode/watchdog.go":[],"/Users/egv/dev/yolo-runner/go.mod":[{"range":{"start":{"line":6,"character":44},"end":{"line":6,"character":55}},"severity":2,"source":"go mod tidy","message":"github.com/charmbracelet/bubbletea should be direct"},{"range":{"start":{"line":19,"character":26},"end":{"line":19,"character":37}},"severity":2,"source":"go mod tidy","message":"golang.org/x/term should be direct"}],"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main.go":[],"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go":[],"/Users/egv/dev/yolo-runner/cmd/yolo-runner/exec_test.go":[],"/Users/egv/dev/yolo-runner/internal/opencode/agent_test.go":[],"/Users/egv/dev/yolo-runner/internal/opencode/agent.go":[]},"diff":"Index: /Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go\n===================================================================\n--- /Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go\n+++ /Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go\n@@ -281,8 +281,9 @@\n \n func TestRunOnceMainMissingRootRequiresExplicitFlag(t *testing.T) {\n \ttempDir := t.TempDir()\n \twriteIssuesFile(t, tempDir, `{\"id\":\"epic-1\",\"title\":\"Other\",\"issue_type\":\"epic\",\"status\":\"open\"}`)\n+\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n \trunner := &fakeRunOnce{result: \"no_tasks\"}\n \texit := &fakeExit{}\n \tstdout := &bytes.Buffer{}\n \tstderr := &bytes.Buffer{}\n","filediff":{"file":"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go","before":"package main\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"yolo-runner/internal/opencode\"\n\t\"yolo-runner/internal/runner\"\n)\n\ntype fakeRunner struct {\n\tcalls []string\n}\n\nfunc (f *fakeRunner) Run(args ...string) (string, error) {\n\tf.calls = append(f.calls, strings.Join(args, \" \"))\n\treturn \"\", nil\n}\n\ntype fakeOpenCodeRunLogger struct {\n\tcalled     bool\n\tissueID    string\n\trepoRoot   string\n\tprompt     string\n\tmodel      string\n\tconfigRoot string\n\tconfigDir  string\n\tlogPath    string\n}\n\nfunc (f *fakeOpenCodeRunLogger) Run(issueID string, repoRoot string, prompt string, model string, configRoot string, configDir string, logPath string) error {\n\tf.called = true\n\tf.issueID = issueID\n\tf.repoRoot = repoRoot\n\tf.prompt = prompt\n\tf.model = model\n\tf.configRoot = configRoot\n\tf.configDir = configDir\n\tf.logPath = logPath\n\treturn nil\n}\n\ntype fakeOpenCodeRunner struct {\n\tenv map[string]string\n}\n\ntype fakeOpenCodeProcess struct{}\n\nfunc (fakeOpenCodeProcess) Wait() error { return nil }\n\nfunc (fakeOpenCodeProcess) Kill() error { return nil }\n\nfunc (f *fakeOpenCodeRunner) Start(args []string, env map[string]string, stdoutPath string) (opencode.Process, error) {\n\tf.env = env\n\treturn fakeOpenCodeProcess{}, nil\n}\n\ntype fakeGitRunner struct {\n\tcalls  []string\n\toutput string\n\terr    error\n}\n\nfunc (f *fakeGitRunner) Run(name string, args ...string) (string, error) {\n\tf.calls = append(f.calls, name+\" \"+strings.Join(args, \" \"))\n\treturn f.output, f.err\n}\n\ntype fakeExit struct {\n\tcode int\n}\n\nfunc (f *fakeExit) Exit(code int) {\n\tf.code = code\n}\n\ntype fakeRunOnce struct {\n\tcalled bool\n\topts   runner.RunOnceOptions\n\tdeps   runner.RunOnceDeps\n\tresult string\n\terr    error\n}\n\nfunc (f *fakeRunOnce) Run(opts runner.RunOnceOptions, deps runner.RunOnceDeps) (string, error) {\n\n\tf.called = true\n\tf.opts = opts\n\tf.deps = deps\n\treturn f.result, f.err\n}\n\nfunc TestRunOnceMainReturnsErrorCodeOnFailure(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n\trunner := &fakeRunOnce{err: errors.New(\"boom\")}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\"}, runner.Run, exit.Exit, out, out, nil, nil)\n\n\tif code != 1 {\n\t\tt.Fatalf(\"expected exit code 1, got %d\", code)\n\t}\n\tif exit.code != 1 {\n\t\tt.Fatalf(\"expected exit to be called with 1, got %d\", exit.code)\n\t}\n\tif !strings.Contains(out.String(), \"boom\") {\n\t\tt.Fatalf(\"expected error output, got %q\", out.String())\n\t}\n}\n\nfunc TestRunOnceMainWiresDependencies(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tRunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\", \"--model\", \"model\", \"--dry-run\"}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif !runner.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n\tif runner.opts.RepoRoot != \"/repo\" || runner.opts.RootID != \"root\" || runner.opts.Model != \"model\" || !runner.opts.DryRun {\n\t\tt.Fatalf(\"unexpected options: %#v\", runner.opts)\n\t}\n\tif runner.opts.Out == nil {\n\t\tt.Fatalf(\"expected output writer\")\n\t}\n\tif runner.deps.Beads == nil || runner.deps.Git == nil || runner.deps.Prompt == nil || runner.deps.OpenCode == nil || runner.deps.Logger == nil {\n\t\tt.Fatalf(\"expected deps to be wired\")\n\t}\n\tif exit.code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", exit.code)\n\t}\n}\n\nfunc TestRunOnceMainDefaultsConfigPaths(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tt.Setenv(\"HOME\", \"/home/user\")\n\n\tRunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\"}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif !runner.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n\tif runner.opts.ConfigRoot == \"\" {\n\t\tt.Fatalf(\"expected config root to be set\")\n\t}\n\tif runner.opts.ConfigDir == \"\" {\n\t\tt.Fatalf(\"expected config dir to be set\")\n\t}\n\texpectedConfigRoot := filepath.Join(\"/home/user\", \".config\", \"opencode-runner\")\n\tif runner.opts.ConfigRoot != expectedConfigRoot {\n\t\tt.Fatalf(\"expected config root %q, got %q\", expectedConfigRoot, runner.opts.ConfigRoot)\n\t}\n\texpectedConfigDir := filepath.Join(expectedConfigRoot, \"opencode\")\n\tif runner.opts.ConfigDir != expectedConfigDir {\n\t\tt.Fatalf(\"expected config dir %q, got %q\", expectedConfigDir, runner.opts.ConfigDir)\n\t}\n\tif exit.code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", exit.code)\n\t}\n}\n\nfunc TestRunOnceMainFailsWhenYoloAgentMissing(t *testing.T) {\n\ttempDir := t.TempDir()\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tstdout := &bytes.Buffer{}\n\tstderr := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\"}, runner.Run, exit.Exit, stdout, stderr, beadsRunner, gitRunner)\n\n\tif code != 1 {\n\t\tt.Fatalf(\"expected exit code 1, got %d\", code)\n\t}\n\tif exit.code != 1 {\n\t\tt.Fatalf(\"expected exit to be called with 1, got %d\", exit.code)\n\t}\n\tif runner.called {\n\t\tt.Fatalf(\"expected run once not to be called\")\n\t}\n\tif !strings.Contains(stderr.String(), \"yolo.md\") {\n\t\tt.Fatalf(\"expected error to mention yolo.md, got %q\", stderr.String())\n\t}\n}\n\nfunc TestRunOnceMainFailsWhenYoloAgentMissingPermission(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteAgentFile(t, tempDir, \"---\\nname: yolo\\n---\\n\")\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tstdout := &bytes.Buffer{}\n\tstderr := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\"}, runner.Run, exit.Exit, stdout, stderr, beadsRunner, gitRunner)\n\n\tif code != 1 {\n\t\tt.Fatalf(\"expected exit code 1, got %d\", code)\n\t}\n\tif exit.code != 1 {\n\t\tt.Fatalf(\"expected exit to be called with 1, got %d\", exit.code)\n\t}\n\tif runner.called {\n\t\tt.Fatalf(\"expected run once not to be called\")\n\t}\n\tif !strings.Contains(stderr.String(), \"permission: allow\") {\n\t\tt.Fatalf(\"expected error to mention permission allow, got %q\", stderr.String())\n\t}\n\tif !strings.Contains(strings.ToLower(stderr.String()), \"init\") {\n\t\tt.Fatalf(\"expected guidance to run init, got %q\", stderr.String())\n\t}\n}\n\nfunc TestRunOnceMainInfersRoadmapRootWhenMissing(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteIssuesFile(t, tempDir, `{\"id\":\"roadmap-1\",\"title\":\"Roadmap\",\"issue_type\":\"epic\",\"status\":\"open\"}`)\n\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", code)\n\t}\n\tif !runner.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n\tif runner.opts.RootID != \"roadmap-1\" {\n\t\tt.Fatalf(\"expected root id to be inferred, got %q\", runner.opts.RootID)\n\t}\n}\n\nfunc TestRunOnceMainInfersRoadmapRootWhenInProgress(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteIssuesFile(t, tempDir, `{\"id\":\"roadmap-2\",\"title\":\"Roadmap\",\"issue_type\":\"epic\",\"status\":\"in_progress\"}`)\n\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", code)\n\t}\n\tif !runner.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n\tif runner.opts.RootID != \"roadmap-2\" {\n\t\tt.Fatalf(\"expected root id to be inferred, got %q\", runner.opts.RootID)\n\t}\n}\n\nfunc TestRunOnceMainMissingRootRequiresExplicitFlag(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteIssuesFile(t, tempDir, `{\"id\":\"epic-1\",\"title\":\"Other\",\"issue_type\":\"epic\",\"status\":\"open\"}`)\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tstdout := &bytes.Buffer{}\n\tstderr := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir}, runner.Run, exit.Exit, stdout, stderr, beadsRunner, gitRunner)\n\n\tif code != 1 {\n\t\tt.Fatalf(\"expected exit code 1, got %d\", code)\n\t}\n\tif exit.code != 1 {\n\t\tt.Fatalf(\"expected exit to be called with 1, got %d\", exit.code)\n\t}\n\tif runner.called {\n\t\tt.Fatalf(\"expected run once not to be called\")\n\t}\n\tif !strings.Contains(stderr.String(), \"--root\") {\n\t\tt.Fatalf(\"expected error to mention --root, got %q\", stderr.String())\n\t}\n\tif !strings.Contains(strings.ToLower(stderr.String()), \"roadmap\") {\n\t\tt.Fatalf(\"expected error to mention roadmap, got %q\", stderr.String())\n\t}\n}\n\ntype fakeTUIProgram struct {\n\tstarted chan struct{}\n\tquit    chan struct{}\n\tevents  chan runner.Event\n}\n\nfunc newFakeTUIProgram() *fakeTUIProgram {\n\treturn &fakeTUIProgram{\n\t\tstarted: make(chan struct{}),\n\t\tquit:    make(chan struct{}),\n\t\tevents:  make(chan runner.Event, 1),\n\t}\n}\n\nfunc (f *fakeTUIProgram) Start() error {\n\tclose(f.started)\n\treturn nil\n}\n\nfunc (f *fakeTUIProgram) Send(event runner.Event) {\n\tf.events <- event\n}\n\nfunc (f *fakeTUIProgram) Quit() {\n\tclose(f.quit)\n}\n\nfunc waitForSignal(t *testing.T, signal chan struct{}, label string) {\n\tt.Helper()\n\tselect {\n\tcase <-signal:\n\t\treturn\n\tcase <-time.After(200 * time.Millisecond):\n\t\tt.Fatalf(\"expected %s\", label)\n\t}\n}\n\nfunc writeIssuesFile(t *testing.T, repoRoot string, payload string) {\n\tt.Helper()\n\tbeadsDir := filepath.Join(repoRoot, \".beads\")\n\tif err := os.MkdirAll(beadsDir, 0o755); err != nil {\n\t\tt.Fatalf(\"mkdir .beads: %v\", err)\n\t}\n\tissuesPath := filepath.Join(beadsDir, \"issues.jsonl\")\n\tif err := os.WriteFile(issuesPath, []byte(payload+\"\\n\"), 0o644); err != nil {\n\t\tt.Fatalf(\"write issues: %v\", err)\n\t}\n}\n\nfunc writeAgentFile(t *testing.T, repoRoot string, payload string) {\n\tt.Helper()\n\tagentDir := filepath.Join(repoRoot, \".opencode\", \"agent\")\n\tif err := os.MkdirAll(agentDir, 0o755); err != nil {\n\t\tt.Fatalf(\"mkdir agent dir: %v\", err)\n\t}\n\tagentPath := filepath.Join(agentDir, \"yolo.md\")\n\tif err := os.WriteFile(agentPath, []byte(payload), 0o644); err != nil {\n\t\tt.Fatalf(\"write agent file: %v\", err)\n\t}\n}\n\nfunc TestRunOnceMainUsesTUIOnTTYByDefault(t *testing.T) {\n\tfakeProgram := newFakeTUIProgram()\n\tprevIsTerminal := isTerminal\n\tprevNewTUIProgram := newTUIProgram\n\tisTerminal = func(io.Writer) bool { return true }\n\tnewTUIProgram = func(stdout io.Writer) tuiProgram { return fakeProgram }\n\tt.Cleanup(func() {\n\t\tisTerminal = prevIsTerminal\n\t\tnewTUIProgram = prevNewTUIProgram\n\t})\n\n\trunOnce := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\"}, runOnce.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", code)\n\t}\n\tif runOnce.deps.Events == nil {\n\t\tt.Fatalf(\"expected events emitter to be set\")\n\t}\n\trunOnce.deps.Events.Emit(runner.Event{Type: runner.EventSelectTask})\n\twaitForSignal(t, fakeProgram.started, \"tui start\")\n\twaitForSignal(t, fakeProgram.quit, \"tui quit\")\n\tselect {\n\tcase <-fakeProgram.events:\n\t\t// ok\n\tcase <-time.After(200 * time.Millisecond):\n\t\tt.Fatalf(\"expected event to be forwarded to TUI\")\n\t}\n}\n\nfunc TestRunOnceMainHeadlessDisablesTUI(t *testing.T) {\n\tcalled := false\n\tprevIsTerminal := isTerminal\n\tprevNewTUIProgram := newTUIProgram\n\tisTerminal = func(io.Writer) bool { return true }\n\tnewTUIProgram = func(stdout io.Writer) tuiProgram {\n\t\tcalled = true\n\t\treturn newFakeTUIProgram()\n\t}\n\tt.Cleanup(func() {\n\t\tisTerminal = prevIsTerminal\n\t\tnewTUIProgram = prevNewTUIProgram\n\t})\n\n\trunOnce := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\tstderr := &bytes.Buffer{}\n\n\tRunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\", \"--headless\"}, runOnce.Run, exit.Exit, out, stderr, beadsRunner, gitRunner)\n\n\tif called {\n\t\tt.Fatalf(\"expected TUI program not to start\")\n\t}\n\tif runOnce.deps.Events != nil {\n\t\tt.Fatalf(\"expected no events emitter in headless mode\")\n\t}\n}\n\nfunc TestOpenCodeRunDefaultsCreateConfigAndEnv(t *testing.T) {\n\ttempDir := t.TempDir()\n\trepoRoot := filepath.Join(tempDir, \"repo\")\n\tif err := os.MkdirAll(repoRoot, 0o755); err != nil {\n\t\tt.Fatalf(\"mkdir repo: %v\", err)\n\t}\n\tt.Setenv(\"HOME\", tempDir)\n\n\topenCodeRunner := &fakeOpenCodeRunner{}\n\topenCodeAdapter := openCodeAdapter{runner: openCodeRunner}\n\n\tconfigRoot := filepath.Join(tempDir, \".config\", \"opencode-runner\")\n\tconfigDir := filepath.Join(configRoot, \"opencode\")\n\tlogPath := filepath.Join(tempDir, \"runner-logs\", \"opencode\", \"issue-1.jsonl\")\n\n\tif err := openCodeAdapter.Run(\"issue-1\", repoRoot, \"prompt\", \"\", configRoot, configDir, logPath); err != nil {\n\t\tt.Fatalf(\"open code run error: %v\", err)\n\t}\n\n\tconfigFile := filepath.Join(configDir, \"opencode.json\")\n\tif _, err := os.Stat(configFile); err != nil {\n\t\tt.Fatalf(\"expected opencode.json to exist: %v\", err)\n\t}\n\texpectedConfigFile := filepath.Join(configDir, \"opencode.json\")\n\tif openCodeRunner.env[\"XDG_CONFIG_HOME\"] != configRoot {\n\t\tt.Fatalf(\"expected XDG_CONFIG_HOME set\")\n\t}\n\tif openCodeRunner.env[\"OPENCODE_CONFIG_DIR\"] != configDir {\n\t\tt.Fatalf(\"expected OPENCODE_CONFIG_DIR set\")\n\t}\n\tif openCodeRunner.env[\"OPENCODE_CONFIG\"] != expectedConfigFile {\n\t\tt.Fatalf(\"expected OPENCODE_CONFIG set\")\n\t}\n\tif openCodeRunner.env[\"OPENCODE_CONFIG_CONTENT\"] != \"{}\" {\n\t\tt.Fatalf(\"expected OPENCODE_CONFIG_CONTENT set\")\n\t}\n}\n","after":"package main\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"yolo-runner/internal/opencode\"\n\t\"yolo-runner/internal/runner\"\n)\n\ntype fakeRunner struct {\n\tcalls []string\n}\n\nfunc (f *fakeRunner) Run(args ...string) (string, error) {\n\tf.calls = append(f.calls, strings.Join(args, \" \"))\n\treturn \"\", nil\n}\n\ntype fakeOpenCodeRunLogger struct {\n\tcalled     bool\n\tissueID    string\n\trepoRoot   string\n\tprompt     string\n\tmodel      string\n\tconfigRoot string\n\tconfigDir  string\n\tlogPath    string\n}\n\nfunc (f *fakeOpenCodeRunLogger) Run(issueID string, repoRoot string, prompt string, model string, configRoot string, configDir string, logPath string) error {\n\tf.called = true\n\tf.issueID = issueID\n\tf.repoRoot = repoRoot\n\tf.prompt = prompt\n\tf.model = model\n\tf.configRoot = configRoot\n\tf.configDir = configDir\n\tf.logPath = logPath\n\treturn nil\n}\n\ntype fakeOpenCodeRunner struct {\n\tenv map[string]string\n}\n\ntype fakeOpenCodeProcess struct{}\n\nfunc (fakeOpenCodeProcess) Wait() error { return nil }\n\nfunc (fakeOpenCodeProcess) Kill() error { return nil }\n\nfunc (f *fakeOpenCodeRunner) Start(args []string, env map[string]string, stdoutPath string) (opencode.Process, error) {\n\tf.env = env\n\treturn fakeOpenCodeProcess{}, nil\n}\n\ntype fakeGitRunner struct {\n\tcalls  []string\n\toutput string\n\terr    error\n}\n\nfunc (f *fakeGitRunner) Run(name string, args ...string) (string, error) {\n\tf.calls = append(f.calls, name+\" \"+strings.Join(args, \" \"))\n\treturn f.output, f.err\n}\n\ntype fakeExit struct {\n\tcode int\n}\n\nfunc (f *fakeExit) Exit(code int) {\n\tf.code = code\n}\n\ntype fakeRunOnce struct {\n\tcalled bool\n\topts   runner.RunOnceOptions\n\tdeps   runner.RunOnceDeps\n\tresult string\n\terr    error\n}\n\nfunc (f *fakeRunOnce) Run(opts runner.RunOnceOptions, deps runner.RunOnceDeps) (string, error) {\n\n\tf.called = true\n\tf.opts = opts\n\tf.deps = deps\n\treturn f.result, f.err\n}\n\nfunc TestRunOnceMainReturnsErrorCodeOnFailure(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n\trunner := &fakeRunOnce{err: errors.New(\"boom\")}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\"}, runner.Run, exit.Exit, out, out, nil, nil)\n\n\tif code != 1 {\n\t\tt.Fatalf(\"expected exit code 1, got %d\", code)\n\t}\n\tif exit.code != 1 {\n\t\tt.Fatalf(\"expected exit to be called with 1, got %d\", exit.code)\n\t}\n\tif !strings.Contains(out.String(), \"boom\") {\n\t\tt.Fatalf(\"expected error output, got %q\", out.String())\n\t}\n}\n\nfunc TestRunOnceMainWiresDependencies(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tRunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\", \"--model\", \"model\", \"--dry-run\"}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif !runner.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n\tif runner.opts.RepoRoot != \"/repo\" || runner.opts.RootID != \"root\" || runner.opts.Model != \"model\" || !runner.opts.DryRun {\n\t\tt.Fatalf(\"unexpected options: %#v\", runner.opts)\n\t}\n\tif runner.opts.Out == nil {\n\t\tt.Fatalf(\"expected output writer\")\n\t}\n\tif runner.deps.Beads == nil || runner.deps.Git == nil || runner.deps.Prompt == nil || runner.deps.OpenCode == nil || runner.deps.Logger == nil {\n\t\tt.Fatalf(\"expected deps to be wired\")\n\t}\n\tif exit.code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", exit.code)\n\t}\n}\n\nfunc TestRunOnceMainDefaultsConfigPaths(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tt.Setenv(\"HOME\", \"/home/user\")\n\n\tRunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\"}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif !runner.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n\tif runner.opts.ConfigRoot == \"\" {\n\t\tt.Fatalf(\"expected config root to be set\")\n\t}\n\tif runner.opts.ConfigDir == \"\" {\n\t\tt.Fatalf(\"expected config dir to be set\")\n\t}\n\texpectedConfigRoot := filepath.Join(\"/home/user\", \".config\", \"opencode-runner\")\n\tif runner.opts.ConfigRoot != expectedConfigRoot {\n\t\tt.Fatalf(\"expected config root %q, got %q\", expectedConfigRoot, runner.opts.ConfigRoot)\n\t}\n\texpectedConfigDir := filepath.Join(expectedConfigRoot, \"opencode\")\n\tif runner.opts.ConfigDir != expectedConfigDir {\n\t\tt.Fatalf(\"expected config dir %q, got %q\", expectedConfigDir, runner.opts.ConfigDir)\n\t}\n\tif exit.code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", exit.code)\n\t}\n}\n\nfunc TestRunOnceMainFailsWhenYoloAgentMissing(t *testing.T) {\n\ttempDir := t.TempDir()\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tstdout := &bytes.Buffer{}\n\tstderr := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\"}, runner.Run, exit.Exit, stdout, stderr, beadsRunner, gitRunner)\n\n\tif code != 1 {\n\t\tt.Fatalf(\"expected exit code 1, got %d\", code)\n\t}\n\tif exit.code != 1 {\n\t\tt.Fatalf(\"expected exit to be called with 1, got %d\", exit.code)\n\t}\n\tif runner.called {\n\t\tt.Fatalf(\"expected run once not to be called\")\n\t}\n\tif !strings.Contains(stderr.String(), \"yolo.md\") {\n\t\tt.Fatalf(\"expected error to mention yolo.md, got %q\", stderr.String())\n\t}\n}\n\nfunc TestRunOnceMainFailsWhenYoloAgentMissingPermission(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteAgentFile(t, tempDir, \"---\\nname: yolo\\n---\\n\")\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tstdout := &bytes.Buffer{}\n\tstderr := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\"}, runner.Run, exit.Exit, stdout, stderr, beadsRunner, gitRunner)\n\n\tif code != 1 {\n\t\tt.Fatalf(\"expected exit code 1, got %d\", code)\n\t}\n\tif exit.code != 1 {\n\t\tt.Fatalf(\"expected exit to be called with 1, got %d\", exit.code)\n\t}\n\tif runner.called {\n\t\tt.Fatalf(\"expected run once not to be called\")\n\t}\n\tif !strings.Contains(stderr.String(), \"permission: allow\") {\n\t\tt.Fatalf(\"expected error to mention permission allow, got %q\", stderr.String())\n\t}\n\tif !strings.Contains(strings.ToLower(stderr.String()), \"init\") {\n\t\tt.Fatalf(\"expected guidance to run init, got %q\", stderr.String())\n\t}\n}\n\nfunc TestRunOnceMainInfersRoadmapRootWhenMissing(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteIssuesFile(t, tempDir, `{\"id\":\"roadmap-1\",\"title\":\"Roadmap\",\"issue_type\":\"epic\",\"status\":\"open\"}`)\n\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", code)\n\t}\n\tif !runner.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n\tif runner.opts.RootID != \"roadmap-1\" {\n\t\tt.Fatalf(\"expected root id to be inferred, got %q\", runner.opts.RootID)\n\t}\n}\n\nfunc TestRunOnceMainInfersRoadmapRootWhenInProgress(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteIssuesFile(t, tempDir, `{\"id\":\"roadmap-2\",\"title\":\"Roadmap\",\"issue_type\":\"epic\",\"status\":\"in_progress\"}`)\n\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", code)\n\t}\n\tif !runner.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n\tif runner.opts.RootID != \"roadmap-2\" {\n\t\tt.Fatalf(\"expected root id to be inferred, got %q\", runner.opts.RootID)\n\t}\n}\n\nfunc TestRunOnceMainMissingRootRequiresExplicitFlag(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteIssuesFile(t, tempDir, `{\"id\":\"epic-1\",\"title\":\"Other\",\"issue_type\":\"epic\",\"status\":\"open\"}`)\n\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tstdout := &bytes.Buffer{}\n\tstderr := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir}, runner.Run, exit.Exit, stdout, stderr, beadsRunner, gitRunner)\n\n\tif code != 1 {\n\t\tt.Fatalf(\"expected exit code 1, got %d\", code)\n\t}\n\tif exit.code != 1 {\n\t\tt.Fatalf(\"expected exit to be called with 1, got %d\", exit.code)\n\t}\n\tif runner.called {\n\t\tt.Fatalf(\"expected run once not to be called\")\n\t}\n\tif !strings.Contains(stderr.String(), \"--root\") {\n\t\tt.Fatalf(\"expected error to mention --root, got %q\", stderr.String())\n\t}\n\tif !strings.Contains(strings.ToLower(stderr.String()), \"roadmap\") {\n\t\tt.Fatalf(\"expected error to mention roadmap, got %q\", stderr.String())\n\t}\n}\n\ntype fakeTUIProgram struct {\n\tstarted chan struct{}\n\tquit    chan struct{}\n\tevents  chan runner.Event\n}\n\nfunc newFakeTUIProgram() *fakeTUIProgram {\n\treturn &fakeTUIProgram{\n\t\tstarted: make(chan struct{}),\n\t\tquit:    make(chan struct{}),\n\t\tevents:  make(chan runner.Event, 1),\n\t}\n}\n\nfunc (f *fakeTUIProgram) Start() error {\n\tclose(f.started)\n\treturn nil\n}\n\nfunc (f *fakeTUIProgram) Send(event runner.Event) {\n\tf.events <- event\n}\n\nfunc (f *fakeTUIProgram) Quit() {\n\tclose(f.quit)\n}\n\nfunc waitForSignal(t *testing.T, signal chan struct{}, label string) {\n\tt.Helper()\n\tselect {\n\tcase <-signal:\n\t\treturn\n\tcase <-time.After(200 * time.Millisecond):\n\t\tt.Fatalf(\"expected %s\", label)\n\t}\n}\n\nfunc writeIssuesFile(t *testing.T, repoRoot string, payload string) {\n\tt.Helper()\n\tbeadsDir := filepath.Join(repoRoot, \".beads\")\n\tif err := os.MkdirAll(beadsDir, 0o755); err != nil {\n\t\tt.Fatalf(\"mkdir .beads: %v\", err)\n\t}\n\tissuesPath := filepath.Join(beadsDir, \"issues.jsonl\")\n\tif err := os.WriteFile(issuesPath, []byte(payload+\"\\n\"), 0o644); err != nil {\n\t\tt.Fatalf(\"write issues: %v\", err)\n\t}\n}\n\nfunc writeAgentFile(t *testing.T, repoRoot string, payload string) {\n\tt.Helper()\n\tagentDir := filepath.Join(repoRoot, \".opencode\", \"agent\")\n\tif err := os.MkdirAll(agentDir, 0o755); err != nil {\n\t\tt.Fatalf(\"mkdir agent dir: %v\", err)\n\t}\n\tagentPath := filepath.Join(agentDir, \"yolo.md\")\n\tif err := os.WriteFile(agentPath, []byte(payload), 0o644); err != nil {\n\t\tt.Fatalf(\"write agent file: %v\", err)\n\t}\n}\n\nfunc TestRunOnceMainUsesTUIOnTTYByDefault(t *testing.T) {\n\tfakeProgram := newFakeTUIProgram()\n\tprevIsTerminal := isTerminal\n\tprevNewTUIProgram := newTUIProgram\n\tisTerminal = func(io.Writer) bool { return true }\n\tnewTUIProgram = func(stdout io.Writer) tuiProgram { return fakeProgram }\n\tt.Cleanup(func() {\n\t\tisTerminal = prevIsTerminal\n\t\tnewTUIProgram = prevNewTUIProgram\n\t})\n\n\trunOnce := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\"}, runOnce.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", code)\n\t}\n\tif runOnce.deps.Events == nil {\n\t\tt.Fatalf(\"expected events emitter to be set\")\n\t}\n\trunOnce.deps.Events.Emit(runner.Event{Type: runner.EventSelectTask})\n\twaitForSignal(t, fakeProgram.started, \"tui start\")\n\twaitForSignal(t, fakeProgram.quit, \"tui quit\")\n\tselect {\n\tcase <-fakeProgram.events:\n\t\t// ok\n\tcase <-time.After(200 * time.Millisecond):\n\t\tt.Fatalf(\"expected event to be forwarded to TUI\")\n\t}\n}\n\nfunc TestRunOnceMainHeadlessDisablesTUI(t *testing.T) {\n\tcalled := false\n\tprevIsTerminal := isTerminal\n\tprevNewTUIProgram := newTUIProgram\n\tisTerminal = func(io.Writer) bool { return true }\n\tnewTUIProgram = func(stdout io.Writer) tuiProgram {\n\t\tcalled = true\n\t\treturn newFakeTUIProgram()\n\t}\n\tt.Cleanup(func() {\n\t\tisTerminal = prevIsTerminal\n\t\tnewTUIProgram = prevNewTUIProgram\n\t})\n\n\trunOnce := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\tstderr := &bytes.Buffer{}\n\n\tRunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\", \"--headless\"}, runOnce.Run, exit.Exit, out, stderr, beadsRunner, gitRunner)\n\n\tif called {\n\t\tt.Fatalf(\"expected TUI program not to start\")\n\t}\n\tif runOnce.deps.Events != nil {\n\t\tt.Fatalf(\"expected no events emitter in headless mode\")\n\t}\n}\n\nfunc TestOpenCodeRunDefaultsCreateConfigAndEnv(t *testing.T) {\n\ttempDir := t.TempDir()\n\trepoRoot := filepath.Join(tempDir, \"repo\")\n\tif err := os.MkdirAll(repoRoot, 0o755); err != nil {\n\t\tt.Fatalf(\"mkdir repo: %v\", err)\n\t}\n\tt.Setenv(\"HOME\", tempDir)\n\n\topenCodeRunner := &fakeOpenCodeRunner{}\n\topenCodeAdapter := openCodeAdapter{runner: openCodeRunner}\n\n\tconfigRoot := filepath.Join(tempDir, \".config\", \"opencode-runner\")\n\tconfigDir := filepath.Join(configRoot, \"opencode\")\n\tlogPath := filepath.Join(tempDir, \"runner-logs\", \"opencode\", \"issue-1.jsonl\")\n\n\tif err := openCodeAdapter.Run(\"issue-1\", repoRoot, \"prompt\", \"\", configRoot, configDir, logPath); err != nil {\n\t\tt.Fatalf(\"open code run error: %v\", err)\n\t}\n\n\tconfigFile := filepath.Join(configDir, \"opencode.json\")\n\tif _, err := os.Stat(configFile); err != nil {\n\t\tt.Fatalf(\"expected opencode.json to exist: %v\", err)\n\t}\n\texpectedConfigFile := filepath.Join(configDir, \"opencode.json\")\n\tif openCodeRunner.env[\"XDG_CONFIG_HOME\"] != configRoot {\n\t\tt.Fatalf(\"expected XDG_CONFIG_HOME set\")\n\t}\n\tif openCodeRunner.env[\"OPENCODE_CONFIG_DIR\"] != configDir {\n\t\tt.Fatalf(\"expected OPENCODE_CONFIG_DIR set\")\n\t}\n\tif openCodeRunner.env[\"OPENCODE_CONFIG\"] != expectedConfigFile {\n\t\tt.Fatalf(\"expected OPENCODE_CONFIG set\")\n\t}\n\tif openCodeRunner.env[\"OPENCODE_CONFIG_CONTENT\"] != \"{}\" {\n\t\tt.Fatalf(\"expected OPENCODE_CONFIG_CONTENT set\")\n\t}\n}\n","additions":1,"deletions":0},"truncated":false},"time":{"start":1768850784581,"end":1768850784742}},"metadata":{"openai":{"itemId":"fc_02c4724a811c554801696e855b030481919edb28c3758810b8"}}}}
{"type":"step_finish","timestamp":1768850784763,"sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","part":{"id":"prt_bd7b901e7001NN1Y05aA6MRixr","sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","messageID":"msg_bd7b8e825001x4dEMlIoZQuV5K","type":"step-finish","reason":"tool-calls","snapshot":"cc35d5866e6c18946b9ed9c149670674cf40a1e7","cost":0,"tokens":{"input":1035,"output":348,"reasoning":0,"cache":{"read":26240,"write":0}}}}
{"type":"step_start","timestamp":1768850785113,"sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","part":{"id":"prt_bd7b90358001fPTaz0chEIIVJs","sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","messageID":"msg_bd7b9020f001lJmW8BFcY7SgS7","type":"step-start","snapshot":"8b148a98d275c8c1fb92d252c76fa201378ec613"}}
{"type":"tool_use","timestamp":1768850790749,"sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","part":{"id":"prt_bd7b907ac001dqpbOi6tGf6fRL","sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","messageID":"msg_bd7b9020f001lJmW8BFcY7SgS7","type":"tool","callID":"call_HeEOYBoz6wEaXOuAEWENuosL","tool":"edit","state":{"status":"completed","input":{"filePath":"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go","oldString":"\trunOnce := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\"}, runOnce.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n","newString":"\ttempDir := t.TempDir()\n\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n\trunOnce := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\"}, runOnce.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n"},"output":"Edit applied successfully.","title":"cmd/yolo-runner/main_test.go","metadata":{"diagnostics":{"/Users/egv/dev/yolo-runner/internal/opencode/client.go":[{"range":{"start":{"line":28,"character":1},"end":{"line":28,"character":18}},"severity":2,"code":"default","codeDescription":{"href":"https://staticcheck.dev/docs/checks/#S1031"},"source":"S1031","message":"unnecessary nil check around range"}],"/Users/egv/dev/yolo-runner/internal/opencode/watchdog.go":[],"/Users/egv/dev/yolo-runner/go.mod":[{"range":{"start":{"line":6,"character":44},"end":{"line":6,"character":55}},"severity":2,"source":"go mod tidy","message":"github.com/charmbracelet/bubbletea should be direct"},{"range":{"start":{"line":19,"character":26},"end":{"line":19,"character":37}},"severity":2,"source":"go mod tidy","message":"golang.org/x/term should be direct"}],"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main.go":[],"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go":[],"/Users/egv/dev/yolo-runner/cmd/yolo-runner/exec_test.go":[],"/Users/egv/dev/yolo-runner/internal/opencode/agent_test.go":[],"/Users/egv/dev/yolo-runner/internal/opencode/agent.go":[]},"diff":"Index: /Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go\n===================================================================\n--- /Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go\n+++ /Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go\n@@ -380,15 +380,17 @@\n \tisTerminal = prevIsTerminal\n \tnewTUIProgram = prevNewTUIProgram\n })\n \n+tempDir := t.TempDir()\n+writeAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n runOnce := &fakeRunOnce{result: \"no_tasks\"}\n exit := &fakeExit{}\n out := &bytes.Buffer{}\n beadsRunner := &fakeRunner{}\n gitRunner := &fakeGitRunner{}\n \n-code := RunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\"}, runOnce.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n+code := RunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\"}, runOnce.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n \n if code != 0 {\n \tt.Fatalf(\"expected exit code 0, got %d\", code)\n }\n","filediff":{"file":"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go","before":"package main\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"yolo-runner/internal/opencode\"\n\t\"yolo-runner/internal/runner\"\n)\n\ntype fakeRunner struct {\n\tcalls []string\n}\n\nfunc (f *fakeRunner) Run(args ...string) (string, error) {\n\tf.calls = append(f.calls, strings.Join(args, \" \"))\n\treturn \"\", nil\n}\n\ntype fakeOpenCodeRunLogger struct {\n\tcalled     bool\n\tissueID    string\n\trepoRoot   string\n\tprompt     string\n\tmodel      string\n\tconfigRoot string\n\tconfigDir  string\n\tlogPath    string\n}\n\nfunc (f *fakeOpenCodeRunLogger) Run(issueID string, repoRoot string, prompt string, model string, configRoot string, configDir string, logPath string) error {\n\tf.called = true\n\tf.issueID = issueID\n\tf.repoRoot = repoRoot\n\tf.prompt = prompt\n\tf.model = model\n\tf.configRoot = configRoot\n\tf.configDir = configDir\n\tf.logPath = logPath\n\treturn nil\n}\n\ntype fakeOpenCodeRunner struct {\n\tenv map[string]string\n}\n\ntype fakeOpenCodeProcess struct{}\n\nfunc (fakeOpenCodeProcess) Wait() error { return nil }\n\nfunc (fakeOpenCodeProcess) Kill() error { return nil }\n\nfunc (f *fakeOpenCodeRunner) Start(args []string, env map[string]string, stdoutPath string) (opencode.Process, error) {\n\tf.env = env\n\treturn fakeOpenCodeProcess{}, nil\n}\n\ntype fakeGitRunner struct {\n\tcalls  []string\n\toutput string\n\terr    error\n}\n\nfunc (f *fakeGitRunner) Run(name string, args ...string) (string, error) {\n\tf.calls = append(f.calls, name+\" \"+strings.Join(args, \" \"))\n\treturn f.output, f.err\n}\n\ntype fakeExit struct {\n\tcode int\n}\n\nfunc (f *fakeExit) Exit(code int) {\n\tf.code = code\n}\n\ntype fakeRunOnce struct {\n\tcalled bool\n\topts   runner.RunOnceOptions\n\tdeps   runner.RunOnceDeps\n\tresult string\n\terr    error\n}\n\nfunc (f *fakeRunOnce) Run(opts runner.RunOnceOptions, deps runner.RunOnceDeps) (string, error) {\n\n\tf.called = true\n\tf.opts = opts\n\tf.deps = deps\n\treturn f.result, f.err\n}\n\nfunc TestRunOnceMainReturnsErrorCodeOnFailure(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n\trunner := &fakeRunOnce{err: errors.New(\"boom\")}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\"}, runner.Run, exit.Exit, out, out, nil, nil)\n\n\tif code != 1 {\n\t\tt.Fatalf(\"expected exit code 1, got %d\", code)\n\t}\n\tif exit.code != 1 {\n\t\tt.Fatalf(\"expected exit to be called with 1, got %d\", exit.code)\n\t}\n\tif !strings.Contains(out.String(), \"boom\") {\n\t\tt.Fatalf(\"expected error output, got %q\", out.String())\n\t}\n}\n\nfunc TestRunOnceMainWiresDependencies(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tRunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\", \"--model\", \"model\", \"--dry-run\"}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif !runner.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n\tif runner.opts.RepoRoot != \"/repo\" || runner.opts.RootID != \"root\" || runner.opts.Model != \"model\" || !runner.opts.DryRun {\n\t\tt.Fatalf(\"unexpected options: %#v\", runner.opts)\n\t}\n\tif runner.opts.Out == nil {\n\t\tt.Fatalf(\"expected output writer\")\n\t}\n\tif runner.deps.Beads == nil || runner.deps.Git == nil || runner.deps.Prompt == nil || runner.deps.OpenCode == nil || runner.deps.Logger == nil {\n\t\tt.Fatalf(\"expected deps to be wired\")\n\t}\n\tif exit.code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", exit.code)\n\t}\n}\n\nfunc TestRunOnceMainDefaultsConfigPaths(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tt.Setenv(\"HOME\", \"/home/user\")\n\n\tRunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\"}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif !runner.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n\tif runner.opts.ConfigRoot == \"\" {\n\t\tt.Fatalf(\"expected config root to be set\")\n\t}\n\tif runner.opts.ConfigDir == \"\" {\n\t\tt.Fatalf(\"expected config dir to be set\")\n\t}\n\texpectedConfigRoot := filepath.Join(\"/home/user\", \".config\", \"opencode-runner\")\n\tif runner.opts.ConfigRoot != expectedConfigRoot {\n\t\tt.Fatalf(\"expected config root %q, got %q\", expectedConfigRoot, runner.opts.ConfigRoot)\n\t}\n\texpectedConfigDir := filepath.Join(expectedConfigRoot, \"opencode\")\n\tif runner.opts.ConfigDir != expectedConfigDir {\n\t\tt.Fatalf(\"expected config dir %q, got %q\", expectedConfigDir, runner.opts.ConfigDir)\n\t}\n\tif exit.code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", exit.code)\n\t}\n}\n\nfunc TestRunOnceMainFailsWhenYoloAgentMissing(t *testing.T) {\n\ttempDir := t.TempDir()\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tstdout := &bytes.Buffer{}\n\tstderr := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\"}, runner.Run, exit.Exit, stdout, stderr, beadsRunner, gitRunner)\n\n\tif code != 1 {\n\t\tt.Fatalf(\"expected exit code 1, got %d\", code)\n\t}\n\tif exit.code != 1 {\n\t\tt.Fatalf(\"expected exit to be called with 1, got %d\", exit.code)\n\t}\n\tif runner.called {\n\t\tt.Fatalf(\"expected run once not to be called\")\n\t}\n\tif !strings.Contains(stderr.String(), \"yolo.md\") {\n\t\tt.Fatalf(\"expected error to mention yolo.md, got %q\", stderr.String())\n\t}\n}\n\nfunc TestRunOnceMainFailsWhenYoloAgentMissingPermission(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteAgentFile(t, tempDir, \"---\\nname: yolo\\n---\\n\")\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tstdout := &bytes.Buffer{}\n\tstderr := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\"}, runner.Run, exit.Exit, stdout, stderr, beadsRunner, gitRunner)\n\n\tif code != 1 {\n\t\tt.Fatalf(\"expected exit code 1, got %d\", code)\n\t}\n\tif exit.code != 1 {\n\t\tt.Fatalf(\"expected exit to be called with 1, got %d\", exit.code)\n\t}\n\tif runner.called {\n\t\tt.Fatalf(\"expected run once not to be called\")\n\t}\n\tif !strings.Contains(stderr.String(), \"permission: allow\") {\n\t\tt.Fatalf(\"expected error to mention permission allow, got %q\", stderr.String())\n\t}\n\tif !strings.Contains(strings.ToLower(stderr.String()), \"init\") {\n\t\tt.Fatalf(\"expected guidance to run init, got %q\", stderr.String())\n\t}\n}\n\nfunc TestRunOnceMainInfersRoadmapRootWhenMissing(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteIssuesFile(t, tempDir, `{\"id\":\"roadmap-1\",\"title\":\"Roadmap\",\"issue_type\":\"epic\",\"status\":\"open\"}`)\n\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", code)\n\t}\n\tif !runner.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n\tif runner.opts.RootID != \"roadmap-1\" {\n\t\tt.Fatalf(\"expected root id to be inferred, got %q\", runner.opts.RootID)\n\t}\n}\n\nfunc TestRunOnceMainInfersRoadmapRootWhenInProgress(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteIssuesFile(t, tempDir, `{\"id\":\"roadmap-2\",\"title\":\"Roadmap\",\"issue_type\":\"epic\",\"status\":\"in_progress\"}`)\n\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", code)\n\t}\n\tif !runner.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n\tif runner.opts.RootID != \"roadmap-2\" {\n\t\tt.Fatalf(\"expected root id to be inferred, got %q\", runner.opts.RootID)\n\t}\n}\n\nfunc TestRunOnceMainMissingRootRequiresExplicitFlag(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteIssuesFile(t, tempDir, `{\"id\":\"epic-1\",\"title\":\"Other\",\"issue_type\":\"epic\",\"status\":\"open\"}`)\n\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tstdout := &bytes.Buffer{}\n\tstderr := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir}, runner.Run, exit.Exit, stdout, stderr, beadsRunner, gitRunner)\n\n\tif code != 1 {\n\t\tt.Fatalf(\"expected exit code 1, got %d\", code)\n\t}\n\tif exit.code != 1 {\n\t\tt.Fatalf(\"expected exit to be called with 1, got %d\", exit.code)\n\t}\n\tif runner.called {\n\t\tt.Fatalf(\"expected run once not to be called\")\n\t}\n\tif !strings.Contains(stderr.String(), \"--root\") {\n\t\tt.Fatalf(\"expected error to mention --root, got %q\", stderr.String())\n\t}\n\tif !strings.Contains(strings.ToLower(stderr.String()), \"roadmap\") {\n\t\tt.Fatalf(\"expected error to mention roadmap, got %q\", stderr.String())\n\t}\n}\n\ntype fakeTUIProgram struct {\n\tstarted chan struct{}\n\tquit    chan struct{}\n\tevents  chan runner.Event\n}\n\nfunc newFakeTUIProgram() *fakeTUIProgram {\n\treturn &fakeTUIProgram{\n\t\tstarted: make(chan struct{}),\n\t\tquit:    make(chan struct{}),\n\t\tevents:  make(chan runner.Event, 1),\n\t}\n}\n\nfunc (f *fakeTUIProgram) Start() error {\n\tclose(f.started)\n\treturn nil\n}\n\nfunc (f *fakeTUIProgram) Send(event runner.Event) {\n\tf.events <- event\n}\n\nfunc (f *fakeTUIProgram) Quit() {\n\tclose(f.quit)\n}\n\nfunc waitForSignal(t *testing.T, signal chan struct{}, label string) {\n\tt.Helper()\n\tselect {\n\tcase <-signal:\n\t\treturn\n\tcase <-time.After(200 * time.Millisecond):\n\t\tt.Fatalf(\"expected %s\", label)\n\t}\n}\n\nfunc writeIssuesFile(t *testing.T, repoRoot string, payload string) {\n\tt.Helper()\n\tbeadsDir := filepath.Join(repoRoot, \".beads\")\n\tif err := os.MkdirAll(beadsDir, 0o755); err != nil {\n\t\tt.Fatalf(\"mkdir .beads: %v\", err)\n\t}\n\tissuesPath := filepath.Join(beadsDir, \"issues.jsonl\")\n\tif err := os.WriteFile(issuesPath, []byte(payload+\"\\n\"), 0o644); err != nil {\n\t\tt.Fatalf(\"write issues: %v\", err)\n\t}\n}\n\nfunc writeAgentFile(t *testing.T, repoRoot string, payload string) {\n\tt.Helper()\n\tagentDir := filepath.Join(repoRoot, \".opencode\", \"agent\")\n\tif err := os.MkdirAll(agentDir, 0o755); err != nil {\n\t\tt.Fatalf(\"mkdir agent dir: %v\", err)\n\t}\n\tagentPath := filepath.Join(agentDir, \"yolo.md\")\n\tif err := os.WriteFile(agentPath, []byte(payload), 0o644); err != nil {\n\t\tt.Fatalf(\"write agent file: %v\", err)\n\t}\n}\n\nfunc TestRunOnceMainUsesTUIOnTTYByDefault(t *testing.T) {\n\tfakeProgram := newFakeTUIProgram()\n\tprevIsTerminal := isTerminal\n\tprevNewTUIProgram := newTUIProgram\n\tisTerminal = func(io.Writer) bool { return true }\n\tnewTUIProgram = func(stdout io.Writer) tuiProgram { return fakeProgram }\n\tt.Cleanup(func() {\n\t\tisTerminal = prevIsTerminal\n\t\tnewTUIProgram = prevNewTUIProgram\n\t})\n\n\trunOnce := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\"}, runOnce.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", code)\n\t}\n\tif runOnce.deps.Events == nil {\n\t\tt.Fatalf(\"expected events emitter to be set\")\n\t}\n\trunOnce.deps.Events.Emit(runner.Event{Type: runner.EventSelectTask})\n\twaitForSignal(t, fakeProgram.started, \"tui start\")\n\twaitForSignal(t, fakeProgram.quit, \"tui quit\")\n\tselect {\n\tcase <-fakeProgram.events:\n\t\t// ok\n\tcase <-time.After(200 * time.Millisecond):\n\t\tt.Fatalf(\"expected event to be forwarded to TUI\")\n\t}\n}\n\nfunc TestRunOnceMainHeadlessDisablesTUI(t *testing.T) {\n\tcalled := false\n\tprevIsTerminal := isTerminal\n\tprevNewTUIProgram := newTUIProgram\n\tisTerminal = func(io.Writer) bool { return true }\n\tnewTUIProgram = func(stdout io.Writer) tuiProgram {\n\t\tcalled = true\n\t\treturn newFakeTUIProgram()\n\t}\n\tt.Cleanup(func() {\n\t\tisTerminal = prevIsTerminal\n\t\tnewTUIProgram = prevNewTUIProgram\n\t})\n\n\trunOnce := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\tstderr := &bytes.Buffer{}\n\n\tRunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\", \"--headless\"}, runOnce.Run, exit.Exit, out, stderr, beadsRunner, gitRunner)\n\n\tif called {\n\t\tt.Fatalf(\"expected TUI program not to start\")\n\t}\n\tif runOnce.deps.Events != nil {\n\t\tt.Fatalf(\"expected no events emitter in headless mode\")\n\t}\n}\n\nfunc TestOpenCodeRunDefaultsCreateConfigAndEnv(t *testing.T) {\n\ttempDir := t.TempDir()\n\trepoRoot := filepath.Join(tempDir, \"repo\")\n\tif err := os.MkdirAll(repoRoot, 0o755); err != nil {\n\t\tt.Fatalf(\"mkdir repo: %v\", err)\n\t}\n\tt.Setenv(\"HOME\", tempDir)\n\n\topenCodeRunner := &fakeOpenCodeRunner{}\n\topenCodeAdapter := openCodeAdapter{runner: openCodeRunner}\n\n\tconfigRoot := filepath.Join(tempDir, \".config\", \"opencode-runner\")\n\tconfigDir := filepath.Join(configRoot, \"opencode\")\n\tlogPath := filepath.Join(tempDir, \"runner-logs\", \"opencode\", \"issue-1.jsonl\")\n\n\tif err := openCodeAdapter.Run(\"issue-1\", repoRoot, \"prompt\", \"\", configRoot, configDir, logPath); err != nil {\n\t\tt.Fatalf(\"open code run error: %v\", err)\n\t}\n\n\tconfigFile := filepath.Join(configDir, \"opencode.json\")\n\tif _, err := os.Stat(configFile); err != nil {\n\t\tt.Fatalf(\"expected opencode.json to exist: %v\", err)\n\t}\n\texpectedConfigFile := filepath.Join(configDir, \"opencode.json\")\n\tif openCodeRunner.env[\"XDG_CONFIG_HOME\"] != configRoot {\n\t\tt.Fatalf(\"expected XDG_CONFIG_HOME set\")\n\t}\n\tif openCodeRunner.env[\"OPENCODE_CONFIG_DIR\"] != configDir {\n\t\tt.Fatalf(\"expected OPENCODE_CONFIG_DIR set\")\n\t}\n\tif openCodeRunner.env[\"OPENCODE_CONFIG\"] != expectedConfigFile {\n\t\tt.Fatalf(\"expected OPENCODE_CONFIG set\")\n\t}\n\tif openCodeRunner.env[\"OPENCODE_CONFIG_CONTENT\"] != \"{}\" {\n\t\tt.Fatalf(\"expected OPENCODE_CONFIG_CONTENT set\")\n\t}\n}\n","after":"package main\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"yolo-runner/internal/opencode\"\n\t\"yolo-runner/internal/runner\"\n)\n\ntype fakeRunner struct {\n\tcalls []string\n}\n\nfunc (f *fakeRunner) Run(args ...string) (string, error) {\n\tf.calls = append(f.calls, strings.Join(args, \" \"))\n\treturn \"\", nil\n}\n\ntype fakeOpenCodeRunLogger struct {\n\tcalled     bool\n\tissueID    string\n\trepoRoot   string\n\tprompt     string\n\tmodel      string\n\tconfigRoot string\n\tconfigDir  string\n\tlogPath    string\n}\n\nfunc (f *fakeOpenCodeRunLogger) Run(issueID string, repoRoot string, prompt string, model string, configRoot string, configDir string, logPath string) error {\n\tf.called = true\n\tf.issueID = issueID\n\tf.repoRoot = repoRoot\n\tf.prompt = prompt\n\tf.model = model\n\tf.configRoot = configRoot\n\tf.configDir = configDir\n\tf.logPath = logPath\n\treturn nil\n}\n\ntype fakeOpenCodeRunner struct {\n\tenv map[string]string\n}\n\ntype fakeOpenCodeProcess struct{}\n\nfunc (fakeOpenCodeProcess) Wait() error { return nil }\n\nfunc (fakeOpenCodeProcess) Kill() error { return nil }\n\nfunc (f *fakeOpenCodeRunner) Start(args []string, env map[string]string, stdoutPath string) (opencode.Process, error) {\n\tf.env = env\n\treturn fakeOpenCodeProcess{}, nil\n}\n\ntype fakeGitRunner struct {\n\tcalls  []string\n\toutput string\n\terr    error\n}\n\nfunc (f *fakeGitRunner) Run(name string, args ...string) (string, error) {\n\tf.calls = append(f.calls, name+\" \"+strings.Join(args, \" \"))\n\treturn f.output, f.err\n}\n\ntype fakeExit struct {\n\tcode int\n}\n\nfunc (f *fakeExit) Exit(code int) {\n\tf.code = code\n}\n\ntype fakeRunOnce struct {\n\tcalled bool\n\topts   runner.RunOnceOptions\n\tdeps   runner.RunOnceDeps\n\tresult string\n\terr    error\n}\n\nfunc (f *fakeRunOnce) Run(opts runner.RunOnceOptions, deps runner.RunOnceDeps) (string, error) {\n\n\tf.called = true\n\tf.opts = opts\n\tf.deps = deps\n\treturn f.result, f.err\n}\n\nfunc TestRunOnceMainReturnsErrorCodeOnFailure(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n\trunner := &fakeRunOnce{err: errors.New(\"boom\")}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\"}, runner.Run, exit.Exit, out, out, nil, nil)\n\n\tif code != 1 {\n\t\tt.Fatalf(\"expected exit code 1, got %d\", code)\n\t}\n\tif exit.code != 1 {\n\t\tt.Fatalf(\"expected exit to be called with 1, got %d\", exit.code)\n\t}\n\tif !strings.Contains(out.String(), \"boom\") {\n\t\tt.Fatalf(\"expected error output, got %q\", out.String())\n\t}\n}\n\nfunc TestRunOnceMainWiresDependencies(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tRunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\", \"--model\", \"model\", \"--dry-run\"}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif !runner.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n\tif runner.opts.RepoRoot != \"/repo\" || runner.opts.RootID != \"root\" || runner.opts.Model != \"model\" || !runner.opts.DryRun {\n\t\tt.Fatalf(\"unexpected options: %#v\", runner.opts)\n\t}\n\tif runner.opts.Out == nil {\n\t\tt.Fatalf(\"expected output writer\")\n\t}\n\tif runner.deps.Beads == nil || runner.deps.Git == nil || runner.deps.Prompt == nil || runner.deps.OpenCode == nil || runner.deps.Logger == nil {\n\t\tt.Fatalf(\"expected deps to be wired\")\n\t}\n\tif exit.code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", exit.code)\n\t}\n}\n\nfunc TestRunOnceMainDefaultsConfigPaths(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tt.Setenv(\"HOME\", \"/home/user\")\n\n\tRunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\"}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif !runner.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n\tif runner.opts.ConfigRoot == \"\" {\n\t\tt.Fatalf(\"expected config root to be set\")\n\t}\n\tif runner.opts.ConfigDir == \"\" {\n\t\tt.Fatalf(\"expected config dir to be set\")\n\t}\n\texpectedConfigRoot := filepath.Join(\"/home/user\", \".config\", \"opencode-runner\")\n\tif runner.opts.ConfigRoot != expectedConfigRoot {\n\t\tt.Fatalf(\"expected config root %q, got %q\", expectedConfigRoot, runner.opts.ConfigRoot)\n\t}\n\texpectedConfigDir := filepath.Join(expectedConfigRoot, \"opencode\")\n\tif runner.opts.ConfigDir != expectedConfigDir {\n\t\tt.Fatalf(\"expected config dir %q, got %q\", expectedConfigDir, runner.opts.ConfigDir)\n\t}\n\tif exit.code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", exit.code)\n\t}\n}\n\nfunc TestRunOnceMainFailsWhenYoloAgentMissing(t *testing.T) {\n\ttempDir := t.TempDir()\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tstdout := &bytes.Buffer{}\n\tstderr := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\"}, runner.Run, exit.Exit, stdout, stderr, beadsRunner, gitRunner)\n\n\tif code != 1 {\n\t\tt.Fatalf(\"expected exit code 1, got %d\", code)\n\t}\n\tif exit.code != 1 {\n\t\tt.Fatalf(\"expected exit to be called with 1, got %d\", exit.code)\n\t}\n\tif runner.called {\n\t\tt.Fatalf(\"expected run once not to be called\")\n\t}\n\tif !strings.Contains(stderr.String(), \"yolo.md\") {\n\t\tt.Fatalf(\"expected error to mention yolo.md, got %q\", stderr.String())\n\t}\n}\n\nfunc TestRunOnceMainFailsWhenYoloAgentMissingPermission(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteAgentFile(t, tempDir, \"---\\nname: yolo\\n---\\n\")\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tstdout := &bytes.Buffer{}\n\tstderr := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\"}, runner.Run, exit.Exit, stdout, stderr, beadsRunner, gitRunner)\n\n\tif code != 1 {\n\t\tt.Fatalf(\"expected exit code 1, got %d\", code)\n\t}\n\tif exit.code != 1 {\n\t\tt.Fatalf(\"expected exit to be called with 1, got %d\", exit.code)\n\t}\n\tif runner.called {\n\t\tt.Fatalf(\"expected run once not to be called\")\n\t}\n\tif !strings.Contains(stderr.String(), \"permission: allow\") {\n\t\tt.Fatalf(\"expected error to mention permission allow, got %q\", stderr.String())\n\t}\n\tif !strings.Contains(strings.ToLower(stderr.String()), \"init\") {\n\t\tt.Fatalf(\"expected guidance to run init, got %q\", stderr.String())\n\t}\n}\n\nfunc TestRunOnceMainInfersRoadmapRootWhenMissing(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteIssuesFile(t, tempDir, `{\"id\":\"roadmap-1\",\"title\":\"Roadmap\",\"issue_type\":\"epic\",\"status\":\"open\"}`)\n\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", code)\n\t}\n\tif !runner.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n\tif runner.opts.RootID != \"roadmap-1\" {\n\t\tt.Fatalf(\"expected root id to be inferred, got %q\", runner.opts.RootID)\n\t}\n}\n\nfunc TestRunOnceMainInfersRoadmapRootWhenInProgress(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteIssuesFile(t, tempDir, `{\"id\":\"roadmap-2\",\"title\":\"Roadmap\",\"issue_type\":\"epic\",\"status\":\"in_progress\"}`)\n\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", code)\n\t}\n\tif !runner.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n\tif runner.opts.RootID != \"roadmap-2\" {\n\t\tt.Fatalf(\"expected root id to be inferred, got %q\", runner.opts.RootID)\n\t}\n}\n\nfunc TestRunOnceMainMissingRootRequiresExplicitFlag(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteIssuesFile(t, tempDir, `{\"id\":\"epic-1\",\"title\":\"Other\",\"issue_type\":\"epic\",\"status\":\"open\"}`)\n\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tstdout := &bytes.Buffer{}\n\tstderr := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir}, runner.Run, exit.Exit, stdout, stderr, beadsRunner, gitRunner)\n\n\tif code != 1 {\n\t\tt.Fatalf(\"expected exit code 1, got %d\", code)\n\t}\n\tif exit.code != 1 {\n\t\tt.Fatalf(\"expected exit to be called with 1, got %d\", exit.code)\n\t}\n\tif runner.called {\n\t\tt.Fatalf(\"expected run once not to be called\")\n\t}\n\tif !strings.Contains(stderr.String(), \"--root\") {\n\t\tt.Fatalf(\"expected error to mention --root, got %q\", stderr.String())\n\t}\n\tif !strings.Contains(strings.ToLower(stderr.String()), \"roadmap\") {\n\t\tt.Fatalf(\"expected error to mention roadmap, got %q\", stderr.String())\n\t}\n}\n\ntype fakeTUIProgram struct {\n\tstarted chan struct{}\n\tquit    chan struct{}\n\tevents  chan runner.Event\n}\n\nfunc newFakeTUIProgram() *fakeTUIProgram {\n\treturn &fakeTUIProgram{\n\t\tstarted: make(chan struct{}),\n\t\tquit:    make(chan struct{}),\n\t\tevents:  make(chan runner.Event, 1),\n\t}\n}\n\nfunc (f *fakeTUIProgram) Start() error {\n\tclose(f.started)\n\treturn nil\n}\n\nfunc (f *fakeTUIProgram) Send(event runner.Event) {\n\tf.events <- event\n}\n\nfunc (f *fakeTUIProgram) Quit() {\n\tclose(f.quit)\n}\n\nfunc waitForSignal(t *testing.T, signal chan struct{}, label string) {\n\tt.Helper()\n\tselect {\n\tcase <-signal:\n\t\treturn\n\tcase <-time.After(200 * time.Millisecond):\n\t\tt.Fatalf(\"expected %s\", label)\n\t}\n}\n\nfunc writeIssuesFile(t *testing.T, repoRoot string, payload string) {\n\tt.Helper()\n\tbeadsDir := filepath.Join(repoRoot, \".beads\")\n\tif err := os.MkdirAll(beadsDir, 0o755); err != nil {\n\t\tt.Fatalf(\"mkdir .beads: %v\", err)\n\t}\n\tissuesPath := filepath.Join(beadsDir, \"issues.jsonl\")\n\tif err := os.WriteFile(issuesPath, []byte(payload+\"\\n\"), 0o644); err != nil {\n\t\tt.Fatalf(\"write issues: %v\", err)\n\t}\n}\n\nfunc writeAgentFile(t *testing.T, repoRoot string, payload string) {\n\tt.Helper()\n\tagentDir := filepath.Join(repoRoot, \".opencode\", \"agent\")\n\tif err := os.MkdirAll(agentDir, 0o755); err != nil {\n\t\tt.Fatalf(\"mkdir agent dir: %v\", err)\n\t}\n\tagentPath := filepath.Join(agentDir, \"yolo.md\")\n\tif err := os.WriteFile(agentPath, []byte(payload), 0o644); err != nil {\n\t\tt.Fatalf(\"write agent file: %v\", err)\n\t}\n}\n\nfunc TestRunOnceMainUsesTUIOnTTYByDefault(t *testing.T) {\n\tfakeProgram := newFakeTUIProgram()\n\tprevIsTerminal := isTerminal\n\tprevNewTUIProgram := newTUIProgram\n\tisTerminal = func(io.Writer) bool { return true }\n\tnewTUIProgram = func(stdout io.Writer) tuiProgram { return fakeProgram }\n\tt.Cleanup(func() {\n\t\tisTerminal = prevIsTerminal\n\t\tnewTUIProgram = prevNewTUIProgram\n\t})\n\n\ttempDir := t.TempDir()\n\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n\trunOnce := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\"}, runOnce.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", code)\n\t}\n\tif runOnce.deps.Events == nil {\n\t\tt.Fatalf(\"expected events emitter to be set\")\n\t}\n\trunOnce.deps.Events.Emit(runner.Event{Type: runner.EventSelectTask})\n\twaitForSignal(t, fakeProgram.started, \"tui start\")\n\twaitForSignal(t, fakeProgram.quit, \"tui quit\")\n\tselect {\n\tcase <-fakeProgram.events:\n\t\t// ok\n\tcase <-time.After(200 * time.Millisecond):\n\t\tt.Fatalf(\"expected event to be forwarded to TUI\")\n\t}\n}\n\nfunc TestRunOnceMainHeadlessDisablesTUI(t *testing.T) {\n\tcalled := false\n\tprevIsTerminal := isTerminal\n\tprevNewTUIProgram := newTUIProgram\n\tisTerminal = func(io.Writer) bool { return true }\n\tnewTUIProgram = func(stdout io.Writer) tuiProgram {\n\t\tcalled = true\n\t\treturn newFakeTUIProgram()\n\t}\n\tt.Cleanup(func() {\n\t\tisTerminal = prevIsTerminal\n\t\tnewTUIProgram = prevNewTUIProgram\n\t})\n\n\trunOnce := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\tstderr := &bytes.Buffer{}\n\n\tRunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\", \"--headless\"}, runOnce.Run, exit.Exit, out, stderr, beadsRunner, gitRunner)\n\n\tif called {\n\t\tt.Fatalf(\"expected TUI program not to start\")\n\t}\n\tif runOnce.deps.Events != nil {\n\t\tt.Fatalf(\"expected no events emitter in headless mode\")\n\t}\n}\n\nfunc TestOpenCodeRunDefaultsCreateConfigAndEnv(t *testing.T) {\n\ttempDir := t.TempDir()\n\trepoRoot := filepath.Join(tempDir, \"repo\")\n\tif err := os.MkdirAll(repoRoot, 0o755); err != nil {\n\t\tt.Fatalf(\"mkdir repo: %v\", err)\n\t}\n\tt.Setenv(\"HOME\", tempDir)\n\n\topenCodeRunner := &fakeOpenCodeRunner{}\n\topenCodeAdapter := openCodeAdapter{runner: openCodeRunner}\n\n\tconfigRoot := filepath.Join(tempDir, \".config\", \"opencode-runner\")\n\tconfigDir := filepath.Join(configRoot, \"opencode\")\n\tlogPath := filepath.Join(tempDir, \"runner-logs\", \"opencode\", \"issue-1.jsonl\")\n\n\tif err := openCodeAdapter.Run(\"issue-1\", repoRoot, \"prompt\", \"\", configRoot, configDir, logPath); err != nil {\n\t\tt.Fatalf(\"open code run error: %v\", err)\n\t}\n\n\tconfigFile := filepath.Join(configDir, \"opencode.json\")\n\tif _, err := os.Stat(configFile); err != nil {\n\t\tt.Fatalf(\"expected opencode.json to exist: %v\", err)\n\t}\n\texpectedConfigFile := filepath.Join(configDir, \"opencode.json\")\n\tif openCodeRunner.env[\"XDG_CONFIG_HOME\"] != configRoot {\n\t\tt.Fatalf(\"expected XDG_CONFIG_HOME set\")\n\t}\n\tif openCodeRunner.env[\"OPENCODE_CONFIG_DIR\"] != configDir {\n\t\tt.Fatalf(\"expected OPENCODE_CONFIG_DIR set\")\n\t}\n\tif openCodeRunner.env[\"OPENCODE_CONFIG\"] != expectedConfigFile {\n\t\tt.Fatalf(\"expected OPENCODE_CONFIG set\")\n\t}\n\tif openCodeRunner.env[\"OPENCODE_CONFIG_CONTENT\"] != \"{}\" {\n\t\tt.Fatalf(\"expected OPENCODE_CONFIG_CONTENT set\")\n\t}\n}\n","additions":3,"deletions":1},"truncated":false},"time":{"start":1768850790586,"end":1768850790748}},"metadata":{"openai":{"itemId":"fc_0d396c1833aff23f01696e85622e308191a41f5b5c968d4511"}}}}
{"type":"step_finish","timestamp":1768850790767,"sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","part":{"id":"prt_bd7b9195d001uODyoijkIkpbI4","sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","messageID":"msg_bd7b9020f001lJmW8BFcY7SgS7","type":"step-finish","reason":"tool-calls","snapshot":"14a1619f117a550e5ae0d44a1ce62cf0326a788b","cost":0,"tokens":{"input":1394,"output":273,"reasoning":0,"cache":{"read":26240,"write":0}}}}
{"type":"step_start","timestamp":1768850791313,"sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","part":{"id":"prt_bd7b91b91001tOpdLLjY6rraQd","sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","messageID":"msg_bd7b91985001CY3Ti4F0AKYReL","type":"step-start","snapshot":"47c54346b9f2629e53962081012a50f6176821ca"}}
{"type":"tool_use","timestamp":1768850796788,"sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","part":{"id":"prt_bd7b91deb001wlnplJRNRTD3I7","sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","messageID":"msg_bd7b91985001CY3Ti4F0AKYReL","type":"tool","callID":"call_FWbgn8vUCvy3Pd7ekNntbk5Z","tool":"edit","state":{"status":"completed","input":{"filePath":"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go","oldString":"\trunOnce := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\tstderr := &bytes.Buffer{}\n\n\tRunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\", \"--headless\"}, runOnce.Run, exit.Exit, out, stderr, beadsRunner, gitRunner)\n","newString":"\ttempDir := t.TempDir()\n\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n\trunOnce := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\tstderr := &bytes.Buffer{}\n\n\tRunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\", \"--headless\"}, runOnce.Run, exit.Exit, out, stderr, beadsRunner, gitRunner)\n"},"output":"Edit applied successfully.","title":"cmd/yolo-runner/main_test.go","metadata":{"diagnostics":{"/Users/egv/dev/yolo-runner/internal/opencode/client.go":[{"range":{"start":{"line":28,"character":1},"end":{"line":28,"character":18}},"severity":2,"code":"default","codeDescription":{"href":"https://staticcheck.dev/docs/checks/#S1031"},"source":"S1031","message":"unnecessary nil check around range"}],"/Users/egv/dev/yolo-runner/internal/opencode/watchdog.go":[],"/Users/egv/dev/yolo-runner/go.mod":[{"range":{"start":{"line":6,"character":44},"end":{"line":6,"character":55}},"severity":2,"source":"go mod tidy","message":"github.com/charmbracelet/bubbletea should be direct"},{"range":{"start":{"line":19,"character":26},"end":{"line":19,"character":37}},"severity":2,"source":"go mod tidy","message":"golang.org/x/term should be direct"}],"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main.go":[],"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go":[],"/Users/egv/dev/yolo-runner/cmd/yolo-runner/exec_test.go":[],"/Users/egv/dev/yolo-runner/internal/opencode/agent_test.go":[],"/Users/egv/dev/yolo-runner/internal/opencode/agent.go":[]},"diff":"Index: /Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go\n===================================================================\n--- /Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go\n+++ /Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go\n@@ -421,16 +421,18 @@\n \tisTerminal = prevIsTerminal\n \tnewTUIProgram = prevNewTUIProgram\n })\n \n+tempDir := t.TempDir()\n+writeAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n runOnce := &fakeRunOnce{result: \"no_tasks\"}\n exit := &fakeExit{}\n out := &bytes.Buffer{}\n beadsRunner := &fakeRunner{}\n gitRunner := &fakeGitRunner{}\n stderr := &bytes.Buffer{}\n \n-RunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\", \"--headless\"}, runOnce.Run, exit.Exit, out, stderr, beadsRunner, gitRunner)\n+RunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\", \"--headless\"}, runOnce.Run, exit.Exit, out, stderr, beadsRunner, gitRunner)\n \n if called {\n \tt.Fatalf(\"expected TUI program not to start\")\n }\n","filediff":{"file":"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go","before":"package main\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"yolo-runner/internal/opencode\"\n\t\"yolo-runner/internal/runner\"\n)\n\ntype fakeRunner struct {\n\tcalls []string\n}\n\nfunc (f *fakeRunner) Run(args ...string) (string, error) {\n\tf.calls = append(f.calls, strings.Join(args, \" \"))\n\treturn \"\", nil\n}\n\ntype fakeOpenCodeRunLogger struct {\n\tcalled     bool\n\tissueID    string\n\trepoRoot   string\n\tprompt     string\n\tmodel      string\n\tconfigRoot string\n\tconfigDir  string\n\tlogPath    string\n}\n\nfunc (f *fakeOpenCodeRunLogger) Run(issueID string, repoRoot string, prompt string, model string, configRoot string, configDir string, logPath string) error {\n\tf.called = true\n\tf.issueID = issueID\n\tf.repoRoot = repoRoot\n\tf.prompt = prompt\n\tf.model = model\n\tf.configRoot = configRoot\n\tf.configDir = configDir\n\tf.logPath = logPath\n\treturn nil\n}\n\ntype fakeOpenCodeRunner struct {\n\tenv map[string]string\n}\n\ntype fakeOpenCodeProcess struct{}\n\nfunc (fakeOpenCodeProcess) Wait() error { return nil }\n\nfunc (fakeOpenCodeProcess) Kill() error { return nil }\n\nfunc (f *fakeOpenCodeRunner) Start(args []string, env map[string]string, stdoutPath string) (opencode.Process, error) {\n\tf.env = env\n\treturn fakeOpenCodeProcess{}, nil\n}\n\ntype fakeGitRunner struct {\n\tcalls  []string\n\toutput string\n\terr    error\n}\n\nfunc (f *fakeGitRunner) Run(name string, args ...string) (string, error) {\n\tf.calls = append(f.calls, name+\" \"+strings.Join(args, \" \"))\n\treturn f.output, f.err\n}\n\ntype fakeExit struct {\n\tcode int\n}\n\nfunc (f *fakeExit) Exit(code int) {\n\tf.code = code\n}\n\ntype fakeRunOnce struct {\n\tcalled bool\n\topts   runner.RunOnceOptions\n\tdeps   runner.RunOnceDeps\n\tresult string\n\terr    error\n}\n\nfunc (f *fakeRunOnce) Run(opts runner.RunOnceOptions, deps runner.RunOnceDeps) (string, error) {\n\n\tf.called = true\n\tf.opts = opts\n\tf.deps = deps\n\treturn f.result, f.err\n}\n\nfunc TestRunOnceMainReturnsErrorCodeOnFailure(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n\trunner := &fakeRunOnce{err: errors.New(\"boom\")}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\"}, runner.Run, exit.Exit, out, out, nil, nil)\n\n\tif code != 1 {\n\t\tt.Fatalf(\"expected exit code 1, got %d\", code)\n\t}\n\tif exit.code != 1 {\n\t\tt.Fatalf(\"expected exit to be called with 1, got %d\", exit.code)\n\t}\n\tif !strings.Contains(out.String(), \"boom\") {\n\t\tt.Fatalf(\"expected error output, got %q\", out.String())\n\t}\n}\n\nfunc TestRunOnceMainWiresDependencies(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tRunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\", \"--model\", \"model\", \"--dry-run\"}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif !runner.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n\tif runner.opts.RepoRoot != \"/repo\" || runner.opts.RootID != \"root\" || runner.opts.Model != \"model\" || !runner.opts.DryRun {\n\t\tt.Fatalf(\"unexpected options: %#v\", runner.opts)\n\t}\n\tif runner.opts.Out == nil {\n\t\tt.Fatalf(\"expected output writer\")\n\t}\n\tif runner.deps.Beads == nil || runner.deps.Git == nil || runner.deps.Prompt == nil || runner.deps.OpenCode == nil || runner.deps.Logger == nil {\n\t\tt.Fatalf(\"expected deps to be wired\")\n\t}\n\tif exit.code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", exit.code)\n\t}\n}\n\nfunc TestRunOnceMainDefaultsConfigPaths(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tt.Setenv(\"HOME\", \"/home/user\")\n\n\tRunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\"}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif !runner.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n\tif runner.opts.ConfigRoot == \"\" {\n\t\tt.Fatalf(\"expected config root to be set\")\n\t}\n\tif runner.opts.ConfigDir == \"\" {\n\t\tt.Fatalf(\"expected config dir to be set\")\n\t}\n\texpectedConfigRoot := filepath.Join(\"/home/user\", \".config\", \"opencode-runner\")\n\tif runner.opts.ConfigRoot != expectedConfigRoot {\n\t\tt.Fatalf(\"expected config root %q, got %q\", expectedConfigRoot, runner.opts.ConfigRoot)\n\t}\n\texpectedConfigDir := filepath.Join(expectedConfigRoot, \"opencode\")\n\tif runner.opts.ConfigDir != expectedConfigDir {\n\t\tt.Fatalf(\"expected config dir %q, got %q\", expectedConfigDir, runner.opts.ConfigDir)\n\t}\n\tif exit.code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", exit.code)\n\t}\n}\n\nfunc TestRunOnceMainFailsWhenYoloAgentMissing(t *testing.T) {\n\ttempDir := t.TempDir()\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tstdout := &bytes.Buffer{}\n\tstderr := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\"}, runner.Run, exit.Exit, stdout, stderr, beadsRunner, gitRunner)\n\n\tif code != 1 {\n\t\tt.Fatalf(\"expected exit code 1, got %d\", code)\n\t}\n\tif exit.code != 1 {\n\t\tt.Fatalf(\"expected exit to be called with 1, got %d\", exit.code)\n\t}\n\tif runner.called {\n\t\tt.Fatalf(\"expected run once not to be called\")\n\t}\n\tif !strings.Contains(stderr.String(), \"yolo.md\") {\n\t\tt.Fatalf(\"expected error to mention yolo.md, got %q\", stderr.String())\n\t}\n}\n\nfunc TestRunOnceMainFailsWhenYoloAgentMissingPermission(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteAgentFile(t, tempDir, \"---\\nname: yolo\\n---\\n\")\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tstdout := &bytes.Buffer{}\n\tstderr := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\"}, runner.Run, exit.Exit, stdout, stderr, beadsRunner, gitRunner)\n\n\tif code != 1 {\n\t\tt.Fatalf(\"expected exit code 1, got %d\", code)\n\t}\n\tif exit.code != 1 {\n\t\tt.Fatalf(\"expected exit to be called with 1, got %d\", exit.code)\n\t}\n\tif runner.called {\n\t\tt.Fatalf(\"expected run once not to be called\")\n\t}\n\tif !strings.Contains(stderr.String(), \"permission: allow\") {\n\t\tt.Fatalf(\"expected error to mention permission allow, got %q\", stderr.String())\n\t}\n\tif !strings.Contains(strings.ToLower(stderr.String()), \"init\") {\n\t\tt.Fatalf(\"expected guidance to run init, got %q\", stderr.String())\n\t}\n}\n\nfunc TestRunOnceMainInfersRoadmapRootWhenMissing(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteIssuesFile(t, tempDir, `{\"id\":\"roadmap-1\",\"title\":\"Roadmap\",\"issue_type\":\"epic\",\"status\":\"open\"}`)\n\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", code)\n\t}\n\tif !runner.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n\tif runner.opts.RootID != \"roadmap-1\" {\n\t\tt.Fatalf(\"expected root id to be inferred, got %q\", runner.opts.RootID)\n\t}\n}\n\nfunc TestRunOnceMainInfersRoadmapRootWhenInProgress(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteIssuesFile(t, tempDir, `{\"id\":\"roadmap-2\",\"title\":\"Roadmap\",\"issue_type\":\"epic\",\"status\":\"in_progress\"}`)\n\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", code)\n\t}\n\tif !runner.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n\tif runner.opts.RootID != \"roadmap-2\" {\n\t\tt.Fatalf(\"expected root id to be inferred, got %q\", runner.opts.RootID)\n\t}\n}\n\nfunc TestRunOnceMainMissingRootRequiresExplicitFlag(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteIssuesFile(t, tempDir, `{\"id\":\"epic-1\",\"title\":\"Other\",\"issue_type\":\"epic\",\"status\":\"open\"}`)\n\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tstdout := &bytes.Buffer{}\n\tstderr := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir}, runner.Run, exit.Exit, stdout, stderr, beadsRunner, gitRunner)\n\n\tif code != 1 {\n\t\tt.Fatalf(\"expected exit code 1, got %d\", code)\n\t}\n\tif exit.code != 1 {\n\t\tt.Fatalf(\"expected exit to be called with 1, got %d\", exit.code)\n\t}\n\tif runner.called {\n\t\tt.Fatalf(\"expected run once not to be called\")\n\t}\n\tif !strings.Contains(stderr.String(), \"--root\") {\n\t\tt.Fatalf(\"expected error to mention --root, got %q\", stderr.String())\n\t}\n\tif !strings.Contains(strings.ToLower(stderr.String()), \"roadmap\") {\n\t\tt.Fatalf(\"expected error to mention roadmap, got %q\", stderr.String())\n\t}\n}\n\ntype fakeTUIProgram struct {\n\tstarted chan struct{}\n\tquit    chan struct{}\n\tevents  chan runner.Event\n}\n\nfunc newFakeTUIProgram() *fakeTUIProgram {\n\treturn &fakeTUIProgram{\n\t\tstarted: make(chan struct{}),\n\t\tquit:    make(chan struct{}),\n\t\tevents:  make(chan runner.Event, 1),\n\t}\n}\n\nfunc (f *fakeTUIProgram) Start() error {\n\tclose(f.started)\n\treturn nil\n}\n\nfunc (f *fakeTUIProgram) Send(event runner.Event) {\n\tf.events <- event\n}\n\nfunc (f *fakeTUIProgram) Quit() {\n\tclose(f.quit)\n}\n\nfunc waitForSignal(t *testing.T, signal chan struct{}, label string) {\n\tt.Helper()\n\tselect {\n\tcase <-signal:\n\t\treturn\n\tcase <-time.After(200 * time.Millisecond):\n\t\tt.Fatalf(\"expected %s\", label)\n\t}\n}\n\nfunc writeIssuesFile(t *testing.T, repoRoot string, payload string) {\n\tt.Helper()\n\tbeadsDir := filepath.Join(repoRoot, \".beads\")\n\tif err := os.MkdirAll(beadsDir, 0o755); err != nil {\n\t\tt.Fatalf(\"mkdir .beads: %v\", err)\n\t}\n\tissuesPath := filepath.Join(beadsDir, \"issues.jsonl\")\n\tif err := os.WriteFile(issuesPath, []byte(payload+\"\\n\"), 0o644); err != nil {\n\t\tt.Fatalf(\"write issues: %v\", err)\n\t}\n}\n\nfunc writeAgentFile(t *testing.T, repoRoot string, payload string) {\n\tt.Helper()\n\tagentDir := filepath.Join(repoRoot, \".opencode\", \"agent\")\n\tif err := os.MkdirAll(agentDir, 0o755); err != nil {\n\t\tt.Fatalf(\"mkdir agent dir: %v\", err)\n\t}\n\tagentPath := filepath.Join(agentDir, \"yolo.md\")\n\tif err := os.WriteFile(agentPath, []byte(payload), 0o644); err != nil {\n\t\tt.Fatalf(\"write agent file: %v\", err)\n\t}\n}\n\nfunc TestRunOnceMainUsesTUIOnTTYByDefault(t *testing.T) {\n\tfakeProgram := newFakeTUIProgram()\n\tprevIsTerminal := isTerminal\n\tprevNewTUIProgram := newTUIProgram\n\tisTerminal = func(io.Writer) bool { return true }\n\tnewTUIProgram = func(stdout io.Writer) tuiProgram { return fakeProgram }\n\tt.Cleanup(func() {\n\t\tisTerminal = prevIsTerminal\n\t\tnewTUIProgram = prevNewTUIProgram\n\t})\n\n\ttempDir := t.TempDir()\n\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n\trunOnce := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\"}, runOnce.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", code)\n\t}\n\tif runOnce.deps.Events == nil {\n\t\tt.Fatalf(\"expected events emitter to be set\")\n\t}\n\trunOnce.deps.Events.Emit(runner.Event{Type: runner.EventSelectTask})\n\twaitForSignal(t, fakeProgram.started, \"tui start\")\n\twaitForSignal(t, fakeProgram.quit, \"tui quit\")\n\tselect {\n\tcase <-fakeProgram.events:\n\t\t// ok\n\tcase <-time.After(200 * time.Millisecond):\n\t\tt.Fatalf(\"expected event to be forwarded to TUI\")\n\t}\n}\n\nfunc TestRunOnceMainHeadlessDisablesTUI(t *testing.T) {\n\tcalled := false\n\tprevIsTerminal := isTerminal\n\tprevNewTUIProgram := newTUIProgram\n\tisTerminal = func(io.Writer) bool { return true }\n\tnewTUIProgram = func(stdout io.Writer) tuiProgram {\n\t\tcalled = true\n\t\treturn newFakeTUIProgram()\n\t}\n\tt.Cleanup(func() {\n\t\tisTerminal = prevIsTerminal\n\t\tnewTUIProgram = prevNewTUIProgram\n\t})\n\n\trunOnce := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\tstderr := &bytes.Buffer{}\n\n\tRunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\", \"--headless\"}, runOnce.Run, exit.Exit, out, stderr, beadsRunner, gitRunner)\n\n\tif called {\n\t\tt.Fatalf(\"expected TUI program not to start\")\n\t}\n\tif runOnce.deps.Events != nil {\n\t\tt.Fatalf(\"expected no events emitter in headless mode\")\n\t}\n}\n\nfunc TestOpenCodeRunDefaultsCreateConfigAndEnv(t *testing.T) {\n\ttempDir := t.TempDir()\n\trepoRoot := filepath.Join(tempDir, \"repo\")\n\tif err := os.MkdirAll(repoRoot, 0o755); err != nil {\n\t\tt.Fatalf(\"mkdir repo: %v\", err)\n\t}\n\tt.Setenv(\"HOME\", tempDir)\n\n\topenCodeRunner := &fakeOpenCodeRunner{}\n\topenCodeAdapter := openCodeAdapter{runner: openCodeRunner}\n\n\tconfigRoot := filepath.Join(tempDir, \".config\", \"opencode-runner\")\n\tconfigDir := filepath.Join(configRoot, \"opencode\")\n\tlogPath := filepath.Join(tempDir, \"runner-logs\", \"opencode\", \"issue-1.jsonl\")\n\n\tif err := openCodeAdapter.Run(\"issue-1\", repoRoot, \"prompt\", \"\", configRoot, configDir, logPath); err != nil {\n\t\tt.Fatalf(\"open code run error: %v\", err)\n\t}\n\n\tconfigFile := filepath.Join(configDir, \"opencode.json\")\n\tif _, err := os.Stat(configFile); err != nil {\n\t\tt.Fatalf(\"expected opencode.json to exist: %v\", err)\n\t}\n\texpectedConfigFile := filepath.Join(configDir, \"opencode.json\")\n\tif openCodeRunner.env[\"XDG_CONFIG_HOME\"] != configRoot {\n\t\tt.Fatalf(\"expected XDG_CONFIG_HOME set\")\n\t}\n\tif openCodeRunner.env[\"OPENCODE_CONFIG_DIR\"] != configDir {\n\t\tt.Fatalf(\"expected OPENCODE_CONFIG_DIR set\")\n\t}\n\tif openCodeRunner.env[\"OPENCODE_CONFIG\"] != expectedConfigFile {\n\t\tt.Fatalf(\"expected OPENCODE_CONFIG set\")\n\t}\n\tif openCodeRunner.env[\"OPENCODE_CONFIG_CONTENT\"] != \"{}\" {\n\t\tt.Fatalf(\"expected OPENCODE_CONFIG_CONTENT set\")\n\t}\n}\n","after":"package main\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"yolo-runner/internal/opencode\"\n\t\"yolo-runner/internal/runner\"\n)\n\ntype fakeRunner struct {\n\tcalls []string\n}\n\nfunc (f *fakeRunner) Run(args ...string) (string, error) {\n\tf.calls = append(f.calls, strings.Join(args, \" \"))\n\treturn \"\", nil\n}\n\ntype fakeOpenCodeRunLogger struct {\n\tcalled     bool\n\tissueID    string\n\trepoRoot   string\n\tprompt     string\n\tmodel      string\n\tconfigRoot string\n\tconfigDir  string\n\tlogPath    string\n}\n\nfunc (f *fakeOpenCodeRunLogger) Run(issueID string, repoRoot string, prompt string, model string, configRoot string, configDir string, logPath string) error {\n\tf.called = true\n\tf.issueID = issueID\n\tf.repoRoot = repoRoot\n\tf.prompt = prompt\n\tf.model = model\n\tf.configRoot = configRoot\n\tf.configDir = configDir\n\tf.logPath = logPath\n\treturn nil\n}\n\ntype fakeOpenCodeRunner struct {\n\tenv map[string]string\n}\n\ntype fakeOpenCodeProcess struct{}\n\nfunc (fakeOpenCodeProcess) Wait() error { return nil }\n\nfunc (fakeOpenCodeProcess) Kill() error { return nil }\n\nfunc (f *fakeOpenCodeRunner) Start(args []string, env map[string]string, stdoutPath string) (opencode.Process, error) {\n\tf.env = env\n\treturn fakeOpenCodeProcess{}, nil\n}\n\ntype fakeGitRunner struct {\n\tcalls  []string\n\toutput string\n\terr    error\n}\n\nfunc (f *fakeGitRunner) Run(name string, args ...string) (string, error) {\n\tf.calls = append(f.calls, name+\" \"+strings.Join(args, \" \"))\n\treturn f.output, f.err\n}\n\ntype fakeExit struct {\n\tcode int\n}\n\nfunc (f *fakeExit) Exit(code int) {\n\tf.code = code\n}\n\ntype fakeRunOnce struct {\n\tcalled bool\n\topts   runner.RunOnceOptions\n\tdeps   runner.RunOnceDeps\n\tresult string\n\terr    error\n}\n\nfunc (f *fakeRunOnce) Run(opts runner.RunOnceOptions, deps runner.RunOnceDeps) (string, error) {\n\n\tf.called = true\n\tf.opts = opts\n\tf.deps = deps\n\treturn f.result, f.err\n}\n\nfunc TestRunOnceMainReturnsErrorCodeOnFailure(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n\trunner := &fakeRunOnce{err: errors.New(\"boom\")}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\"}, runner.Run, exit.Exit, out, out, nil, nil)\n\n\tif code != 1 {\n\t\tt.Fatalf(\"expected exit code 1, got %d\", code)\n\t}\n\tif exit.code != 1 {\n\t\tt.Fatalf(\"expected exit to be called with 1, got %d\", exit.code)\n\t}\n\tif !strings.Contains(out.String(), \"boom\") {\n\t\tt.Fatalf(\"expected error output, got %q\", out.String())\n\t}\n}\n\nfunc TestRunOnceMainWiresDependencies(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tRunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\", \"--model\", \"model\", \"--dry-run\"}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif !runner.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n\tif runner.opts.RepoRoot != \"/repo\" || runner.opts.RootID != \"root\" || runner.opts.Model != \"model\" || !runner.opts.DryRun {\n\t\tt.Fatalf(\"unexpected options: %#v\", runner.opts)\n\t}\n\tif runner.opts.Out == nil {\n\t\tt.Fatalf(\"expected output writer\")\n\t}\n\tif runner.deps.Beads == nil || runner.deps.Git == nil || runner.deps.Prompt == nil || runner.deps.OpenCode == nil || runner.deps.Logger == nil {\n\t\tt.Fatalf(\"expected deps to be wired\")\n\t}\n\tif exit.code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", exit.code)\n\t}\n}\n\nfunc TestRunOnceMainDefaultsConfigPaths(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tt.Setenv(\"HOME\", \"/home/user\")\n\n\tRunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\"}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif !runner.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n\tif runner.opts.ConfigRoot == \"\" {\n\t\tt.Fatalf(\"expected config root to be set\")\n\t}\n\tif runner.opts.ConfigDir == \"\" {\n\t\tt.Fatalf(\"expected config dir to be set\")\n\t}\n\texpectedConfigRoot := filepath.Join(\"/home/user\", \".config\", \"opencode-runner\")\n\tif runner.opts.ConfigRoot != expectedConfigRoot {\n\t\tt.Fatalf(\"expected config root %q, got %q\", expectedConfigRoot, runner.opts.ConfigRoot)\n\t}\n\texpectedConfigDir := filepath.Join(expectedConfigRoot, \"opencode\")\n\tif runner.opts.ConfigDir != expectedConfigDir {\n\t\tt.Fatalf(\"expected config dir %q, got %q\", expectedConfigDir, runner.opts.ConfigDir)\n\t}\n\tif exit.code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", exit.code)\n\t}\n}\n\nfunc TestRunOnceMainFailsWhenYoloAgentMissing(t *testing.T) {\n\ttempDir := t.TempDir()\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tstdout := &bytes.Buffer{}\n\tstderr := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\"}, runner.Run, exit.Exit, stdout, stderr, beadsRunner, gitRunner)\n\n\tif code != 1 {\n\t\tt.Fatalf(\"expected exit code 1, got %d\", code)\n\t}\n\tif exit.code != 1 {\n\t\tt.Fatalf(\"expected exit to be called with 1, got %d\", exit.code)\n\t}\n\tif runner.called {\n\t\tt.Fatalf(\"expected run once not to be called\")\n\t}\n\tif !strings.Contains(stderr.String(), \"yolo.md\") {\n\t\tt.Fatalf(\"expected error to mention yolo.md, got %q\", stderr.String())\n\t}\n}\n\nfunc TestRunOnceMainFailsWhenYoloAgentMissingPermission(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteAgentFile(t, tempDir, \"---\\nname: yolo\\n---\\n\")\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tstdout := &bytes.Buffer{}\n\tstderr := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\"}, runner.Run, exit.Exit, stdout, stderr, beadsRunner, gitRunner)\n\n\tif code != 1 {\n\t\tt.Fatalf(\"expected exit code 1, got %d\", code)\n\t}\n\tif exit.code != 1 {\n\t\tt.Fatalf(\"expected exit to be called with 1, got %d\", exit.code)\n\t}\n\tif runner.called {\n\t\tt.Fatalf(\"expected run once not to be called\")\n\t}\n\tif !strings.Contains(stderr.String(), \"permission: allow\") {\n\t\tt.Fatalf(\"expected error to mention permission allow, got %q\", stderr.String())\n\t}\n\tif !strings.Contains(strings.ToLower(stderr.String()), \"init\") {\n\t\tt.Fatalf(\"expected guidance to run init, got %q\", stderr.String())\n\t}\n}\n\nfunc TestRunOnceMainInfersRoadmapRootWhenMissing(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteIssuesFile(t, tempDir, `{\"id\":\"roadmap-1\",\"title\":\"Roadmap\",\"issue_type\":\"epic\",\"status\":\"open\"}`)\n\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", code)\n\t}\n\tif !runner.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n\tif runner.opts.RootID != \"roadmap-1\" {\n\t\tt.Fatalf(\"expected root id to be inferred, got %q\", runner.opts.RootID)\n\t}\n}\n\nfunc TestRunOnceMainInfersRoadmapRootWhenInProgress(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteIssuesFile(t, tempDir, `{\"id\":\"roadmap-2\",\"title\":\"Roadmap\",\"issue_type\":\"epic\",\"status\":\"in_progress\"}`)\n\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", code)\n\t}\n\tif !runner.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n\tif runner.opts.RootID != \"roadmap-2\" {\n\t\tt.Fatalf(\"expected root id to be inferred, got %q\", runner.opts.RootID)\n\t}\n}\n\nfunc TestRunOnceMainMissingRootRequiresExplicitFlag(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteIssuesFile(t, tempDir, `{\"id\":\"epic-1\",\"title\":\"Other\",\"issue_type\":\"epic\",\"status\":\"open\"}`)\n\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tstdout := &bytes.Buffer{}\n\tstderr := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir}, runner.Run, exit.Exit, stdout, stderr, beadsRunner, gitRunner)\n\n\tif code != 1 {\n\t\tt.Fatalf(\"expected exit code 1, got %d\", code)\n\t}\n\tif exit.code != 1 {\n\t\tt.Fatalf(\"expected exit to be called with 1, got %d\", exit.code)\n\t}\n\tif runner.called {\n\t\tt.Fatalf(\"expected run once not to be called\")\n\t}\n\tif !strings.Contains(stderr.String(), \"--root\") {\n\t\tt.Fatalf(\"expected error to mention --root, got %q\", stderr.String())\n\t}\n\tif !strings.Contains(strings.ToLower(stderr.String()), \"roadmap\") {\n\t\tt.Fatalf(\"expected error to mention roadmap, got %q\", stderr.String())\n\t}\n}\n\ntype fakeTUIProgram struct {\n\tstarted chan struct{}\n\tquit    chan struct{}\n\tevents  chan runner.Event\n}\n\nfunc newFakeTUIProgram() *fakeTUIProgram {\n\treturn &fakeTUIProgram{\n\t\tstarted: make(chan struct{}),\n\t\tquit:    make(chan struct{}),\n\t\tevents:  make(chan runner.Event, 1),\n\t}\n}\n\nfunc (f *fakeTUIProgram) Start() error {\n\tclose(f.started)\n\treturn nil\n}\n\nfunc (f *fakeTUIProgram) Send(event runner.Event) {\n\tf.events <- event\n}\n\nfunc (f *fakeTUIProgram) Quit() {\n\tclose(f.quit)\n}\n\nfunc waitForSignal(t *testing.T, signal chan struct{}, label string) {\n\tt.Helper()\n\tselect {\n\tcase <-signal:\n\t\treturn\n\tcase <-time.After(200 * time.Millisecond):\n\t\tt.Fatalf(\"expected %s\", label)\n\t}\n}\n\nfunc writeIssuesFile(t *testing.T, repoRoot string, payload string) {\n\tt.Helper()\n\tbeadsDir := filepath.Join(repoRoot, \".beads\")\n\tif err := os.MkdirAll(beadsDir, 0o755); err != nil {\n\t\tt.Fatalf(\"mkdir .beads: %v\", err)\n\t}\n\tissuesPath := filepath.Join(beadsDir, \"issues.jsonl\")\n\tif err := os.WriteFile(issuesPath, []byte(payload+\"\\n\"), 0o644); err != nil {\n\t\tt.Fatalf(\"write issues: %v\", err)\n\t}\n}\n\nfunc writeAgentFile(t *testing.T, repoRoot string, payload string) {\n\tt.Helper()\n\tagentDir := filepath.Join(repoRoot, \".opencode\", \"agent\")\n\tif err := os.MkdirAll(agentDir, 0o755); err != nil {\n\t\tt.Fatalf(\"mkdir agent dir: %v\", err)\n\t}\n\tagentPath := filepath.Join(agentDir, \"yolo.md\")\n\tif err := os.WriteFile(agentPath, []byte(payload), 0o644); err != nil {\n\t\tt.Fatalf(\"write agent file: %v\", err)\n\t}\n}\n\nfunc TestRunOnceMainUsesTUIOnTTYByDefault(t *testing.T) {\n\tfakeProgram := newFakeTUIProgram()\n\tprevIsTerminal := isTerminal\n\tprevNewTUIProgram := newTUIProgram\n\tisTerminal = func(io.Writer) bool { return true }\n\tnewTUIProgram = func(stdout io.Writer) tuiProgram { return fakeProgram }\n\tt.Cleanup(func() {\n\t\tisTerminal = prevIsTerminal\n\t\tnewTUIProgram = prevNewTUIProgram\n\t})\n\n\ttempDir := t.TempDir()\n\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n\trunOnce := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\"}, runOnce.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", code)\n\t}\n\tif runOnce.deps.Events == nil {\n\t\tt.Fatalf(\"expected events emitter to be set\")\n\t}\n\trunOnce.deps.Events.Emit(runner.Event{Type: runner.EventSelectTask})\n\twaitForSignal(t, fakeProgram.started, \"tui start\")\n\twaitForSignal(t, fakeProgram.quit, \"tui quit\")\n\tselect {\n\tcase <-fakeProgram.events:\n\t\t// ok\n\tcase <-time.After(200 * time.Millisecond):\n\t\tt.Fatalf(\"expected event to be forwarded to TUI\")\n\t}\n}\n\nfunc TestRunOnceMainHeadlessDisablesTUI(t *testing.T) {\n\tcalled := false\n\tprevIsTerminal := isTerminal\n\tprevNewTUIProgram := newTUIProgram\n\tisTerminal = func(io.Writer) bool { return true }\n\tnewTUIProgram = func(stdout io.Writer) tuiProgram {\n\t\tcalled = true\n\t\treturn newFakeTUIProgram()\n\t}\n\tt.Cleanup(func() {\n\t\tisTerminal = prevIsTerminal\n\t\tnewTUIProgram = prevNewTUIProgram\n\t})\n\n\ttempDir := t.TempDir()\n\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n\trunOnce := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\tstderr := &bytes.Buffer{}\n\n\tRunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\", \"--headless\"}, runOnce.Run, exit.Exit, out, stderr, beadsRunner, gitRunner)\n\n\tif called {\n\t\tt.Fatalf(\"expected TUI program not to start\")\n\t}\n\tif runOnce.deps.Events != nil {\n\t\tt.Fatalf(\"expected no events emitter in headless mode\")\n\t}\n}\n\nfunc TestOpenCodeRunDefaultsCreateConfigAndEnv(t *testing.T) {\n\ttempDir := t.TempDir()\n\trepoRoot := filepath.Join(tempDir, \"repo\")\n\tif err := os.MkdirAll(repoRoot, 0o755); err != nil {\n\t\tt.Fatalf(\"mkdir repo: %v\", err)\n\t}\n\tt.Setenv(\"HOME\", tempDir)\n\n\topenCodeRunner := &fakeOpenCodeRunner{}\n\topenCodeAdapter := openCodeAdapter{runner: openCodeRunner}\n\n\tconfigRoot := filepath.Join(tempDir, \".config\", \"opencode-runner\")\n\tconfigDir := filepath.Join(configRoot, \"opencode\")\n\tlogPath := filepath.Join(tempDir, \"runner-logs\", \"opencode\", \"issue-1.jsonl\")\n\n\tif err := openCodeAdapter.Run(\"issue-1\", repoRoot, \"prompt\", \"\", configRoot, configDir, logPath); err != nil {\n\t\tt.Fatalf(\"open code run error: %v\", err)\n\t}\n\n\tconfigFile := filepath.Join(configDir, \"opencode.json\")\n\tif _, err := os.Stat(configFile); err != nil {\n\t\tt.Fatalf(\"expected opencode.json to exist: %v\", err)\n\t}\n\texpectedConfigFile := filepath.Join(configDir, \"opencode.json\")\n\tif openCodeRunner.env[\"XDG_CONFIG_HOME\"] != configRoot {\n\t\tt.Fatalf(\"expected XDG_CONFIG_HOME set\")\n\t}\n\tif openCodeRunner.env[\"OPENCODE_CONFIG_DIR\"] != configDir {\n\t\tt.Fatalf(\"expected OPENCODE_CONFIG_DIR set\")\n\t}\n\tif openCodeRunner.env[\"OPENCODE_CONFIG\"] != expectedConfigFile {\n\t\tt.Fatalf(\"expected OPENCODE_CONFIG set\")\n\t}\n\tif openCodeRunner.env[\"OPENCODE_CONFIG_CONTENT\"] != \"{}\" {\n\t\tt.Fatalf(\"expected OPENCODE_CONFIG_CONTENT set\")\n\t}\n}\n","additions":3,"deletions":1},"truncated":false},"time":{"start":1768850796625,"end":1768850796786}},"metadata":{"openai":{"itemId":"fc_0d13ebab3fcc2b3e01696e8567da188191a66093990caf8a9d"}}}}
{"type":"step_finish","timestamp":1768850796808,"sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","part":{"id":"prt_bd7b930f3001EiyJyPWWPCCpGe","sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","messageID":"msg_bd7b91985001CY3Ti4F0AKYReL","type":"step-finish","reason":"tool-calls","snapshot":"44c48ff6d575036c50bc5014b9abb6a67ced712e","cost":0,"tokens":{"input":654,"output":295,"reasoning":0,"cache":{"read":27264,"write":0}}}}
{"type":"step_start","timestamp":1768850797147,"sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","part":{"id":"prt_bd7b9325b001DsZQqAHEhAtS0w","sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","messageID":"msg_bd7b9311f001PjEJwoJaOqhl7o","type":"step-start","snapshot":"bdc51d11ccd727d9081d385ee36d700b193a7450"}}
{"type":"tool_use","timestamp":1768850799675,"sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","part":{"id":"prt_bd7b935310011kiq0qIuxeFStC","sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","messageID":"msg_bd7b9311f001PjEJwoJaOqhl7o","type":"tool","callID":"call_zoVdXOLHf6PDw1b4lvWVjiQU","tool":"bash","state":{"status":"completed","input":{"command":"go test ./...","description":"Runs full Go test suite"},"output":"ok  \tyolo-runner\t(cached)\n--- FAIL: TestRunOnceMainWiresDependencies (0.00s)\n    main_test.go:134: unexpected options: runner.RunOnceOptions{RepoRoot:\"/var/folders/zj/0f4pb2q113d618xs3bpdm_ch0000gn/T/TestRunOnceMainWiresDependencies3305154277/001\", RootID:\"root\", Model:\"model\", ConfigRoot:\"/Users/egv/.config/opencode-runner\", ConfigDir:\"/Users/egv/.config/opencode-runner/opencode\", LogPath:\"\", DryRun:true, Out:(*bytes.Buffer)(0x140001136b0)}\n--- FAIL: TestRunOnceMainFailsWhenYoloAgentMissing (0.00s)\n    main_test.go:194: expected exit code 1, got 0\n--- FAIL: TestRunOnceMainFailsWhenYoloAgentMissingPermission (0.00s)\n    main_test.go:220: expected exit code 1, got 0\nFAIL\nFAIL\tyolo-runner/cmd/yolo-runner\t1.096s\nok  \tyolo-runner/internal/beads\t(cached)\nok  \tyolo-runner/internal/logging\t(cached)\nok  \tyolo-runner/internal/opencode\t0.526s\nok  \tyolo-runner/internal/prompt\t(cached)\nok  \tyolo-runner/internal/runner\t0.789s\nok  \tyolo-runner/internal/ui/tui\t(cached)\nok  \tyolo-runner/internal/vcs/git\t(cached)\nFAIL\n","title":"Runs full Go test suite","metadata":{"output":"ok  \tyolo-runner\t(cached)\n--- FAIL: TestRunOnceMainWiresDependencies (0.00s)\n    main_test.go:134: unexpected options: runner.RunOnceOptions{RepoRoot:\"/var/folders/zj/0f4pb2q113d618xs3bpdm_ch0000gn/T/TestRunOnceMainWiresDependencies3305154277/001\", RootID:\"root\", Model:\"model\", ConfigRoot:\"/Users/egv/.config/opencode-runner\", ConfigDir:\"/Users/egv/.config/opencode-runner/opencode\", LogPath:\"\", DryRun:true, Out:(*bytes.Buffer)(0x140001136b0)}\n--- FAIL: TestRunOnceMainFailsWhenYoloAgentMissing (0.00s)\n    main_test.go:194: expected exit code 1, got 0\n--- FAIL: TestRunOnceMainFailsWhenYoloAgentMissingPermission (0.00s)\n    main_test.go:220: expected exit code 1, got 0\nFAIL\nFAIL\tyolo-runner/cmd/yolo-runner\t1.096s\nok  \tyolo-runner/internal/beads\t(cached)\nok  \tyolo-runner/internal/logging\t(cached)\nok  \tyolo-runner/internal/opencode\t0.526s\nok  \tyolo-runner/internal/prompt\t(cached)\nok  \tyolo-runner/internal/runner\t0.789s\nok  \tyolo-runner/internal/ui/tui\t(cached)\nok  \tyolo-runner/internal/vcs/git\t(cached)\nFAIL\n","exit":1,"description":"Runs full Go test suite","truncated":false},"time":{"start":1768850798214,"end":1768850799674}},"metadata":{"openai":{"itemId":"fc_0f9b1b24ecb6809401696e856dc77c8191ac68ae9026ccc8d9"}}}}
{"type":"step_finish","timestamp":1768850799691,"sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","part":{"id":"prt_bd7b93c3b001W6d7gOv9HkxdIw","sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","messageID":"msg_bd7b9311f001PjEJwoJaOqhl7o","type":"step-finish","reason":"tool-calls","snapshot":"4600ecfb31d329464eda76f0280bfab00452bd58","cost":0,"tokens":{"input":960,"output":29,"reasoning":0,"cache":{"read":27264,"write":0}}}}
{"type":"step_start","timestamp":1768850799980,"sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","part":{"id":"prt_bd7b93d6b0014K1JkD4uezQzwq","sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","messageID":"msg_bd7b93c63001cTNQkpilORqCyo","type":"step-start","snapshot":"619329e4587b27661e36476adb2c31731aa64204"}}
{"type":"tool_use","timestamp":1768850805063,"sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","part":{"id":"prt_bd7b94175001s4tizBaPPBn86n","sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","messageID":"msg_bd7b93c63001cTNQkpilORqCyo","type":"tool","callID":"call_oPsl4QiPhkIq2KBlsIregnVv","tool":"edit","state":{"status":"completed","input":{"filePath":"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go","oldString":"\tif runner.opts.RepoRoot != \"/repo\" || runner.opts.RootID != \"root\" || runner.opts.Model != \"model\" || !runner.opts.DryRun {\n\t\tt.Fatalf(\"unexpected options: %#v\", runner.opts)\n\t}\n","newString":"\tif runner.opts.RepoRoot != tempDir || runner.opts.RootID != \"root\" || runner.opts.Model != \"model\" || !runner.opts.DryRun {\n\t\tt.Fatalf(\"unexpected options: %#v\", runner.opts)\n\t}\n"},"output":"Edit applied successfully.","title":"cmd/yolo-runner/main_test.go","metadata":{"diagnostics":{"/Users/egv/dev/yolo-runner/internal/opencode/client.go":[{"range":{"start":{"line":28,"character":1},"end":{"line":28,"character":18}},"severity":2,"code":"default","codeDescription":{"href":"https://staticcheck.dev/docs/checks/#S1031"},"source":"S1031","message":"unnecessary nil check around range"}],"/Users/egv/dev/yolo-runner/internal/opencode/watchdog.go":[],"/Users/egv/dev/yolo-runner/go.mod":[{"range":{"start":{"line":6,"character":44},"end":{"line":6,"character":55}},"severity":2,"source":"go mod tidy","message":"github.com/charmbracelet/bubbletea should be direct"},{"range":{"start":{"line":19,"character":26},"end":{"line":19,"character":37}},"severity":2,"source":"go mod tidy","message":"golang.org/x/term should be direct"}],"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main.go":[],"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go":[],"/Users/egv/dev/yolo-runner/cmd/yolo-runner/exec_test.go":[],"/Users/egv/dev/yolo-runner/internal/opencode/agent_test.go":[],"/Users/egv/dev/yolo-runner/internal/opencode/agent.go":[]},"diff":"Index: /Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go\n===================================================================\n--- /Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go\n+++ /Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go\n@@ -129,9 +129,9 @@\n \n if !runner.called {\n \tt.Fatalf(\"expected run once to be called\")\n }\n-if runner.opts.RepoRoot != \"/repo\" || runner.opts.RootID != \"root\" || runner.opts.Model != \"model\" || !runner.opts.DryRun {\n+if runner.opts.RepoRoot != tempDir || runner.opts.RootID != \"root\" || runner.opts.Model != \"model\" || !runner.opts.DryRun {\n \tt.Fatalf(\"unexpected options: %#v\", runner.opts)\n }\n if runner.opts.Out == nil {\n \tt.Fatalf(\"expected output writer\")\n","filediff":{"file":"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go","before":"package main\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"yolo-runner/internal/opencode\"\n\t\"yolo-runner/internal/runner\"\n)\n\ntype fakeRunner struct {\n\tcalls []string\n}\n\nfunc (f *fakeRunner) Run(args ...string) (string, error) {\n\tf.calls = append(f.calls, strings.Join(args, \" \"))\n\treturn \"\", nil\n}\n\ntype fakeOpenCodeRunLogger struct {\n\tcalled     bool\n\tissueID    string\n\trepoRoot   string\n\tprompt     string\n\tmodel      string\n\tconfigRoot string\n\tconfigDir  string\n\tlogPath    string\n}\n\nfunc (f *fakeOpenCodeRunLogger) Run(issueID string, repoRoot string, prompt string, model string, configRoot string, configDir string, logPath string) error {\n\tf.called = true\n\tf.issueID = issueID\n\tf.repoRoot = repoRoot\n\tf.prompt = prompt\n\tf.model = model\n\tf.configRoot = configRoot\n\tf.configDir = configDir\n\tf.logPath = logPath\n\treturn nil\n}\n\ntype fakeOpenCodeRunner struct {\n\tenv map[string]string\n}\n\ntype fakeOpenCodeProcess struct{}\n\nfunc (fakeOpenCodeProcess) Wait() error { return nil }\n\nfunc (fakeOpenCodeProcess) Kill() error { return nil }\n\nfunc (f *fakeOpenCodeRunner) Start(args []string, env map[string]string, stdoutPath string) (opencode.Process, error) {\n\tf.env = env\n\treturn fakeOpenCodeProcess{}, nil\n}\n\ntype fakeGitRunner struct {\n\tcalls  []string\n\toutput string\n\terr    error\n}\n\nfunc (f *fakeGitRunner) Run(name string, args ...string) (string, error) {\n\tf.calls = append(f.calls, name+\" \"+strings.Join(args, \" \"))\n\treturn f.output, f.err\n}\n\ntype fakeExit struct {\n\tcode int\n}\n\nfunc (f *fakeExit) Exit(code int) {\n\tf.code = code\n}\n\ntype fakeRunOnce struct {\n\tcalled bool\n\topts   runner.RunOnceOptions\n\tdeps   runner.RunOnceDeps\n\tresult string\n\terr    error\n}\n\nfunc (f *fakeRunOnce) Run(opts runner.RunOnceOptions, deps runner.RunOnceDeps) (string, error) {\n\n\tf.called = true\n\tf.opts = opts\n\tf.deps = deps\n\treturn f.result, f.err\n}\n\nfunc TestRunOnceMainReturnsErrorCodeOnFailure(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n\trunner := &fakeRunOnce{err: errors.New(\"boom\")}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\"}, runner.Run, exit.Exit, out, out, nil, nil)\n\n\tif code != 1 {\n\t\tt.Fatalf(\"expected exit code 1, got %d\", code)\n\t}\n\tif exit.code != 1 {\n\t\tt.Fatalf(\"expected exit to be called with 1, got %d\", exit.code)\n\t}\n\tif !strings.Contains(out.String(), \"boom\") {\n\t\tt.Fatalf(\"expected error output, got %q\", out.String())\n\t}\n}\n\nfunc TestRunOnceMainWiresDependencies(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tRunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\", \"--model\", \"model\", \"--dry-run\"}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif !runner.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n\tif runner.opts.RepoRoot != \"/repo\" || runner.opts.RootID != \"root\" || runner.opts.Model != \"model\" || !runner.opts.DryRun {\n\t\tt.Fatalf(\"unexpected options: %#v\", runner.opts)\n\t}\n\tif runner.opts.Out == nil {\n\t\tt.Fatalf(\"expected output writer\")\n\t}\n\tif runner.deps.Beads == nil || runner.deps.Git == nil || runner.deps.Prompt == nil || runner.deps.OpenCode == nil || runner.deps.Logger == nil {\n\t\tt.Fatalf(\"expected deps to be wired\")\n\t}\n\tif exit.code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", exit.code)\n\t}\n}\n\nfunc TestRunOnceMainDefaultsConfigPaths(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tt.Setenv(\"HOME\", \"/home/user\")\n\n\tRunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\"}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif !runner.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n\tif runner.opts.ConfigRoot == \"\" {\n\t\tt.Fatalf(\"expected config root to be set\")\n\t}\n\tif runner.opts.ConfigDir == \"\" {\n\t\tt.Fatalf(\"expected config dir to be set\")\n\t}\n\texpectedConfigRoot := filepath.Join(\"/home/user\", \".config\", \"opencode-runner\")\n\tif runner.opts.ConfigRoot != expectedConfigRoot {\n\t\tt.Fatalf(\"expected config root %q, got %q\", expectedConfigRoot, runner.opts.ConfigRoot)\n\t}\n\texpectedConfigDir := filepath.Join(expectedConfigRoot, \"opencode\")\n\tif runner.opts.ConfigDir != expectedConfigDir {\n\t\tt.Fatalf(\"expected config dir %q, got %q\", expectedConfigDir, runner.opts.ConfigDir)\n\t}\n\tif exit.code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", exit.code)\n\t}\n}\n\nfunc TestRunOnceMainFailsWhenYoloAgentMissing(t *testing.T) {\n\ttempDir := t.TempDir()\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tstdout := &bytes.Buffer{}\n\tstderr := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\"}, runner.Run, exit.Exit, stdout, stderr, beadsRunner, gitRunner)\n\n\tif code != 1 {\n\t\tt.Fatalf(\"expected exit code 1, got %d\", code)\n\t}\n\tif exit.code != 1 {\n\t\tt.Fatalf(\"expected exit to be called with 1, got %d\", exit.code)\n\t}\n\tif runner.called {\n\t\tt.Fatalf(\"expected run once not to be called\")\n\t}\n\tif !strings.Contains(stderr.String(), \"yolo.md\") {\n\t\tt.Fatalf(\"expected error to mention yolo.md, got %q\", stderr.String())\n\t}\n}\n\nfunc TestRunOnceMainFailsWhenYoloAgentMissingPermission(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteAgentFile(t, tempDir, \"---\\nname: yolo\\n---\\n\")\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tstdout := &bytes.Buffer{}\n\tstderr := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\"}, runner.Run, exit.Exit, stdout, stderr, beadsRunner, gitRunner)\n\n\tif code != 1 {\n\t\tt.Fatalf(\"expected exit code 1, got %d\", code)\n\t}\n\tif exit.code != 1 {\n\t\tt.Fatalf(\"expected exit to be called with 1, got %d\", exit.code)\n\t}\n\tif runner.called {\n\t\tt.Fatalf(\"expected run once not to be called\")\n\t}\n\tif !strings.Contains(stderr.String(), \"permission: allow\") {\n\t\tt.Fatalf(\"expected error to mention permission allow, got %q\", stderr.String())\n\t}\n\tif !strings.Contains(strings.ToLower(stderr.String()), \"init\") {\n\t\tt.Fatalf(\"expected guidance to run init, got %q\", stderr.String())\n\t}\n}\n\nfunc TestRunOnceMainInfersRoadmapRootWhenMissing(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteIssuesFile(t, tempDir, `{\"id\":\"roadmap-1\",\"title\":\"Roadmap\",\"issue_type\":\"epic\",\"status\":\"open\"}`)\n\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", code)\n\t}\n\tif !runner.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n\tif runner.opts.RootID != \"roadmap-1\" {\n\t\tt.Fatalf(\"expected root id to be inferred, got %q\", runner.opts.RootID)\n\t}\n}\n\nfunc TestRunOnceMainInfersRoadmapRootWhenInProgress(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteIssuesFile(t, tempDir, `{\"id\":\"roadmap-2\",\"title\":\"Roadmap\",\"issue_type\":\"epic\",\"status\":\"in_progress\"}`)\n\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", code)\n\t}\n\tif !runner.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n\tif runner.opts.RootID != \"roadmap-2\" {\n\t\tt.Fatalf(\"expected root id to be inferred, got %q\", runner.opts.RootID)\n\t}\n}\n\nfunc TestRunOnceMainMissingRootRequiresExplicitFlag(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteIssuesFile(t, tempDir, `{\"id\":\"epic-1\",\"title\":\"Other\",\"issue_type\":\"epic\",\"status\":\"open\"}`)\n\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tstdout := &bytes.Buffer{}\n\tstderr := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir}, runner.Run, exit.Exit, stdout, stderr, beadsRunner, gitRunner)\n\n\tif code != 1 {\n\t\tt.Fatalf(\"expected exit code 1, got %d\", code)\n\t}\n\tif exit.code != 1 {\n\t\tt.Fatalf(\"expected exit to be called with 1, got %d\", exit.code)\n\t}\n\tif runner.called {\n\t\tt.Fatalf(\"expected run once not to be called\")\n\t}\n\tif !strings.Contains(stderr.String(), \"--root\") {\n\t\tt.Fatalf(\"expected error to mention --root, got %q\", stderr.String())\n\t}\n\tif !strings.Contains(strings.ToLower(stderr.String()), \"roadmap\") {\n\t\tt.Fatalf(\"expected error to mention roadmap, got %q\", stderr.String())\n\t}\n}\n\ntype fakeTUIProgram struct {\n\tstarted chan struct{}\n\tquit    chan struct{}\n\tevents  chan runner.Event\n}\n\nfunc newFakeTUIProgram() *fakeTUIProgram {\n\treturn &fakeTUIProgram{\n\t\tstarted: make(chan struct{}),\n\t\tquit:    make(chan struct{}),\n\t\tevents:  make(chan runner.Event, 1),\n\t}\n}\n\nfunc (f *fakeTUIProgram) Start() error {\n\tclose(f.started)\n\treturn nil\n}\n\nfunc (f *fakeTUIProgram) Send(event runner.Event) {\n\tf.events <- event\n}\n\nfunc (f *fakeTUIProgram) Quit() {\n\tclose(f.quit)\n}\n\nfunc waitForSignal(t *testing.T, signal chan struct{}, label string) {\n\tt.Helper()\n\tselect {\n\tcase <-signal:\n\t\treturn\n\tcase <-time.After(200 * time.Millisecond):\n\t\tt.Fatalf(\"expected %s\", label)\n\t}\n}\n\nfunc writeIssuesFile(t *testing.T, repoRoot string, payload string) {\n\tt.Helper()\n\tbeadsDir := filepath.Join(repoRoot, \".beads\")\n\tif err := os.MkdirAll(beadsDir, 0o755); err != nil {\n\t\tt.Fatalf(\"mkdir .beads: %v\", err)\n\t}\n\tissuesPath := filepath.Join(beadsDir, \"issues.jsonl\")\n\tif err := os.WriteFile(issuesPath, []byte(payload+\"\\n\"), 0o644); err != nil {\n\t\tt.Fatalf(\"write issues: %v\", err)\n\t}\n}\n\nfunc writeAgentFile(t *testing.T, repoRoot string, payload string) {\n\tt.Helper()\n\tagentDir := filepath.Join(repoRoot, \".opencode\", \"agent\")\n\tif err := os.MkdirAll(agentDir, 0o755); err != nil {\n\t\tt.Fatalf(\"mkdir agent dir: %v\", err)\n\t}\n\tagentPath := filepath.Join(agentDir, \"yolo.md\")\n\tif err := os.WriteFile(agentPath, []byte(payload), 0o644); err != nil {\n\t\tt.Fatalf(\"write agent file: %v\", err)\n\t}\n}\n\nfunc TestRunOnceMainUsesTUIOnTTYByDefault(t *testing.T) {\n\tfakeProgram := newFakeTUIProgram()\n\tprevIsTerminal := isTerminal\n\tprevNewTUIProgram := newTUIProgram\n\tisTerminal = func(io.Writer) bool { return true }\n\tnewTUIProgram = func(stdout io.Writer) tuiProgram { return fakeProgram }\n\tt.Cleanup(func() {\n\t\tisTerminal = prevIsTerminal\n\t\tnewTUIProgram = prevNewTUIProgram\n\t})\n\n\ttempDir := t.TempDir()\n\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n\trunOnce := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\"}, runOnce.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", code)\n\t}\n\tif runOnce.deps.Events == nil {\n\t\tt.Fatalf(\"expected events emitter to be set\")\n\t}\n\trunOnce.deps.Events.Emit(runner.Event{Type: runner.EventSelectTask})\n\twaitForSignal(t, fakeProgram.started, \"tui start\")\n\twaitForSignal(t, fakeProgram.quit, \"tui quit\")\n\tselect {\n\tcase <-fakeProgram.events:\n\t\t// ok\n\tcase <-time.After(200 * time.Millisecond):\n\t\tt.Fatalf(\"expected event to be forwarded to TUI\")\n\t}\n}\n\nfunc TestRunOnceMainHeadlessDisablesTUI(t *testing.T) {\n\tcalled := false\n\tprevIsTerminal := isTerminal\n\tprevNewTUIProgram := newTUIProgram\n\tisTerminal = func(io.Writer) bool { return true }\n\tnewTUIProgram = func(stdout io.Writer) tuiProgram {\n\t\tcalled = true\n\t\treturn newFakeTUIProgram()\n\t}\n\tt.Cleanup(func() {\n\t\tisTerminal = prevIsTerminal\n\t\tnewTUIProgram = prevNewTUIProgram\n\t})\n\n\ttempDir := t.TempDir()\n\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n\trunOnce := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\tstderr := &bytes.Buffer{}\n\n\tRunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\", \"--headless\"}, runOnce.Run, exit.Exit, out, stderr, beadsRunner, gitRunner)\n\n\tif called {\n\t\tt.Fatalf(\"expected TUI program not to start\")\n\t}\n\tif runOnce.deps.Events != nil {\n\t\tt.Fatalf(\"expected no events emitter in headless mode\")\n\t}\n}\n\nfunc TestOpenCodeRunDefaultsCreateConfigAndEnv(t *testing.T) {\n\ttempDir := t.TempDir()\n\trepoRoot := filepath.Join(tempDir, \"repo\")\n\tif err := os.MkdirAll(repoRoot, 0o755); err != nil {\n\t\tt.Fatalf(\"mkdir repo: %v\", err)\n\t}\n\tt.Setenv(\"HOME\", tempDir)\n\n\topenCodeRunner := &fakeOpenCodeRunner{}\n\topenCodeAdapter := openCodeAdapter{runner: openCodeRunner}\n\n\tconfigRoot := filepath.Join(tempDir, \".config\", \"opencode-runner\")\n\tconfigDir := filepath.Join(configRoot, \"opencode\")\n\tlogPath := filepath.Join(tempDir, \"runner-logs\", \"opencode\", \"issue-1.jsonl\")\n\n\tif err := openCodeAdapter.Run(\"issue-1\", repoRoot, \"prompt\", \"\", configRoot, configDir, logPath); err != nil {\n\t\tt.Fatalf(\"open code run error: %v\", err)\n\t}\n\n\tconfigFile := filepath.Join(configDir, \"opencode.json\")\n\tif _, err := os.Stat(configFile); err != nil {\n\t\tt.Fatalf(\"expected opencode.json to exist: %v\", err)\n\t}\n\texpectedConfigFile := filepath.Join(configDir, \"opencode.json\")\n\tif openCodeRunner.env[\"XDG_CONFIG_HOME\"] != configRoot {\n\t\tt.Fatalf(\"expected XDG_CONFIG_HOME set\")\n\t}\n\tif openCodeRunner.env[\"OPENCODE_CONFIG_DIR\"] != configDir {\n\t\tt.Fatalf(\"expected OPENCODE_CONFIG_DIR set\")\n\t}\n\tif openCodeRunner.env[\"OPENCODE_CONFIG\"] != expectedConfigFile {\n\t\tt.Fatalf(\"expected OPENCODE_CONFIG set\")\n\t}\n\tif openCodeRunner.env[\"OPENCODE_CONFIG_CONTENT\"] != \"{}\" {\n\t\tt.Fatalf(\"expected OPENCODE_CONFIG_CONTENT set\")\n\t}\n}\n","after":"package main\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"yolo-runner/internal/opencode\"\n\t\"yolo-runner/internal/runner\"\n)\n\ntype fakeRunner struct {\n\tcalls []string\n}\n\nfunc (f *fakeRunner) Run(args ...string) (string, error) {\n\tf.calls = append(f.calls, strings.Join(args, \" \"))\n\treturn \"\", nil\n}\n\ntype fakeOpenCodeRunLogger struct {\n\tcalled     bool\n\tissueID    string\n\trepoRoot   string\n\tprompt     string\n\tmodel      string\n\tconfigRoot string\n\tconfigDir  string\n\tlogPath    string\n}\n\nfunc (f *fakeOpenCodeRunLogger) Run(issueID string, repoRoot string, prompt string, model string, configRoot string, configDir string, logPath string) error {\n\tf.called = true\n\tf.issueID = issueID\n\tf.repoRoot = repoRoot\n\tf.prompt = prompt\n\tf.model = model\n\tf.configRoot = configRoot\n\tf.configDir = configDir\n\tf.logPath = logPath\n\treturn nil\n}\n\ntype fakeOpenCodeRunner struct {\n\tenv map[string]string\n}\n\ntype fakeOpenCodeProcess struct{}\n\nfunc (fakeOpenCodeProcess) Wait() error { return nil }\n\nfunc (fakeOpenCodeProcess) Kill() error { return nil }\n\nfunc (f *fakeOpenCodeRunner) Start(args []string, env map[string]string, stdoutPath string) (opencode.Process, error) {\n\tf.env = env\n\treturn fakeOpenCodeProcess{}, nil\n}\n\ntype fakeGitRunner struct {\n\tcalls  []string\n\toutput string\n\terr    error\n}\n\nfunc (f *fakeGitRunner) Run(name string, args ...string) (string, error) {\n\tf.calls = append(f.calls, name+\" \"+strings.Join(args, \" \"))\n\treturn f.output, f.err\n}\n\ntype fakeExit struct {\n\tcode int\n}\n\nfunc (f *fakeExit) Exit(code int) {\n\tf.code = code\n}\n\ntype fakeRunOnce struct {\n\tcalled bool\n\topts   runner.RunOnceOptions\n\tdeps   runner.RunOnceDeps\n\tresult string\n\terr    error\n}\n\nfunc (f *fakeRunOnce) Run(opts runner.RunOnceOptions, deps runner.RunOnceDeps) (string, error) {\n\n\tf.called = true\n\tf.opts = opts\n\tf.deps = deps\n\treturn f.result, f.err\n}\n\nfunc TestRunOnceMainReturnsErrorCodeOnFailure(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n\trunner := &fakeRunOnce{err: errors.New(\"boom\")}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\"}, runner.Run, exit.Exit, out, out, nil, nil)\n\n\tif code != 1 {\n\t\tt.Fatalf(\"expected exit code 1, got %d\", code)\n\t}\n\tif exit.code != 1 {\n\t\tt.Fatalf(\"expected exit to be called with 1, got %d\", exit.code)\n\t}\n\tif !strings.Contains(out.String(), \"boom\") {\n\t\tt.Fatalf(\"expected error output, got %q\", out.String())\n\t}\n}\n\nfunc TestRunOnceMainWiresDependencies(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tRunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\", \"--model\", \"model\", \"--dry-run\"}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif !runner.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n\tif runner.opts.RepoRoot != tempDir || runner.opts.RootID != \"root\" || runner.opts.Model != \"model\" || !runner.opts.DryRun {\n\t\tt.Fatalf(\"unexpected options: %#v\", runner.opts)\n\t}\n\tif runner.opts.Out == nil {\n\t\tt.Fatalf(\"expected output writer\")\n\t}\n\tif runner.deps.Beads == nil || runner.deps.Git == nil || runner.deps.Prompt == nil || runner.deps.OpenCode == nil || runner.deps.Logger == nil {\n\t\tt.Fatalf(\"expected deps to be wired\")\n\t}\n\tif exit.code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", exit.code)\n\t}\n}\n\nfunc TestRunOnceMainDefaultsConfigPaths(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tt.Setenv(\"HOME\", \"/home/user\")\n\n\tRunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\"}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif !runner.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n\tif runner.opts.ConfigRoot == \"\" {\n\t\tt.Fatalf(\"expected config root to be set\")\n\t}\n\tif runner.opts.ConfigDir == \"\" {\n\t\tt.Fatalf(\"expected config dir to be set\")\n\t}\n\texpectedConfigRoot := filepath.Join(\"/home/user\", \".config\", \"opencode-runner\")\n\tif runner.opts.ConfigRoot != expectedConfigRoot {\n\t\tt.Fatalf(\"expected config root %q, got %q\", expectedConfigRoot, runner.opts.ConfigRoot)\n\t}\n\texpectedConfigDir := filepath.Join(expectedConfigRoot, \"opencode\")\n\tif runner.opts.ConfigDir != expectedConfigDir {\n\t\tt.Fatalf(\"expected config dir %q, got %q\", expectedConfigDir, runner.opts.ConfigDir)\n\t}\n\tif exit.code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", exit.code)\n\t}\n}\n\nfunc TestRunOnceMainFailsWhenYoloAgentMissing(t *testing.T) {\n\ttempDir := t.TempDir()\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tstdout := &bytes.Buffer{}\n\tstderr := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\"}, runner.Run, exit.Exit, stdout, stderr, beadsRunner, gitRunner)\n\n\tif code != 1 {\n\t\tt.Fatalf(\"expected exit code 1, got %d\", code)\n\t}\n\tif exit.code != 1 {\n\t\tt.Fatalf(\"expected exit to be called with 1, got %d\", exit.code)\n\t}\n\tif runner.called {\n\t\tt.Fatalf(\"expected run once not to be called\")\n\t}\n\tif !strings.Contains(stderr.String(), \"yolo.md\") {\n\t\tt.Fatalf(\"expected error to mention yolo.md, got %q\", stderr.String())\n\t}\n}\n\nfunc TestRunOnceMainFailsWhenYoloAgentMissingPermission(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteAgentFile(t, tempDir, \"---\\nname: yolo\\n---\\n\")\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tstdout := &bytes.Buffer{}\n\tstderr := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\"}, runner.Run, exit.Exit, stdout, stderr, beadsRunner, gitRunner)\n\n\tif code != 1 {\n\t\tt.Fatalf(\"expected exit code 1, got %d\", code)\n\t}\n\tif exit.code != 1 {\n\t\tt.Fatalf(\"expected exit to be called with 1, got %d\", exit.code)\n\t}\n\tif runner.called {\n\t\tt.Fatalf(\"expected run once not to be called\")\n\t}\n\tif !strings.Contains(stderr.String(), \"permission: allow\") {\n\t\tt.Fatalf(\"expected error to mention permission allow, got %q\", stderr.String())\n\t}\n\tif !strings.Contains(strings.ToLower(stderr.String()), \"init\") {\n\t\tt.Fatalf(\"expected guidance to run init, got %q\", stderr.String())\n\t}\n}\n\nfunc TestRunOnceMainInfersRoadmapRootWhenMissing(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteIssuesFile(t, tempDir, `{\"id\":\"roadmap-1\",\"title\":\"Roadmap\",\"issue_type\":\"epic\",\"status\":\"open\"}`)\n\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", code)\n\t}\n\tif !runner.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n\tif runner.opts.RootID != \"roadmap-1\" {\n\t\tt.Fatalf(\"expected root id to be inferred, got %q\", runner.opts.RootID)\n\t}\n}\n\nfunc TestRunOnceMainInfersRoadmapRootWhenInProgress(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteIssuesFile(t, tempDir, `{\"id\":\"roadmap-2\",\"title\":\"Roadmap\",\"issue_type\":\"epic\",\"status\":\"in_progress\"}`)\n\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", code)\n\t}\n\tif !runner.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n\tif runner.opts.RootID != \"roadmap-2\" {\n\t\tt.Fatalf(\"expected root id to be inferred, got %q\", runner.opts.RootID)\n\t}\n}\n\nfunc TestRunOnceMainMissingRootRequiresExplicitFlag(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteIssuesFile(t, tempDir, `{\"id\":\"epic-1\",\"title\":\"Other\",\"issue_type\":\"epic\",\"status\":\"open\"}`)\n\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tstdout := &bytes.Buffer{}\n\tstderr := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir}, runner.Run, exit.Exit, stdout, stderr, beadsRunner, gitRunner)\n\n\tif code != 1 {\n\t\tt.Fatalf(\"expected exit code 1, got %d\", code)\n\t}\n\tif exit.code != 1 {\n\t\tt.Fatalf(\"expected exit to be called with 1, got %d\", exit.code)\n\t}\n\tif runner.called {\n\t\tt.Fatalf(\"expected run once not to be called\")\n\t}\n\tif !strings.Contains(stderr.String(), \"--root\") {\n\t\tt.Fatalf(\"expected error to mention --root, got %q\", stderr.String())\n\t}\n\tif !strings.Contains(strings.ToLower(stderr.String()), \"roadmap\") {\n\t\tt.Fatalf(\"expected error to mention roadmap, got %q\", stderr.String())\n\t}\n}\n\ntype fakeTUIProgram struct {\n\tstarted chan struct{}\n\tquit    chan struct{}\n\tevents  chan runner.Event\n}\n\nfunc newFakeTUIProgram() *fakeTUIProgram {\n\treturn &fakeTUIProgram{\n\t\tstarted: make(chan struct{}),\n\t\tquit:    make(chan struct{}),\n\t\tevents:  make(chan runner.Event, 1),\n\t}\n}\n\nfunc (f *fakeTUIProgram) Start() error {\n\tclose(f.started)\n\treturn nil\n}\n\nfunc (f *fakeTUIProgram) Send(event runner.Event) {\n\tf.events <- event\n}\n\nfunc (f *fakeTUIProgram) Quit() {\n\tclose(f.quit)\n}\n\nfunc waitForSignal(t *testing.T, signal chan struct{}, label string) {\n\tt.Helper()\n\tselect {\n\tcase <-signal:\n\t\treturn\n\tcase <-time.After(200 * time.Millisecond):\n\t\tt.Fatalf(\"expected %s\", label)\n\t}\n}\n\nfunc writeIssuesFile(t *testing.T, repoRoot string, payload string) {\n\tt.Helper()\n\tbeadsDir := filepath.Join(repoRoot, \".beads\")\n\tif err := os.MkdirAll(beadsDir, 0o755); err != nil {\n\t\tt.Fatalf(\"mkdir .beads: %v\", err)\n\t}\n\tissuesPath := filepath.Join(beadsDir, \"issues.jsonl\")\n\tif err := os.WriteFile(issuesPath, []byte(payload+\"\\n\"), 0o644); err != nil {\n\t\tt.Fatalf(\"write issues: %v\", err)\n\t}\n}\n\nfunc writeAgentFile(t *testing.T, repoRoot string, payload string) {\n\tt.Helper()\n\tagentDir := filepath.Join(repoRoot, \".opencode\", \"agent\")\n\tif err := os.MkdirAll(agentDir, 0o755); err != nil {\n\t\tt.Fatalf(\"mkdir agent dir: %v\", err)\n\t}\n\tagentPath := filepath.Join(agentDir, \"yolo.md\")\n\tif err := os.WriteFile(agentPath, []byte(payload), 0o644); err != nil {\n\t\tt.Fatalf(\"write agent file: %v\", err)\n\t}\n}\n\nfunc TestRunOnceMainUsesTUIOnTTYByDefault(t *testing.T) {\n\tfakeProgram := newFakeTUIProgram()\n\tprevIsTerminal := isTerminal\n\tprevNewTUIProgram := newTUIProgram\n\tisTerminal = func(io.Writer) bool { return true }\n\tnewTUIProgram = func(stdout io.Writer) tuiProgram { return fakeProgram }\n\tt.Cleanup(func() {\n\t\tisTerminal = prevIsTerminal\n\t\tnewTUIProgram = prevNewTUIProgram\n\t})\n\n\ttempDir := t.TempDir()\n\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n\trunOnce := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\"}, runOnce.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", code)\n\t}\n\tif runOnce.deps.Events == nil {\n\t\tt.Fatalf(\"expected events emitter to be set\")\n\t}\n\trunOnce.deps.Events.Emit(runner.Event{Type: runner.EventSelectTask})\n\twaitForSignal(t, fakeProgram.started, \"tui start\")\n\twaitForSignal(t, fakeProgram.quit, \"tui quit\")\n\tselect {\n\tcase <-fakeProgram.events:\n\t\t// ok\n\tcase <-time.After(200 * time.Millisecond):\n\t\tt.Fatalf(\"expected event to be forwarded to TUI\")\n\t}\n}\n\nfunc TestRunOnceMainHeadlessDisablesTUI(t *testing.T) {\n\tcalled := false\n\tprevIsTerminal := isTerminal\n\tprevNewTUIProgram := newTUIProgram\n\tisTerminal = func(io.Writer) bool { return true }\n\tnewTUIProgram = func(stdout io.Writer) tuiProgram {\n\t\tcalled = true\n\t\treturn newFakeTUIProgram()\n\t}\n\tt.Cleanup(func() {\n\t\tisTerminal = prevIsTerminal\n\t\tnewTUIProgram = prevNewTUIProgram\n\t})\n\n\ttempDir := t.TempDir()\n\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n\trunOnce := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\tstderr := &bytes.Buffer{}\n\n\tRunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\", \"--headless\"}, runOnce.Run, exit.Exit, out, stderr, beadsRunner, gitRunner)\n\n\tif called {\n\t\tt.Fatalf(\"expected TUI program not to start\")\n\t}\n\tif runOnce.deps.Events != nil {\n\t\tt.Fatalf(\"expected no events emitter in headless mode\")\n\t}\n}\n\nfunc TestOpenCodeRunDefaultsCreateConfigAndEnv(t *testing.T) {\n\ttempDir := t.TempDir()\n\trepoRoot := filepath.Join(tempDir, \"repo\")\n\tif err := os.MkdirAll(repoRoot, 0o755); err != nil {\n\t\tt.Fatalf(\"mkdir repo: %v\", err)\n\t}\n\tt.Setenv(\"HOME\", tempDir)\n\n\topenCodeRunner := &fakeOpenCodeRunner{}\n\topenCodeAdapter := openCodeAdapter{runner: openCodeRunner}\n\n\tconfigRoot := filepath.Join(tempDir, \".config\", \"opencode-runner\")\n\tconfigDir := filepath.Join(configRoot, \"opencode\")\n\tlogPath := filepath.Join(tempDir, \"runner-logs\", \"opencode\", \"issue-1.jsonl\")\n\n\tif err := openCodeAdapter.Run(\"issue-1\", repoRoot, \"prompt\", \"\", configRoot, configDir, logPath); err != nil {\n\t\tt.Fatalf(\"open code run error: %v\", err)\n\t}\n\n\tconfigFile := filepath.Join(configDir, \"opencode.json\")\n\tif _, err := os.Stat(configFile); err != nil {\n\t\tt.Fatalf(\"expected opencode.json to exist: %v\", err)\n\t}\n\texpectedConfigFile := filepath.Join(configDir, \"opencode.json\")\n\tif openCodeRunner.env[\"XDG_CONFIG_HOME\"] != configRoot {\n\t\tt.Fatalf(\"expected XDG_CONFIG_HOME set\")\n\t}\n\tif openCodeRunner.env[\"OPENCODE_CONFIG_DIR\"] != configDir {\n\t\tt.Fatalf(\"expected OPENCODE_CONFIG_DIR set\")\n\t}\n\tif openCodeRunner.env[\"OPENCODE_CONFIG\"] != expectedConfigFile {\n\t\tt.Fatalf(\"expected OPENCODE_CONFIG set\")\n\t}\n\tif openCodeRunner.env[\"OPENCODE_CONFIG_CONTENT\"] != \"{}\" {\n\t\tt.Fatalf(\"expected OPENCODE_CONFIG_CONTENT set\")\n\t}\n}\n","additions":1,"deletions":1},"truncated":false},"time":{"start":1768850804901,"end":1768850805062}},"metadata":{"openai":{"itemId":"fc_07b00c37b898cf7801696e857100388191aba8cfa99bfc6560"}}}}
{"type":"step_finish","timestamp":1768850805082,"sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","part":{"id":"prt_bd7b95147001APNS503luBNP2O","sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","messageID":"msg_bd7b93c63001cTNQkpilORqCyo","type":"step-finish","reason":"tool-calls","snapshot":"64a0dd3cc23031dbf060267c9ab75bdd0368af66","cost":0,"tokens":{"input":438,"output":156,"reasoning":0,"cache":{"read":28160,"write":0}}}}
{"type":"step_start","timestamp":1768850805404,"sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","part":{"id":"prt_bd7b9529b001l1edNfvE2i5W2g","sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","messageID":"msg_bd7b95170001o0Fesq9f82KTZw","type":"step-start","snapshot":"2661b8c151465c6101866d811b7ccbaeee1f0a92"}}
{"type":"tool_use","timestamp":1768850807721,"sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","part":{"id":"prt_bd7b9551c001zGLqx8DY5lFENy","sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","messageID":"msg_bd7b95170001o0Fesq9f82KTZw","type":"tool","callID":"call_fNmFBW1SXkonaqRAX6NKdoeB","tool":"edit","state":{"status":"completed","input":{"filePath":"/Users/egv/dev/yolo-runner/internal/opencode/agent_test.go","oldString":"\trepoRoot := t.TempDir()\n\n\terr := ValidateAgent(repoRoot)\n","newString":"\trepoRoot := t.TempDir()\n\t// Ensure validation uses repo root path\n\terr := ValidateAgent(repoRoot)\n"},"output":"Edit applied successfully.","title":"internal/opencode/agent_test.go","metadata":{"diagnostics":{"/Users/egv/dev/yolo-runner/internal/opencode/client.go":[],"/Users/egv/dev/yolo-runner/internal/opencode/watchdog.go":[],"/Users/egv/dev/yolo-runner/go.mod":[{"range":{"start":{"line":6,"character":44},"end":{"line":6,"character":55}},"severity":2,"source":"go mod tidy","message":"github.com/charmbracelet/bubbletea should be direct"},{"range":{"start":{"line":19,"character":26},"end":{"line":19,"character":37}},"severity":2,"source":"go mod tidy","message":"golang.org/x/term should be direct"}],"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main.go":[{"range":{"start":{"line":66,"character":8},"end":{"line":66,"character":23}},"severity":4,"code":"default","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/gopls/internal/analysis/deprecated"},"source":"deprecated","message":"b.program.Start is deprecated: please use [Program.Run] instead.","tags":[2]}],"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go":[],"/Users/egv/dev/yolo-runner/cmd/yolo-runner/exec_test.go":[],"/Users/egv/dev/yolo-runner/internal/opencode/agent_test.go":[],"/Users/egv/dev/yolo-runner/internal/opencode/agent.go":[]},"diff":"Index: /Users/egv/dev/yolo-runner/internal/opencode/agent_test.go\n===================================================================\n--- /Users/egv/dev/yolo-runner/internal/opencode/agent_test.go\n+++ /Users/egv/dev/yolo-runner/internal/opencode/agent_test.go\n@@ -8,9 +8,9 @@\n )\n \n func TestValidateAgentMissingFile(t *testing.T) {\n \trepoRoot := t.TempDir()\n-\n+\t// Ensure validation uses repo root path\n \terr := ValidateAgent(repoRoot)\n \n \tif err == nil {\n \t\tt.Fatalf(\"expected error\")\n","filediff":{"file":"/Users/egv/dev/yolo-runner/internal/opencode/agent_test.go","before":"package opencode\n\nimport (\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"testing\"\n)\n\nfunc TestValidateAgentMissingFile(t *testing.T) {\n\trepoRoot := t.TempDir()\n\n\terr := ValidateAgent(repoRoot)\n\n\tif err == nil {\n\t\tt.Fatalf(\"expected error\")\n\t}\n\tif !strings.Contains(err.Error(), \"yolo.md\") {\n\t\tt.Fatalf(\"expected error to mention yolo.md, got %q\", err.Error())\n\t}\n}\n\nfunc TestValidateAgentMissingPermission(t *testing.T) {\n\trepoRoot := t.TempDir()\n\tagentDir := filepath.Join(repoRoot, \".opencode\", \"agent\")\n\tif err := os.MkdirAll(agentDir, 0o755); err != nil {\n\t\tt.Fatalf(\"mkdir agent dir: %v\", err)\n\t}\n\tagentPath := filepath.Join(agentDir, \"yolo.md\")\n\tif err := os.WriteFile(agentPath, []byte(\"---\\nname: yolo\\n---\\n\"), 0o644); err != nil {\n\t\tt.Fatalf(\"write agent file: %v\", err)\n\t}\n\n\terr := ValidateAgent(repoRoot)\n\n\tif err == nil {\n\t\tt.Fatalf(\"expected error\")\n\t}\n\tif !strings.Contains(err.Error(), \"permission: allow\") {\n\t\tt.Fatalf(\"expected error to mention permission allow, got %q\", err.Error())\n\t}\n\tif !strings.Contains(strings.ToLower(err.Error()), \"init\") {\n\t\tt.Fatalf(\"expected guidance to run init, got %q\", err.Error())\n\t}\n}\n\nfunc TestValidateAgentAllowsPermissionAllow(t *testing.T) {\n\trepoRoot := t.TempDir()\n\tagentDir := filepath.Join(repoRoot, \".opencode\", \"agent\")\n\tif err := os.MkdirAll(agentDir, 0o755); err != nil {\n\t\tt.Fatalf(\"mkdir agent dir: %v\", err)\n\t}\n\tagentPath := filepath.Join(agentDir, \"yolo.md\")\n\tcontent := \"---\\nname: yolo\\npermission: allow\\n---\\n\"\n\tif err := os.WriteFile(agentPath, []byte(content), 0o644); err != nil {\n\t\tt.Fatalf(\"write agent file: %v\", err)\n\t}\n\n\terr := ValidateAgent(repoRoot)\n\n\tif err != nil {\n\t\tt.Fatalf(\"expected no error, got %v\", err)\n\t}\n}\n","after":"package opencode\n\nimport (\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"testing\"\n)\n\nfunc TestValidateAgentMissingFile(t *testing.T) {\n\trepoRoot := t.TempDir()\n\t// Ensure validation uses repo root path\n\terr := ValidateAgent(repoRoot)\n\n\tif err == nil {\n\t\tt.Fatalf(\"expected error\")\n\t}\n\tif !strings.Contains(err.Error(), \"yolo.md\") {\n\t\tt.Fatalf(\"expected error to mention yolo.md, got %q\", err.Error())\n\t}\n}\n\nfunc TestValidateAgentMissingPermission(t *testing.T) {\n\trepoRoot := t.TempDir()\n\tagentDir := filepath.Join(repoRoot, \".opencode\", \"agent\")\n\tif err := os.MkdirAll(agentDir, 0o755); err != nil {\n\t\tt.Fatalf(\"mkdir agent dir: %v\", err)\n\t}\n\tagentPath := filepath.Join(agentDir, \"yolo.md\")\n\tif err := os.WriteFile(agentPath, []byte(\"---\\nname: yolo\\n---\\n\"), 0o644); err != nil {\n\t\tt.Fatalf(\"write agent file: %v\", err)\n\t}\n\n\terr := ValidateAgent(repoRoot)\n\n\tif err == nil {\n\t\tt.Fatalf(\"expected error\")\n\t}\n\tif !strings.Contains(err.Error(), \"permission: allow\") {\n\t\tt.Fatalf(\"expected error to mention permission allow, got %q\", err.Error())\n\t}\n\tif !strings.Contains(strings.ToLower(err.Error()), \"init\") {\n\t\tt.Fatalf(\"expected guidance to run init, got %q\", err.Error())\n\t}\n}\n\nfunc TestValidateAgentAllowsPermissionAllow(t *testing.T) {\n\trepoRoot := t.TempDir()\n\tagentDir := filepath.Join(repoRoot, \".opencode\", \"agent\")\n\tif err := os.MkdirAll(agentDir, 0o755); err != nil {\n\t\tt.Fatalf(\"mkdir agent dir: %v\", err)\n\t}\n\tagentPath := filepath.Join(agentDir, \"yolo.md\")\n\tcontent := \"---\\nname: yolo\\npermission: allow\\n---\\n\"\n\tif err := os.WriteFile(agentPath, []byte(content), 0o644); err != nil {\n\t\tt.Fatalf(\"write agent file: %v\", err)\n\t}\n\n\terr := ValidateAgent(repoRoot)\n\n\tif err != nil {\n\t\tt.Fatalf(\"expected no error, got %v\", err)\n\t}\n}\n","additions":1,"deletions":1},"truncated":false},"time":{"start":1768850807561,"end":1768850807720}},"metadata":{"openai":{"itemId":"fc_02af4aab538b0f3f01696e857608788191bd6aa0d8d7264b9a"}}}}
{"type":"step_finish","timestamp":1768850807739,"sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","part":{"id":"prt_bd7b95ba9001pbGcZQb0OUYK3M","sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","messageID":"msg_bd7b95170001o0Fesq9f82KTZw","type":"step-finish","reason":"tool-calls","snapshot":"dd2785d3e14ac601dc8f5b8038bc3ee12fe36172","cost":0,"tokens":{"input":477,"output":90,"reasoning":0,"cache":{"read":28288,"write":0}}}}
{"type":"step_start","timestamp":1768850808156,"sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","part":{"id":"prt_bd7b95d5c001pr5B3lzTf7GBaF","sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","messageID":"msg_bd7b95bd4001ZmS3ZRhL5m1jNS","type":"step-start","snapshot":"b882a582bc37e853b3d76492cb6267d28eed0357"}}
{"type":"tool_use","timestamp":1768850823642,"sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","part":{"id":"prt_bd7b997c9001KWEBdT77mk1AAe","sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","messageID":"msg_bd7b95bd4001ZmS3ZRhL5m1jNS","type":"tool","callID":"call_07GMGp3LJZUZrnmp9zjYZp6F","tool":"grep","state":{"status":"completed","input":{"pattern":"RunOnceMain","path":"/Users/egv/dev/yolo-runner","include":"*.go"},"output":"Found 22 matches\n/Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go:\n  Line 99: func TestRunOnceMainReturnsErrorCodeOnFailure(t *testing.T) {\n  Line 106: \tcode := RunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\"}, runner.Run, exit.Exit, out, out, nil, nil)\n  Line 119: func TestRunOnceMainWiresDependencies(t *testing.T) {\n  Line 128: \tRunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\", \"--model\", \"model\", \"--dry-run\"}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n  Line 147: func TestRunOnceMainDefaultsConfigPaths(t *testing.T) {\n  Line 158: \tRunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\"}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n  Line 182: func TestRunOnceMainFailsWhenYoloAgentMissing(t *testing.T) {\n  Line 191: \tcode := RunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\"}, runner.Run, exit.Exit, stdout, stderr, beadsRunner, gitRunner)\n  Line 207: func TestRunOnceMainFailsWhenYoloAgentMissingPermission(t *testing.T) {\n  Line 217: \tcode := RunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\"}, runner.Run, exit.Exit, stdout, stderr, beadsRunner, gitRunner)\n  Line 236: func TestRunOnceMainInfersRoadmapRootWhenMissing(t *testing.T) {\n  Line 246: \tcode := RunOnceMain([]string{\"--repo\", tempDir}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n  Line 259: func TestRunOnceMainInfersRoadmapRootWhenInProgress(t *testing.T) {\n  Line 269: \tcode := RunOnceMain([]string{\"--repo\", tempDir}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n  Line 282: func TestRunOnceMainMissingRootRequiresExplicitFlag(t *testing.T) {\n  Line 293: \tcode := RunOnceMain([]string{\"--repo\", tempDir}, runner.Run, exit.Exit, stdout, stderr, beadsRunner, gitRunner)\n  Line 373: func TestRunOnceMainUsesTUIOnTTYByDefault(t *testing.T) {\n  Line 392: \tcode := RunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\"}, runOnce.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n  Line 411: func TestRunOnceMainHeadlessDisablesTUI(t *testing.T) {\n  Line 434: \tRunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\", \"--headless\"}, runOnce.Run, exit.Exit, out, stderr, beadsRunner, gitRunner)\n\n/Users/egv/dev/yolo-runner/cmd/yolo-runner/main.go:\n  Line 116: func RunOnceMain(args []string, runOnce runOnceFunc, exit exitFunc, stdout io.Writer, stderr io.Writer, beadsRunner beadsRunner, gitRunner gitRunner) int {\n  Line 234: \tRunOnceMain(os.Args[1:], runner.RunOnce, os.Exit, os.Stdout, os.Stderr, nil, nil)","title":"RunOnceMain","metadata":{"matches":22,"truncated":false},"time":{"start":1768850823619,"end":1768850823642}},"metadata":{"openai":{"itemId":"fc_0cc823830276396301696e8587061c81918e3e1358fc5b906c"}}}}
{"type":"step_finish","timestamp":1768850823687,"sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","part":{"id":"prt_bd7b999f3001lf2HlvRmZYVi1u","sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","messageID":"msg_bd7b95bd4001ZmS3ZRhL5m1jNS","type":"step-finish","reason":"tool-calls","snapshot":"23a882b7d4a61bff1a9cdd3cc501e60cb2b7a63f","cost":0,"tokens":{"input":194,"output":744,"reasoning":704,"cache":{"read":28672,"write":0}}}}
{"type":"step_start","timestamp":1768850824913,"sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","part":{"id":"prt_bd7b99ed0001TF0mp103f6T36I","sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","messageID":"msg_bd7b99a1e001PRhvzd8SE4xAfX","type":"step-start","snapshot":"e44d4fa7fecd74135366550843f7a41e56cf51e4"}}
{"type":"tool_use","timestamp":1768850830618,"sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","part":{"id":"prt_bd7b9a2fd0017YQRus6v44PMcX","sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","messageID":"msg_bd7b99a1e001PRhvzd8SE4xAfX","type":"tool","callID":"call_e9lQqno9KHX8l4jOKYtGVFTS","tool":"edit","state":{"status":"completed","input":{"filePath":"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go","oldString":"\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tt.Setenv(\"HOME\", \"/home/user\")\n\n\tRunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\"}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n","newString":"\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tt.Setenv(\"HOME\", \"/home/user\")\n\tt.Setenv(\"XDG_CONFIG_HOME\", \"\")\n\n\tRunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\"}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n"},"output":"Edit applied successfully.","title":"cmd/yolo-runner/main_test.go","metadata":{"diagnostics":{"/Users/egv/dev/yolo-runner/internal/opencode/client.go":[{"range":{"start":{"line":28,"character":1},"end":{"line":28,"character":18}},"severity":2,"code":"default","codeDescription":{"href":"https://staticcheck.dev/docs/checks/#S1031"},"source":"S1031","message":"unnecessary nil check around range"}],"/Users/egv/dev/yolo-runner/internal/opencode/watchdog.go":[],"/Users/egv/dev/yolo-runner/go.mod":[{"range":{"start":{"line":6,"character":44},"end":{"line":6,"character":55}},"severity":2,"source":"go mod tidy","message":"github.com/charmbracelet/bubbletea should be direct"},{"range":{"start":{"line":19,"character":26},"end":{"line":19,"character":37}},"severity":2,"source":"go mod tidy","message":"golang.org/x/term should be direct"}],"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main.go":[],"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go":[],"/Users/egv/dev/yolo-runner/cmd/yolo-runner/exec_test.go":[],"/Users/egv/dev/yolo-runner/internal/opencode/agent_test.go":[],"/Users/egv/dev/yolo-runner/internal/opencode/agent.go":[]},"diff":"Index: /Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go\n===================================================================\n--- /Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go\n+++ /Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go\n@@ -153,8 +153,9 @@\n beadsRunner := &fakeRunner{}\n gitRunner := &fakeGitRunner{}\n \n t.Setenv(\"HOME\", \"/home/user\")\n+t.Setenv(\"XDG_CONFIG_HOME\", \"\")\n \n RunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\"}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n \n if !runner.called {\n","filediff":{"file":"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go","before":"package main\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"yolo-runner/internal/opencode\"\n\t\"yolo-runner/internal/runner\"\n)\n\ntype fakeRunner struct {\n\tcalls []string\n}\n\nfunc (f *fakeRunner) Run(args ...string) (string, error) {\n\tf.calls = append(f.calls, strings.Join(args, \" \"))\n\treturn \"\", nil\n}\n\ntype fakeOpenCodeRunLogger struct {\n\tcalled     bool\n\tissueID    string\n\trepoRoot   string\n\tprompt     string\n\tmodel      string\n\tconfigRoot string\n\tconfigDir  string\n\tlogPath    string\n}\n\nfunc (f *fakeOpenCodeRunLogger) Run(issueID string, repoRoot string, prompt string, model string, configRoot string, configDir string, logPath string) error {\n\tf.called = true\n\tf.issueID = issueID\n\tf.repoRoot = repoRoot\n\tf.prompt = prompt\n\tf.model = model\n\tf.configRoot = configRoot\n\tf.configDir = configDir\n\tf.logPath = logPath\n\treturn nil\n}\n\ntype fakeOpenCodeRunner struct {\n\tenv map[string]string\n}\n\ntype fakeOpenCodeProcess struct{}\n\nfunc (fakeOpenCodeProcess) Wait() error { return nil }\n\nfunc (fakeOpenCodeProcess) Kill() error { return nil }\n\nfunc (f *fakeOpenCodeRunner) Start(args []string, env map[string]string, stdoutPath string) (opencode.Process, error) {\n\tf.env = env\n\treturn fakeOpenCodeProcess{}, nil\n}\n\ntype fakeGitRunner struct {\n\tcalls  []string\n\toutput string\n\terr    error\n}\n\nfunc (f *fakeGitRunner) Run(name string, args ...string) (string, error) {\n\tf.calls = append(f.calls, name+\" \"+strings.Join(args, \" \"))\n\treturn f.output, f.err\n}\n\ntype fakeExit struct {\n\tcode int\n}\n\nfunc (f *fakeExit) Exit(code int) {\n\tf.code = code\n}\n\ntype fakeRunOnce struct {\n\tcalled bool\n\topts   runner.RunOnceOptions\n\tdeps   runner.RunOnceDeps\n\tresult string\n\terr    error\n}\n\nfunc (f *fakeRunOnce) Run(opts runner.RunOnceOptions, deps runner.RunOnceDeps) (string, error) {\n\n\tf.called = true\n\tf.opts = opts\n\tf.deps = deps\n\treturn f.result, f.err\n}\n\nfunc TestRunOnceMainReturnsErrorCodeOnFailure(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n\trunner := &fakeRunOnce{err: errors.New(\"boom\")}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\"}, runner.Run, exit.Exit, out, out, nil, nil)\n\n\tif code != 1 {\n\t\tt.Fatalf(\"expected exit code 1, got %d\", code)\n\t}\n\tif exit.code != 1 {\n\t\tt.Fatalf(\"expected exit to be called with 1, got %d\", exit.code)\n\t}\n\tif !strings.Contains(out.String(), \"boom\") {\n\t\tt.Fatalf(\"expected error output, got %q\", out.String())\n\t}\n}\n\nfunc TestRunOnceMainWiresDependencies(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tRunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\", \"--model\", \"model\", \"--dry-run\"}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif !runner.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n\tif runner.opts.RepoRoot != tempDir || runner.opts.RootID != \"root\" || runner.opts.Model != \"model\" || !runner.opts.DryRun {\n\t\tt.Fatalf(\"unexpected options: %#v\", runner.opts)\n\t}\n\tif runner.opts.Out == nil {\n\t\tt.Fatalf(\"expected output writer\")\n\t}\n\tif runner.deps.Beads == nil || runner.deps.Git == nil || runner.deps.Prompt == nil || runner.deps.OpenCode == nil || runner.deps.Logger == nil {\n\t\tt.Fatalf(\"expected deps to be wired\")\n\t}\n\tif exit.code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", exit.code)\n\t}\n}\n\nfunc TestRunOnceMainDefaultsConfigPaths(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tt.Setenv(\"HOME\", \"/home/user\")\n\n\tRunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\"}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif !runner.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n\tif runner.opts.ConfigRoot == \"\" {\n\t\tt.Fatalf(\"expected config root to be set\")\n\t}\n\tif runner.opts.ConfigDir == \"\" {\n\t\tt.Fatalf(\"expected config dir to be set\")\n\t}\n\texpectedConfigRoot := filepath.Join(\"/home/user\", \".config\", \"opencode-runner\")\n\tif runner.opts.ConfigRoot != expectedConfigRoot {\n\t\tt.Fatalf(\"expected config root %q, got %q\", expectedConfigRoot, runner.opts.ConfigRoot)\n\t}\n\texpectedConfigDir := filepath.Join(expectedConfigRoot, \"opencode\")\n\tif runner.opts.ConfigDir != expectedConfigDir {\n\t\tt.Fatalf(\"expected config dir %q, got %q\", expectedConfigDir, runner.opts.ConfigDir)\n\t}\n\tif exit.code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", exit.code)\n\t}\n}\n\nfunc TestRunOnceMainFailsWhenYoloAgentMissing(t *testing.T) {\n\ttempDir := t.TempDir()\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tstdout := &bytes.Buffer{}\n\tstderr := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\"}, runner.Run, exit.Exit, stdout, stderr, beadsRunner, gitRunner)\n\n\tif code != 1 {\n\t\tt.Fatalf(\"expected exit code 1, got %d\", code)\n\t}\n\tif exit.code != 1 {\n\t\tt.Fatalf(\"expected exit to be called with 1, got %d\", exit.code)\n\t}\n\tif runner.called {\n\t\tt.Fatalf(\"expected run once not to be called\")\n\t}\n\tif !strings.Contains(stderr.String(), \"yolo.md\") {\n\t\tt.Fatalf(\"expected error to mention yolo.md, got %q\", stderr.String())\n\t}\n}\n\nfunc TestRunOnceMainFailsWhenYoloAgentMissingPermission(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteAgentFile(t, tempDir, \"---\\nname: yolo\\n---\\n\")\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tstdout := &bytes.Buffer{}\n\tstderr := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\"}, runner.Run, exit.Exit, stdout, stderr, beadsRunner, gitRunner)\n\n\tif code != 1 {\n\t\tt.Fatalf(\"expected exit code 1, got %d\", code)\n\t}\n\tif exit.code != 1 {\n\t\tt.Fatalf(\"expected exit to be called with 1, got %d\", exit.code)\n\t}\n\tif runner.called {\n\t\tt.Fatalf(\"expected run once not to be called\")\n\t}\n\tif !strings.Contains(stderr.String(), \"permission: allow\") {\n\t\tt.Fatalf(\"expected error to mention permission allow, got %q\", stderr.String())\n\t}\n\tif !strings.Contains(strings.ToLower(stderr.String()), \"init\") {\n\t\tt.Fatalf(\"expected guidance to run init, got %q\", stderr.String())\n\t}\n}\n\nfunc TestRunOnceMainInfersRoadmapRootWhenMissing(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteIssuesFile(t, tempDir, `{\"id\":\"roadmap-1\",\"title\":\"Roadmap\",\"issue_type\":\"epic\",\"status\":\"open\"}`)\n\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", code)\n\t}\n\tif !runner.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n\tif runner.opts.RootID != \"roadmap-1\" {\n\t\tt.Fatalf(\"expected root id to be inferred, got %q\", runner.opts.RootID)\n\t}\n}\n\nfunc TestRunOnceMainInfersRoadmapRootWhenInProgress(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteIssuesFile(t, tempDir, `{\"id\":\"roadmap-2\",\"title\":\"Roadmap\",\"issue_type\":\"epic\",\"status\":\"in_progress\"}`)\n\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", code)\n\t}\n\tif !runner.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n\tif runner.opts.RootID != \"roadmap-2\" {\n\t\tt.Fatalf(\"expected root id to be inferred, got %q\", runner.opts.RootID)\n\t}\n}\n\nfunc TestRunOnceMainMissingRootRequiresExplicitFlag(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteIssuesFile(t, tempDir, `{\"id\":\"epic-1\",\"title\":\"Other\",\"issue_type\":\"epic\",\"status\":\"open\"}`)\n\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tstdout := &bytes.Buffer{}\n\tstderr := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir}, runner.Run, exit.Exit, stdout, stderr, beadsRunner, gitRunner)\n\n\tif code != 1 {\n\t\tt.Fatalf(\"expected exit code 1, got %d\", code)\n\t}\n\tif exit.code != 1 {\n\t\tt.Fatalf(\"expected exit to be called with 1, got %d\", exit.code)\n\t}\n\tif runner.called {\n\t\tt.Fatalf(\"expected run once not to be called\")\n\t}\n\tif !strings.Contains(stderr.String(), \"--root\") {\n\t\tt.Fatalf(\"expected error to mention --root, got %q\", stderr.String())\n\t}\n\tif !strings.Contains(strings.ToLower(stderr.String()), \"roadmap\") {\n\t\tt.Fatalf(\"expected error to mention roadmap, got %q\", stderr.String())\n\t}\n}\n\ntype fakeTUIProgram struct {\n\tstarted chan struct{}\n\tquit    chan struct{}\n\tevents  chan runner.Event\n}\n\nfunc newFakeTUIProgram() *fakeTUIProgram {\n\treturn &fakeTUIProgram{\n\t\tstarted: make(chan struct{}),\n\t\tquit:    make(chan struct{}),\n\t\tevents:  make(chan runner.Event, 1),\n\t}\n}\n\nfunc (f *fakeTUIProgram) Start() error {\n\tclose(f.started)\n\treturn nil\n}\n\nfunc (f *fakeTUIProgram) Send(event runner.Event) {\n\tf.events <- event\n}\n\nfunc (f *fakeTUIProgram) Quit() {\n\tclose(f.quit)\n}\n\nfunc waitForSignal(t *testing.T, signal chan struct{}, label string) {\n\tt.Helper()\n\tselect {\n\tcase <-signal:\n\t\treturn\n\tcase <-time.After(200 * time.Millisecond):\n\t\tt.Fatalf(\"expected %s\", label)\n\t}\n}\n\nfunc writeIssuesFile(t *testing.T, repoRoot string, payload string) {\n\tt.Helper()\n\tbeadsDir := filepath.Join(repoRoot, \".beads\")\n\tif err := os.MkdirAll(beadsDir, 0o755); err != nil {\n\t\tt.Fatalf(\"mkdir .beads: %v\", err)\n\t}\n\tissuesPath := filepath.Join(beadsDir, \"issues.jsonl\")\n\tif err := os.WriteFile(issuesPath, []byte(payload+\"\\n\"), 0o644); err != nil {\n\t\tt.Fatalf(\"write issues: %v\", err)\n\t}\n}\n\nfunc writeAgentFile(t *testing.T, repoRoot string, payload string) {\n\tt.Helper()\n\tagentDir := filepath.Join(repoRoot, \".opencode\", \"agent\")\n\tif err := os.MkdirAll(agentDir, 0o755); err != nil {\n\t\tt.Fatalf(\"mkdir agent dir: %v\", err)\n\t}\n\tagentPath := filepath.Join(agentDir, \"yolo.md\")\n\tif err := os.WriteFile(agentPath, []byte(payload), 0o644); err != nil {\n\t\tt.Fatalf(\"write agent file: %v\", err)\n\t}\n}\n\nfunc TestRunOnceMainUsesTUIOnTTYByDefault(t *testing.T) {\n\tfakeProgram := newFakeTUIProgram()\n\tprevIsTerminal := isTerminal\n\tprevNewTUIProgram := newTUIProgram\n\tisTerminal = func(io.Writer) bool { return true }\n\tnewTUIProgram = func(stdout io.Writer) tuiProgram { return fakeProgram }\n\tt.Cleanup(func() {\n\t\tisTerminal = prevIsTerminal\n\t\tnewTUIProgram = prevNewTUIProgram\n\t})\n\n\ttempDir := t.TempDir()\n\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n\trunOnce := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\"}, runOnce.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", code)\n\t}\n\tif runOnce.deps.Events == nil {\n\t\tt.Fatalf(\"expected events emitter to be set\")\n\t}\n\trunOnce.deps.Events.Emit(runner.Event{Type: runner.EventSelectTask})\n\twaitForSignal(t, fakeProgram.started, \"tui start\")\n\twaitForSignal(t, fakeProgram.quit, \"tui quit\")\n\tselect {\n\tcase <-fakeProgram.events:\n\t\t// ok\n\tcase <-time.After(200 * time.Millisecond):\n\t\tt.Fatalf(\"expected event to be forwarded to TUI\")\n\t}\n}\n\nfunc TestRunOnceMainHeadlessDisablesTUI(t *testing.T) {\n\tcalled := false\n\tprevIsTerminal := isTerminal\n\tprevNewTUIProgram := newTUIProgram\n\tisTerminal = func(io.Writer) bool { return true }\n\tnewTUIProgram = func(stdout io.Writer) tuiProgram {\n\t\tcalled = true\n\t\treturn newFakeTUIProgram()\n\t}\n\tt.Cleanup(func() {\n\t\tisTerminal = prevIsTerminal\n\t\tnewTUIProgram = prevNewTUIProgram\n\t})\n\n\ttempDir := t.TempDir()\n\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n\trunOnce := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\tstderr := &bytes.Buffer{}\n\n\tRunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\", \"--headless\"}, runOnce.Run, exit.Exit, out, stderr, beadsRunner, gitRunner)\n\n\tif called {\n\t\tt.Fatalf(\"expected TUI program not to start\")\n\t}\n\tif runOnce.deps.Events != nil {\n\t\tt.Fatalf(\"expected no events emitter in headless mode\")\n\t}\n}\n\nfunc TestOpenCodeRunDefaultsCreateConfigAndEnv(t *testing.T) {\n\ttempDir := t.TempDir()\n\trepoRoot := filepath.Join(tempDir, \"repo\")\n\tif err := os.MkdirAll(repoRoot, 0o755); err != nil {\n\t\tt.Fatalf(\"mkdir repo: %v\", err)\n\t}\n\tt.Setenv(\"HOME\", tempDir)\n\n\topenCodeRunner := &fakeOpenCodeRunner{}\n\topenCodeAdapter := openCodeAdapter{runner: openCodeRunner}\n\n\tconfigRoot := filepath.Join(tempDir, \".config\", \"opencode-runner\")\n\tconfigDir := filepath.Join(configRoot, \"opencode\")\n\tlogPath := filepath.Join(tempDir, \"runner-logs\", \"opencode\", \"issue-1.jsonl\")\n\n\tif err := openCodeAdapter.Run(\"issue-1\", repoRoot, \"prompt\", \"\", configRoot, configDir, logPath); err != nil {\n\t\tt.Fatalf(\"open code run error: %v\", err)\n\t}\n\n\tconfigFile := filepath.Join(configDir, \"opencode.json\")\n\tif _, err := os.Stat(configFile); err != nil {\n\t\tt.Fatalf(\"expected opencode.json to exist: %v\", err)\n\t}\n\texpectedConfigFile := filepath.Join(configDir, \"opencode.json\")\n\tif openCodeRunner.env[\"XDG_CONFIG_HOME\"] != configRoot {\n\t\tt.Fatalf(\"expected XDG_CONFIG_HOME set\")\n\t}\n\tif openCodeRunner.env[\"OPENCODE_CONFIG_DIR\"] != configDir {\n\t\tt.Fatalf(\"expected OPENCODE_CONFIG_DIR set\")\n\t}\n\tif openCodeRunner.env[\"OPENCODE_CONFIG\"] != expectedConfigFile {\n\t\tt.Fatalf(\"expected OPENCODE_CONFIG set\")\n\t}\n\tif openCodeRunner.env[\"OPENCODE_CONFIG_CONTENT\"] != \"{}\" {\n\t\tt.Fatalf(\"expected OPENCODE_CONFIG_CONTENT set\")\n\t}\n}\n","after":"package main\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"yolo-runner/internal/opencode\"\n\t\"yolo-runner/internal/runner\"\n)\n\ntype fakeRunner struct {\n\tcalls []string\n}\n\nfunc (f *fakeRunner) Run(args ...string) (string, error) {\n\tf.calls = append(f.calls, strings.Join(args, \" \"))\n\treturn \"\", nil\n}\n\ntype fakeOpenCodeRunLogger struct {\n\tcalled     bool\n\tissueID    string\n\trepoRoot   string\n\tprompt     string\n\tmodel      string\n\tconfigRoot string\n\tconfigDir  string\n\tlogPath    string\n}\n\nfunc (f *fakeOpenCodeRunLogger) Run(issueID string, repoRoot string, prompt string, model string, configRoot string, configDir string, logPath string) error {\n\tf.called = true\n\tf.issueID = issueID\n\tf.repoRoot = repoRoot\n\tf.prompt = prompt\n\tf.model = model\n\tf.configRoot = configRoot\n\tf.configDir = configDir\n\tf.logPath = logPath\n\treturn nil\n}\n\ntype fakeOpenCodeRunner struct {\n\tenv map[string]string\n}\n\ntype fakeOpenCodeProcess struct{}\n\nfunc (fakeOpenCodeProcess) Wait() error { return nil }\n\nfunc (fakeOpenCodeProcess) Kill() error { return nil }\n\nfunc (f *fakeOpenCodeRunner) Start(args []string, env map[string]string, stdoutPath string) (opencode.Process, error) {\n\tf.env = env\n\treturn fakeOpenCodeProcess{}, nil\n}\n\ntype fakeGitRunner struct {\n\tcalls  []string\n\toutput string\n\terr    error\n}\n\nfunc (f *fakeGitRunner) Run(name string, args ...string) (string, error) {\n\tf.calls = append(f.calls, name+\" \"+strings.Join(args, \" \"))\n\treturn f.output, f.err\n}\n\ntype fakeExit struct {\n\tcode int\n}\n\nfunc (f *fakeExit) Exit(code int) {\n\tf.code = code\n}\n\ntype fakeRunOnce struct {\n\tcalled bool\n\topts   runner.RunOnceOptions\n\tdeps   runner.RunOnceDeps\n\tresult string\n\terr    error\n}\n\nfunc (f *fakeRunOnce) Run(opts runner.RunOnceOptions, deps runner.RunOnceDeps) (string, error) {\n\n\tf.called = true\n\tf.opts = opts\n\tf.deps = deps\n\treturn f.result, f.err\n}\n\nfunc TestRunOnceMainReturnsErrorCodeOnFailure(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n\trunner := &fakeRunOnce{err: errors.New(\"boom\")}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\"}, runner.Run, exit.Exit, out, out, nil, nil)\n\n\tif code != 1 {\n\t\tt.Fatalf(\"expected exit code 1, got %d\", code)\n\t}\n\tif exit.code != 1 {\n\t\tt.Fatalf(\"expected exit to be called with 1, got %d\", exit.code)\n\t}\n\tif !strings.Contains(out.String(), \"boom\") {\n\t\tt.Fatalf(\"expected error output, got %q\", out.String())\n\t}\n}\n\nfunc TestRunOnceMainWiresDependencies(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tRunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\", \"--model\", \"model\", \"--dry-run\"}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif !runner.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n\tif runner.opts.RepoRoot != tempDir || runner.opts.RootID != \"root\" || runner.opts.Model != \"model\" || !runner.opts.DryRun {\n\t\tt.Fatalf(\"unexpected options: %#v\", runner.opts)\n\t}\n\tif runner.opts.Out == nil {\n\t\tt.Fatalf(\"expected output writer\")\n\t}\n\tif runner.deps.Beads == nil || runner.deps.Git == nil || runner.deps.Prompt == nil || runner.deps.OpenCode == nil || runner.deps.Logger == nil {\n\t\tt.Fatalf(\"expected deps to be wired\")\n\t}\n\tif exit.code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", exit.code)\n\t}\n}\n\nfunc TestRunOnceMainDefaultsConfigPaths(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tt.Setenv(\"HOME\", \"/home/user\")\n\tt.Setenv(\"XDG_CONFIG_HOME\", \"\")\n\n\tRunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\"}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif !runner.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n\tif runner.opts.ConfigRoot == \"\" {\n\t\tt.Fatalf(\"expected config root to be set\")\n\t}\n\tif runner.opts.ConfigDir == \"\" {\n\t\tt.Fatalf(\"expected config dir to be set\")\n\t}\n\texpectedConfigRoot := filepath.Join(\"/home/user\", \".config\", \"opencode-runner\")\n\tif runner.opts.ConfigRoot != expectedConfigRoot {\n\t\tt.Fatalf(\"expected config root %q, got %q\", expectedConfigRoot, runner.opts.ConfigRoot)\n\t}\n\texpectedConfigDir := filepath.Join(expectedConfigRoot, \"opencode\")\n\tif runner.opts.ConfigDir != expectedConfigDir {\n\t\tt.Fatalf(\"expected config dir %q, got %q\", expectedConfigDir, runner.opts.ConfigDir)\n\t}\n\tif exit.code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", exit.code)\n\t}\n}\n\nfunc TestRunOnceMainFailsWhenYoloAgentMissing(t *testing.T) {\n\ttempDir := t.TempDir()\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tstdout := &bytes.Buffer{}\n\tstderr := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\"}, runner.Run, exit.Exit, stdout, stderr, beadsRunner, gitRunner)\n\n\tif code != 1 {\n\t\tt.Fatalf(\"expected exit code 1, got %d\", code)\n\t}\n\tif exit.code != 1 {\n\t\tt.Fatalf(\"expected exit to be called with 1, got %d\", exit.code)\n\t}\n\tif runner.called {\n\t\tt.Fatalf(\"expected run once not to be called\")\n\t}\n\tif !strings.Contains(stderr.String(), \"yolo.md\") {\n\t\tt.Fatalf(\"expected error to mention yolo.md, got %q\", stderr.String())\n\t}\n}\n\nfunc TestRunOnceMainFailsWhenYoloAgentMissingPermission(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteAgentFile(t, tempDir, \"---\\nname: yolo\\n---\\n\")\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tstdout := &bytes.Buffer{}\n\tstderr := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\"}, runner.Run, exit.Exit, stdout, stderr, beadsRunner, gitRunner)\n\n\tif code != 1 {\n\t\tt.Fatalf(\"expected exit code 1, got %d\", code)\n\t}\n\tif exit.code != 1 {\n\t\tt.Fatalf(\"expected exit to be called with 1, got %d\", exit.code)\n\t}\n\tif runner.called {\n\t\tt.Fatalf(\"expected run once not to be called\")\n\t}\n\tif !strings.Contains(stderr.String(), \"permission: allow\") {\n\t\tt.Fatalf(\"expected error to mention permission allow, got %q\", stderr.String())\n\t}\n\tif !strings.Contains(strings.ToLower(stderr.String()), \"init\") {\n\t\tt.Fatalf(\"expected guidance to run init, got %q\", stderr.String())\n\t}\n}\n\nfunc TestRunOnceMainInfersRoadmapRootWhenMissing(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteIssuesFile(t, tempDir, `{\"id\":\"roadmap-1\",\"title\":\"Roadmap\",\"issue_type\":\"epic\",\"status\":\"open\"}`)\n\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", code)\n\t}\n\tif !runner.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n\tif runner.opts.RootID != \"roadmap-1\" {\n\t\tt.Fatalf(\"expected root id to be inferred, got %q\", runner.opts.RootID)\n\t}\n}\n\nfunc TestRunOnceMainInfersRoadmapRootWhenInProgress(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteIssuesFile(t, tempDir, `{\"id\":\"roadmap-2\",\"title\":\"Roadmap\",\"issue_type\":\"epic\",\"status\":\"in_progress\"}`)\n\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", code)\n\t}\n\tif !runner.called {\n\t\tt.Fatalf(\"expected run once to be called\")\n\t}\n\tif runner.opts.RootID != \"roadmap-2\" {\n\t\tt.Fatalf(\"expected root id to be inferred, got %q\", runner.opts.RootID)\n\t}\n}\n\nfunc TestRunOnceMainMissingRootRequiresExplicitFlag(t *testing.T) {\n\ttempDir := t.TempDir()\n\twriteIssuesFile(t, tempDir, `{\"id\":\"epic-1\",\"title\":\"Other\",\"issue_type\":\"epic\",\"status\":\"open\"}`)\n\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n\trunner := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tstdout := &bytes.Buffer{}\n\tstderr := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir}, runner.Run, exit.Exit, stdout, stderr, beadsRunner, gitRunner)\n\n\tif code != 1 {\n\t\tt.Fatalf(\"expected exit code 1, got %d\", code)\n\t}\n\tif exit.code != 1 {\n\t\tt.Fatalf(\"expected exit to be called with 1, got %d\", exit.code)\n\t}\n\tif runner.called {\n\t\tt.Fatalf(\"expected run once not to be called\")\n\t}\n\tif !strings.Contains(stderr.String(), \"--root\") {\n\t\tt.Fatalf(\"expected error to mention --root, got %q\", stderr.String())\n\t}\n\tif !strings.Contains(strings.ToLower(stderr.String()), \"roadmap\") {\n\t\tt.Fatalf(\"expected error to mention roadmap, got %q\", stderr.String())\n\t}\n}\n\ntype fakeTUIProgram struct {\n\tstarted chan struct{}\n\tquit    chan struct{}\n\tevents  chan runner.Event\n}\n\nfunc newFakeTUIProgram() *fakeTUIProgram {\n\treturn &fakeTUIProgram{\n\t\tstarted: make(chan struct{}),\n\t\tquit:    make(chan struct{}),\n\t\tevents:  make(chan runner.Event, 1),\n\t}\n}\n\nfunc (f *fakeTUIProgram) Start() error {\n\tclose(f.started)\n\treturn nil\n}\n\nfunc (f *fakeTUIProgram) Send(event runner.Event) {\n\tf.events <- event\n}\n\nfunc (f *fakeTUIProgram) Quit() {\n\tclose(f.quit)\n}\n\nfunc waitForSignal(t *testing.T, signal chan struct{}, label string) {\n\tt.Helper()\n\tselect {\n\tcase <-signal:\n\t\treturn\n\tcase <-time.After(200 * time.Millisecond):\n\t\tt.Fatalf(\"expected %s\", label)\n\t}\n}\n\nfunc writeIssuesFile(t *testing.T, repoRoot string, payload string) {\n\tt.Helper()\n\tbeadsDir := filepath.Join(repoRoot, \".beads\")\n\tif err := os.MkdirAll(beadsDir, 0o755); err != nil {\n\t\tt.Fatalf(\"mkdir .beads: %v\", err)\n\t}\n\tissuesPath := filepath.Join(beadsDir, \"issues.jsonl\")\n\tif err := os.WriteFile(issuesPath, []byte(payload+\"\\n\"), 0o644); err != nil {\n\t\tt.Fatalf(\"write issues: %v\", err)\n\t}\n}\n\nfunc writeAgentFile(t *testing.T, repoRoot string, payload string) {\n\tt.Helper()\n\tagentDir := filepath.Join(repoRoot, \".opencode\", \"agent\")\n\tif err := os.MkdirAll(agentDir, 0o755); err != nil {\n\t\tt.Fatalf(\"mkdir agent dir: %v\", err)\n\t}\n\tagentPath := filepath.Join(agentDir, \"yolo.md\")\n\tif err := os.WriteFile(agentPath, []byte(payload), 0o644); err != nil {\n\t\tt.Fatalf(\"write agent file: %v\", err)\n\t}\n}\n\nfunc TestRunOnceMainUsesTUIOnTTYByDefault(t *testing.T) {\n\tfakeProgram := newFakeTUIProgram()\n\tprevIsTerminal := isTerminal\n\tprevNewTUIProgram := newTUIProgram\n\tisTerminal = func(io.Writer) bool { return true }\n\tnewTUIProgram = func(stdout io.Writer) tuiProgram { return fakeProgram }\n\tt.Cleanup(func() {\n\t\tisTerminal = prevIsTerminal\n\t\tnewTUIProgram = prevNewTUIProgram\n\t})\n\n\ttempDir := t.TempDir()\n\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n\trunOnce := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\n\tcode := RunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\"}, runOnce.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n\n\tif code != 0 {\n\t\tt.Fatalf(\"expected exit code 0, got %d\", code)\n\t}\n\tif runOnce.deps.Events == nil {\n\t\tt.Fatalf(\"expected events emitter to be set\")\n\t}\n\trunOnce.deps.Events.Emit(runner.Event{Type: runner.EventSelectTask})\n\twaitForSignal(t, fakeProgram.started, \"tui start\")\n\twaitForSignal(t, fakeProgram.quit, \"tui quit\")\n\tselect {\n\tcase <-fakeProgram.events:\n\t\t// ok\n\tcase <-time.After(200 * time.Millisecond):\n\t\tt.Fatalf(\"expected event to be forwarded to TUI\")\n\t}\n}\n\nfunc TestRunOnceMainHeadlessDisablesTUI(t *testing.T) {\n\tcalled := false\n\tprevIsTerminal := isTerminal\n\tprevNewTUIProgram := newTUIProgram\n\tisTerminal = func(io.Writer) bool { return true }\n\tnewTUIProgram = func(stdout io.Writer) tuiProgram {\n\t\tcalled = true\n\t\treturn newFakeTUIProgram()\n\t}\n\tt.Cleanup(func() {\n\t\tisTerminal = prevIsTerminal\n\t\tnewTUIProgram = prevNewTUIProgram\n\t})\n\n\ttempDir := t.TempDir()\n\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n\trunOnce := &fakeRunOnce{result: \"no_tasks\"}\n\texit := &fakeExit{}\n\tout := &bytes.Buffer{}\n\tbeadsRunner := &fakeRunner{}\n\tgitRunner := &fakeGitRunner{}\n\tstderr := &bytes.Buffer{}\n\n\tRunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\", \"--headless\"}, runOnce.Run, exit.Exit, out, stderr, beadsRunner, gitRunner)\n\n\tif called {\n\t\tt.Fatalf(\"expected TUI program not to start\")\n\t}\n\tif runOnce.deps.Events != nil {\n\t\tt.Fatalf(\"expected no events emitter in headless mode\")\n\t}\n}\n\nfunc TestOpenCodeRunDefaultsCreateConfigAndEnv(t *testing.T) {\n\ttempDir := t.TempDir()\n\trepoRoot := filepath.Join(tempDir, \"repo\")\n\tif err := os.MkdirAll(repoRoot, 0o755); err != nil {\n\t\tt.Fatalf(\"mkdir repo: %v\", err)\n\t}\n\tt.Setenv(\"HOME\", tempDir)\n\n\topenCodeRunner := &fakeOpenCodeRunner{}\n\topenCodeAdapter := openCodeAdapter{runner: openCodeRunner}\n\n\tconfigRoot := filepath.Join(tempDir, \".config\", \"opencode-runner\")\n\tconfigDir := filepath.Join(configRoot, \"opencode\")\n\tlogPath := filepath.Join(tempDir, \"runner-logs\", \"opencode\", \"issue-1.jsonl\")\n\n\tif err := openCodeAdapter.Run(\"issue-1\", repoRoot, \"prompt\", \"\", configRoot, configDir, logPath); err != nil {\n\t\tt.Fatalf(\"open code run error: %v\", err)\n\t}\n\n\tconfigFile := filepath.Join(configDir, \"opencode.json\")\n\tif _, err := os.Stat(configFile); err != nil {\n\t\tt.Fatalf(\"expected opencode.json to exist: %v\", err)\n\t}\n\texpectedConfigFile := filepath.Join(configDir, \"opencode.json\")\n\tif openCodeRunner.env[\"XDG_CONFIG_HOME\"] != configRoot {\n\t\tt.Fatalf(\"expected XDG_CONFIG_HOME set\")\n\t}\n\tif openCodeRunner.env[\"OPENCODE_CONFIG_DIR\"] != configDir {\n\t\tt.Fatalf(\"expected OPENCODE_CONFIG_DIR set\")\n\t}\n\tif openCodeRunner.env[\"OPENCODE_CONFIG\"] != expectedConfigFile {\n\t\tt.Fatalf(\"expected OPENCODE_CONFIG set\")\n\t}\n\tif openCodeRunner.env[\"OPENCODE_CONFIG_CONTENT\"] != \"{}\" {\n\t\tt.Fatalf(\"expected OPENCODE_CONFIG_CONTENT set\")\n\t}\n}\n","additions":1,"deletions":0},"truncated":false},"time":{"start":1768850830451,"end":1768850830617}},"metadata":{"openai":{"itemId":"fc_091c2cc3f6fe9c4501696e8589f0088191862a76fc78339329"}}}}
{"type":"step_finish","timestamp":1768850830640,"sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","part":{"id":"prt_bd7b9b51a001Ke6HduvMtHy6Ib","sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","messageID":"msg_bd7b99a1e001PRhvzd8SE4xAfX","type":"step-finish","reason":"tool-calls","snapshot":"67ad12f3c5d5e4940373d07f48446d6abf21e26e","cost":0,"tokens":{"input":1370,"output":274,"reasoning":0,"cache":{"read":28288,"write":0}}}}
{"type":"step_start","timestamp":1768850831141,"sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","part":{"id":"prt_bd7b9b725001I9B09D8ZRXNFky","sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","messageID":"msg_bd7b9b549001BlHZsFPubxRKu3","type":"step-start","snapshot":"8a84199b83fff5e0f6d9dc4b2a79e46983d9836a"}}
{"type":"tool_use","timestamp":1768850846624,"sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","part":{"id":"prt_bd7b9ec91001ydLsb78F7fPHsE","sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","messageID":"msg_bd7b9b549001BlHZsFPubxRKu3","type":"tool","callID":"call_i0NVd3kZBwSX4ehK6aYzXYnN","tool":"edit","state":{"status":"completed","input":{"filePath":"/Users/egv/dev/yolo-runner/internal/opencode/agent_test.go","oldString":"\trepoRoot := t.TempDir()\n\t// Ensure validation uses repo root path\n\terr := ValidateAgent(repoRoot)\n","newString":"\trepoRoot := t.TempDir()\n\n\terr := ValidateAgent(repoRoot)\n"},"output":"Edit applied successfully.","title":"internal/opencode/agent_test.go","metadata":{"diagnostics":{"/Users/egv/dev/yolo-runner/internal/opencode/client.go":[],"/Users/egv/dev/yolo-runner/internal/opencode/watchdog.go":[],"/Users/egv/dev/yolo-runner/go.mod":[{"range":{"start":{"line":6,"character":44},"end":{"line":6,"character":55}},"severity":2,"source":"go mod tidy","message":"github.com/charmbracelet/bubbletea should be direct"},{"range":{"start":{"line":19,"character":26},"end":{"line":19,"character":37}},"severity":2,"source":"go mod tidy","message":"golang.org/x/term should be direct"}],"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main.go":[{"range":{"start":{"line":66,"character":8},"end":{"line":66,"character":23}},"severity":4,"code":"default","codeDescription":{"href":"https://pkg.go.dev/golang.org/x/tools/gopls/internal/analysis/deprecated"},"source":"deprecated","message":"b.program.Start is deprecated: please use [Program.Run] instead.","tags":[2]}],"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go":[],"/Users/egv/dev/yolo-runner/cmd/yolo-runner/exec_test.go":[],"/Users/egv/dev/yolo-runner/internal/opencode/agent_test.go":[],"/Users/egv/dev/yolo-runner/internal/opencode/agent.go":[]},"diff":"Index: /Users/egv/dev/yolo-runner/internal/opencode/agent_test.go\n===================================================================\n--- /Users/egv/dev/yolo-runner/internal/opencode/agent_test.go\n+++ /Users/egv/dev/yolo-runner/internal/opencode/agent_test.go\n@@ -8,9 +8,9 @@\n )\n \n func TestValidateAgentMissingFile(t *testing.T) {\n \trepoRoot := t.TempDir()\n-\t// Ensure validation uses repo root path\n+\n \terr := ValidateAgent(repoRoot)\n \n \tif err == nil {\n \t\tt.Fatalf(\"expected error\")\n","filediff":{"file":"/Users/egv/dev/yolo-runner/internal/opencode/agent_test.go","before":"package opencode\n\nimport (\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"testing\"\n)\n\nfunc TestValidateAgentMissingFile(t *testing.T) {\n\trepoRoot := t.TempDir()\n\t// Ensure validation uses repo root path\n\terr := ValidateAgent(repoRoot)\n\n\tif err == nil {\n\t\tt.Fatalf(\"expected error\")\n\t}\n\tif !strings.Contains(err.Error(), \"yolo.md\") {\n\t\tt.Fatalf(\"expected error to mention yolo.md, got %q\", err.Error())\n\t}\n}\n\nfunc TestValidateAgentMissingPermission(t *testing.T) {\n\trepoRoot := t.TempDir()\n\tagentDir := filepath.Join(repoRoot, \".opencode\", \"agent\")\n\tif err := os.MkdirAll(agentDir, 0o755); err != nil {\n\t\tt.Fatalf(\"mkdir agent dir: %v\", err)\n\t}\n\tagentPath := filepath.Join(agentDir, \"yolo.md\")\n\tif err := os.WriteFile(agentPath, []byte(\"---\\nname: yolo\\n---\\n\"), 0o644); err != nil {\n\t\tt.Fatalf(\"write agent file: %v\", err)\n\t}\n\n\terr := ValidateAgent(repoRoot)\n\n\tif err == nil {\n\t\tt.Fatalf(\"expected error\")\n\t}\n\tif !strings.Contains(err.Error(), \"permission: allow\") {\n\t\tt.Fatalf(\"expected error to mention permission allow, got %q\", err.Error())\n\t}\n\tif !strings.Contains(strings.ToLower(err.Error()), \"init\") {\n\t\tt.Fatalf(\"expected guidance to run init, got %q\", err.Error())\n\t}\n}\n\nfunc TestValidateAgentAllowsPermissionAllow(t *testing.T) {\n\trepoRoot := t.TempDir()\n\tagentDir := filepath.Join(repoRoot, \".opencode\", \"agent\")\n\tif err := os.MkdirAll(agentDir, 0o755); err != nil {\n\t\tt.Fatalf(\"mkdir agent dir: %v\", err)\n\t}\n\tagentPath := filepath.Join(agentDir, \"yolo.md\")\n\tcontent := \"---\\nname: yolo\\npermission: allow\\n---\\n\"\n\tif err := os.WriteFile(agentPath, []byte(content), 0o644); err != nil {\n\t\tt.Fatalf(\"write agent file: %v\", err)\n\t}\n\n\terr := ValidateAgent(repoRoot)\n\n\tif err != nil {\n\t\tt.Fatalf(\"expected no error, got %v\", err)\n\t}\n}\n","after":"package opencode\n\nimport (\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"testing\"\n)\n\nfunc TestValidateAgentMissingFile(t *testing.T) {\n\trepoRoot := t.TempDir()\n\n\terr := ValidateAgent(repoRoot)\n\n\tif err == nil {\n\t\tt.Fatalf(\"expected error\")\n\t}\n\tif !strings.Contains(err.Error(), \"yolo.md\") {\n\t\tt.Fatalf(\"expected error to mention yolo.md, got %q\", err.Error())\n\t}\n}\n\nfunc TestValidateAgentMissingPermission(t *testing.T) {\n\trepoRoot := t.TempDir()\n\tagentDir := filepath.Join(repoRoot, \".opencode\", \"agent\")\n\tif err := os.MkdirAll(agentDir, 0o755); err != nil {\n\t\tt.Fatalf(\"mkdir agent dir: %v\", err)\n\t}\n\tagentPath := filepath.Join(agentDir, \"yolo.md\")\n\tif err := os.WriteFile(agentPath, []byte(\"---\\nname: yolo\\n---\\n\"), 0o644); err != nil {\n\t\tt.Fatalf(\"write agent file: %v\", err)\n\t}\n\n\terr := ValidateAgent(repoRoot)\n\n\tif err == nil {\n\t\tt.Fatalf(\"expected error\")\n\t}\n\tif !strings.Contains(err.Error(), \"permission: allow\") {\n\t\tt.Fatalf(\"expected error to mention permission allow, got %q\", err.Error())\n\t}\n\tif !strings.Contains(strings.ToLower(err.Error()), \"init\") {\n\t\tt.Fatalf(\"expected guidance to run init, got %q\", err.Error())\n\t}\n}\n\nfunc TestValidateAgentAllowsPermissionAllow(t *testing.T) {\n\trepoRoot := t.TempDir()\n\tagentDir := filepath.Join(repoRoot, \".opencode\", \"agent\")\n\tif err := os.MkdirAll(agentDir, 0o755); err != nil {\n\t\tt.Fatalf(\"mkdir agent dir: %v\", err)\n\t}\n\tagentPath := filepath.Join(agentDir, \"yolo.md\")\n\tcontent := \"---\\nname: yolo\\npermission: allow\\n---\\n\"\n\tif err := os.WriteFile(agentPath, []byte(content), 0o644); err != nil {\n\t\tt.Fatalf(\"write agent file: %v\", err)\n\t}\n\n\terr := ValidateAgent(repoRoot)\n\n\tif err != nil {\n\t\tt.Fatalf(\"expected no error, got %v\", err)\n\t}\n}\n","additions":1,"deletions":1},"truncated":false},"time":{"start":1768850846465,"end":1768850846623}},"metadata":{"openai":{"itemId":"fc_02ea06b997d1b05c01696e859cc8808191b362cd5f9c51d2e7"}}}}
{"type":"step_finish","timestamp":1768850846643,"sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","part":{"id":"prt_bd7b9f3a0001vRg6LKOBWgjH3z","sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","messageID":"msg_bd7b9b549001BlHZsFPubxRKu3","type":"step-finish","reason":"tool-calls","snapshot":"066f0877792a6a8110f96f67fad4660dda93ce4f","cost":0,"tokens":{"input":631,"output":604,"reasoning":512,"cache":{"read":29312,"write":0}}}}
{"type":"step_start","timestamp":1768850847001,"sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","part":{"id":"prt_bd7b9f518001cbf3r0M835K2fg","sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","messageID":"msg_bd7b9f3cc001UZJ4rHWdvoT6Qm","type":"step-start","snapshot":"2c72147b014073166e6874cd4eb0a3520a9e7682"}}
{"type":"tool_use","timestamp":1768850849440,"sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","part":{"id":"prt_bd7b9f747001BUbqYmC4Hb99K0","sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","messageID":"msg_bd7b9f3cc001UZJ4rHWdvoT6Qm","type":"tool","callID":"call_P86C84FZ0ldWahuqbIVZ9PQu","tool":"bash","state":{"status":"completed","input":{"command":"go test ./...","description":"Runs full Go test suite"},"output":"ok  \tyolo-runner\t(cached)\n--- FAIL: TestRunOnceMainFailsWhenYoloAgentMissing (0.00s)\n    main_test.go:195: expected exit code 1, got 0\n--- FAIL: TestRunOnceMainFailsWhenYoloAgentMissingPermission (0.00s)\n    main_test.go:221: expected exit code 1, got 0\nFAIL\nFAIL\tyolo-runner/cmd/yolo-runner\t0.982s\nok  \tyolo-runner/internal/beads\t(cached)\nok  \tyolo-runner/internal/logging\t(cached)\nok  \tyolo-runner/internal/opencode\t(cached)\nok  \tyolo-runner/internal/prompt\t(cached)\nok  \tyolo-runner/internal/runner\t(cached)\nok  \tyolo-runner/internal/ui/tui\t(cached)\nok  \tyolo-runner/internal/vcs/git\t(cached)\nFAIL\n","title":"Runs full Go test suite","metadata":{"output":"ok  \tyolo-runner\t(cached)\n--- FAIL: TestRunOnceMainFailsWhenYoloAgentMissing (0.00s)\n    main_test.go:195: expected exit code 1, got 0\n--- FAIL: TestRunOnceMainFailsWhenYoloAgentMissingPermission (0.00s)\n    main_test.go:221: expected exit code 1, got 0\nFAIL\nFAIL\tyolo-runner/cmd/yolo-runner\t0.982s\nok  \tyolo-runner/internal/beads\t(cached)\nok  \tyolo-runner/internal/logging\t(cached)\nok  \tyolo-runner/internal/opencode\t(cached)\nok  \tyolo-runner/internal/prompt\t(cached)\nok  \tyolo-runner/internal/runner\t(cached)\nok  \tyolo-runner/internal/ui/tui\t(cached)\nok  \tyolo-runner/internal/vcs/git\t(cached)\nFAIL\n","exit":1,"description":"Runs full Go test suite","truncated":false},"time":{"start":1768850848057,"end":1768850849439}},"metadata":{"openai":{"itemId":"fc_0eecf8d496ca5abb01696e859f8a0c8191a73d8130af3760af"}}}}
{"type":"step_finish","timestamp":1768850849460,"sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","part":{"id":"prt_bd7b9fea0001jUH3j8HlTbaXuG","sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","messageID":"msg_bd7b9f3cc001UZJ4rHWdvoT6Qm","type":"step-finish","reason":"tool-calls","snapshot":"d7294aafb07935e3bb84182c75cdecce5521b9fe","cost":0,"tokens":{"input":732,"output":29,"reasoning":0,"cache":{"read":29312,"write":0}}}}
{"type":"step_start","timestamp":1768850849788,"sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","part":{"id":"prt_bd7b9fffc001j1WQPVPyCgXHIB","sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","messageID":"msg_bd7b9fecc001XEbroeaQOmiAUr","type":"step-start","snapshot":"e46ead833e11f1b3a38652ec42bbb257d82c7dbe"}}
{"type":"tool_use","timestamp":1768850859081,"sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","part":{"id":"prt_bd7ba0267001bD58S9F61xCJWL","sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","messageID":"msg_bd7b9fecc001XEbroeaQOmiAUr","type":"tool","callID":"call_3o6mICNDVh9vzu5wcZMqUAWI","tool":"edit","state":{"status":"completed","input":{"filePath":"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main.go","oldString":"\tif runOnce == nil {\n\t\trunOnce = runner.RunOnce\n\t}\n\n\tif beadsRunner == nil {\n\t\tbeadsRunner = adapterRunner{}\n\t}\n\tif gitRunner == nil {\n\t\tgitRunner = adapterGitRunner{}\n\t}\n\n\tbeadsAdapter := beads.New(beadsRunner)\n\tgitAdapter := gitadapter.New(gitRunner)\n\topenCodeAdapter := openCodeAdapter{runner: defaultOpenCodeRunner{}}\n\n\tresolvedRootID := *rootID\n\tif resolvedRootID == \"\" {\n\t\tinferredRootID, err := inferDefaultRootID(*repoRoot)\n\t\tif err != nil {\n\t\t\tfmt.Fprintln(stderr, err)\n\t\t\tif exit != nil {\n\t\t\t\texit(1)\n\t\t\t}\n\t\t\treturn 1\n\t\t}\n\t\tresolvedRootID = inferredRootID\n\t}\n","newString":"\tif runOnce == nil {\n\t\trunOnce = runner.RunOnce\n\t}\n\n\tif err := opencode.ValidateAgent(*repoRoot); err != nil {\n\t\tfmt.Fprintln(stderr, err)\n\t\tif exit != nil {\n\t\t\texit(1)\n\t\t}\n\t\treturn 1\n\t}\n\n\tif beadsRunner == nil {\n\t\tbeadsRunner = adapterRunner{}\n\t}\n\tif gitRunner == nil {\n\t\tgitRunner = adapterGitRunner{}\n\t}\n\n\tbeadsAdapter := beads.New(beadsRunner)\n\tgitAdapter := gitadapter.New(gitRunner)\n\topenCodeAdapter := openCodeAdapter{runner: defaultOpenCodeRunner{}}\n\n\tresolvedRootID := *rootID\n\tif resolvedRootID == \"\" {\n\t\tinferredRootID, err := inferDefaultRootID(*repoRoot)\n\t\tif err != nil {\n\t\t\tfmt.Fprintln(stderr, err)\n\t\t\tif exit != nil {\n\t\t\t\texit(1)\n\t\t\t}\n\t\t\treturn 1\n\t\t}\n\t\tresolvedRootID = inferredRootID\n\t}\n"},"output":"Edit applied successfully.","title":"cmd/yolo-runner/main.go","metadata":{"diagnostics":{"/Users/egv/dev/yolo-runner/internal/opencode/client.go":[{"range":{"start":{"line":28,"character":1},"end":{"line":28,"character":18}},"severity":2,"code":"default","codeDescription":{"href":"https://staticcheck.dev/docs/checks/#S1031"},"source":"S1031","message":"unnecessary nil check around range"}],"/Users/egv/dev/yolo-runner/internal/opencode/watchdog.go":[],"/Users/egv/dev/yolo-runner/go.mod":[{"range":{"start":{"line":6,"character":44},"end":{"line":6,"character":55}},"severity":2,"source":"go mod tidy","message":"github.com/charmbracelet/bubbletea should be direct"},{"range":{"start":{"line":19,"character":26},"end":{"line":19,"character":37}},"severity":2,"source":"go mod tidy","message":"golang.org/x/term should be direct"}],"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main.go":[],"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main_test.go":[],"/Users/egv/dev/yolo-runner/cmd/yolo-runner/exec_test.go":[],"/Users/egv/dev/yolo-runner/internal/opencode/agent_test.go":[],"/Users/egv/dev/yolo-runner/internal/opencode/agent.go":[]},"diff":"Index: /Users/egv/dev/yolo-runner/cmd/yolo-runner/main.go\n===================================================================\n--- /Users/egv/dev/yolo-runner/cmd/yolo-runner/main.go\n+++ /Users/egv/dev/yolo-runner/cmd/yolo-runner/main.go\n@@ -136,8 +136,16 @@\n if runOnce == nil {\n \trunOnce = runner.RunOnce\n }\n \n+if err := opencode.ValidateAgent(*repoRoot); err != nil {\n+\tfmt.Fprintln(stderr, err)\n+\tif exit != nil {\n+\t\texit(1)\n+\t}\n+\treturn 1\n+}\n+\n if beadsRunner == nil {\n \tbeadsRunner = adapterRunner{}\n }\n if gitRunner == nil {\n","filediff":{"file":"/Users/egv/dev/yolo-runner/cmd/yolo-runner/main.go","before":"package main\n\nimport (\n\t\"bufio\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"flag\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\n\t\"yolo-runner/internal/beads\"\n\t\"yolo-runner/internal/logging\"\n\t\"yolo-runner/internal/opencode\"\n\t\"yolo-runner/internal/prompt\"\n\t\"yolo-runner/internal/runner\"\n\t\"yolo-runner/internal/ui/tui\"\n\tgitadapter \"yolo-runner/internal/vcs/git\"\n\n\ttea \"github.com/charmbracelet/bubbletea\"\n\t\"golang.org/x/term\"\n)\n\ntype runOnceFunc func(opts runner.RunOnceOptions, deps runner.RunOnceDeps) (string, error)\n\ntype exitFunc func(code int)\n\ntype beadsRunner interface {\n\tRun(args ...string) (string, error)\n}\n\ntype gitRunner interface {\n\tRun(name string, args ...string) (string, error)\n}\n\ntype openCodeRunner interface {\n\tStart(args []string, env map[string]string, stdoutPath string) (opencode.Process, error)\n}\n\ntype tuiProgram interface {\n\tStart() error\n\tSend(event runner.Event)\n\tQuit()\n}\n\ntype tuiEmitter struct {\n\tprogram tuiProgram\n}\n\nfunc (t tuiEmitter) Emit(event runner.Event) {\n\tif t.program == nil {\n\t\treturn\n\t}\n\tgo t.program.Send(event)\n}\n\ntype bubbleTUIProgram struct {\n\tprogram *tea.Program\n}\n\nfunc (b bubbleTUIProgram) Start() error {\n\tif b.program == nil {\n\t\treturn nil\n\t}\n\treturn b.program.Start()\n}\n\nfunc (b bubbleTUIProgram) Send(event runner.Event) {\n\tif b.program == nil {\n\t\treturn\n\t}\n\tb.program.Send(event)\n}\n\nfunc (b bubbleTUIProgram) Quit() {\n\tif b.program == nil {\n\t\treturn\n\t}\n\tb.program.Quit()\n}\n\nvar isTerminal = func(writer io.Writer) bool {\n\tif file, ok := writer.(*os.File); ok {\n\t\treturn term.IsTerminal(int(file.Fd()))\n\t}\n\treturn false\n}\n\nvar newTUIProgram = func(stdout io.Writer) tuiProgram {\n\tprogram := tea.NewProgram(tui.NewModel(nil), tea.WithInput(nil), tea.WithOutput(stdout))\n\treturn bubbleTUIProgram{program: program}\n}\n\ntype adapterRunner struct{}\n\nfunc (adapterRunner) Run(args ...string) (string, error) {\n\treturn runCommand(args...)\n}\n\ntype adapterGitRunner struct{}\n\nfunc (adapterGitRunner) Run(name string, args ...string) (string, error) {\n\treturn runCommand(append([]string{name}, args...)...)\n}\n\ntype openCodeAdapter struct {\n\trunner openCodeRunner\n}\n\nfunc (o openCodeAdapter) Run(issueID string, repoRoot string, promptText string, model string, configRoot string, configDir string, logPath string) error {\n\treturn opencode.Run(issueID, repoRoot, promptText, model, configRoot, configDir, logPath, o.runner)\n}\n\nfunc RunOnceMain(args []string, runOnce runOnceFunc, exit exitFunc, stdout io.Writer, stderr io.Writer, beadsRunner beadsRunner, gitRunner gitRunner) int {\n\tfs := flag.NewFlagSet(\"yolo-runner\", flag.ContinueOnError)\n\tfs.SetOutput(stderr)\n\n\trepoRoot := fs.String(\"repo\", \".\", \"Repository root path\")\n\trootID := fs.String(\"root\", \"\", \"Root bead/epic ID\")\n\tmodel := fs.String(\"model\", \"\", \"OpenCode model\")\n\tdryRun := fs.Bool(\"dry-run\", false, \"Print task and prompt without executing\")\n\theadless := fs.Bool(\"headless\", false, \"Force plain output without TUI\")\n\tconfigRoot := fs.String(\"config-root\", \"\", \"OpenCode config root\")\n\tconfigDir := fs.String(\"config-dir\", \"\", \"OpenCode config dir\")\n\n\tif err := fs.Parse(args); err != nil {\n\t\tfmt.Fprintln(stderr, err)\n\t\tif exit != nil {\n\t\t\texit(1)\n\t\t}\n\t\treturn 1\n\t}\n\n\tif runOnce == nil {\n\t\trunOnce = runner.RunOnce\n\t}\n\n\tif beadsRunner == nil {\n\t\tbeadsRunner = adapterRunner{}\n\t}\n\tif gitRunner == nil {\n\t\tgitRunner = adapterGitRunner{}\n\t}\n\n\tbeadsAdapter := beads.New(beadsRunner)\n\tgitAdapter := gitadapter.New(gitRunner)\n\topenCodeAdapter := openCodeAdapter{runner: defaultOpenCodeRunner{}}\n\n\tresolvedRootID := *rootID\n\tif resolvedRootID == \"\" {\n\t\tinferredRootID, err := inferDefaultRootID(*repoRoot)\n\t\tif err != nil {\n\t\t\tfmt.Fprintln(stderr, err)\n\t\t\tif exit != nil {\n\t\t\t\texit(1)\n\t\t\t}\n\t\t\treturn 1\n\t\t}\n\t\tresolvedRootID = inferredRootID\n\t}\n\n\tdeps := runner.RunOnceDeps{\n\t\tBeads:    beadsAdapter,\n\t\tPrompt:   promptBuilder{},\n\t\tOpenCode: openCodeAdapter,\n\t\tGit:      gitAdapter,\n\t\tLogger:   runnerLogger{},\n\t}\n\n\tresolvedConfigRoot := *configRoot\n\tresolvedConfigDir := *configDir\n\tif resolvedConfigRoot == \"\" {\n\t\thomeDir := os.Getenv(\"HOME\")\n\t\tif homeDir != \"\" {\n\t\t\tresolvedConfigRoot = filepath.Join(homeDir, \".config\", \"opencode-runner\")\n\t\t}\n\t}\n\tif resolvedConfigDir == \"\" && resolvedConfigRoot != \"\" {\n\t\tresolvedConfigDir = filepath.Join(resolvedConfigRoot, \"opencode\")\n\t}\n\n\toptions := runner.RunOnceOptions{\n\t\tRepoRoot:   *repoRoot,\n\t\tRootID:     resolvedRootID,\n\t\tModel:      *model,\n\t\tConfigRoot: resolvedConfigRoot,\n\t\tConfigDir:  resolvedConfigDir,\n\t\tDryRun:     *dryRun,\n\t\tOut:        stdout,\n\t}\n\n\tif stdout == nil {\n\t\toptions.Out = io.Discard\n\t}\n\tif stderr == nil {\n\t\tstderr = io.Discard\n\t}\n\n\tvar program tuiProgram\n\tif !*headless && isTerminal(stdout) {\n\t\tprogram = newTUIProgram(stdout)\n\t\tdeps.Events = tuiEmitter{program: program}\n\t\tgo func() {\n\t\t\tif err := program.Start(); err != nil {\n\t\t\t\tfmt.Fprintln(stderr, err)\n\t\t\t\tif exit != nil {\n\t\t\t\t\texit(1)\n\t\t\t\t}\n\t\t\t}\n\t\t}()\n\t}\n\n\t_, err := runOnce(options, deps)\n\tif program != nil {\n\t\tprogram.Quit()\n\t}\n\tif err != nil {\n\t\tfmt.Fprintln(stderr, err)\n\t\tif exit != nil {\n\t\t\texit(1)\n\t\t}\n\t\treturn 1\n\t}\n\n\tif exit != nil {\n\t\texit(0)\n\t}\n\treturn 0\n}\n\nfunc main() {\n\tRunOnceMain(os.Args[1:], runner.RunOnce, os.Exit, os.Stdout, os.Stderr, nil, nil)\n}\n\ntype promptBuilder struct{}\n\nfunc (promptBuilder) Build(issueID string, title string, description string, acceptance string) string {\n\treturn prompt.Build(issueID, title, description, acceptance)\n}\n\ntype runnerLogger struct{}\n\nfunc (runnerLogger) AppendRunnerSummary(repoRoot string, issueID string, title string, status string, commitSHA string) error {\n\treturn logging.AppendRunnerSummary(repoRoot, issueID, title, status, commitSHA)\n}\n\ntype defaultOpenCodeRunner struct{}\n\nfunc (defaultOpenCodeRunner) Start(args []string, env map[string]string, stdoutPath string) (opencode.Process, error) {\n\treturn startCommandWithEnv(args, env, stdoutPath)\n}\n\ntype roadmapCandidate struct {\n\tID     string `json:\"id\"`\n\tTitle  string `json:\"title\"`\n\tType   string `json:\"issue_type\"`\n\tStatus string `json:\"status\"`\n}\n\nfunc inferDefaultRootID(repoRoot string) (string, error) {\n\tissuesPath := filepath.Join(repoRoot, \".beads\", \"issues.jsonl\")\n\tfile, err := os.Open(issuesPath)\n\tif err != nil {\n\t\treturn \"\", errors.New(\"missing --root and no readable .beads/issues.jsonl; pass --root explicitly\")\n\t}\n\tdefer file.Close()\n\n\tscanner := bufio.NewScanner(file)\n\tcount := 0\n\tvar match roadmapCandidate\n\tfor scanner.Scan() {\n\t\tline := strings.TrimSpace(scanner.Text())\n\t\tif line == \"\" {\n\t\t\tcontinue\n\t\t}\n\t\tvar item roadmapCandidate\n\t\tif err := json.Unmarshal([]byte(line), &item); err != nil {\n\t\t\tcontinue\n\t\t}\n\t\tif item.Title == \"Roadmap\" && item.Type == \"epic\" && (item.Status == \"open\" || item.Status == \"in_progress\") {\n\t\t\tcount++\n\t\t\tmatch = item\n\t\t}\n\t}\n\tif err := scanner.Err(); err != nil {\n\t\treturn \"\", errors.New(\"missing --root and unable to read .beads/issues.jsonl; pass --root explicitly\")\n\t}\n\tif count == 1 && match.ID != \"\" {\n\t\treturn match.ID, nil\n\t}\n\treturn \"\", errors.New(\"missing --root and no unique Roadmap epic found; pass --root explicitly\")\n}\n","after":"package main\n\nimport (\n\t\"bufio\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"flag\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\n\t\"yolo-runner/internal/beads\"\n\t\"yolo-runner/internal/logging\"\n\t\"yolo-runner/internal/opencode\"\n\t\"yolo-runner/internal/prompt\"\n\t\"yolo-runner/internal/runner\"\n\t\"yolo-runner/internal/ui/tui\"\n\tgitadapter \"yolo-runner/internal/vcs/git\"\n\n\ttea \"github.com/charmbracelet/bubbletea\"\n\t\"golang.org/x/term\"\n)\n\ntype runOnceFunc func(opts runner.RunOnceOptions, deps runner.RunOnceDeps) (string, error)\n\ntype exitFunc func(code int)\n\ntype beadsRunner interface {\n\tRun(args ...string) (string, error)\n}\n\ntype gitRunner interface {\n\tRun(name string, args ...string) (string, error)\n}\n\ntype openCodeRunner interface {\n\tStart(args []string, env map[string]string, stdoutPath string) (opencode.Process, error)\n}\n\ntype tuiProgram interface {\n\tStart() error\n\tSend(event runner.Event)\n\tQuit()\n}\n\ntype tuiEmitter struct {\n\tprogram tuiProgram\n}\n\nfunc (t tuiEmitter) Emit(event runner.Event) {\n\tif t.program == nil {\n\t\treturn\n\t}\n\tgo t.program.Send(event)\n}\n\ntype bubbleTUIProgram struct {\n\tprogram *tea.Program\n}\n\nfunc (b bubbleTUIProgram) Start() error {\n\tif b.program == nil {\n\t\treturn nil\n\t}\n\treturn b.program.Start()\n}\n\nfunc (b bubbleTUIProgram) Send(event runner.Event) {\n\tif b.program == nil {\n\t\treturn\n\t}\n\tb.program.Send(event)\n}\n\nfunc (b bubbleTUIProgram) Quit() {\n\tif b.program == nil {\n\t\treturn\n\t}\n\tb.program.Quit()\n}\n\nvar isTerminal = func(writer io.Writer) bool {\n\tif file, ok := writer.(*os.File); ok {\n\t\treturn term.IsTerminal(int(file.Fd()))\n\t}\n\treturn false\n}\n\nvar newTUIProgram = func(stdout io.Writer) tuiProgram {\n\tprogram := tea.NewProgram(tui.NewModel(nil), tea.WithInput(nil), tea.WithOutput(stdout))\n\treturn bubbleTUIProgram{program: program}\n}\n\ntype adapterRunner struct{}\n\nfunc (adapterRunner) Run(args ...string) (string, error) {\n\treturn runCommand(args...)\n}\n\ntype adapterGitRunner struct{}\n\nfunc (adapterGitRunner) Run(name string, args ...string) (string, error) {\n\treturn runCommand(append([]string{name}, args...)...)\n}\n\ntype openCodeAdapter struct {\n\trunner openCodeRunner\n}\n\nfunc (o openCodeAdapter) Run(issueID string, repoRoot string, promptText string, model string, configRoot string, configDir string, logPath string) error {\n\treturn opencode.Run(issueID, repoRoot, promptText, model, configRoot, configDir, logPath, o.runner)\n}\n\nfunc RunOnceMain(args []string, runOnce runOnceFunc, exit exitFunc, stdout io.Writer, stderr io.Writer, beadsRunner beadsRunner, gitRunner gitRunner) int {\n\tfs := flag.NewFlagSet(\"yolo-runner\", flag.ContinueOnError)\n\tfs.SetOutput(stderr)\n\n\trepoRoot := fs.String(\"repo\", \".\", \"Repository root path\")\n\trootID := fs.String(\"root\", \"\", \"Root bead/epic ID\")\n\tmodel := fs.String(\"model\", \"\", \"OpenCode model\")\n\tdryRun := fs.Bool(\"dry-run\", false, \"Print task and prompt without executing\")\n\theadless := fs.Bool(\"headless\", false, \"Force plain output without TUI\")\n\tconfigRoot := fs.String(\"config-root\", \"\", \"OpenCode config root\")\n\tconfigDir := fs.String(\"config-dir\", \"\", \"OpenCode config dir\")\n\n\tif err := fs.Parse(args); err != nil {\n\t\tfmt.Fprintln(stderr, err)\n\t\tif exit != nil {\n\t\t\texit(1)\n\t\t}\n\t\treturn 1\n\t}\n\n\tif runOnce == nil {\n\t\trunOnce = runner.RunOnce\n\t}\n\n\tif err := opencode.ValidateAgent(*repoRoot); err != nil {\n\t\tfmt.Fprintln(stderr, err)\n\t\tif exit != nil {\n\t\t\texit(1)\n\t\t}\n\t\treturn 1\n\t}\n\n\tif beadsRunner == nil {\n\t\tbeadsRunner = adapterRunner{}\n\t}\n\tif gitRunner == nil {\n\t\tgitRunner = adapterGitRunner{}\n\t}\n\n\tbeadsAdapter := beads.New(beadsRunner)\n\tgitAdapter := gitadapter.New(gitRunner)\n\topenCodeAdapter := openCodeAdapter{runner: defaultOpenCodeRunner{}}\n\n\tresolvedRootID := *rootID\n\tif resolvedRootID == \"\" {\n\t\tinferredRootID, err := inferDefaultRootID(*repoRoot)\n\t\tif err != nil {\n\t\t\tfmt.Fprintln(stderr, err)\n\t\t\tif exit != nil {\n\t\t\t\texit(1)\n\t\t\t}\n\t\t\treturn 1\n\t\t}\n\t\tresolvedRootID = inferredRootID\n\t}\n\n\tdeps := runner.RunOnceDeps{\n\t\tBeads:    beadsAdapter,\n\t\tPrompt:   promptBuilder{},\n\t\tOpenCode: openCodeAdapter,\n\t\tGit:      gitAdapter,\n\t\tLogger:   runnerLogger{},\n\t}\n\n\tresolvedConfigRoot := *configRoot\n\tresolvedConfigDir := *configDir\n\tif resolvedConfigRoot == \"\" {\n\t\thomeDir := os.Getenv(\"HOME\")\n\t\tif homeDir != \"\" {\n\t\t\tresolvedConfigRoot = filepath.Join(homeDir, \".config\", \"opencode-runner\")\n\t\t}\n\t}\n\tif resolvedConfigDir == \"\" && resolvedConfigRoot != \"\" {\n\t\tresolvedConfigDir = filepath.Join(resolvedConfigRoot, \"opencode\")\n\t}\n\n\toptions := runner.RunOnceOptions{\n\t\tRepoRoot:   *repoRoot,\n\t\tRootID:     resolvedRootID,\n\t\tModel:      *model,\n\t\tConfigRoot: resolvedConfigRoot,\n\t\tConfigDir:  resolvedConfigDir,\n\t\tDryRun:     *dryRun,\n\t\tOut:        stdout,\n\t}\n\n\tif stdout == nil {\n\t\toptions.Out = io.Discard\n\t}\n\tif stderr == nil {\n\t\tstderr = io.Discard\n\t}\n\n\tvar program tuiProgram\n\tif !*headless && isTerminal(stdout) {\n\t\tprogram = newTUIProgram(stdout)\n\t\tdeps.Events = tuiEmitter{program: program}\n\t\tgo func() {\n\t\t\tif err := program.Start(); err != nil {\n\t\t\t\tfmt.Fprintln(stderr, err)\n\t\t\t\tif exit != nil {\n\t\t\t\t\texit(1)\n\t\t\t\t}\n\t\t\t}\n\t\t}()\n\t}\n\n\t_, err := runOnce(options, deps)\n\tif program != nil {\n\t\tprogram.Quit()\n\t}\n\tif err != nil {\n\t\tfmt.Fprintln(stderr, err)\n\t\tif exit != nil {\n\t\t\texit(1)\n\t\t}\n\t\treturn 1\n\t}\n\n\tif exit != nil {\n\t\texit(0)\n\t}\n\treturn 0\n}\n\nfunc main() {\n\tRunOnceMain(os.Args[1:], runner.RunOnce, os.Exit, os.Stdout, os.Stderr, nil, nil)\n}\n\ntype promptBuilder struct{}\n\nfunc (promptBuilder) Build(issueID string, title string, description string, acceptance string) string {\n\treturn prompt.Build(issueID, title, description, acceptance)\n}\n\ntype runnerLogger struct{}\n\nfunc (runnerLogger) AppendRunnerSummary(repoRoot string, issueID string, title string, status string, commitSHA string) error {\n\treturn logging.AppendRunnerSummary(repoRoot, issueID, title, status, commitSHA)\n}\n\ntype defaultOpenCodeRunner struct{}\n\nfunc (defaultOpenCodeRunner) Start(args []string, env map[string]string, stdoutPath string) (opencode.Process, error) {\n\treturn startCommandWithEnv(args, env, stdoutPath)\n}\n\ntype roadmapCandidate struct {\n\tID     string `json:\"id\"`\n\tTitle  string `json:\"title\"`\n\tType   string `json:\"issue_type\"`\n\tStatus string `json:\"status\"`\n}\n\nfunc inferDefaultRootID(repoRoot string) (string, error) {\n\tissuesPath := filepath.Join(repoRoot, \".beads\", \"issues.jsonl\")\n\tfile, err := os.Open(issuesPath)\n\tif err != nil {\n\t\treturn \"\", errors.New(\"missing --root and no readable .beads/issues.jsonl; pass --root explicitly\")\n\t}\n\tdefer file.Close()\n\n\tscanner := bufio.NewScanner(file)\n\tcount := 0\n\tvar match roadmapCandidate\n\tfor scanner.Scan() {\n\t\tline := strings.TrimSpace(scanner.Text())\n\t\tif line == \"\" {\n\t\t\tcontinue\n\t\t}\n\t\tvar item roadmapCandidate\n\t\tif err := json.Unmarshal([]byte(line), &item); err != nil {\n\t\t\tcontinue\n\t\t}\n\t\tif item.Title == \"Roadmap\" && item.Type == \"epic\" && (item.Status == \"open\" || item.Status == \"in_progress\") {\n\t\t\tcount++\n\t\t\tmatch = item\n\t\t}\n\t}\n\tif err := scanner.Err(); err != nil {\n\t\treturn \"\", errors.New(\"missing --root and unable to read .beads/issues.jsonl; pass --root explicitly\")\n\t}\n\tif count == 1 && match.ID != \"\" {\n\t\treturn match.ID, nil\n\t}\n\treturn \"\", errors.New(\"missing --root and no unique Roadmap epic found; pass --root explicitly\")\n}\n","additions":8,"deletions":0},"truncated":false},"time":{"start":1768850858921,"end":1768850859080}},"metadata":{"openai":{"itemId":"fc_0d03fe24fa8deb6201696e85a265d481918ca6c63f4f6f5c51"}}}}
{"type":"step_finish","timestamp":1768850859102,"sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","part":{"id":"prt_bd7ba2449001F6x1zO32uhBW1o","sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","messageID":"msg_bd7b9fecc001XEbroeaQOmiAUr","type":"step-finish","reason":"tool-calls","snapshot":"459734a448b76c2b9a48d1e353e8bd5a22c6b816","cost":0,"tokens":{"input":326,"output":527,"reasoning":0,"cache":{"read":29952,"write":0}}}}
{"type":"step_start","timestamp":1768850859655,"sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","part":{"id":"prt_bd7ba2686001aXh4Lvwaz9jZee","sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","messageID":"msg_bd7ba247b001Pf6LtvSYvtvF1X","type":"step-start","snapshot":"e0ec7151d81b77e784ee57441bf6415c501f6ee0"}}
{"type":"tool_use","timestamp":1768850861305,"sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","part":{"id":"prt_bd7ba28e3001P0U5jXYy3OB3Rn","sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","messageID":"msg_bd7ba247b001Pf6LtvSYvtvF1X","type":"tool","callID":"call_bPRDxdv4tHjqL68j6LpACVrH","tool":"bash","state":{"status":"completed","input":{"command":"go test ./...","description":"Runs full Go test suite"},"output":"ok  \tyolo-runner\t(cached)\nok  \tyolo-runner/cmd/yolo-runner\t0.407s\nok  \tyolo-runner/internal/beads\t(cached)\nok  \tyolo-runner/internal/logging\t(cached)\nok  \tyolo-runner/internal/opencode\t(cached)\nok  \tyolo-runner/internal/prompt\t(cached)\nok  \tyolo-runner/internal/runner\t(cached)\nok  \tyolo-runner/internal/ui/tui\t(cached)\nok  \tyolo-runner/internal/vcs/git\t(cached)\n","title":"Runs full Go test suite","metadata":{"output":"ok  \tyolo-runner\t(cached)\nok  \tyolo-runner/cmd/yolo-runner\t0.407s\nok  \tyolo-runner/internal/beads\t(cached)\nok  \tyolo-runner/internal/logging\t(cached)\nok  \tyolo-runner/internal/opencode\t(cached)\nok  \tyolo-runner/internal/prompt\t(cached)\nok  \tyolo-runner/internal/runner\t(cached)\nok  \tyolo-runner/internal/ui/tui\t(cached)\nok  \tyolo-runner/internal/vcs/git\t(cached)\n","exit":0,"description":"Runs full Go test suite","truncated":false},"time":{"start":1768850860677,"end":1768850861305}},"metadata":{"openai":{"itemId":"fc_026a2d971b03366501696e85ac2af88191a3fc57389e952bc4"}}}}
{"type":"step_finish","timestamp":1768850861326,"sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","part":{"id":"prt_bd7ba2cf9001T6N4qo8f3wyNX6","sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","messageID":"msg_bd7ba247b001Pf6LtvSYvtvF1X","type":"step-finish","reason":"tool-calls","snapshot":"a25095ebbbca64471e3daff5f0e9f2f4c6c3f5a3","cost":0,"tokens":{"input":1504,"output":29,"reasoning":0,"cache":{"read":29312,"write":0}}}}
{"type":"step_start","timestamp":1768850861848,"sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","part":{"id":"prt_bd7ba2f170018VRRT6DIxDpLjK","sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","messageID":"msg_bd7ba2d2a0015kvNY2B3l9SS1W","type":"step-start","snapshot":"1ab80abb9282d6a7eb299dd0bdbbe24ca0b13690"}}
{"type":"tool_use","timestamp":1768850869186,"sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","part":{"id":"prt_bd7ba49a90017vy3Ar2Gvdjrjh","sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","messageID":"msg_bd7ba2d2a0015kvNY2B3l9SS1W","type":"tool","callID":"call_B5oUlYo0GxF2F3fjG4yUJtNn","tool":"bash","state":{"status":"completed","input":{"command":"git status --short","description":"Shows working tree status"},"output":" M .beads/issues.jsonl\n M bin/yolo-runner\n M cmd/yolo-runner/main.go\n M cmd/yolo-runner/main_test.go\n?? internal/opencode/agent.go\n?? internal/opencode/agent_test.go\n?? runner-logs/opencode/yolo-runner-127.4.10.jsonl\n?? runner-logs/opencode/yolo-runner-127.4.10.stderr.log\n","title":"Shows working tree status","metadata":{"output":" M .beads/issues.jsonl\n M bin/yolo-runner\n M cmd/yolo-runner/main.go\n M cmd/yolo-runner/main_test.go\n?? internal/opencode/agent.go\n?? internal/opencode/agent_test.go\n?? runner-logs/opencode/yolo-runner-127.4.10.jsonl\n?? runner-logs/opencode/yolo-runner-127.4.10.stderr.log\n","exit":0,"description":"Shows working tree status","truncated":false},"time":{"start":1768850869173,"end":1768850869186}},"metadata":{"openai":{"itemId":"fc_03613a9b9093d82601696e85b499848191ad1dfd589c92518f"}}}}
{"type":"tool_use","timestamp":1768850869630,"sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","part":{"id":"prt_bd7ba4bb6001EJFpMd4v25hqBc","sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","messageID":"msg_bd7ba2d2a0015kvNY2B3l9SS1W","type":"tool","callID":"call_0hSWOEWrCG6j42UzL2CMns7I","tool":"bash","state":{"status":"completed","input":{"command":"git diff","description":"Shows unstaged changes"},"output":"diff --git a/.beads/issues.jsonl b/.beads/issues.jsonl\nindex 1423038..84389dd 100644\n--- a/.beads/issues.jsonl\n+++ b/.beads/issues.jsonl\n@@ -12,7 +12,7 @@\n {\"id\":\"yolo-runner-127.3\",\"title\":\"v1.2: Init Command + YOLO Agent Guard\",\"description\":\"Add a runner init command that installs the YOLO agent into the project OpenCode configuration, and make the runner refuse to start if the YOLO agent is missing.\\n\\nDesign:\\n- Project-local (no system-wide install)\\n- init overwrites .opencode/agent/yolo.md to match yolo.md (source of truth)\\n- Runner validates agent presence before doing any work\\n\\nNon-goals:\\n- Managing other agents\\n- Editing user global opencode config\",\"acceptance_criteria\":\"- Given .opencode/agent/yolo.md is missing, when running yolo-runner (non-init), then it exits non-zero with a clear message and does not modify beads/git\\n- Given yolo.md exists, when running yolo-runner init, then it creates or overwrites .opencode/agent/yolo.md to match yolo.md\\n- Given init ran, when running yolo-runner, then it proceeds normally (no agent-not-found)\\n- go test ./... passes\",\"status\":\"closed\",\"priority\":2,\"issue_type\":\"epic\",\"owner\":\"g.evstratov@gmail.com\",\"created_at\":\"2026-01-19T15:19:49.466284+03:00\",\"created_by\":\"Gennady Evstratov\",\"updated_at\":\"2026-01-19T22:11:08.069612+03:00\",\"closed_at\":\"2026-01-19T22:11:08.069612+03:00\",\"close_reason\":\"Flattened: tasks moved under yolo-runner-127.4 for runner compatibility\",\"dependencies\":[{\"issue_id\":\"yolo-runner-127.3\",\"depends_on_id\":\"yolo-runner-127\",\"type\":\"parent-child\",\"created_at\":\"2026-01-19T15:19:49.468097+03:00\",\"created_by\":\"Gennady Evstratov\"},{\"issue_id\":\"yolo-runner-127.3\",\"depends_on_id\":\"yolo-runner-127.1\",\"type\":\"blocks\",\"created_at\":\"2026-01-19T15:19:49.527131+03:00\",\"created_by\":\"Gennady Evstratov\"}]}\n {\"id\":\"yolo-runner-127.4\",\"title\":\"v1.1: Observability (TUI + watchdog + init/guards)\",\"description\":\"Make the runner robust and observable before adding molecule traversal.\\n\\nIncludes:\\n- Bubble Tea TUI progress UI (TTY by default, with --headless)\\n- Watchdog to detect and fail-fast on OpenCode stalls, with evidence\\n- Init/guards to ensure YOLO agent is installed and permissions allow non-interactive runs\\n- Fix default --root behavior (avoid hardcoded algi-8bt)\\n\\nAll implementation must be Go.\",\"acceptance_criteria\":\"- Runner does not hang indefinitely on OpenCode stalls (watchdog)\\n- Runner has clear progress output (TUI on TTY, --headless for logs)\\n- Runner refuses to start if YOLO agent missing; init installs it\\n- Default root is inferred or runner errors clearly\\n- go test ./... passes\",\"status\":\"open\",\"priority\":1,\"issue_type\":\"epic\",\"owner\":\"g.evstratov@gmail.com\",\"created_at\":\"2026-01-19T15:55:27.038426+03:00\",\"created_by\":\"Gennady Evstratov\",\"updated_at\":\"2026-01-19T16:24:16.935052+03:00\",\"dependencies\":[{\"issue_id\":\"yolo-runner-127.4\",\"depends_on_id\":\"yolo-runner-127\",\"type\":\"parent-child\",\"created_at\":\"2026-01-19T15:55:27.039062+03:00\",\"created_by\":\"Gennady Evstratov\"}]}\n {\"id\":\"yolo-runner-127.4.1\",\"title\":\"v1.2: Add Bubble Tea dependency\",\"description\":\"Add Bubble Tea dependencies and minimal wiring.\\n\\nFiles:\\n- Modify: go.mod\\n- Modify: go.sum\\n\\nAcceptance:\\n- go test ./... passes\\n- Bubble Tea module is added and buildable\",\"acceptance_criteria\":\"- go test ./... passes\\n- Bubble Tea module is added and buildable\",\"status\":\"closed\",\"priority\":1,\"issue_type\":\"task\",\"owner\":\"g.evstratov@gmail.com\",\"created_at\":\"2026-01-19T15:55:27.195836+03:00\",\"created_by\":\"Gennady Evstratov\",\"updated_at\":\"2026-01-19T18:59:10.354843+03:00\",\"closed_at\":\"2026-01-19T18:59:10.354843+03:00\",\"close_reason\":\"Closed\",\"dependencies\":[{\"issue_id\":\"yolo-runner-127.4.1\",\"depends_on_id\":\"yolo-runner-127.4\",\"type\":\"parent-child\",\"created_at\":\"2026-01-19T15:55:27.196499+03:00\",\"created_by\":\"Gennady Evstratov\"}]}\n-{\"id\":\"yolo-runner-127.4.10\",\"title\":\"v1.2: Refuse to run if YOLO agent missing\",\"description\":\"Before selecting any beads task, validate the YOLO agent is installed for this repo.\\n\\nFiles:\\n- Modify: cmd/yolo-runner/main.go\\n- Create: internal/opencode/agent.go\\n- Create: internal/opencode/agent_test.go\\n\\nRules:\\n- Go only\\n\\nAcceptance:\\n- If .opencode/agent/yolo.md does not exist, runner exits non-zero and prints a clear message\\n- If agent file exists but does not contain frontmatter key permission: allow, runner exits non-zero and prints guidance to run init\\n- Validation happens before any bd update / git add / opencode run\\n- go test ./... passes\",\"acceptance_criteria\":\"- Missing agent file fails fast with clear message\\n- Missing permission allow fails fast with guidance\\n- Validation runs before any mutations\\n- go test ./... passes\",\"status\":\"open\",\"priority\":1,\"issue_type\":\"task\",\"owner\":\"g.evstratov@gmail.com\",\"created_at\":\"2026-01-19T22:14:35.318898+03:00\",\"created_by\":\"Gennady Evstratov\",\"updated_at\":\"2026-01-19T22:14:35.442922+03:00\",\"dependencies\":[{\"issue_id\":\"yolo-runner-127.4.10\",\"depends_on_id\":\"yolo-runner-127.4\",\"type\":\"parent-child\",\"created_at\":\"2026-01-19T22:14:35.319632+03:00\",\"created_by\":\"Gennady Evstratov\"}]}\n+{\"id\":\"yolo-runner-127.4.10\",\"title\":\"v1.2: Refuse to run if YOLO agent missing\",\"description\":\"Before selecting any beads task, validate the YOLO agent is installed for this repo.\\n\\nFiles:\\n- Modify: cmd/yolo-runner/main.go\\n- Create: internal/opencode/agent.go\\n- Create: internal/opencode/agent_test.go\\n\\nRules:\\n- Go only\\n\\nAcceptance:\\n- If .opencode/agent/yolo.md does not exist, runner exits non-zero and prints a clear message\\n- If agent file exists but does not contain frontmatter key permission: allow, runner exits non-zero and prints guidance to run init\\n- Validation happens before any bd update / git add / opencode run\\n- go test ./... passes\",\"acceptance_criteria\":\"- Missing agent file fails fast with clear message\\n- Missing permission allow fails fast with guidance\\n- Validation runs before any mutations\\n- go test ./... passes\",\"status\":\"in_progress\",\"priority\":1,\"issue_type\":\"task\",\"owner\":\"g.evstratov@gmail.com\",\"created_at\":\"2026-01-19T22:14:35.318898+03:00\",\"created_by\":\"Gennady Evstratov\",\"updated_at\":\"2026-01-19T22:23:42.705995+03:00\",\"dependencies\":[{\"issue_id\":\"yolo-runner-127.4.10\",\"depends_on_id\":\"yolo-runner-127.4\",\"type\":\"parent-child\",\"created_at\":\"2026-01-19T22:14:35.319632+03:00\",\"created_by\":\"Gennady Evstratov\"}]}\n {\"id\":\"yolo-runner-127.4.11\",\"title\":\"v1.2: Add init subcommand to install YOLO agent\",\"description\":\"Add an init command to the Go runner that installs the YOLO agent into the project OpenCode config.\\n\\nCommand:\\n- yolo-runner init\\n\\nBehavior:\\n- Create .opencode/agent/ if needed\\n- Copy yolo.md -\\u003e .opencode/agent/yolo.md\\n- Overwrite existing .opencode/agent/yolo.md to match yolo.md\\n\\nFiles:\\n- Modify: cmd/yolo-runner/main.go\\n- Modify: cmd/yolo-runner/main_test.go\\n- Modify: internal/opencode/agent.go\\n\\nRules:\\n- Go only\\n\\nAcceptance:\\n- Running yolo-runner init creates/overwrites .opencode/agent/yolo.md\\n- After init, yolo-runner run mode no longer errors on missing agent\\n- go test ./... passes\",\"acceptance_criteria\":\"- init creates/overwrites agent file\\n- run mode passes agent validation after init\\n- go test ./... passes\",\"status\":\"open\",\"priority\":1,\"issue_type\":\"task\",\"owner\":\"g.evstratov@gmail.com\",\"created_at\":\"2026-01-19T22:14:35.744001+03:00\",\"created_by\":\"Gennady Evstratov\",\"updated_at\":\"2026-01-19T22:14:35.861089+03:00\",\"dependencies\":[{\"issue_id\":\"yolo-runner-127.4.11\",\"depends_on_id\":\"yolo-runner-127.4\",\"type\":\"parent-child\",\"created_at\":\"2026-01-19T22:14:35.744669+03:00\",\"created_by\":\"Gennady Evstratov\"}]}\n {\"id\":\"yolo-runner-127.4.12\",\"title\":\"v1.2: Document init + agent requirements\",\"description\":\"Document how agent installation works and how to recover when the runner refuses to start.\\n\\nFiles:\\n- Modify: README.md\\n\\nAcceptance:\\n- README documents yolo-runner init\\n- README explains why runner refuses to start if agent missing\\n- README includes troubleshooting steps\\n- go test ./... passes\",\"acceptance_criteria\":\"- README includes init usage and troubleshooting\",\"status\":\"open\",\"priority\":2,\"issue_type\":\"task\",\"owner\":\"g.evstratov@gmail.com\",\"created_at\":\"2026-01-19T22:14:36.163844+03:00\",\"created_by\":\"Gennady Evstratov\",\"updated_at\":\"2026-01-19T22:14:36.283427+03:00\",\"dependencies\":[{\"issue_id\":\"yolo-runner-127.4.12\",\"depends_on_id\":\"yolo-runner-127.4\",\"type\":\"parent-child\",\"created_at\":\"2026-01-19T22:14:36.164313+03:00\",\"created_by\":\"Gennady Evstratov\"}]}\n {\"id\":\"yolo-runner-127.4.2\",\"title\":\"v1.2: TUI model for runner status\",\"description\":\"Implement a Bubble Tea model that renders:\\n- current task (id + title)\\n- current phase/state string\\n- spinner that advances when new output is detected\\n- last-output age seconds\\n\\nFiles:\\n- Create: internal/ui/tui/model.go\\n- Create: internal/ui/tui/model_test.go\\n\\nAcceptance:\\n- Given status updates, view output contains task id/title and phase string\\n- Spinner advances when notified of new output\\n- Tests run without requiring a real TTY\\n- go test ./... passes\",\"acceptance_criteria\":\"- Renders task and phase\\n- Spinner advances on output events\\n- Tests are deterministic and non-TTY\\n- go test ./... passes\",\"status\":\"closed\",\"priority\":1,\"issue_type\":\"task\",\"owner\":\"g.evstratov@gmail.com\",\"created_at\":\"2026-01-19T15:55:27.275855+03:00\",\"created_by\":\"Gennady Evstratov\",\"updated_at\":\"2026-01-19T19:02:37.853373+03:00\",\"closed_at\":\"2026-01-19T19:02:37.853373+03:00\",\"close_reason\":\"Closed\",\"dependencies\":[{\"issue_id\":\"yolo-runner-127.4.2\",\"depends_on_id\":\"yolo-runner-127.4\",\"type\":\"parent-child\",\"created_at\":\"2026-01-19T15:55:27.276643+03:00\",\"created_by\":\"Gennady Evstratov\"}]}\ndiff --git a/bin/yolo-runner b/bin/yolo-runner\nindex 79264ef..1da1ecb 100755\nBinary files a/bin/yolo-runner and b/bin/yolo-runner differ\ndiff --git a/cmd/yolo-runner/main.go b/cmd/yolo-runner/main.go\nindex 3cf1512..befdb9f 100644\n--- a/cmd/yolo-runner/main.go\n+++ b/cmd/yolo-runner/main.go\n@@ -137,6 +137,14 @@ func RunOnceMain(args []string, runOnce runOnceFunc, exit exitFunc, stdout io.Wr\n \t\trunOnce = runner.RunOnce\n \t}\n \n+\tif err := opencode.ValidateAgent(*repoRoot); err != nil {\n+\t\tfmt.Fprintln(stderr, err)\n+\t\tif exit != nil {\n+\t\t\texit(1)\n+\t\t}\n+\t\treturn 1\n+\t}\n+\n \tif beadsRunner == nil {\n \t\tbeadsRunner = adapterRunner{}\n \t}\ndiff --git a/cmd/yolo-runner/main_test.go b/cmd/yolo-runner/main_test.go\nindex 2d02644..0252b1e 100644\n--- a/cmd/yolo-runner/main_test.go\n+++ b/cmd/yolo-runner/main_test.go\n@@ -97,11 +97,13 @@ func (f *fakeRunOnce) Run(opts runner.RunOnceOptions, deps runner.RunOnceDeps) (\n }\n \n func TestRunOnceMainReturnsErrorCodeOnFailure(t *testing.T) {\n+\ttempDir := t.TempDir()\n+\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n \trunner := &fakeRunOnce{err: errors.New(\"boom\")}\n \texit := &fakeExit{}\n \tout := &bytes.Buffer{}\n \n-\tcode := RunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\"}, runner.Run, exit.Exit, out, out, nil, nil)\n+\tcode := RunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\"}, runner.Run, exit.Exit, out, out, nil, nil)\n \n \tif code != 1 {\n \t\tt.Fatalf(\"expected exit code 1, got %d\", code)\n@@ -115,18 +117,20 @@ func TestRunOnceMainReturnsErrorCodeOnFailure(t *testing.T) {\n }\n \n func TestRunOnceMainWiresDependencies(t *testing.T) {\n+\ttempDir := t.TempDir()\n+\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n \trunner := &fakeRunOnce{result: \"no_tasks\"}\n \texit := &fakeExit{}\n \tout := &bytes.Buffer{}\n \tbeadsRunner := &fakeRunner{}\n \tgitRunner := &fakeGitRunner{}\n \n-\tRunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\", \"--model\", \"model\", \"--dry-run\"}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n+\tRunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\", \"--model\", \"model\", \"--dry-run\"}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n \n \tif !runner.called {\n \t\tt.Fatalf(\"expected run once to be called\")\n \t}\n-\tif runner.opts.RepoRoot != \"/repo\" || runner.opts.RootID != \"root\" || runner.opts.Model != \"model\" || !runner.opts.DryRun {\n+\tif runner.opts.RepoRoot != tempDir || runner.opts.RootID != \"root\" || runner.opts.Model != \"model\" || !runner.opts.DryRun {\n \t\tt.Fatalf(\"unexpected options: %#v\", runner.opts)\n \t}\n \tif runner.opts.Out == nil {\n@@ -141,6 +145,8 @@ func TestRunOnceMainWiresDependencies(t *testing.T) {\n }\n \n func TestRunOnceMainDefaultsConfigPaths(t *testing.T) {\n+\ttempDir := t.TempDir()\n+\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n \trunner := &fakeRunOnce{result: \"no_tasks\"}\n \texit := &fakeExit{}\n \tout := &bytes.Buffer{}\n@@ -148,8 +154,9 @@ func TestRunOnceMainDefaultsConfigPaths(t *testing.T) {\n \tgitRunner := &fakeGitRunner{}\n \n \tt.Setenv(\"HOME\", \"/home/user\")\n+\tt.Setenv(\"XDG_CONFIG_HOME\", \"\")\n \n-\tRunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\"}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n+\tRunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\"}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n \n \tif !runner.called {\n \t\tt.Fatalf(\"expected run once to be called\")\n@@ -173,9 +180,64 @@ func TestRunOnceMainDefaultsConfigPaths(t *testing.T) {\n \t}\n }\n \n+func TestRunOnceMainFailsWhenYoloAgentMissing(t *testing.T) {\n+\ttempDir := t.TempDir()\n+\trunner := &fakeRunOnce{result: \"no_tasks\"}\n+\texit := &fakeExit{}\n+\tstdout := &bytes.Buffer{}\n+\tstderr := &bytes.Buffer{}\n+\tbeadsRunner := &fakeRunner{}\n+\tgitRunner := &fakeGitRunner{}\n+\n+\tcode := RunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\"}, runner.Run, exit.Exit, stdout, stderr, beadsRunner, gitRunner)\n+\n+\tif code != 1 {\n+\t\tt.Fatalf(\"expected exit code 1, got %d\", code)\n+\t}\n+\tif exit.code != 1 {\n+\t\tt.Fatalf(\"expected exit to be called with 1, got %d\", exit.code)\n+\t}\n+\tif runner.called {\n+\t\tt.Fatalf(\"expected run once not to be called\")\n+\t}\n+\tif !strings.Contains(stderr.String(), \"yolo.md\") {\n+\t\tt.Fatalf(\"expected error to mention yolo.md, got %q\", stderr.String())\n+\t}\n+}\n+\n+func TestRunOnceMainFailsWhenYoloAgentMissingPermission(t *testing.T) {\n+\ttempDir := t.TempDir()\n+\twriteAgentFile(t, tempDir, \"---\\nname: yolo\\n---\\n\")\n+\trunner := &fakeRunOnce{result: \"no_tasks\"}\n+\texit := &fakeExit{}\n+\tstdout := &bytes.Buffer{}\n+\tstderr := &bytes.Buffer{}\n+\tbeadsRunner := &fakeRunner{}\n+\tgitRunner := &fakeGitRunner{}\n+\n+\tcode := RunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\"}, runner.Run, exit.Exit, stdout, stderr, beadsRunner, gitRunner)\n+\n+\tif code != 1 {\n+\t\tt.Fatalf(\"expected exit code 1, got %d\", code)\n+\t}\n+\tif exit.code != 1 {\n+\t\tt.Fatalf(\"expected exit to be called with 1, got %d\", exit.code)\n+\t}\n+\tif runner.called {\n+\t\tt.Fatalf(\"expected run once not to be called\")\n+\t}\n+\tif !strings.Contains(stderr.String(), \"permission: allow\") {\n+\t\tt.Fatalf(\"expected error to mention permission allow, got %q\", stderr.String())\n+\t}\n+\tif !strings.Contains(strings.ToLower(stderr.String()), \"init\") {\n+\t\tt.Fatalf(\"expected guidance to run init, got %q\", stderr.String())\n+\t}\n+}\n+\n func TestRunOnceMainInfersRoadmapRootWhenMissing(t *testing.T) {\n \ttempDir := t.TempDir()\n \twriteIssuesFile(t, tempDir, `{\"id\":\"roadmap-1\",\"title\":\"Roadmap\",\"issue_type\":\"epic\",\"status\":\"open\"}`)\n+\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n \trunner := &fakeRunOnce{result: \"no_tasks\"}\n \texit := &fakeExit{}\n \tout := &bytes.Buffer{}\n@@ -198,6 +260,7 @@ func TestRunOnceMainInfersRoadmapRootWhenMissing(t *testing.T) {\n func TestRunOnceMainInfersRoadmapRootWhenInProgress(t *testing.T) {\n \ttempDir := t.TempDir()\n \twriteIssuesFile(t, tempDir, `{\"id\":\"roadmap-2\",\"title\":\"Roadmap\",\"issue_type\":\"epic\",\"status\":\"in_progress\"}`)\n+\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n \trunner := &fakeRunOnce{result: \"no_tasks\"}\n \texit := &fakeExit{}\n \tout := &bytes.Buffer{}\n@@ -220,6 +283,7 @@ func TestRunOnceMainInfersRoadmapRootWhenInProgress(t *testing.T) {\n func TestRunOnceMainMissingRootRequiresExplicitFlag(t *testing.T) {\n \ttempDir := t.TempDir()\n \twriteIssuesFile(t, tempDir, `{\"id\":\"epic-1\",\"title\":\"Other\",\"issue_type\":\"epic\",\"status\":\"open\"}`)\n+\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n \trunner := &fakeRunOnce{result: \"no_tasks\"}\n \texit := &fakeExit{}\n \tstdout := &bytes.Buffer{}\n@@ -295,6 +359,18 @@ func writeIssuesFile(t *testing.T, repoRoot string, payload string) {\n \t}\n }\n \n+func writeAgentFile(t *testing.T, repoRoot string, payload string) {\n+\tt.Helper()\n+\tagentDir := filepath.Join(repoRoot, \".opencode\", \"agent\")\n+\tif err := os.MkdirAll(agentDir, 0o755); err != nil {\n+\t\tt.Fatalf(\"mkdir agent dir: %v\", err)\n+\t}\n+\tagentPath := filepath.Join(agentDir, \"yolo.md\")\n+\tif err := os.WriteFile(agentPath, []byte(payload), 0o644); err != nil {\n+\t\tt.Fatalf(\"write agent file: %v\", err)\n+\t}\n+}\n+\n func TestRunOnceMainUsesTUIOnTTYByDefault(t *testing.T) {\n \tfakeProgram := newFakeTUIProgram()\n \tprevIsTerminal := isTerminal\n@@ -306,13 +382,15 @@ func TestRunOnceMainUsesTUIOnTTYByDefault(t *testing.T) {\n \t\tnewTUIProgram = prevNewTUIProgram\n \t})\n \n+\ttempDir := t.TempDir()\n+\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n \trunOnce := &fakeRunOnce{result: \"no_tasks\"}\n \texit := &fakeExit{}\n \tout := &bytes.Buffer{}\n \tbeadsRunner := &fakeRunner{}\n \tgitRunner := &fakeGitRunner{}\n \n-\tcode := RunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\"}, runOnce.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n+\tcode := RunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\"}, runOnce.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n \n \tif code != 0 {\n \t\tt.Fatalf(\"expected exit code 0, got %d\", code)\n@@ -345,6 +423,8 @@ func TestRunOnceMainHeadlessDisablesTUI(t *testing.T) {\n \t\tnewTUIProgram = prevNewTUIProgram\n \t})\n \n+\ttempDir := t.TempDir()\n+\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n \trunOnce := &fakeRunOnce{result: \"no_tasks\"}\n \texit := &fakeExit{}\n \tout := &bytes.Buffer{}\n@@ -352,7 +432,7 @@ func TestRunOnceMainHeadlessDisablesTUI(t *testing.T) {\n \tgitRunner := &fakeGitRunner{}\n \tstderr := &bytes.Buffer{}\n \n-\tRunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\", \"--headless\"}, runOnce.Run, exit.Exit, out, stderr, beadsRunner, gitRunner)\n+\tRunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\", \"--headless\"}, runOnce.Run, exit.Exit, out, stderr, beadsRunner, gitRunner)\n \n \tif called {\n \t\tt.Fatalf(\"expected TUI program not to start\")\n","title":"Shows unstaged changes","metadata":{"output":"diff --git a/.beads/issues.jsonl b/.beads/issues.jsonl\nindex 1423038..84389dd 100644\n--- a/.beads/issues.jsonl\n+++ b/.beads/issues.jsonl\n@@ -12,7 +12,7 @@\n {\"id\":\"yolo-runner-127.3\",\"title\":\"v1.2: Init Command + YOLO Agent Guard\",\"description\":\"Add a runner init command that installs the YOLO agent into the project OpenCode configuration, and make the runner refuse to start if the YOLO agent is missing.\\n\\nDesign:\\n- Project-local (no system-wide install)\\n- init overwrites .opencode/agent/yolo.md to match yolo.md (source of truth)\\n- Runner validates agent presence before doing any work\\n\\nNon-goals:\\n- Managing other agents\\n- Editing user global opencode config\",\"acceptance_criteria\":\"- Given .opencode/agent/yolo.md is missing, when running yolo-runner (non-init), then it exits non-zero with a clear message and does not modify beads/git\\n- Given yolo.md exists, when running yolo-runner init, then it creates or overwrites .opencode/agent/yolo.md to match yolo.md\\n- Given init ran, when running yolo-runner, then it proceeds normally (no agent-not-found)\\n- go test ./... passes\",\"status\":\"closed\",\"priority\":2,\"issue_type\":\"epic\",\"owner\":\"g.evstratov@gmail.com\",\"created_at\":\"2026-01-19T15:19:49.466284+03:00\",\"created_by\":\"Gennady Evstratov\",\"updated_at\":\"2026-01-19T22:11:08.069612+03:00\",\"closed_at\":\"2026-01-19T22:11:08.069612+03:00\",\"close_reason\":\"Flattened: tasks moved under yolo-runner-127.4 for runner compatibility\",\"dependencies\":[{\"issue_id\":\"yolo-runner-127.3\",\"depends_on_id\":\"yolo-runner-127\",\"type\":\"parent-child\",\"created_at\":\"2026-01-19T15:19:49.468097+03:00\",\"created_by\":\"Gennady Evstratov\"},{\"issue_id\":\"yolo-runner-127.3\",\"depends_on_id\":\"yolo-runner-127.1\",\"type\":\"blocks\",\"created_at\":\"2026-01-19T15:19:49.527131+03:00\",\"created_by\":\"Gennady Evstratov\"}]}\n {\"id\":\"yolo-runner-127.4\",\"title\":\"v1.1: Observability (TUI + watchdog + init/guards)\",\"description\":\"Make the runner robust and observable before adding molecule traversal.\\n\\nIncludes:\\n- Bubble Tea TUI progress UI (TTY by default, with --headless)\\n- Watchdog to detect and fail-fast on OpenCode stalls, with evidence\\n- Init/guards to ensure YOLO agent is installed and permissions allow non-interactive runs\\n- Fix default --root behavior (avoid hardcoded algi-8bt)\\n\\nAll implementation must be Go.\",\"acceptance_criteria\":\"- Runner does not hang indefinitely on OpenCode stalls (watchdog)\\n- Runner has clear progress output (TUI on TTY, --headless for logs)\\n- Runner refuses to start if YOLO agent missing; init installs it\\n- Default root is inferred or runner errors clearly\\n- go test ./... passes\",\"status\":\"open\",\"priority\":1,\"issue_type\":\"epic\",\"owner\":\"g.evstratov@gmail.com\",\"created_at\":\"2026-01-19T15:55:27.038426+03:00\",\"created_by\":\"Gennady Evstratov\",\"updated_at\":\"2026-01-19T16:24:16.935052+03:00\",\"dependencies\":[{\"issue_id\":\"yolo-runner-127.4\",\"depends_on_id\":\"yolo-runner-127\",\"type\":\"parent-child\",\"created_at\":\"2026-01-19T15:55:27.039062+03:00\",\"created_by\":\"Gennady Evstratov\"}]}\n {\"id\":\"yolo-runner-127.4.1\",\"title\":\"v1.2: Add Bubble Tea dependency\",\"description\":\"Add Bubble Tea dependencies and minimal wiring.\\n\\nFiles:\\n- Modify: go.mod\\n- Modify: go.sum\\n\\nAcceptance:\\n- go test ./... passes\\n- Bubble Tea module is added and buildable\",\"acceptance_criteria\":\"- go test ./... passes\\n- Bubble Tea module is added and buildable\",\"status\":\"closed\",\"priority\":1,\"issue_type\":\"task\",\"owner\":\"g.evstratov@gmail.com\",\"created_at\":\"2026-01-19T15:55:27.195836+03:00\",\"created_by\":\"Gennady Evstratov\",\"updated_at\":\"2026-01-19T18:59:10.354843+03:00\",\"closed_at\":\"2026-01-19T18:59:10.354843+03:00\",\"close_reason\":\"Closed\",\"dependencies\":[{\"issue_id\":\"yolo-runner-127.4.1\",\"depends_on_id\":\"yolo-runner-127.4\",\"type\":\"parent-child\",\"created_at\":\"2026-01-19T15:55:27.196499+03:00\",\"created_by\":\"Gennady Evstratov\"}]}\n-{\"id\":\"yolo-runner-127.4.10\",\"title\":\"v1.2: Refuse to run if YOLO agent missing\",\"description\":\"Before selecting any beads task, validate the YOLO agent is installed for this repo.\\n\\nFiles:\\n- Modify: cmd/yolo-runner/main.go\\n- Create: internal/opencode/agent.go\\n- Create: internal/opencode/agent_test.go\\n\\nRules:\\n- Go only\\n\\nAcceptance:\\n- If .opencode/agent/yolo.md does not exist, runner exits non-zero and prints a clear message\\n- If agent file exists but does not contain frontmatter key permission: allow, runner exits non-zero and prints guidance to run init\\n- Validation happens before any bd update / git add / opencode run\\n- go test ./... passes\",\"acceptance_criteria\":\"- Missing agent file fails fast with clear message\\n- Missing permission allow fails fast with guidance\\n- Validation runs before any mutations\\n- go test ./... passes\",\"status\":\"open\",\"priority\":1,\"issue_type\":\"task\",\"owner\":\"g.evstratov@gmail.com\",\"created_at\":\"2026-01-19T22:14:35.318898+03:00\",\"created_by\":\"Gennady Evstratov\",\"updated_at\":\"2026-01-19T22:14:35.442922+03:00\",\"dependencies\":[{\"issue_id\":\"yolo-runner-127.4.10\",\"depends_on_id\":\"yolo-runner-127.4\",\"type\":\"parent-child\",\"created_at\":\"2026-01-19T22:14:35.319632+03:00\",\"created_by\":\"Gennady Evstratov\"}]}\n+{\"id\":\"yolo-runner-127.4.10\",\"title\":\"v1.2: Refuse to run if YOLO agent missing\",\"description\":\"Before selecting any beads task, validate the YOLO agent is installed for this repo.\\n\\nFiles:\\n- Modify: cmd/yolo-runner/main.go\\n- Create: internal/opencode/agent.go\\n- Create: internal/opencode/agent_test.go\\n\\nRules:\\n- Go only\\n\\nAcceptance:\\n- If .opencode/agent/yolo.md does not exist, runner exits non-zero and prints a clear message\\n- If agent file exists but does not contain frontmatter key permission: allow, runner exits non-zero and prints guidance to run init\\n- Validation happens before any bd update / git add / opencode run\\n- go test ./... passes\",\"acceptance_criteria\":\"- Missing agent file fails fast with clear message\\n- Missing permission allow fails fast with guidance\\n- Validation runs before any mutations\\n- go test ./... passes\",\"status\":\"in_progress\",\"priority\":1,\"issue_type\":\"task\",\"owner\":\"g.evstratov@gmail.com\",\"created_at\":\"2026-01-19T22:14:35.318898+03:00\",\"created_by\":\"Gennady Evstratov\",\"updated_at\":\"2026-01-19T22:23:42.705995+03:00\",\"dependencies\":[{\"issue_id\":\"yolo-runner-127.4.10\",\"depends_on_id\":\"yolo-runner-127.4\",\"type\":\"parent-child\",\"created_at\":\"2026-01-19T22:14:35.319632+03:00\",\"created_by\":\"Gennady Evstratov\"}]}\n {\"id\":\"yolo-runner-127.4.11\",\"title\":\"v1.2: Add init subcommand to install YOLO agent\",\"description\":\"Add an init command to the Go runner that installs the YOLO agent into the project OpenCode config.\\n\\nCommand:\\n- yolo-runner init\\n\\nBehavior:\\n- Create .opencode/agent/ if needed\\n- Copy yolo.md -\\u003e .opencode/agent/yolo.md\\n- Overwrite existing .opencode/agent/yolo.md to match yolo.md\\n\\nFiles:\\n- Modify: cmd/yolo-runner/main.go\\n- Modify: cmd/yolo-runner/main_test.go\\n- Modify: internal/opencode/agent.go\\n\\nRules:\\n- Go only\\n\\nAcceptance:\\n- Running yolo-runner init creates/overwrites .opencode/agent/yolo.md\\n- After init, yolo-runner run mode no longer errors on missing agent\\n- go test ./... passes\",\"acceptance_criteria\":\"- init creates/overwrites agent file\\n- run mode passes agent validation after init\\n- go test ./... passes\",\"status\":\"open\",\"priority\":1,\"issue_type\":\"task\",\"owner\":\"g.evstratov@gmail.com\",\"created_at\":\"2026-01-19T22:14:35.744001+03:00\",\"created_by\":\"Gennady Evstratov\",\"updated_at\":\"2026-01-19T22:14:35.861089+03:00\",\"dependencies\":[{\"issue_id\":\"yolo-runner-127.4.11\",\"depends_on_id\":\"yolo-runner-127.4\",\"type\":\"parent-child\",\"created_at\":\"2026-01-19T22:14:35.744669+03:00\",\"created_by\":\"Gennady Evstratov\"}]}\n {\"id\":\"yolo-runner-127.4.12\",\"title\":\"v1.2: Document init + agent requirements\",\"description\":\"Document how agent installation works and how to recover when the runner refuses to start.\\n\\nFiles:\\n- Modify: README.md\\n\\nAcceptance:\\n- README documents yolo-runner init\\n- README explains why runner refuses to start if agent missing\\n- README includes troubleshooting steps\\n- go test ./... passes\",\"acceptance_criteria\":\"- README includes init usage and troubleshooting\",\"status\":\"open\",\"priority\":2,\"issue_type\":\"task\",\"owner\":\"g.evstratov@gmail.com\",\"created_at\":\"2026-01-19T22:14:36.163844+03:00\",\"created_by\":\"Gennady Evstratov\",\"updated_at\":\"2026-01-19T22:14:36.283427+03:00\",\"dependencies\":[{\"issue_id\":\"yolo-runner-127.4.12\",\"depends_on_id\":\"yolo-runner-127.4\",\"type\":\"parent-child\",\"created_at\":\"2026-01-19T22:14:36.164313+03:00\",\"created_by\":\"Gennady Evstratov\"}]}\n {\"id\":\"yolo-runner-127.4.2\",\"title\":\"v1.2: TUI model for runner status\",\"description\":\"Implement a Bubble Tea model that renders:\\n- current task (id + title)\\n- current phase/state string\\n- spinner that advances when new output is detected\\n- last-output age seconds\\n\\nFiles:\\n- Create: internal/ui/tui/model.go\\n- Create: internal/ui/tui/model_test.go\\n\\nAcceptance:\\n- Given status updates, view output contains task id/title and phase string\\n- Spinner advances when notified of new output\\n- Tests run without requiring a real TTY\\n- go test ./... passes\",\"acceptance_criteria\":\"- Renders task and phase\\n- Spinner advances on output events\\n- Tests are deterministic and non-TTY\\n- go test ./... passes\",\"status\":\"closed\",\"priority\":1,\"issue_type\":\"task\",\"owner\":\"g.evstratov@gmail.com\",\"created_at\":\"2026-01-19T15:55:27.275855+03:00\",\"created_by\":\"Gennady Evstratov\",\"updated_at\":\"2026-01-19T19:02:37.853373+03:00\",\"closed_at\":\"2026-01-19T19:02:37.853373+03:00\",\"close_reason\":\"Closed\",\"dependencies\":[{\"issue_id\":\"yolo-runner-127.4.2\",\"depends_on_id\":\"yolo-runner-127.4\",\"type\":\"parent-child\",\"created_at\":\"2026-01-19T15:55:27.276643+03:00\",\"created_by\":\"Gennady Evstratov\"}]}\ndiff --git a/bin/yolo-runner b/bin/yolo-runner\nindex 79264ef..1da1ecb 100755\nBinary files a/bin/yolo-runner and b/bin/yolo-runner differ\ndiff --git a/cmd/yolo-runner/main.go b/cmd/yolo-runner/main.go\nindex 3cf1512..befdb9f 100644\n--- a/cmd/yolo-runner/main.go\n+++ b/cmd/yolo-runner/main.go\n@@ -137,6 +137,14 @@ func RunOnceMain(args []string, runOnce runOnceFunc, exit exitFunc, stdout io.Wr\n \t\trunOnce = runner.RunOnce\n \t}\n \n+\tif err := opencode.ValidateAgent(*repoRoot); err != nil {\n+\t\tfmt.Fprintln(stderr, err)\n+\t\tif exit != nil {\n+\t\t\texit(1)\n+\t\t}\n+\t\treturn 1\n+\t}\n+\n \tif beadsRunner == nil {\n \t\tbeadsRunner = adapterRunner{}\n \t}\ndiff --git a/cmd/yolo-runner/main_test.go b/cmd/yolo-runner/main_test.go\nindex 2d02644..0252b1e 100644\n--- a/cmd/yolo-runner/main_test.go\n+++ b/cmd/yolo-runner/main_test.go\n@@ -97,11 +97,13 @@ func (f *fakeRunOnce) Run(opts runner.RunOnceOptions, deps runner.RunOnceDeps) (\n }\n \n func TestRunOnceMainReturnsErrorCodeOnFailure(t *testing.T) {\n+\ttempDir := t.TempDir()\n+\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n \trunner := &fakeRunOnce{err: errors.New(\"boom\")}\n \texit := &fakeExit{}\n \tout := &bytes.Buffer{}\n \n-\tcode := RunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\"}, runner.Run, exit.Exit, out, out, nil, nil)\n+\tcode := RunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\"}, runner.Run, exit.Exit, out, out, nil, nil)\n \n \tif code != 1 {\n \t\tt.Fatalf(\"expected exit code 1, got %d\", code)\n@@ -115,18 +117,20 @@ func TestRunOnceMainReturnsErrorCodeOnFailure(t *testing.T) {\n }\n \n func TestRunOnceMainWiresDependencies(t *testing.T) {\n+\ttempDir := t.TempDir()\n+\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n \trunner := &fakeRunOnce{result: \"no_tasks\"}\n \texit := &fakeExit{}\n \tout := &bytes.Buffer{}\n \tbeadsRunner := &fakeRunner{}\n \tgitRunner := &fakeGitRunner{}\n \n-\tRunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\", \"--model\", \"model\", \"--dry-run\"}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n+\tRunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\", \"--model\", \"model\", \"--dry-run\"}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n \n \tif !runner.called {\n \t\tt.Fatalf(\"expected run once to be called\")\n \t}\n-\tif runner.opts.RepoRoot != \"/repo\" || runner.opts.RootID != \"root\" || runner.opts.Model != \"model\" || !runner.opts.DryRun {\n+\tif runner.opts.RepoRoot != tempDir || runner.opts.RootID != \"root\" || runner.opts.Model != \"model\" || !runner.opts.DryRun {\n \t\tt.Fatalf(\"unexpected options: %#v\", runner.opts)\n \t}\n \tif runner.opts.Out == nil {\n@@ -141,6 +145,8 @@ func TestRunOnceMainWiresDependencies(t *testing.T) {\n }\n \n func TestRunOnceMainDefaultsConfigPaths(t *testing.T) {\n+\ttempDir := t.TempDir()\n+\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n \trunner := &fakeRunOnce{result: \"no_tasks\"}\n \texit := &fakeExit{}\n \tout := &bytes.Buffer{}\n@@ -148,8 +154,9 @@ func TestRunOnceMainDefaultsConfigPaths(t *testing.T) {\n \tgitRunner := &fakeGitRunner{}\n \n \tt.Setenv(\"HOME\", \"/home/user\")\n+\tt.Setenv(\"XDG_CONFIG_HOME\", \"\")\n \n-\tRunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\"}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n+\tRunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\"}, runner.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n \n \tif !runner.called {\n \t\tt.Fatalf(\"expected run once to be called\")\n@@ -173,9 +180,64 @@ func TestRunOnceMainDefaultsConfigPaths(t *testing.T) {\n \t}\n }\n \n+func TestRunOnceMainFailsWhenYoloAgentMissing(t *testing.T) {\n+\ttempDir := t.TempDir()\n+\trunner := &fakeRunOnce{result: \"no_tasks\"}\n+\texit := &fakeExit{}\n+\tstdout := &bytes.Buffer{}\n+\tstderr := &bytes.Buffer{}\n+\tbeadsRunner := &fakeRunner{}\n+\tgitRunner := &fakeGitRunner{}\n+\n+\tcode := RunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\"}, runner.Run, exit.Exit, stdout, stderr, beadsRunner, gitRunner)\n+\n+\tif code != 1 {\n+\t\tt.Fatalf(\"expected exit code 1, got %d\", code)\n+\t}\n+\tif exit.code != 1 {\n+\t\tt.Fatalf(\"expected exit to be called with 1, got %d\", exit.code)\n+\t}\n+\tif runner.called {\n+\t\tt.Fatalf(\"expected run once not to be called\")\n+\t}\n+\tif !strings.Contains(stderr.String(), \"yolo.md\") {\n+\t\tt.Fatalf(\"expected error to mention yolo.md, got %q\", stderr.String())\n+\t}\n+}\n+\n+func TestRunOnceMainFailsWhenYoloAgentMissingPermission(t *testing.T) {\n+\ttempDir := t.TempDir()\n+\twriteAgentFile(t, tempDir, \"---\\nname: yolo\\n---\\n\")\n+\trunner := &fakeRunOnce{result: \"no_tasks\"}\n+\texit := &fakeExit{}\n+\tstdout := &bytes.Buffer{}\n+\tstderr := &bytes.Buffer{}\n+\tbeadsRunner := &fakeRunner{}\n+\tgitRunner := &fakeGitRunner{}\n+\n+\tcode := RunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\"}, runner.Run, exit.Exit, stdout, stderr, beadsRunner, gitRunner)\n+\n+\tif code != 1 {\n+\t\tt.Fatalf(\"expected exit code 1, got %d\", code)\n+\t}\n+\tif exit.code != 1 {\n+\t\tt.Fatalf(\"expected exit to be called with 1, got %d\", exit.code)\n+\t}\n+\tif runner.called {\n+\t\tt.Fatalf(\"expected run once not to be called\")\n+\t}\n+\tif !strings.Contains(stderr.String(), \"permission: allow\") {\n+\t\tt.Fatalf(\"expected error to mention permission allow, got %q\", stderr.String())\n+\t}\n+\tif !strings.Contains(strings.ToLower(stderr.String()), \"init\") {\n+\t\tt.Fatalf(\"expected guidance to run init, got %q\", stderr.String())\n+\t}\n+}\n+\n func TestRunOnceMainInfersRoadmapRootWhenMissing(t *testing.T) {\n \ttempDir := t.TempDir()\n \twriteIssuesFile(t, tempDir, `{\"id\":\"roadmap-1\",\"title\":\"Roadmap\",\"issue_type\":\"epic\",\"status\":\"open\"}`)\n+\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n \trunner := &fakeRunOnce{result: \"no_tasks\"}\n \texit := &fakeExit{}\n \tout := &bytes.Buffer{}\n@@ -198,6 +260,7 @@ func TestRunOnceMainInfersRoadmapRootWhenMissing(t *testing.T) {\n func TestRunOnceMainInfersRoadmapRootWhenInProgress(t *testing.T) {\n \ttempDir := t.TempDir()\n \twriteIssuesFile(t, tempDir, `{\"id\":\"roadmap-2\",\"title\":\"Roadmap\",\"issue_type\":\"epic\",\"status\":\"in_progress\"}`)\n+\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n \trunner := &fakeRunOnce{result: \"no_tasks\"}\n \texit := &fakeExit{}\n \tout := &bytes.Buffer{}\n@@ -220,6 +283,7 @@ func TestRunOnceMainInfersRoadmapRootWhenInProgress(t *testing.T) {\n func TestRunOnceMainMissingRootRequiresExplicitFlag(t *testing.T) {\n \ttempDir := t.TempDir()\n \twriteIssuesFile(t, tempDir, `{\"id\":\"epic-1\",\"title\":\"Other\",\"issue_type\":\"epic\",\"status\":\"open\"}`)\n+\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n \trunner := &fakeRunOnce{result: \"no_tasks\"}\n \texit := &fakeExit{}\n \tstdout := &bytes.Buffer{}\n@@ -295,6 +359,18 @@ func writeIssuesFile(t *testing.T, repoRoot string, payload string) {\n \t}\n }\n \n+func writeAgentFile(t *testing.T, repoRoot string, payload string) {\n+\tt.Helper()\n+\tagentDir := filepath.Join(repoRoot, \".opencode\", \"agent\")\n+\tif err := os.MkdirAll(agentDir, 0o755); err != nil {\n+\t\tt.Fatalf(\"mkdir agent dir: %v\", err)\n+\t}\n+\tagentPath := filepath.Join(agentDir, \"yolo.md\")\n+\tif err := os.WriteFile(agentPath, []byte(payload), 0o644); err != nil {\n+\t\tt.Fatalf(\"write agent file: %v\", err)\n+\t}\n+}\n+\n func TestRunOnceMainUsesTUIOnTTYByDefault(t *testing.T) {\n \tfakeProgram := newFakeTUIProgram()\n \tprevIsTerminal := isTerminal\n@@ -306,13 +382,15 @@ func TestRunOnceMainUsesTUIOnTTYByDefault(t *testing.T) {\n \t\tnewTUIProgram = prevNewTUIProgram\n \t})\n \n+\ttempDir := t.TempDir()\n+\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n \trunOnce := &fakeRunOnce{result: \"no_tasks\"}\n \texit := &fakeExit{}\n \tout := &bytes.Buffer{}\n \tbeadsRunner := &fakeRunner{}\n \tgitRunner := &fakeGitRunner{}\n \n-\tcode := RunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\"}, runOnce.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n+\tcode := RunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\"}, runOnce.Run, exit.Exit, out, out, beadsRunner, gitRunner)\n \n \tif code != 0 {\n \t\tt.Fatalf(\"expected exit code 0, got %d\", code)\n@@ -345,6 +423,8 @@ func TestRunOnceMainHeadlessDisablesTUI(t *testing.T) {\n \t\tnewTUIProgram = prevNewTUIProgram\n \t})\n \n+\ttempDir := t.TempDir()\n+\twriteAgentFile(t, tempDir, \"---\\npermission: allow\\n---\\n\")\n \trunOnce := &fakeRunOnce{result: \"no_tasks\"}\n \texit := &fakeExit{}\n \tout := &bytes.Buffer{}\n@@ -352,7 +432,7 @@ func TestRunOnceMainHeadlessDisablesTUI(t *testing.T) {\n \tgitRunner := &fakeGitRunner{}\n \tstderr := &bytes.Buffer{}\n \n-\tRunOnceMain([]string{\"--repo\", \"/repo\", \"--root\", \"root\", \"--headless\"}, runOnce.Run, exit.Exit, out, stderr, beadsRunner, gitRunner)\n+\tRunOnceMain([]string{\"--repo\", tempDir, \"--root\", \"root\", \"--headless\"}, runOnce.Run, exit.Exit, out, stderr, beadsRunner, gitRunner)\n \n \tif called {\n \t\tt.Fatalf(\"expected TUI program not to start\")\n","exit":0,"description":"Shows unstaged changes","truncated":false},"time":{"start":1768850869598,"end":1768850869629}},"metadata":{"openai":{"itemId":"fc_03613a9b9093d82601696e85b5266481918434c40b9f8692be"}}}}
{"type":"tool_use","timestamp":1768850870258,"sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","part":{"id":"prt_bd7ba4d5f001WayGQSssQPV4Ne","sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","messageID":"msg_bd7ba2d2a0015kvNY2B3l9SS1W","type":"tool","callID":"call_2lkvewFgDnQxTx2Xn5EakNdl","tool":"bash","state":{"status":"completed","input":{"command":"git log -5 --oneline","description":"Shows recent commit messages"},"output":"efb9689 bd sync: 2026-01-19 22:14:50\ne232b17 bd sync: 2026-01-19 22:14:36\nacd3b7e bd sync: 2026-01-19 22:11:08\ne3dcc0a bd sync: 2026-01-19 22:10:54\ne46fd3e bd sync: 2026-01-19 21:12:10\n","title":"Shows recent commit messages","metadata":{"output":"efb9689 bd sync: 2026-01-19 22:14:50\ne232b17 bd sync: 2026-01-19 22:14:36\nacd3b7e bd sync: 2026-01-19 22:11:08\ne3dcc0a bd sync: 2026-01-19 22:10:54\ne46fd3e bd sync: 2026-01-19 21:12:10\n","exit":0,"description":"Shows recent commit messages","truncated":false},"time":{"start":1768850870247,"end":1768850870258}},"metadata":{"openai":{"itemId":"fc_03613a9b9093d82601696e85b594ec8191b5ffb4ab64bf7a54"}}}}
{"type":"step_finish","timestamp":1768850870375,"sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","part":{"id":"prt_bd7ba5053001MiLu63DFgo7gX4","sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","messageID":"msg_bd7ba2d2a0015kvNY2B3l9SS1W","type":"step-finish","reason":"tool-calls","snapshot":"0b1d0daca90f30bf709dd3a1452a092ba5a1a89f","cost":0,"tokens":{"input":84,"output":351,"reasoning":256,"cache":{"read":10240,"write":0}}}}
{"type":"step_start","timestamp":1768850870876,"sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","part":{"id":"prt_bd7ba525c00137PghyFSpRZHVi","sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","messageID":"msg_bd7ba5085001DDIF3z4G18p4kk","type":"step-start","snapshot":"666340f0d5b08539e5ebc4fd684963edf54f62ab"}}
{"type":"tool_use","timestamp":1768850879441,"sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","part":{"id":"prt_bd7ba6de7001Wv9KGWCpaNkJJZ","sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","messageID":"msg_bd7ba5085001DDIF3z4G18p4kk","type":"tool","callID":"call_uChyAkjwV1cFBJBozmwsPFgg","tool":"bash","state":{"status":"completed","input":{"command":"git add cmd/yolo-runner/main.go cmd/yolo-runner/main_test.go internal/opencode/agent.go internal/opencode/agent_test.go && git commit -m \"feat: yolo-runner-127.4.10\" && git status --short","description":"Stages files, commits, shows status"},"output":"[rewind/v1-go-cleanup 02d9e77] feat: yolo-runner-127.4.10\n 5 files changed, 202 insertions(+), 7 deletions(-)\n create mode 100644 internal/opencode/agent.go\n create mode 100644 internal/opencode/agent_test.go\n M bin/yolo-runner\n?? runner-logs/opencode/yolo-runner-127.4.10.jsonl\n?? runner-logs/opencode/yolo-runner-127.4.10.stderr.log\n","title":"Stages files, commits, shows status","metadata":{"output":"[rewind/v1-go-cleanup 02d9e77] feat: yolo-runner-127.4.10\n 5 files changed, 202 insertions(+), 7 deletions(-)\n create mode 100644 internal/opencode/agent.go\n create mode 100644 internal/opencode/agent_test.go\n M bin/yolo-runner\n?? runner-logs/opencode/yolo-runner-127.4.10.jsonl\n?? runner-logs/opencode/yolo-runner-127.4.10.stderr.log\n","exit":0,"description":"Stages files, commits, shows status","truncated":false},"time":{"start":1768850879154,"end":1768850879440}},"metadata":{"openai":{"itemId":"fc_08ac5a204e91ac8701696e85bde67c8191b2224e0d1ec65fe7"}}}}
{"type":"step_finish","timestamp":1768850879457,"sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","part":{"id":"prt_bd7ba73d0001Ov7ANQXAX36Slv","sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","messageID":"msg_bd7ba5085001DDIF3z4G18p4kk","type":"step-finish","reason":"tool-calls","snapshot":"6c82d5ca6388f2b191c15011d8e2cb618060168f","cost":0,"tokens":{"input":6534,"output":339,"reasoning":256,"cache":{"read":30336,"write":0}}}}
{"type":"step_start","timestamp":1768850880072,"sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","part":{"id":"prt_bd7ba7648001f71T2NRIJYYnKu","sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","messageID":"msg_bd7ba73fc00110ukKav0mUATNp","type":"step-start","snapshot":"0df55a22281a6f49293b26b56c654902aa5fe3cc"}}
{"type":"text","timestamp":1768850884418,"sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","part":{"id":"prt_bd7ba77b40015UIhW3ulG1QKdR","sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","messageID":"msg_bd7ba73fc00110ukKav0mUATNp","type":"text","text":"Agent validation now runs before any work, and tests cover missing agent and missing permission scenarios. Added `internal/opencode/agent.go` with a simple validator that checks `.opencode/agent/yolo.md` and the `permission: allow` frontmatter, plus unit tests. `cmd/yolo-runner/main.go` now fails fast on validation errors before any beads/git/opencode activity, and existing RunOnceMain tests were updated to set up a valid agent file.\n\nFiles touched:\n- `cmd/yolo-runner/main.go`\n- `cmd/yolo-runner/main_test.go`\n- `internal/opencode/agent.go`\n- `internal/opencode/agent_test.go`\n\nTests:\n- `go test ./...`\n\nCommit:\n- `feat: yolo-runner-127.4.10`\n\nNext steps:\n1. Run `git add -u` if you want to stage your local logs or exclude them.\n2. If you want me to push per project rules, say the word.","time":{"start":1768850884417,"end":1768850884417},"metadata":{"openai":{"itemId":"msg_05717d4570775a6801696e85c0681c8191a84fd56b4dc2e970"}}}}
{"type":"step_finish","timestamp":1768850884488,"sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","part":{"id":"prt_bd7ba8776001r8WeASWkyNYwCD","sessionID":"ses_4284973ecffeHQ0iEe5FtFzTwM","messageID":"msg_bd7ba73fc00110ukKav0mUATNp","type":"step-finish","reason":"stop","snapshot":"39455a9a46475fdb119006b2cd83593a88eb000e","cost":0,"tokens":{"input":594,"output":208,"reasoning":0,"cache":{"read":36480,"write":0}}}}
