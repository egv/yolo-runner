---
id: yr-xolw
status: closed
deps: [yr-2t4f]
links: []
created: 2026-02-09T23:42:04Z
type: task
priority: 0
assignee: Gennady Evstratov
parent: yr-0xy1
---
# E1-T11 Propagate meaningful errors end-to-end

STRICT TDD: replace generic exit status surfaces in agent/runner/adapter boundaries with typed errors and context-rich wrapping.

## Acceptance Criteria

Given failures across stack boundaries, when they reach yolo-agent stderr, then messages retain root cause context and remediation hint.


## Notes

**2026-02-10T00:12:18Z**

triage_reason=serena initialization failed: INFO  2026-02-10T00:12:18 +2ms service=mcp key=serena mcp stderr: INFO  2026-02-10 00:12:18,090 [Task-6:SearchForPatternTool] serena.tools.tools_base:task:304 - Result: {"internal/exec/runner.go": ["  >  31:\tvar stdout, stderr strings.Builder", "  >  41:\t\tcmd.Stderr = &stderr", "  >  44:\t\tcmd.Stderr = &stderr", "  >  56:\t\tif logErr := logger.LogCommand(args, stdout.String(), stderr.String(), err, start); logErr != nil {"], "internal/ui/tui/spinner.go": ["  >   8:// Spinner is a wrapper around bubbles/spinner for the TUI status bar"], "internal/ui/tui/statusbar_test.go": ["  > 452:\t// View should be generated (content may be wrapped by lipgloss)"], "internal/docs/smoke_command_test.go": ["  >  26:\tif !strings.Contains(makefile, \"go test ./cmd/yolo-agent ./cmd/yolo-tui\") {", "  >  27:\t\tt.Fatalf(\"smoke-agent-tui target must run yolo-agent/yolo-tui smoke tests\")"], "internal/agent/error_taxonomy_test.go": ["  >  59:\terr := errors.New(\"git checkout main failed: error: Your local changes to the following files would be overwritten by checkout: exit status 1\")", "  >  62:\tif strings.Contains(message, \"exit status 1\") {", "  >  63:\t\tt.Fatalf(\"expected actionable message to omit generic exit status, got %q\", message)"], "internal/agent/error_taxonomy.go": ["  >  37:\tconst suffix = \": exit status \""], "internal/runner/events.go": ["  >  32:// RunnerEventType exposes the event type as a string for UI adapters.", "  >  35:// RunnerEventTitle exposes the event title for UI adapters.", "  >  38:// RunnerEventThought exposes the event thought for UI adapters."], "internal/runner/acceptance_criteria_test.go": ["  > 127:\t// Verify the interfaces were used directly (not via adapters)"], "internal/runner/adapters_test.go": ["  >  22:\t// Test adapter", "  >  23:\tadapter := NewTaskTrackerAdapter(tracker)", "  >  24:\tif adapter == nil {", "  >  29:\tready, err := adapter.Ready(\"test-1\")", "  >  38:\tbead, err := adapter.Show(\"test-1\")", "  >  47:\ttree, err := adapter.Tree(\"test-1\")", "  >  56:\terr = adapter.UpdateStatus(\"test-1\", \"in_progress\")", "  >  62:\tupdated, err := adapter.Show(\"test-1\")", "  >  71:\terr = adapter.UpdateStatusWithReason(\"test-1\", \"blocked\", \"test reason\")", "  >  77:\terr = adapter.Close(\"test-1\")", "  >  83:\terr = adapter.Sync()", "  >  89:\terr = adapter.CloseEligible()", "  >  99:\t// Test adapter", "  > 100:\tadapter := NewCodingAgentAdapter(agent)", "  > 101:\tif adapter == nil {", "  > 106:\terr := adapter.Run(\"test-1\", \"/tmp/test-repo\", \"Implement feature X\", \"test-model\", \"/tmp/config\", \"/tmp/config/opencode\", \"/tmp/test.log\")"], "internal/opencode/integration_test.go": ["  >  52:\t// Capture stderr"], "internal/opencode/command_runner.go": ["  >  15:\tstderrFile *os.File", "  >  28:\tif p.stderrFile != nil {", "  >  29:\t\t_ = p.stderrFile.Close()", "  >  45:\tif p.stderrFile != nil {", "  >  46:\t\t_ = p.stderrFile.Close()", "  >  74:\tstderrPath := strings.TrimSuffix(stdoutPath, \".jsonl\") + \".stderr.log\"", "  >  74:\tstderrPath := strings.TrimSuffix(stdoutPath, \".jsonl\") + \".stderr.log\"", "  >  75:\tstderrFile, err := os.Create(stderrPath)", "  >  75:\tstderrFile, err := os.Create(stderrPath)", "  >  79:\tcmd.Stderr = stderrFile", "  >  83:\t\t_ = stderrFile.Close()", "  >  89:\t\t_ = stderrFile.Close()", "  >  96:\t\t_ = stderrFile.Close()", "  > 100:\treturn commandProcess{cmd: cmd, stderrFile: stderrFile, stdin: stdinPipe, stdout: stdoutPipe}, nil", "  > 100:\treturn commandProcess{cmd: cmd, stderrFile: stderrFile, stdin: stdinPipe, stdout: stdoutPipe}, nil"], "internal/opencode/timeout_test.go": ["  >  98:\t_ = os.Remove(strings.TrimSuffix(logPath, \".jsonl\") + \".stderr.log\")", "  > 121:\t// Create a mock process that writes Serena initialization error to stderr", "  > 123:\terrorLog := strings.TrimSuffix(logPath, \".jsonl\") + \".stderr.log\"", "  > 124:\tstderrFile, err := os.Create(errorLog)", "  > 126:\t\tt.Fatalf(\"failed to create stderr log: %v\", err)", "  > 130:\tstderrContent := `The language server manager is not initialized, indicating a problem during project activation. Inform the user, telling them to inspect Serena's logs in order to determine the issue. IMPORTANT: Wait for further instructions before you continue!`", "  > 131:\tif _, err := stderrFile.WriteString(stderrContent); err != nil {", "  > 131:\tif _, err := stderrFile.WriteString(stderrContent); err != nil {", "  > 132:\t\tt.Fatalf(\"failed to write to stderr: %v\", err)", "  > 134:\tstderrFile.Close()", "  > 143:\tmockProcess.waitCh <- errors.New(\"exit status 1\")", "  > 168:\terrorLog := strings.TrimSuffix(logPath, \".jsonl\") + \".stderr.log\"", "  > 169:\tstderrFile, err := os.Create(errorLog)", "  > 171:\t\tt.Fatalf(\"failed to create stderr log: %v\", err)", "  > 173:\tstderrContent := \"language server manager is not initialized\"", "  > 174:\tif _, err := stderrFile.WriteString(stderrContent); err != nil {", "  > 174:\tif _, err := stderrFile.WriteString(stderrContent); err != nil {", "  > 175:\t\tt.Fatalf(\"failed to write to stderr: %v\", err)", "  > 177:\tstderrFile.Close()", "  > 357:\t// Capture stderr to verify error logging", "  > 370:\tmockProcess.waitCh <- errors.New(\"exit status 1\")", "  > 379:\terrorLog := strings.TrimSuffix(logPath, \".jsonl\") + \".stderr.log\"", "  > 380:\tstderrFile, err := os.Create(errorLog)", "  > 382:\t\tt.Fatalf(\"failed to create stderr log: %v\", err)", "  > 384:\tstderrContent := \"language server manager is not initialized\"", "  > 385:\tif _, err := stderrFile.WriteString(stderrContent); err != nil {", "  > 385:\tif _, err := stderrFile.WriteString(stderrContent); err != nil {", "  > 386:\t\tt.Fatalf(\"failed to write to stderr: %v\", err)", "  > 388:\tstderrFile.Close()", "  > 392:\t// Restore stderr and capture output", "  > 396:\tvar stderrOutput strings.Builder", "  > 397:\tio.Copy(&stderrOutput, r)", "  > 404:\tstderrStr := stderrOutput.String()", "  > 404:\tstderrStr := stderrOutput.String()", "  > 405:\tif !strings.Contains(stderrStr, \"language server manager is not initialized\") {", "  > 406:\t\tt.Fatalf(\"expected clear error message in stderr, got: %s\", stderrStr)", "  > 406:\t\tt.Fatalf(\"expected clear error message in stderr, got: %s\", stderrStr)"], "internal/opencode/runner_adapter_test.go": ["  >  20:\tadapter := &CLIRunnerAdapter{runWithACP: func(context.Context, string, string, string, string, string, string, string, Runner, ACPClient) error {", "  >  24:\tresult, err := adapter.Run(context.Background(), contracts.RunnerRequest{TaskID: \"t-1\", RepoRoot: \"/repo\", Prompt: \"do x\"})", "  >  34:\tadapter := &CLIRunnerAdapter{runWithACP: func(context.Context, string, string, string, string, string, string, string, Runner, ACPClient) error {", "  >  38:\tresult, err := adapter.Run(context.Background(), contracts.RunnerRequest{TaskID: \"t-1\", RepoRoot: \"/repo\", Prompt: \"do x\"})", "  >  48:\tadapter := &CLIRunnerAdapter{runWithACP: func(context.Context, string, string, string, string, string, string, string, Runner, ACPClient) error {", "  >  52:\tresult, err := adapter.Run(context.Background(), contracts.RunnerRequest{TaskID: \"t-1\", RepoRoot: \"/repo\", Prompt: \"do x\"})", "  >  62:\tadapter := &CLIRunnerAdapter{runWithACP: func(ctx context.Context, issueID string, repoRoot string, prompt string, model string, configRoot string, configDir string, logPath string, _ Runner, _ ACPClient) error {", "  >  73:\tresult, err := adapter.Run(context.Background(), contracts.RunnerRequest{TaskID: \"t-1\", RepoRoot: \"/repo\", Prompt: \"do x\", Timeout: 2 * time.Second})", "  >  83:\tadapter := &CLIRunnerAdapter{runWithACP: func(context.Context, string, string, string, string, string, string, string, Runner, ACPClient) error {", "  >  87:\tresult, err := adapter.Run(context.Background(), contracts.RunnerRequest{TaskID: \"t-1\", RepoRoot: \"/repo\", Prompt: \"do x\", Timeout: 1 * time.Second})", "  > 100:\tadapter := &CLIRunnerAdapter{runWithACP: func(context.Context, string, string, string, string, string, string, string, Runner, ACPClient) error {", "  > 104:\tresult, err := adapter.Run(context.Background(), contracts.RunnerRequest{TaskID: \"t-1\", RepoRoot: \"/repo\", Prompt: \"do x\"})", "  > 119:\tadapter := &CLIRunnerAdapter{runWithACP: func(context.Context, string, string, string, string, string, string, string, Runner, ACPClient) error {", "  > 124:\tresult, err := adapter.Run(context.Background(), contracts.RunnerRequest{TaskID: \"t-1\", RepoRoot: \"/repo\", Prompt: \"review\", Mode: contracts.RunnerModeReview, Metadata: map[string]string{\"log_path\": logPath}})", "  > 139:\tadapter := &CLIRunnerAdapter{runWithACP: func(context.Context, string, string, string, string, string, string, string, Runner, ACPClient) error {", "  > 144:\tresult, err := adapter.Run(context.Background(), contracts.RunnerRequest{TaskID: \"t-1\", RepoRoot: \"/repo\", Prompt: \"review\", Mode: contracts.RunnerModeReview, Metadata: map[string]string{\"log_path\": logPath}})", "  > 159:\tadapter := &CLIRunnerAdapter{runWithACP: func(context.Context, string, string, string, string, string, string, string, Runner, ACPClient) error {", "  > 164:\tresult, err := adapter.Run(context.Background(), contracts.RunnerRequest{TaskID: \"t-1\", RepoRoot: \"/repo\", Prompt: \"review\", Mode: contracts.RunnerModeReview, Metadata: map[string]string{\"log_path\": logPath}})", "  > 179:\tadapter := &CLIRunnerAdapter{runWithACP: func(context.Context, string, string, string, string, string, string, string, Runner, ACPClient) error {", "  > 184:\tresult, err := adapter.Run(context.Background(), contracts.RunnerRequest{TaskID: \"t-1\", RepoRoot: \"/repo\", Prompt: \"review\", Mode: contracts.RunnerModeReview, Metadata: map[string]string{\"log_path\": logPath}})"], "internal/opencode/client.go": ["  > 216:\t// Check stderr logs for Serena initialization failures", "  > 217:\tstderrPath := strings.TrimSuffix(logPath, \".jsonl\") + \".stderr.log\"", "  > 217:\tstderrPath := strings.TrimSuffix(logPath, \".jsonl\") + \".stderr.log\"", "  > 219:\tif line, ok := findSerenaInitErrorSince(stderrPath, serenaSince); ok {", "  > 224:\t\tgo monitorInitFailures(initCtx, stderrPath, serenaErrCh, serenaSince)", "  > 301:\tif line, ok := findSerenaInitErrorSince(stderrPath, serenaSince); ok {"], "internal/opencode/timeout_monitor_test.go": ["  >  12:\tstderrPath := filepath.Join(tempDir, \"run.stderr.log\")", "  >  12:\tstderrPath := filepath.Join(tempDir, \"run.stderr.log\")", "  >  13:\tcontent := \"INFO service=mcp key=serena mcp stderr: language server manager is not initialized\\n\"", "  >  14:\tif err := os.WriteFile(stderrPath, []byte(content), 0o644); err != nil {", "  >  15:\t\tt.Fatalf(\"write stderr file: %v\", err)", "  >  18:\tline, ok := findSerenaInitErrorSince(stderrPath, time.Time{})", "  >  29:\tstderrPath := filepath.Join(tempDir, \"run.stderr.log\")", "  >  29:\tstderrPath := filepath.Join(tempDir, \"run.stderr.log\")", "  >  31:\tif err := os.WriteFile(stderrPath, []byte(content), 0o644); err != nil {", "  >  32:\t\tt.Fatalf(\"write stderr file: %v\", err)", "  >  35:\t_, ok := findSerenaInitErrorSince(stderrPath, time.Time{})", "  >  43:\tstderrPath := filepath.Join(tempDir, \"run.stderr.log\")", "  >  43:\tstderrPath := filepath.Join(tempDir, \"run.stderr.log\")", "  >  45:\tif err := os.WriteFile(stderrPath, []byte(content), 0o644); err != nil {", "  >  46:\t\tt.Fatalf(\"write stderr file: %v\", err)", "  >  49:\t_, ok := findSerenaInitErrorSince(stderrPath, time.Time{})"], "internal/opencode/timeout_monitor.go": ["  >  14:// monitorInitFailures monitors stderr logs for Serena initialization failures", "  >  16:func monitorInitFailures(ctx context.Context, stderrPath string, errCh chan<- error, since time.Time) {", "  >  17:\tif stderrPath == \"\" {", "  >  32:\t\t\tif line, ok := findSerenaInitErrorSince(stderrPath, since); ok {", "  >  45:// findSerenaInitError checks if stderr log contains Serena initialization error", "  >  47:func findSerenaInitErrorSince(stderrPath string, since time.Time) (string, bool) {", "  >  48:\tinfo, err := os.Stat(stderrPath)", "  >  56:\tfile, err := os.Open(stderrPath)"], "internal/tk/task_manager.go": ["  >  12:\tadapter *Adapter", "  >  17:\treturn &TaskManager{adapter: New(runner), runner: runner}", "  >  21:\ttickets, err := m.adapter.queryTickets()", "  >  30:\tready, err := m.adapter.Ready(parentID)", "  >  70:\tbead, err := m.adapter.Show(taskID)", "  >  83:\treturn m.adapter.UpdateStatus(taskID, string(status))"], "internal/beads/command_logging_test.go": ["  >  24:\tadapter := New(commandRunner)", "  >  34:\t\t\t\t_, err := adapter.Ready(\"root\")", "  >  41:\t\t\t\t_, err := adapter.Show(\"task-1\")", "  >  48:\t\t\t\treturn adapter.UpdateStatus(\"task-1\", \"in_progress\")", "  >  54:\t\t\t\treturn adapter.Close(\"task-1\")", "  >  60:\t\t\t\treturn adapter.Sync()"], "internal/beads/beads_test.go": ["  >  31:\tadapter := New(runner)", "  >  33:\tissue, err := adapter.Ready(\"root\")", "  >  50:\tadapter := New(fake)", "  >  52:\tissue, err := adapter.Ready(\"root\")", "  >  71:\tadapter := New(runner)", "  >  73:\tissue, err := adapter.Ready(\"task-1\")", "  >  96:\tadapter := New(runner)", "  >  98:\tissue, err := adapter.Ready(\"task-1\")", "  > 111:\tadapter := New(runner)", "  > 113:\tissue, err := adapter.Ready(\"epic-1\")", "  > 125:\tadapter := New(runner)", "  > 127:\tbead, err := adapter.Show(\"task-1\")", "  > 140:\tadapter := New(runner)", "  > 142:\tif err := adapter.UpdateStatus(\"task-1\", \"blocked\"); err != nil {", "  > 151:\tadapter := New(runner)", "  > 153:\tif err := adapter.UpdateStatusWithReason(\"task-1\", \"blocked\", \"no_output last_output_age=10s\"); err != nil {", "  > 166:\tadapter := New(runner)", "  > 169:\tif err := adapter.UpdateStatusWithReason(\"task-1\", \"blocked\", reason); err != nil {", "  > 180:\tadapter := New(runner)", "  > 183:\tif err := adapter.UpdateStatusWithReason(\"task-1\", \"blocked\", long); err != nil {", "  > 199:\tadapter := New(runner)", "  > 202:\tif err := adapter.UpdateStatusWithReason(\"task-1\", \"blocked\", reason); err != nil {", "  > 216:\tadapter := New(runner)", "  > 218:\tif err := adapter.Close(\"task-1\"); err != nil {", "  > 227:\tadapter := New(runner)", "  > 229:\tif err := adapter.Sync(); err != nil {", "  > 239:\tadapter := New(runner)", "  > 241:\tissue, err := adapter.Tree(\"root\")", "  > 257:\tadapter := New(runner)", "  > 259:\tif _, err := adapter.Ready(\"root\"); err == nil {", "  > 262:\tif _, err := adapter.Show(\"task-1\"); err == nil {", "  > 265:\tif err := adapter.UpdateStatus(\"task-1\", \"open\"); err == nil {", "  > 268:\tif _, err := adapter.Tree(\"root\"); err == nil {", "  > 271:\tif err := adapter.Close(\"task-1\"); err == nil {", "  > 274:\tif err := adapter.Sync(); err == nil {"], "internal/vcs/git/vcs_test.go": ["  >  31:\t\terr:    errors.New(\"exit status 1\"),", "  >  43:\t\tt.Fatalf(\"expected git stderr details in error, got %q\", err.Error())"], "internal/vcs/git/command_logging_test.go": ["  >  25:\tadapter := New(gitAdapter)", "  >  36:\t\t\t\treturn adapter.AddAll()", "  >  43:\t\t\t\treturn adapter.Commit(\"test commit\")", "  >  50:\t\t\t\t_, err := adapter.IsDirty()", "  >  58:\t\t\t\t_, err := adapter.RevParseHead()", "  >  66:\t\t\t\t_, err := adapter.StatusPorcelain()", "  >  74:\t\t\t\treturn adapter.RestoreAll()", "  >  81:\t\t\t\treturn adapter.CleanAll()"], "internal/vcs/git/git_test.go": ["  >  27:\tadapter := New(runner)", "  >  29:\tdirty, err := adapter.IsDirty()", "  >  41:\tadapter := New(runner)", "  >  43:\tdirty, err := adapter.IsDirty()", "  >  55:\tadapter := New(runner)", "  >  57:\t_, err := adapter.IsDirty()", "  >  66:\tadapter := New(runner)", "  >  68:\tif err := adapter.AddAll(); err != nil {", "  >  76:\tadapter := New(runner)", "  >  78:\tif err := adapter.Commit(\"message\"); err != nil {", "  >  86:\tadapter := New(runner)", "  >  88:\trev, err := adapter.RevParseHead()", "  > 100:\tadapter := New(runner)", "  > 102:\tstatus, err := adapter.StatusPorcelain()", "  > 114:\tadapter := New(runner)", "  > 116:\tif err := adapter.RestoreAll(); err != nil {", "  > 124:\tadapter := New(runner)", "  > 126:\tif err := adapter.CleanAll(); err != nil {"], "internal/logging/command.go": ["  >  11:// CommandLogger handles logging of command stdout/stderr to files", "  >  23:// LogCommand logs a command's execution details, stdout, and stderr to files", "  >  24:func (cl *CommandLogger) LogCommand(command []string, stdout string, stderr string, err error, startTime time.Time) error {", "  >  67:\t// Write stderr if present", "  >  68:\tif stderr != \"\" {", "  >  69:\t\tfmt.Fprintf(logFile, \"\\n=== STDERR ===\\n%s\\n\", stderr)"]}
signal: killed

**2026-02-10T00:12:18Z**

triage_status=failed
